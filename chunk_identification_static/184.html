<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>184</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    184
                    <a href="183.html">prev</a>
                    <a href="185.html">next</a>
                    <a href="184_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_310203c9852593bd4f07481ea4d693d3096b6994_admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/dao/DynamicEntityDaoImpl.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;310203c9852593bd4f07481ea4d693d3096b6994:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/dao/DynamicEntityDaoImpl.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;310203c9852593bd4f07481ea4d693d3096b6994^1:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/dao/DynamicEntityDaoImpl.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;310203c9852593bd4f07481ea4d693d3096b6994^2:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/dao/DynamicEntityDaoImpl.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;c2b9b7cebcb68adf6459f3932383315f3716ab81:admin/broadleaf-open-admin-platform/src/main/java/org/broadleafcommerce/openadmin/server/dao/DynamicEntityDaoImpl.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj], [s]], subset: [[bj], [s]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  * 
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.server.dao;
  19 
  20 
  21 import org.apache.commons.collections4.map.LRUMap;
  22 import org.apache.commons.lang.StringUtils;
  23 import org.apache.commons.lang3.ArrayUtils;
  24 import org.apache.commons.logging.Log;
  25 import org.apache.commons.logging.LogFactory;
  26 import org.broadleafcommerce.common.money.Money;
  27 import org.broadleafcommerce.common.persistence.EntityConfiguration;
  28 import org.broadleafcommerce.common.persistence.Status;
  29 import org.broadleafcommerce.common.presentation.AdminPresentationClass;
  30 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  31 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  32 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  33 import org.broadleafcommerce.common.util.dao.DynamicDaoHelper;
  34 import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
  35 import org.broadleafcommerce.common.util.dao.HibernateMappingProvider;
  36 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  37 import org.broadleafcommerce.openadmin.dto.BasicCollectionMetadata;
  38 import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  39 import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  40 import org.broadleafcommerce.openadmin.dto.ClassTree;
  41 import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  42 import org.broadleafcommerce.openadmin.dto.ForeignKey;
  43 import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  44 import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  45 import org.broadleafcommerce.openadmin.dto.TabMetadata;
  46 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.BasicFieldMetadataProvider;
  47 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.FieldMetadataProvider;
<abbr title="  48 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequest;">  48 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequeðŸ”µ</abbr>
  49 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.LateStageAddMetadataRequest;
  50 import org.broadleafcommerce.openadmin.server.service.persistence.module.FieldManager;
  51 import org.broadleafcommerce.openadmin.server.service.persistence.validation.FieldNamePropertyValidator;
  52 import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  53 import org.hibernate.Criteria;
  54 import org.hibernate.MappingException;
  55 import org.hibernate.Session;
  56 import org.hibernate.mapping.PersistentClass;
  57 import org.hibernate.mapping.Property;
  58 import org.hibernate.type.ComponentType;
  59 import org.hibernate.type.Type;
  60 import org.springframework.beans.BeansException;
  61 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
  62 import org.springframework.beans.factory.annotation.Value;
  63 import org.springframework.context.ApplicationContext;
  64 import org.springframework.context.ApplicationContextAware;
  65 import org.springframework.context.annotation.Scope;
  66 import org.springframework.core.annotation.AnnotationUtils;
  67 import org.springframework.stereotype.Component;
  68 
  69 import java.io.Serializable;
  70 import java.lang.reflect.Field;
  71 import java.lang.reflect.Method;
  72 import java.lang.reflect.Modifier;
  73 import java.math.BigDecimal;
  74 import java.math.BigInteger;
  75 import java.security.MessageDigest;
  76 import java.security.NoSuchAlgorithmException;
  77 import java.text.DecimalFormat;
  78 import java.text.NumberFormat;
  79 import java.util.ArrayList;
  80 import java.util.Arrays;
  81 import java.util.Collections;
  82 import java.util.Comparator;
  83 import java.util.Date;
  84 import java.util.HashMap;
  85 import java.util.HashSet;
  86 import java.util.Iterator;
  87 import java.util.List;
  88 import java.util.Map;
  89 import java.util.Set;
  90 
  91 import javax.annotation.Nonnull;
  92 import javax.annotation.Resource;
  93 import javax.persistence.EntityManager;
  94 import javax.persistence.criteria.CriteriaBuilder;
  95 import javax.persistence.criteria.CriteriaQuery;
  96 import javax.persistence.criteria.Path;
  97 import javax.persistence.criteria.Predicate;
  98 import javax.persistence.criteria.Root;
  99 
 100 /**
 101  * @author jfischer
 102  */
 103 @Component(&quot;blDynamicEntityDao&quot;)
 104 @Scope(&quot;prototype&quot;)
 105 public class DynamicEntityDaoImpl implements DynamicEntityDao, ApplicationContextAware {
 106 
 107     private static final Log LOG = LogFactory.getLog(DynamicEntityDaoImpl.class);
 108 
 109     protected static final Map&lt;String, Map&lt;String, FieldMetadata&gt;&gt; METADATA_CACHE = new LRUMap&lt;&gt;(1000);
 110 
 111     /**
<abbr title=" 112      * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we have cached in METADATA_CACHE over the lifetime"> 112      * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we hðŸ”µ</abbr>
<abbr title=" 113      * of the application. This should survive evictions from METADATA_CACHE because it is for the purpose of diagnosing when we store different property"> 113      * of the application. This should survive evictions from METADATA_CACHE because it is for the purposðŸ”µ</abbr>
 114      * counts in METADATA_CACHE as a result of cache eviction
 115      */
 116     protected static final Map&lt;String, Integer&gt; METADATA_CACHE_SIZES = new HashMap&lt;&gt;();
 117 
 118     /*
<abbr title=" 119      * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are abstract or have been marked for exclusion"> 119      * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are absðŸ”µ</abbr>
 120      * from polymorphism
 121      */
 122 
 123     protected EntityManager standardEntityManager;
 124 
 125     @Resource(name = &quot;blMetadata&quot;)
 126     protected Metadata metadata;
 127 
 128     @Resource(name = &quot;blEntityConfiguration&quot;)
 129     protected EntityConfiguration entityConfiguration;
 130 
 131     @Resource(name = &quot;blFieldMetadataProviders&quot;)
 132     protected List&lt;FieldMetadataProvider&gt; fieldMetadataProviders = new ArrayList&lt;&gt;();
 133 
 134     @Resource(name = &quot;blDefaultFieldMetadataProvider&quot;)
 135     protected FieldMetadataProvider defaultFieldMetadataProvider;
 136 
 137     @Resource(name = &quot;blBasicFieldMetadataProvider&quot;)
 138     protected BasicFieldMetadataProvider basicFieldMetadataProvider;
 139 
 140     @Resource(name = &quot;blAppConfigurationMap&quot;)
 141     protected Map&lt;String, String&gt; propertyConfigurations = new HashMap&lt;&gt;();
 142 
 143     protected DynamicDaoHelper dynamicDaoHelper = new DynamicDaoHelperImpl();
 144 
 145     @Value(&quot;${cache.entity.dao.metadata.ttl}&quot;)
 146     protected int cacheEntityMetaDataTtl;
 147 
 148     /**
<abbr title=" 149      * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the application"> 149      * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the applicatioðŸ”µ</abbr>
 150      */
 151     @Value(&quot;${validate.metadata.cache.sizes:false}&quot;)
 152     protected boolean validateMetadataCacheSizes;
 153 
 154     protected long lastCacheFlushTime = System.currentTimeMillis();
 155 
 156     protected ApplicationContext applicationContext;
 157 
 158     protected FieldManager fieldManager;
 159 
 160     @Override
 161     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 162         this.applicationContext = applicationContext;
 163     }
 164 
 165     @Override
 166     public Criteria createCriteria(Class&lt;?&gt; entityClass) {
 167         return getStandardEntityManager().unwrap(Session.class).createCriteria(entityClass);
 168     }
 169 
 170     @Override
 171     public &lt;T&gt; T persist(T entity) {
 172         standardEntityManager.persist(entity);
 173         standardEntityManager.flush();
 174         return entity;
 175     }
 176 
 177     @Override
 178     public Object find(Class&lt;?&gt; entityClass, Object key) {
 179         return standardEntityManager.find(entityClass, key);
 180     }
 181 
 182     @Override
 183     public &lt;T&gt; T merge(T entity) {
 184         T response = standardEntityManager.merge(entity);
 185         standardEntityManager.flush();
 186         return response;
 187     }
 188 
 189     @Override
 190     public void flush() {
 191         standardEntityManager.flush();
 192     }
 193 
 194     @Override
 195     public void detach(Serializable entity) {
 196         standardEntityManager.detach(entity);
 197     }
 198 
 199     @Override
 200     public void refresh(Serializable entity) {
 201         standardEntityManager.refresh(entity);
 202     }
 203 
 204     @Override
 205     public Serializable retrieve(Class&lt;?&gt; entityClass, Object primaryKey) {
 206         return (Serializable) standardEntityManager.find(entityClass, primaryKey);
 207     }
 208 
 209     @Override
 210     public void remove(Serializable entity) {
 211         standardEntityManager.remove(entity);
 212         standardEntityManager.flush();
 213     }
 214 
 215     @Override
 216     public void clear() {
 217         standardEntityManager.clear();
 218     }
 219 
 220     @Override
 221     public PersistentClass getPersistentClass(String targetClassName) {
 222         return HibernateMappingProvider.getMapping(targetClassName);
 223     }
 224 
 225     @Override
 226     public boolean useCache() {
 227         if (cacheEntityMetaDataTtl &lt; 0) {
 228             return true;
 229         }
 230         if (cacheEntityMetaDataTtl == 0) {
 231             return false;
 232         } else {
 233             if ((System.currentTimeMillis() - lastCacheFlushTime) &gt; cacheEntityMetaDataTtl) {
 234                 lastCacheFlushTime = System.currentTimeMillis();
 235                 METADATA_CACHE.clear();
 236                 DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE.clear();
 237                 DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE_WO_EXCLUSIONS.clear();
 238                 LOG.trace(&quot;Metadata cache evicted&quot;);
 239                 return true; // cache is empty
 240             } else {
 241                 return true;
 242             }
 243         }
 244     }
 245 
 246     @Override
 247     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass) {
 248         return getAllPolymorphicEntitiesFromCeiling(ceilingClass, true);
 249     }
 250 
 251     @Override
<abbr title=" 252     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymorphicEntities) {"> 252     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifðŸ”µ</abbr>
<abbr title=" 253         return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolymorphicEntities, useCache());"> 253         return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolyðŸ”µ</abbr>
 254     }
 255 
 256     @Override
 257     public Class&lt;?&gt;[] getUpDownInheritance(Class&lt;?&gt; testClass) {
 258         return dynamicDaoHelper.getUpDownInheritance(testClass, true, useCache());
 259     }
 260 
 261     @Override
 262     public Class&lt;?&gt; getImplClass(String className) {
 263         Class&lt;?&gt; clazz = null;
 264         try {
 265             clazz = entityConfiguration.lookupEntityClass(className);
 266         } catch (NoSuchBeanDefinitionException e) {
 267             //do nothing
 268         }
 269         if (clazz == null) {
 270             try {
 271                 clazz = Class.forName(className);
 272             } catch (ClassNotFoundException e) {
 273                 throw new RuntimeException(e);
 274             }
 275             clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 276         }
 277         return clazz;
 278     }
 279 
 280     @Override
 281     public Class&lt;?&gt; getCeilingImplClass(String className) {
 282         Class&lt;?&gt; clazz;
 283         try {
 284             clazz = Class.forName(className);
 285         } catch (ClassNotFoundException e) {
 286             throw new RuntimeException(e);
 287         }
 288         Class&lt;?&gt;[] entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 289         if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
 290             clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 291             entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 292         }
 293         if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
<abbr title=" 294             throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for the requested class name (%s)&quot;, className));"> 294             throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for tðŸ”µ</abbr>
 295         }
 296         clazz = entitiesFromCeiling[entitiesFromCeiling.length - 1];
 297         return clazz;
 298     }
 299 
 300     @Override
<abbr title=" 301     public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, String value) {"> 301     public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, StriðŸ”µ</abbr>
<abbr title=" 302         Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass());"> 302         Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass())ðŸ”µ</abbr>
 303         CriteriaBuilder builder = this.standardEntityManager.getCriteriaBuilder();
 304         CriteriaQuery&lt;Long&gt; criteria = builder.createQuery(Long.class);
 305         Root root = criteria.from(clazz);
 306         Path idField = root.get(this.getIdField(clazz).getName());
 307         criteria.select(idField.as(Long.class));
 308         List&lt;Predicate&gt; restrictions = new ArrayList();
 309 
 310         Path path = null;
 311 
 312         // Support property name such as &quot;defaultSku.name&quot;
 313         if (propertyName.contains(&quot;.&quot;)) {
 314             String[] split = propertyName.split(&quot;\\.&quot;);
 315             for (String splitResult : split) {
 316                 if (path == null) {
 317                     path = root.get(splitResult);
 318                 } else {
 319                     path = path.get(splitResult);
 320                 }
 321             }
 322         } else {
 323             path = root.get(propertyName);
 324         }
 325 
 326         restrictions.add(builder.equal(path, value));
 327         Serializable identifier = this.getIdentifier(instance);
 328         //when we creating the new item identifier is not exists
 329         if (identifier != null) {
 330             restrictions.add(builder.notEqual(idField, identifier));
 331         }
 332 
 333         if (instance instanceof Status) {
<abbr title=" 334             restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), builder.equal(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;), &#x27;N&#x27;)));"> 334             restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), buildeðŸ”µ</abbr>
 335         }
 336 
 337         criteria.where(restrictions.toArray(new Predicate[restrictions.size()]));
 338         return this.standardEntityManager.createQuery(criteria).getResultList();
 339     }
 340 
 341     @Override
 342     public Serializable getIdentifier(Object entity) {
 343         return dynamicDaoHelper.getIdentifier(entity);
 344     }
 345 
 346     protected Field getIdField(Class&lt;?&gt; clazz) {
 347         return dynamicDaoHelper.getIdField(clazz);
 348     }
 349 
 350     public Class&lt;?&gt;[] sortEntities(Class&lt;?&gt; ceilingClass, List&lt;Class&lt;?&gt;&gt; entities) {
 351         return dynamicDaoHelper.sortEntities(ceilingClass, entities);
 352     }
 353 
 354     protected void addClassToTree(Class&lt;?&gt; clazz, ClassTree tree) {
 355         Class&lt;?&gt; testClass;
 356         try {
 357             testClass = Class.forName(tree.getFullyQualifiedClassname());
 358         } catch (ClassNotFoundException e) {
 359             throw new RuntimeException(e);
 360         }
 361         if (clazz.equals(testClass)) {
 362             return;
 363         }
 364         if (clazz.getSuperclass().equals(testClass)) {
 365             ClassTree myTree = new ClassTree(clazz.getName(), isExcludeClassFromPolymorphism(clazz));
 366             createClassTreeFromAnnotation(clazz, myTree);
 367             tree.setChildren(ArrayUtils.add(tree.getChildren(), myTree));
 368         } else {
 369             for (ClassTree child : tree.getChildren()) {
 370                 addClassToTree(clazz, child);
 371             }
 372         }
 373     }
 374 
 375     protected void createClassTreeFromAnnotation(Class&lt;?&gt; clazz, ClassTree myTree) {
<abbr title=" 376         AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 376         AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentatioðŸ”µ</abbr>
 377         if (classPresentation != null) {
 378             String friendlyName = classPresentation.friendlyName();
 379             if (!StringUtils.isEmpty(friendlyName)) {
 380                 myTree.setFriendlyName(friendlyName);
 381             }
 382         }
 383     }
 384 
 385     @Override
 386     public ClassTree getClassTree(Class&lt;?&gt;[] polymorphicClasses) {
 387         String ceilingClass = null;
 388         for (Class&lt;?&gt; clazz : polymorphicClasses) {
<abbr title=" 389             AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 389             AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentðŸ”µ</abbr>
 390             if (classPresentation != null) {
 391                 String ceilingEntity = classPresentation.ceilingDisplayEntity();
 392                 if (!StringUtils.isEmpty(ceilingEntity)) {
 393                     ceilingClass = ceilingEntity;
 394                     break;
 395                 }
 396             }
 397         }
 398         if (ceilingClass != null) {
 399             int pos = -1;
 400             int j = 0;
 401             for (Class&lt;?&gt; clazz : polymorphicClasses) {
 402                 if (clazz.getName().equals(ceilingClass)) {
 403                     pos = j;
 404                     break;
 405                 }
 406                 j++;
 407             }
 408             if (pos &gt;= 0) {
 409                 Class&lt;?&gt;[] temp = new Class&lt;?&gt;[pos + 1];
 410                 System.arraycopy(polymorphicClasses, 0, temp, 0, j + 1);
 411                 polymorphicClasses = temp;
 412             }
 413         }
 414 
 415         ClassTree classTree = null;
 416         if (!ArrayUtils.isEmpty(polymorphicClasses)) {
 417             Class&lt;?&gt; topClass = polymorphicClasses[polymorphicClasses.length - 1];
 418             classTree = new ClassTree(topClass.getName(), isExcludeClassFromPolymorphism(topClass));
 419             createClassTreeFromAnnotation(topClass, classTree);
 420             for (int j = polymorphicClasses.length - 1; j &gt;= 0; j--) {
 421                 addClassToTree(polymorphicClasses[j], classTree);
 422             }
 423             classTree.finalizeStructure(1);
 424         }
 425         return classTree;
 426     }
 427 
 428     @Override
 429     public ClassTree getClassTreeFromCeiling(Class&lt;?&gt; ceilingClass) {
 430         Class&lt;?&gt;[] sortedEntities = getAllPolymorphicEntitiesFromCeiling(ceilingClass);
 431         return getClassTree(sortedEntities);
 432     }
 433 
 434     @Override
<abbr title=" 435     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 435     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspectiveðŸ”µ</abbr>
 436         Class&lt;?&gt;[] entityClasses;
 437         try {
 438             entityClasses = getAllPolymorphicEntitiesFromCeiling(Class.forName(entityName));
 439         } catch (ClassNotFoundException e) {
 440             throw new RuntimeException(e);
 441         }
 442         if (!ArrayUtils.isEmpty(entityClasses)) {
 443             return getMergedProperties(
 444                     entityName,
 445                     entityClasses,
<abbr title=" 446                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 446                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePðŸ”µ</abbr>
 447                     persistencePerspective.getAdditionalNonPersistentProperties(),
 448                     persistencePerspective.getAdditionalForeignKeys(),
 449                     MergedPropertyType.PRIMARY,
 450                     persistencePerspective.getPopulateToOneFields(),
 451                     persistencePerspective.getIncludeFields(),
 452                     persistencePerspective.getExcludeFields(),
 453                     persistencePerspective.getConfigurationKey(),
 454                     &quot;&quot;
 455             );
 456         } else {
 457             Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 458             Class&lt;?&gt; targetClass;
 459             try {
 460                 targetClass = Class.forName(entityName);
 461             } catch (ClassNotFoundException e) {
 462                 throw new RuntimeException(e);
 463             }
<abbr title=" 464             Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 464             Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targðŸ”µ</abbr>
 465             for (String property : attributesMap.keySet()) {
 466                 FieldMetadata presentationAttribute = attributesMap.get(property);
 467                 if (!presentationAttribute.getExcluded()) {
 468                     Field field = FieldManager.getSingleField(targetClass, property);
 469                     if (!Modifier.isStatic(field.getModifiers())) {
 470                         boolean handled = false;
 471                         for (FieldMetadataProvider provider : fieldMetadataProviders) {
 472                             MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title=" 473                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 473                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForðŸ”µ</abbr>
 474                                             MergedPropertyType.PRIMARY, null, null, &quot;&quot;,
<abbr title=" 475                                             property, null, false, 0, attributesMap, presentationAttribute,"> 475                                             property, null, false, 0, attributesMap, presentationAttributðŸ”µ</abbr>
<abbr title=" 476                                             ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(), field.getType(), this),"> 476                                             ((BasicFieldMetadata) presentationAttribute).getExplicitFieldðŸ”µ</abbr>
 477                                     mergedProperties);
 478                             if (MetadataProviderResponse.NOT_HANDLED != response) {
 479                                 handled = true;
 480                             }
 481                             if (MetadataProviderResponse.HANDLED_BREAK == response) {
 482                                 break;
 483                             }
 484                         }
 485                         if (!handled) {
<abbr title=" 486                             //this provider is not included in the provider list on purpose - it is designed to handle basic"> 486                             //this provider is not included in the provider list on purpose - it is desigðŸ”µ</abbr>
<abbr title=" 487                             //AdminPresentation fields, and those fields not admin presentation annotated at all"> 487                             //AdminPresentation fields, and those fields not admin presentation annotatedðŸ”µ</abbr>
 488                             defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title=" 489                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 489                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForðŸ”µ</abbr>
 490                                             MergedPropertyType.PRIMARY, null, null, &quot;&quot;, property,
<abbr title=" 491                                             null, false, 0, attributesMap, presentationAttribute, ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(),"> 491                                             null, false, 0, attributesMap, presentationAttribute, ((BasicðŸ”µ</abbr>
 492                                             field.getType(), this), mergedProperties);
 493                         }
 494                     }
 495                 }
 496             }
 497 
 498             return mergedProperties;
 499         }
 500     }
 501 
 502     @Override
 503     public Map&lt;String, FieldMetadata&gt; getMergedProperties(@Nonnull Class&lt;?&gt; cls) {
 504         Class&lt;?&gt;[] polymorphicTypes = getAllPolymorphicEntitiesFromCeiling(cls);
 505         return getMergedProperties(
 506                 cls.getName(),
 507                 polymorphicTypes,
 508                 null,
 509                 new String[]{},
 510                 new ForeignKey[]{},
 511                 MergedPropertyType.PRIMARY,
 512                 true,
 513                 new String[]{},
 514                 new String[]{},
 515                 null,
 516                 &quot;&quot;
 517         );
 518     }
 519 
 520     @Override
 521     public Map&lt;String, FieldMetadata&gt; getMergedProperties(
 522             String ceilingEntityFullyQualifiedClassname,
 523             Class&lt;?&gt;[] entities,
 524             ForeignKey foreignField,
 525             String[] additionalNonPersistentProperties,
 526             ForeignKey[] additionalForeignFields,
 527             MergedPropertyType mergedPropertyType,
 528             Boolean populateManyToOneFields,
 529             String[] includeFields,
 530             String[] excludeFields,
 531             String configurationKey,
 532             String prefix) {
 533         Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedPropertiesRecursively(
 534                 ceilingEntityFullyQualifiedClassname,
 535                 entities,
 536                 foreignField,
 537                 additionalNonPersistentProperties,
 538                 additionalForeignFields,
 539                 mergedPropertyType,
 540                 populateManyToOneFields,
 541                 includeFields,
 542                 excludeFields,
 543                 configurationKey,
 544                 new ArrayList&lt;Class&lt;?&gt;&gt;(),
 545                 prefix,
 546                 false,
 547                 &quot;&quot;);
 548 
 549         final List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 550 
 551         for (final String key : mergedProperties.keySet()) {
<abbr title=" 552             if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded()) {"> 552             if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded(ðŸ”µ</abbr>
 553                 removeKeys.add(key);
 554             }
 555         }
 556 
 557         for (String removeKey : removeKeys) {
 558             mergedProperties.remove(removeKey);
 559         }
 560 
<abbr title=" 561         // Allow field metadata providers to contribute additional fields here. These latestage handlers take place"> 561         // Allow field metadata providers to contribute additional fields here. These latestage handlers ðŸ”µ</abbr>
<abbr title=" 562         // after any cached lookups occur, and are ideal for adding in dynamic properties that are not globally cacheable"> 562         // after any cached lookups occur, and are ideal for adding in dynamic properties that are not glðŸ”µ</abbr>
 563         // like properties gleaned from reflection typically are.
 564         Set&lt;String&gt; keys = new HashSet&lt;&gt;(mergedProperties.keySet());
 565         for (Class&lt;?&gt; targetClass : entities) {
 566             for (String key : keys) {
<abbr title=" 567                 LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass, this, &quot;&quot;);"> 567                 LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass,ðŸ”µ</abbr>
 568 
 569                 boolean foundOneOrMoreHandlers = false;
 570                 for (FieldMetadataProvider fieldMetadataProvider : fieldMetadataProviders) {
<abbr title=" 571                     MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);"> 571                     MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mðŸ”µ</abbr>
 572                     if (MetadataProviderResponse.NOT_HANDLED != response) {
 573                         foundOneOrMoreHandlers = true;
 574                     }
 575                     if (MetadataProviderResponse.HANDLED_BREAK == response) {
 576                         break;
 577                     }
 578                 }
 579                 if (!foundOneOrMoreHandlers) {
 580                     defaultFieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);
 581                 }
 582             }
 583         }
 584 
 585         return mergedProperties;
 586     }
 587 
 588     protected Map&lt;String, FieldMetadata&gt; getMergedPropertiesRecursively(
 589             final String ceilingEntityFullyQualifiedClassname,
 590             final Class&lt;?&gt;[] entities,
 591             final ForeignKey foreignField,
 592             final String[] additionalNonPersistentProperties,
 593             final ForeignKey[] additionalForeignFields,
 594             final MergedPropertyType mergedPropertyType,
 595             final Boolean populateManyToOneFields,
 596             final String[] includeFields,
 597             final String[] excludeFields,
 598             final String configurationKey,
 599             final List&lt;Class&lt;?&gt;&gt; parentClasses,
 600             final String prefix,
 601             final Boolean isParentExcluded,
 602             final String parentPrefix) {
 603         PropertyBuilder propertyBuilder = new PropertyBuilder() {
 604             @Override
 605             public Map&lt;String, FieldMetadata&gt; execute(Boolean overridePopulateManyToOne) {
 606                 Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 607                 Boolean classAnnotatedPopulateManyToOneFields;
 608                 if (overridePopulateManyToOne != null) {
 609                     classAnnotatedPopulateManyToOneFields = overridePopulateManyToOne;
 610                 } else {
 611                     classAnnotatedPopulateManyToOneFields = populateManyToOneFields;
 612                 }
 613 
 614                 buildPropertiesFromPolymorphicEntities(
 615                         entities,
 616                         foreignField,
 617                         additionalNonPersistentProperties,
 618                         additionalForeignFields,
 619                         mergedPropertyType,
 620                         classAnnotatedPopulateManyToOneFields,
 621                         includeFields,
 622                         excludeFields,
 623                         configurationKey,
 624                         ceilingEntityFullyQualifiedClassname,
 625                         mergedProperties,
 626                         parentClasses,
 627                         prefix,
 628                         isParentExcluded,
 629                         parentPrefix);
 630 
 631                 return mergedProperties;
 632             }
 633         };
 634 
<abbr title=" 635         Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilder, prefix, isParentExcluded, ceilingEntityFullyQualifiedClassname, configurationKey, this);"> 635         Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilderðŸ”µ</abbr>
<abbr title=" 636         applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedProperties);"> 636         applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedPropertiesðŸ”µ</abbr>
 637         applyForeignKeyPrecedence(foreignField, additionalForeignFields, mergedProperties);
 638 
 639         return mergedProperties;
 640     }
 641 
<abbr title=" 642     protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFields, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 642     protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFieldðŸ”µ</abbr>
 643         for (String key : mergedProperties.keySet()) {
 644             boolean isForeign = false;
 645             if (foreignField != null) {
 646                 isForeign = foreignField.getManyToField().equals(key);
 647             }
 648             if (!isForeign &amp;&amp; !ArrayUtils.isEmpty(additionalForeignFields)) {
 649                 for (ForeignKey foreignKey : additionalForeignFields) {
 650                     isForeign = foreignKey.getManyToField().equals(key);
 651                     if (isForeign) {
 652                         break;
 653                     }
 654                 }
 655             }
 656             if (isForeign) {
 657                 FieldMetadata metadata = mergedProperties.get(key);
 658                 metadata.setExcluded(false);
 659             }
 660         }
 661     }
 662 
<abbr title=" 663     protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefix, Boolean isParentExcluded, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 663     protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefixðŸ”µ</abbr>
 664         //check includes
 665         if (!ArrayUtils.isEmpty(includeFields)) {
 666             for (String include : includeFields) {
 667                 for (String key : mergedProperties.keySet()) {
 668                     String testKey = prefix + key;
 669                     if (!(testKey.startsWith(include + &quot;.&quot;) || testKey.equals(include))) {
 670                         FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 671                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did not appear in the explicit includeFields list&quot;);"> 671                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did ðŸ”µ</abbr>
 672                         metadata.setExcluded(true);
 673                     } else {
 674                         FieldMetadata metadata = mergedProperties.get(key);
 675                         if (!isParentExcluded) {
<abbr title=" 676                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field appears in the explicit includeFields list&quot;);"> 676                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field apðŸ”µ</abbr>
 677                             metadata.setExcluded(false);
 678                         }
 679                     }
 680                 }
 681             }
 682         } else if (!ArrayUtils.isEmpty(excludeFields)) {
 683             //check excludes
 684             for (String exclude : excludeFields) {
 685                 for (String key : mergedProperties.keySet()) {
 686                     String testKey = prefix + key;
 687                     if (testKey.startsWith(exclude + &quot;.&quot;) || testKey.equals(exclude)) {
 688                         FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 689                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appears in the explicit excludeFields list&quot;);"> 689                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appeðŸ”µ</abbr>
 690                         metadata.setExcluded(true);
 691                     } else {
 692                         FieldMetadata metadata = mergedProperties.get(key);
 693                         if (!isParentExcluded) {
<abbr title=" 694                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field did not appear in the explicit excludeFields list&quot;);"> 694                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field diðŸ”µ</abbr>
 695                             metadata.setExcluded(false);
 696                         }
 697                     }
 698                 }
 699             }
 700         }
 701     }
 702 
 703     protected String pad(String s, int length, char pad) {
 704         StringBuilder buffer = new StringBuilder(s);
 705         while (buffer.length() &lt; length) {
 706             buffer.insert(0, pad);
 707         }
 708         return buffer.toString();
 709     }
 710 
<abbr title=" 711     protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, String[] additionalNonPersistentProperties, ForeignKey[] additionalForeignFields, MergedPropertyType mergedPropertyType, Boolean populateManyToOneFields, Class&lt;?&gt; clazz, String configurationKey, Boolean isParentExcluded) {"> 711     protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, StðŸ”µ</abbr>
 712         StringBuilder sb = new StringBuilder(150);
 713         sb.append(ceilingEntityFullyQualifiedClassname);
 714         sb.append(clazz.hashCode());
 715         sb.append(foreignField == null ? &quot;&quot; : foreignField.toString());
 716         sb.append(configurationKey);
 717         sb.append(isParentExcluded);
 718         if (additionalNonPersistentProperties != null) {
 719             for (String prop : additionalNonPersistentProperties) {
 720                 sb.append(prop);
 721             }
 722         }
 723         if (additionalForeignFields != null) {
 724             for (ForeignKey key : additionalForeignFields) {
 725                 sb.append(key.toString());
 726             }
 727         }
 728         sb.append(mergedPropertyType);
 729         sb.append(populateManyToOneFields);
 730 
 731         String digest;
 732         try {
 733             MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
 734             byte[] messageDigest = md.digest(sb.toString().getBytes());
 735             BigInteger number = new BigInteger(1, messageDigest);
 736             digest = number.toString(16);
 737         } catch (NoSuchAlgorithmException e) {
 738             throw new RuntimeException(e);
 739         }
 740 
 741         String key = pad(digest, 32, &#x27;0&#x27;);
 742 
 743         if (LOG.isDebugEnabled()) {
 744             LOG.debug(&quot;Created cache key: &quot; + key + &quot; from the following string: &quot; + sb.toString());
 745         }
 746         return key;
 747     }
 748 
 749     protected void buildPropertiesFromPolymorphicEntities(
 750             Class&lt;?&gt;[] entities,
 751             ForeignKey foreignField,
 752             String[] additionalNonPersistentProperties,
 753             ForeignKey[] additionalForeignFields,
 754             MergedPropertyType mergedPropertyType,
 755             Boolean populateManyToOneFields,
 756             String[] includeFields,
 757             String[] excludeFields,
 758             String configurationKey,
 759             String ceilingEntityFullyQualifiedClassname,
 760             Map&lt;String, FieldMetadata&gt; mergedProperties,
 761             List&lt;Class&lt;?&gt;&gt; parentClasses,
 762             String prefix,
 763             Boolean isParentExcluded,
 764             String parentPrefix) {
 765         for (Class&lt;?&gt; clazz : entities) {
<abbr title=" 766             String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNonPersistentProperties, additionalForeignFields, mergedPropertyType, populateManyToOneFields, clazz, configurationKey, isParentExcluded);"> 766             String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNðŸ”µ</abbr>
 767 
 768             Map&lt;String, FieldMetadata&gt; cacheData = null;
 769             synchronized (DynamicDaoHelperImpl.LOCK_OBJECT) {
 770                 if (useCache()) {
 771                     cacheData = METADATA_CACHE.get(cacheKey);
 772                 }
 773 
 774                 if (cacheData == null) {
 775                     Map&lt;String, FieldMetadata&gt; props = getPropertiesForEntityClass(
 776                             clazz,
 777                             foreignField,
 778                             additionalNonPersistentProperties,
 779                             additionalForeignFields,
 780                             mergedPropertyType,
 781                             populateManyToOneFields,
 782                             includeFields,
 783                             excludeFields,
 784                             configurationKey,
 785                             ceilingEntityFullyQualifiedClassname,
 786                             parentClasses,
 787                             prefix,
 788                             isParentExcluded,
 789                             parentPrefix);
<abbr title=" 790                     //first check all the properties currently in there to see if my entity inherits from them"> 790                     //first check all the properties currently in there to see if my entity inherits fromðŸ”µ</abbr>
 791                     for (Class&lt;?&gt; clazz2 : entities) {
 792                         if (!clazz2.getName().equals(clazz.getName())) {
 793                             for (Map.Entry&lt;String, FieldMetadata&gt; entry : props.entrySet()) {
 794                                 FieldMetadata metadata = entry.getValue();
 795                                 try {
<abbr title=" 796                                     if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(clazz2)) {"> 796                                     if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(cðŸ”µ</abbr>
<abbr title=" 797                                         String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(), new String[]{clazz2.getName()});"> 797                                         String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(),ðŸ”µ</abbr>
 798                                         metadata.setAvailableToTypes(both);
 799                                     }
 800                                 } catch (ClassNotFoundException e) {
 801                                     throw new RuntimeException(e);
 802                                 }
 803                             }
 804                         }
 805                     }
 806                     METADATA_CACHE.put(cacheKey, props);
 807 
 808                     if (LOG.isTraceEnabled()) {
<abbr title=" 809                         LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 809                         LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKeyðŸ”µ</abbr>
 810                     }
 811 
 812                     if (validateMetadataCacheSizes) {
 813                         Integer previousSize = METADATA_CACHE_SIZES.get(cacheKey);
 814                         Integer currentSize = props.size();
 815                         if (previousSize == null) {
 816                             METADATA_CACHE_SIZES.put(cacheKey, currentSize);
 817                         } else if (!currentSize.equals(previousSize)) {
<abbr title=" 818                             String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache for the key &quot; + cacheKey + &quot; but we had previously stored &quot; + previousSize + &quot; properties&quot;;"> 818                             String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache ðŸ”µ</abbr>
 819                             LOG.error(msg);
 820                             throw new RuntimeException(msg);
 821                         }
 822                     }
 823 
 824                     cacheData = props;
 825                 } else {
 826                     if (LOG.isTraceEnabled()) {
<abbr title=" 827                         LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 827                         LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheðŸ”µ</abbr>
 828                     }
 829 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 830                     //in case of MT different sites can potentially have different data driven enums, as we don&#x27;t take into account"> 830                     //in case of MT different sites can potentially have different data driven enums, as ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 831                     //site during cache key calculation(have metadata per-site is overkill) we want to refresh data driven enums"> 831                     //site during cache key calculation(have metadata per-site is overkill) we want to reðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 832                     for (FieldMetadata value : cacheData.values()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 833                         if(value instanceof BasicFieldMetadata &amp;&amp; StringUtils.isNotEmpty(((BasicFieldMetadata)value).getOptionListEntity())){"> 833                         if(value instanceof BasicFieldMetadata &amp;&amp; StringUtils.isNotEmpty(((BasicFieldMetaðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 834                             basicFieldMetadataProvider.refreshDataDrivenEnumMetadata((BasicFieldMetadata) value);"> 834                             basicFieldMetadataProvider.refreshDataDrivenEnumMetadata((BasicFieldMetadata)ðŸ”µ</abbr></span>
 835 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 836             Map&lt;String, FieldMetadata&gt; clonedCache = new HashMap&lt;&gt;(cacheData.size());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 837             for (Map.Entry&lt;String, FieldMetadata&gt; entry : cacheData.entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 838                 clonedCache.put(entry.getKey(), entry.getValue().cloneFieldMetadata());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 839             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 840             mergedProperties.putAll(clonedCache);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 841         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 842     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 843 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 844     @Override</span>
 845 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 846                     for (FieldMetadata value : cacheData.values()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 847                         //that&#x27;s for the case when metadata cache is enabled(cache.entity.dao.metadata.ttl=-1) and you cache metadata for en locale"> 847                         //that&#x27;s for the case when metadata cache is enabled(cache.entity.dao.metadata.ttðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 848                         //then switch to FR that has comma as decimal separator</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 849                         if (value instanceof BasicFieldMetadata) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 850                             BasicFieldMetadata v = (BasicFieldMetadata) value;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 851                             if (SupportedFieldType.DECIMAL.equals(v.getSecondaryType()) || SupportedFieldType.INTEGER.equals(v.getSecondaryType())"> 851                             if (SupportedFieldType.DECIMAL.equals(v.getSecondaryType()) || SupportedFieldðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 852                                     || SupportedFieldType.INTEGER.equals(v.getFieldType()) || SupportedFieldType.DECIMAL.equals(v.getFieldType())) {"> 852                                     || SupportedFieldType.INTEGER.equals(v.getFieldType()) || SupportedFiðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 853                                 refreshDecimalDefaultValue(v);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 854                             }</span>
 855 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 856                         }
 857                     }
 858                 }
 859             }
 860             //clone the metadata before passing to the system
 861             Map&lt;String, FieldMetadata&gt; clonedCache = new HashMap&lt;&gt;(cacheData.size());
 862             for (Map.Entry&lt;String, FieldMetadata&gt; entry : cacheData.entrySet()) {
 863                 clonedCache.put(entry.getKey(), entry.getValue().cloneFieldMetadata());
 864             }
 865             mergedProperties.putAll(clonedCache);
 866         }
 867     }
 868 
 869     public void refreshDecimalDefaultValue(BasicFieldMetadata value) {
<abbr title=" 870         DecimalFormat instance = (DecimalFormat) NumberFormat.getInstance(BroadleafRequestContext.getBroadleafRequestContext().getJavaLocale());"> 870         DecimalFormat instance = (DecimalFormat) NumberFormat.getInstance(BroadleafRequestContext.getBroaðŸ”µ</abbr>
<abbr title=" 871         if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;.&quot;) &amp;&amp; instance.getDecimalFormatSymbols().getDecimalSeparator()!=&#x27;.&#x27;){"> 871         if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;.&quot;) &amp;&amp; inðŸ”µ</abbr>
<abbr title=" 872             value.setDefaultValue(value.getDefaultValue().replace(&#x27;.&#x27;, instance.getDecimalFormatSymbols().getDecimalSeparator()));"> 872             value.setDefaultValue(value.getDefaultValue().replace(&#x27;.&#x27;, instance.getDecimalFormatSymbols()ðŸ”µ</abbr>
<abbr title=" 873         }else if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;,&quot;) &amp;&amp; instance.getDecimalFormatSymbols().getDecimalSeparator()!=&#x27;,&#x27;){"> 873         }else if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;,&quot;)ðŸ”µ</abbr>
<abbr title=" 874             value.setDefaultValue(value.getDefaultValue().replace(&#x27;,&#x27;, instance.getDecimalFormatSymbols().getDecimalSeparator()));"> 874             value.setDefaultValue(value.getDefaultValue().replace(&#x27;,&#x27;, instance.getDecimalFormatSymbols()ðŸ”µ</abbr>
 875         }
 876 
 877     }
 878 
 879     @Override
 880     public Field[] getAllFields(Class&lt;?&gt; targetClass) {
 881         Field[] allFields = new Field[]{};
 882         boolean eof = false;
 883         Class&lt;?&gt; currentClass = targetClass;
 884         while (!eof) {
 885             Field[] fields = currentClass.getDeclaredFields();
 886             allFields = ArrayUtils.addAll(allFields, fields);
 887             if (currentClass.getSuperclass() != null) {
 888                 currentClass = currentClass.getSuperclass();
 889             } else {
 890                 eof = true;
 891             }
 892         }
 893 
 894         return allFields;
 895     }
 896 
 897     @Override
 898     public Map&lt;String, FieldMetadata&gt; getPropertiesForPrimitiveClass(
 899             String propertyName,
 900             String friendlyPropertyName,
 901             Class&lt;?&gt; targetClass,
 902             Class&lt;?&gt; parentClass,
 903             MergedPropertyType mergedPropertyType
 904     ) {
 905         Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 906         BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
 907         presentationAttribute.setFriendlyName(friendlyPropertyName);
 908         if (String.class.isAssignableFrom(targetClass)) {
 909             presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
 910             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 911             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.STRING, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 911             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 912         } else if (Boolean.class.isAssignableFrom(targetClass)) {
 913             presentationAttribute.setExplicitFieldType(SupportedFieldType.BOOLEAN);
 914             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 915             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.BOOLEAN, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 915             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 916         } else if (Date.class.isAssignableFrom(targetClass)) {
 917             presentationAttribute.setExplicitFieldType(SupportedFieldType.DATE);
 918             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 919             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DATE, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 919             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 920         } else if (Money.class.isAssignableFrom(targetClass)) {
 921             presentationAttribute.setExplicitFieldType(SupportedFieldType.MONEY);
 922             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 923             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.MONEY, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 923             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 924         } else if (
 925                 Byte.class.isAssignableFrom(targetClass) ||
 926                         Integer.class.isAssignableFrom(targetClass) ||
 927                         Long.class.isAssignableFrom(targetClass) ||
 928                         Short.class.isAssignableFrom(targetClass)
 929                 ) {
 930             presentationAttribute.setExplicitFieldType(SupportedFieldType.INTEGER);
 931             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 932             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.INTEGER, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 932             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 933         } else if (
 934                 Double.class.isAssignableFrom(targetClass) ||
 935                         BigDecimal.class.isAssignableFrom(targetClass)
 936                 ) {
 937             presentationAttribute.setExplicitFieldType(SupportedFieldType.DECIMAL);
 938             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 939             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DECIMAL, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 939             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 940         }
 941         ((BasicFieldMetadata) fields.get(propertyName)).setLength(255);
 942         ((BasicFieldMetadata) fields.get(propertyName)).setForeignKeyCollection(false);
 943         ((BasicFieldMetadata) fields.get(propertyName)).setRequired(true);
 944         ((BasicFieldMetadata) fields.get(propertyName)).setUnique(true);
 945         ((BasicFieldMetadata) fields.get(propertyName)).setScale(100);
 946         ((BasicFieldMetadata) fields.get(propertyName)).setPrecision(100);
 947 
 948         return fields;
 949     }
 950 
 951     @Override
 952     public Map&lt;String, Object&gt; getIdMetadata(Class&lt;?&gt; entityClass) {
 953         return dynamicDaoHelper.getIdMetadata(entityClass, standardEntityManager);
 954     }
 955 
 956     @Override
 957     public List&lt;String&gt; getPropertyNames(Class&lt;?&gt; entityClass) {
 958         return dynamicDaoHelper.getPropertyNames(entityClass);
 959     }
 960 
 961     @Override
 962     public List&lt;Type&gt; getPropertyTypes(Class&lt;?&gt; entityClass) {
 963         return dynamicDaoHelper.getPropertyTypes(entityClass);
 964     }
 965 
 966     @Override
 967     public Map&lt;String, TabMetadata&gt; getTabAndGroupMetadata(Class&lt;?&gt;[] entities, ClassMetadata cmd) {
 968         Class&lt;?&gt;[] superClassEntities = getSuperClassHierarchy(entities[entities.length - 1]);
 969 
<abbr title=" 970         Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entities);"> 970         Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entitiesðŸ”µ</abbr>
 971         metadata.applyTabAndGroupMetadataOverrides(superClassEntities, mergedTabAndGroupMetadata);
 972         metadata.buildAdditionalTabAndGroupMetadataFromCmdProperties(cmd, mergedTabAndGroupMetadata);
 973 
 974         return mergedTabAndGroupMetadata;
 975     }
 976 
 977     public Class&lt;?&gt;[] getSuperClassHierarchy(Class&lt;?&gt; ceilingEntity) {
 978         Class&lt;?&gt;[] entities = new Class&lt;?&gt;[]{};
 979 
 980         if (ceilingEntity != null) {
 981             entities = ArrayUtils.add(entities, ceilingEntity);
 982             while (!ceilingEntity.getSuperclass().equals(Object.class)) {
 983                 entities = ArrayUtils.add(entities, ceilingEntity.getSuperclass());
 984                 ceilingEntity = ceilingEntity.getSuperclass();
 985             }
 986         }
 987         return entities;
 988     }
 989 
 990     protected Map&lt;String, FieldMetadata&gt; getPropertiesForEntityClass(
 991             Class&lt;?&gt; targetClass,
 992             ForeignKey foreignField,
 993             String[] additionalNonPersistentProperties,
 994             ForeignKey[] additionalForeignFields,
 995             MergedPropertyType mergedPropertyType,
 996             Boolean populateManyToOneFields,
 997             String[] includeFields,
 998             String[] excludeFields,
 999             String configurationKey,
1000             String ceilingEntityFullyQualifiedClassname,
1001             List&lt;Class&lt;?&gt;&gt; parentClasses,
1002             String prefix,
1003             Boolean isParentExcluded,
1004             String parentPrefix) {
<abbr title="1005         Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);">1005         Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null,ðŸ”µ</abbr>
1006         if (isParentExcluded) {
1007             for (String key : presentationAttributes.keySet()) {
<abbr title="1008                 LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;);">1008                 LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;ðŸ”µ</abbr>
1009                 presentationAttributes.get(key).setExcluded(true);
1010             }
1011         }
1012 
1013         Map idMetadata = getIdMetadata(targetClass);
1014         Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
1015         String idProperty = (String) idMetadata.get(&quot;name&quot;);
1016         List&lt;String&gt; propertyNames = getPropertyNames(targetClass);
1017         propertyNames.add(idProperty);
1018         Type idType = (Type) idMetadata.get(&quot;type&quot;);
1019         List&lt;Type&gt; propertyTypes = getPropertyTypes(targetClass);
1020         propertyTypes.add(idType);
1021 
1022         PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1023         Iterator testIter = persistentClass.getPropertyIterator();
1024         List&lt;Property&gt; propertyList = new ArrayList&lt;&gt;();
1025 
1026         //check the properties for problems
1027         while (testIter.hasNext()) {
1028             Property property = (Property) testIter.next();
1029             if (property.getName().contains(&quot;.&quot;)) {
<abbr title="1030                 throw new IllegalArgumentException(&quot;Properties from entities that utilize a period character (&#x27;.&#x27;) in their name are incompatible with this system. The property name in question is: (&quot; + property.getName() + &quot;) from the class: (&quot; + targetClass.getName() + &quot;)&quot;);">1030                 throw new IllegalArgumentException(&quot;Properties from entities that utilize a period characðŸ”µ</abbr>
1031             }
1032             propertyList.add(property);
1033         }
1034 
1035         buildProperties(
1036                 targetClass,
1037                 foreignField,
1038                 additionalForeignFields,
1039                 additionalNonPersistentProperties,
1040                 mergedPropertyType,
1041                 presentationAttributes,
1042                 propertyList,
1043                 fields,
1044                 propertyNames,
1045                 propertyTypes,
1046                 idProperty,
1047                 populateManyToOneFields,
1048                 includeFields,
1049                 excludeFields,
1050                 configurationKey,
1051                 ceilingEntityFullyQualifiedClassname,
1052                 parentClasses,
1053                 prefix,
1054                 isParentExcluded,
1055                 false,
1056                 parentPrefix
1057         );
1058         BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
1059         presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
1060         presentationAttribute.setVisibility(VisibilityEnum.HIDDEN_ALL);
1061         if (!ArrayUtils.isEmpty(additionalNonPersistentProperties)) {
1062             Class&lt;?&gt;[] entities = getAllPolymorphicEntitiesFromCeiling(targetClass);
1063             for (String additionalNonPersistentProperty : additionalNonPersistentProperties) {
<abbr title="1064                 if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersistentProperty.startsWith(prefix))) {">1064                 if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersisteðŸ”µ</abbr>
1065                     String myAdditionalNonPersistentProperty = additionalNonPersistentProperty;
1066                     //get final property if this is a dot delimited property
1067                     int finalDotPos = additionalNonPersistentProperty.lastIndexOf(&#x27;.&#x27;);
1068                     if (finalDotPos &gt;= 0) {
<abbr title="1069                         myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(finalDotPos + 1, myAdditionalNonPersistentProperty.length());">1069                         myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(fðŸ”µ</abbr>
1070                     }
<abbr title="1071                     //check all the polymorphic types on this target class to see if the end property exists">1071                     //check all the polymorphic types on this target class to see if the end property exiðŸ”µ</abbr>
1072                     Field testField = null;
1073                     Method testMethod = null;
1074                     for (Class&lt;?&gt; clazz : entities) {
1075                         try {
1076                             testMethod = clazz.getMethod(myAdditionalNonPersistentProperty);
1077                             if (testMethod != null) {
1078                                 break;
1079                             }
1080                         } catch (NoSuchMethodException e) {
1081                             //do nothing - method does not exist
1082                         }
1083                         testField = getFieldManager().getField(clazz, myAdditionalNonPersistentProperty);
1084                         if (testField != null) {
1085                             break;
1086                         }
1087                     }
1088                     //if the property exists, add it to the metadata for this class
1089                     if (testField != null || testMethod != null) {
<abbr title="1090                         fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, additionalNonPersistentProperty, propertyList, SupportedFieldType.STRING, null, targetClass, presentationAttribute, mergedPropertyType, this));">1090                         fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, addðŸ”µ</abbr>
1091                     }
1092                 }
1093             }
1094         }
1095 
1096         return fields;
1097     }
1098 
1099     protected void buildProperties(
1100             Class&lt;?&gt; targetClass,
1101             ForeignKey foreignField,
1102             ForeignKey[] additionalForeignFields,
1103             String[] additionalNonPersistentProperties,
1104             MergedPropertyType mergedPropertyType,
1105             Map&lt;String, FieldMetadata&gt; presentationAttributes,
1106             List&lt;Property&gt; componentProperties,
1107             Map&lt;String, FieldMetadata&gt; fields,
1108             List&lt;String&gt; propertyNames,
1109             List&lt;Type&gt; propertyTypes,
1110             String idProperty,
1111             Boolean populateManyToOneFields,
1112             String[] includeFields,
1113             String[] excludeFields,
1114             String configurationKey,
1115             String ceilingEntityFullyQualifiedClassname,
1116             List&lt;Class&lt;?&gt;&gt; parentClasses,
1117             String prefix,
1118             Boolean isParentExcluded,
1119             Boolean isComponentPrefix,
1120             String parentPrefix) {
1121         int j = 0;
1122         Comparator&lt;String&gt; propertyComparator = new Comparator&lt;String&gt;() {
1123             @Override
1124             public int compare(String o1, String o2) {
1125                 //check for property name equality and for map field properties
<abbr title="1126                 if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FieldManager.MAPFIELDSEPARATOR)) {">1126                 if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(ðŸ”µ</abbr>
1127                     return 0;
1128                 }
1129                 return o1.compareTo(o2);
1130             }
1131         };
1132         List&lt;String&gt; presentationKeyList = new ArrayList&lt;&gt;(presentationAttributes.keySet());
1133         Collections.sort(presentationKeyList);
1134 
1135         for (String propertyName : propertyNames) {
1136             final Type type = propertyTypes.get(j);
1137             boolean isPropertyForeignKey = testForeignProperty(foreignField, prefix, propertyName);
<abbr title="1138             int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFields, prefix, propertyName);">1138             int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFieldsðŸ”µ</abbr>
1139             j++;
1140             Field myField = getFieldManager().getField(targetClass, propertyName);
1141             if (myField == null) {
<abbr title="1142                 //try to get the field with the prefix - needed for advanced collections that appear in @Embedded classes">1142                 //try to get the field with the prefix - needed for advanced collections that appear in @ðŸ”µ</abbr>
1143                 myField = getFieldManager().getField(targetClass, prefix + propertyName);
1144             }
1145             if (
1146                     !type.isAnyType() &amp;&amp; !type.isCollectionType() ||
1147                             isPropertyForeignKey ||
1148                             additionalForeignKeyIndexPosition &gt;= 0 ||
<abbr title="1149                             Collections.binarySearch(presentationKeyList, propertyName, propertyComparator) &gt;= 0">1149                             Collections.binarySearch(presentationKeyList, propertyName, propertyComparatoðŸ”µ</abbr>
1150                     ) {
1151                 if (myField != null) {
1152                     boolean handled = false;
1153                     for (FieldMetadataProvider provider : fieldMetadataProviders) {
1154                         FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1155                         if (presentationAttribute != null) {
1156                             setExcludedBasedOnShowIfProperty(presentationAttribute);
1157                         }
1158                         MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title="1159                                 new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, additionalForeignFields,">1159                                 new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, aðŸ”µ</abbr>
1160                                         mergedPropertyType, componentProperties, idProperty, prefix,
<abbr title="1161                                         propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition,">1161                                         propertyName, type, isPropertyForeignKey, additionalForeignKeyIndðŸ”µ</abbr>
<abbr title="1162                                         presentationAttributes, presentationAttribute, null, type.getReturnedClass(), this), fields);">1162                                         presentationAttributes, presentationAttribute, null, type.getRetuðŸ”µ</abbr>
1163                         if (MetadataProviderResponse.NOT_HANDLED != response) {
1164                             handled = true;
1165                         }
1166                         if (MetadataProviderResponse.HANDLED_BREAK == response) {
1167                             break;
1168                         }
1169                     }
1170                     if (!handled) {
1171                         buildBasicProperty(myField, targetClass, foreignField, additionalForeignFields,
<abbr title="1172                                 additionalNonPersistentProperties, mergedPropertyType, presentationAttributes,">1172                                 additionalNonPersistentProperties, mergedPropertyType, presentationAttribðŸ”µ</abbr>
<abbr title="1173                                 componentProperties, fields, idProperty, populateManyToOneFields, includeFields,">1173                                 componentProperties, fields, idProperty, populateManyToOneFields, includeðŸ”µ</abbr>
<abbr title="1174                                 excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClasses,">1174                                 excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, paðŸ”µ</abbr>
<abbr title="1175                                 prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition, isComponentPrefix, parentPrefix);">1175                                 prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additðŸ”µ</abbr>
1176                     }
1177                 }
1178             }
1179         }
1180     }
1181 
1182     public Boolean testPropertyInclusion(FieldMetadata presentationAttribute) {
1183         setExcludedBasedOnShowIfProperty(presentationAttribute);
1184 
<abbr title="1185         return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presentationAttribute.getExcluded()) || (presentationAttribute.getChildrenExcluded() != null &amp;&amp; presentationAttribute.getChildrenExcluded())));">1185         return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presenðŸ”µ</abbr>
1186 
1187     }
1188 
1189     protected void setExcludedBasedOnShowIfProperty(FieldMetadata fieldMetadata) {
1190         if (fieldMetadata != null
1191                 &amp;&amp; StringUtils.isNotEmpty(fieldMetadata.getShowIfProperty())
1192                 &amp;&amp; propertyConfigurations.get(fieldMetadata.getShowIfProperty()) != null
1193                 &amp;&amp; !Boolean.valueOf(propertyConfigurations.get(fieldMetadata.getShowIfProperty()))) {
1194 
1195             //do not include this in the display if it returns false.
1196             fieldMetadata.setExcluded(true);
1197         }
1198     }
1199 
<abbr title="1200     protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyName, Class&lt;?&gt; targetClass,">1200     protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyNðŸ”µ</abbr>
<abbr title="1201                                             String ceilingEntityFullyQualifiedClassname, Boolean isComponentPrefix, String parentPrefix) {">1201                                             String ceilingEntityFullyQualifiedClassname, Boolean isComponðŸ”µ</abbr>
1202 
<abbr title="1203         Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyName, targetClass,">1203         Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyðŸ”µ</abbr>
1204                 ceilingEntityFullyQualifiedClassname, isComponentPrefix);
1205 
<abbr title="1206         Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isComponentPrefix,">1206         Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isCompoðŸ”µ</abbr>
1207                 parentPrefix, propertyName);
1208 
1209         return standardRecursionDetected || multiLevelEmbeddableRecursionDetected;
1210     }
1211 
<abbr title="1212     protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String parentPrefix, String propertyName) {">1212     protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String ðŸ”µ</abbr>
1213         return isComponentPrefix &amp;&amp; parentPrefix.contains(&quot;.&quot; + prefix + propertyName);
1214     }
1215 
1216     protected Boolean testStandardPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String
1217             propertyName, Class&lt;?&gt; targetClass, String ceilingEntityFullyQualifiedClassname, Boolean
1218                                                             isComponentPrefix) {
1219         Boolean response = false;
1220         //don&#x27;t want to shun a self-referencing property in an @Embeddable
<abbr title="1221         boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).length &gt; 1);">1221         boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).lðŸ”µ</abbr>
1222         if (shouldTest) {
1223             Field testField = getFieldManager().getField(targetClass, propertyName);
1224             if (testField == null) {
1225                 Class&lt;?&gt;[] entities;
1226                 try {
<abbr title="1227                     entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1227                     entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualiðŸ”µ</abbr>
1228                 } catch (ClassNotFoundException e) {
1229                     throw new RuntimeException(e);
1230                 }
1231                 for (Class&lt;?&gt; clazz : entities) {
1232                     testField = getFieldManager().getField(clazz, propertyName);
1233                     if (testField != null) {
1234                         break;
1235                     }
1236                 }
1237                 String testProperty = prefix + propertyName;
1238                 if (testField == null) {
1239                     testField = getFieldManager().getField(targetClass, testProperty);
1240                 }
1241                 if (testField == null) {
1242                     for (Class&lt;?&gt; clazz : entities) {
1243                         testField = getFieldManager().getField(clazz, testProperty);
1244                         if (testField != null) {
1245                             break;
1246                         }
1247                     }
1248                 }
1249             }
1250             response = determineExclusionForField(parentClasses, targetClass, testField);
1251         }
1252         return response;
1253     }
1254 
<abbr title="1255     protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, Field testField) {">1255     protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, FielðŸ”µ</abbr>
1256         Boolean response = false;
1257         if (testField != null) {
1258             Class&lt;?&gt; testType = testField.getType();
1259             for (Class&lt;?&gt; parentClass : parentClasses) {
1260                 if (parentClass.isAssignableFrom(testType) || testType.isAssignableFrom(parentClass)) {
1261                     response = true;
1262                     break;
1263                 }
1264             }
<abbr title="1265             if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetClass))) {">1265             if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetCðŸ”µ</abbr>
1266                 response = true;
1267             }
1268         }
1269         return response;
1270     }
1271 
1272     protected void buildBasicProperty(
1273             Field field,
1274             Class&lt;?&gt; targetClass,
1275             ForeignKey foreignField,
1276             ForeignKey[] additionalForeignFields,
1277             String[] additionalNonPersistentProperties,
1278             MergedPropertyType mergedPropertyType,
1279             Map&lt;String, FieldMetadata&gt; presentationAttributes,
1280             List&lt;Property&gt; componentProperties,
1281             Map&lt;String, FieldMetadata&gt; fields,
1282             String idProperty,
1283             Boolean populateManyToOneFields,
1284             String[] includeFields,
1285             String[] excludeFields,
1286             String configurationKey,
1287             String ceilingEntityFullyQualifiedClassname,
1288             List&lt;Class&lt;?&gt;&gt; parentClasses,
1289             String prefix,
1290             Boolean isParentExcluded,
1291             String propertyName,
1292             Type type,
1293             boolean propertyForeignKey,
1294             int additionalForeignKeyIndexPosition,
1295             Boolean isComponentPrefix,
1296             String parentPrefix) {
1297         FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1298         Boolean amIExcluded = isParentExcluded || !testPropertyInclusion(presentationAttribute);
1299         Boolean includeField = !testPropertyRecursion(prefix, parentClasses, propertyName, targetClass,
1300                 ceilingEntityFullyQualifiedClassname, isComponentPrefix, parentPrefix);
1301 
1302         SupportedFieldType explicitType = null;
1303         if (presentationAttribute != null &amp;&amp; presentationAttribute instanceof BasicFieldMetadata) {
1304             explicitType = ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType();
1305         }
1306         Class&lt;?&gt; returnedClass = type.getReturnedClass();
1307         checkProp:
1308         {
1309             if (type.isComponentType() &amp;&amp; includeField) {
1310                 buildComponentProperties(
1311                         targetClass,
1312                         foreignField,
1313                         additionalForeignFields,
1314                         additionalNonPersistentProperties,
1315                         mergedPropertyType,
1316                         fields,
1317                         idProperty,
1318                         populateManyToOneFields,
1319                         includeFields,
1320                         excludeFields,
1321                         configurationKey,
1322                         ceilingEntityFullyQualifiedClassname,
1323                         propertyName,
1324                         type,
1325                         returnedClass,
1326                         parentClasses,
1327                         amIExcluded,
1328                         prefix,
1329                         parentPrefix);
1330                 break checkProp;
1331             }
1332             /*
1333              * Currently we do not support ManyToOne fields whose class type is the same
1334              * as the target type, since this forms an infinite loop and will cause a stack overflow.
1335              */
1336             if (
1337                     type.isEntityType() &amp;&amp;
1338                             !returnedClass.isAssignableFrom(targetClass) &amp;&amp;
1339                             populateManyToOneFields &amp;&amp;
1340                             includeField
1341                     ) {
1342                 buildEntityProperties(
1343                         fields,
1344                         foreignField,
1345                         additionalForeignFields,
1346                         additionalNonPersistentProperties,
1347                         populateManyToOneFields,
1348                         includeFields,
1349                         excludeFields,
1350                         configurationKey,
1351                         ceilingEntityFullyQualifiedClassname,
1352                         propertyName,
1353                         returnedClass,
1354                         targetClass,
1355                         parentClasses,
1356                         prefix,
1357                         amIExcluded,
1358                         parentPrefix
1359                 );
1360                 break checkProp;
1361             }
1362         }
1363         //Don&#x27;t include this property if it failed manyToOne inclusion and is not a specified foreign key
1364         if (includeField || propertyForeignKey || additionalForeignKeyIndexPosition &gt;= 0) {
1365             defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title="1366                     new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeignFields,">1366                     new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeiðŸ”µ</abbr>
<abbr title="1367                             mergedPropertyType, componentProperties, idProperty, prefix, propertyName, type,">1367                             mergedPropertyType, componentProperties, idProperty, prefix, propertyName, tyðŸ”µ</abbr>
<abbr title="1368                             propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributes,">1368                             propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributesðŸ”µ</abbr>
1369                             presentationAttribute, explicitType, returnedClass, this), fields);
1370         }
1371     }
1372 
1373     protected boolean testForeignProperty(ForeignKey foreignField, String prefix, String propertyName) {
1374         boolean isPropertyForeignKey = false;
1375         if (foreignField != null) {
1376             isPropertyForeignKey = foreignField.getManyToField().equals(prefix + propertyName);
1377         }
1378         return isPropertyForeignKey;
1379     }
1380 
<abbr title="1381     protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, String propertyName) {">1381     protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, StriðŸ”µ</abbr>
1382         int additionalForeignKeyIndexPosition = -1;
1383         if (additionalForeignFields != null) {
<abbr title="1384             additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKey(prefix + propertyName, null, null), new Comparator&lt;ForeignKey&gt;() {">1384             additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKðŸ”µ</abbr>
1385                 @Override
1386                 public int compare(ForeignKey o1, ForeignKey o2) {
1387                     return o1.getManyToField().compareTo(o2.getManyToField());
1388                 }
1389             });
1390         }
1391         return additionalForeignKeyIndexPosition;
1392     }
1393 
1394     protected void buildEntityProperties(
1395             Map&lt;String, FieldMetadata&gt; fields,
1396             ForeignKey foreignField,
1397             ForeignKey[] additionalForeignFields,
1398             String[] additionalNonPersistentProperties,
1399             Boolean populateManyToOneFields,
1400             String[] includeFields,
1401             String[] excludeFields,
1402             String configurationKey,
1403             String ceilingEntityFullyQualifiedClassname,
1404             String propertyName,
1405             Class&lt;?&gt; returnedClass,
1406             Class&lt;?&gt; targetClass,
1407             List&lt;Class&lt;?&gt;&gt; parentClasses,
1408             String prefix,
1409             Boolean isParentExcluded,
1410             String parentPrefix) {
1411         Class&lt;?&gt;[] polymorphicEntities = getAllPolymorphicEntitiesFromCeiling(returnedClass);
1412         List&lt;Class&lt;?&gt;&gt; clonedParentClasses = new ArrayList&lt;&gt;();
1413 
1414         for (Class&lt;?&gt; parentClass : parentClasses) {
1415             clonedParentClasses.add(parentClass);
1416         }
1417 
1418         clonedParentClasses.add(targetClass);
1419 
1420         Map&lt;String, FieldMetadata&gt; newFields = getMergedPropertiesRecursively(
1421                 ceilingEntityFullyQualifiedClassname,
1422                 polymorphicEntities,
1423                 foreignField,
1424                 additionalNonPersistentProperties,
1425                 additionalForeignFields,
1426                 MergedPropertyType.PRIMARY,
1427                 populateManyToOneFields,
1428                 includeFields,
1429                 excludeFields,
1430                 configurationKey,
1431                 clonedParentClasses,
1432                 prefix + propertyName + &#x27;.&#x27;,
1433                 isParentExcluded,
1434                 parentPrefix);
1435 
1436         final String targetClassName = targetClass.getName();
1437 
1438         for (FieldMetadata newMetadata : newFields.values()) {
1439             newMetadata.setInheritedFromType(targetClassName);
1440             newMetadata.setAvailableToTypes(new String[]{targetClassName});
1441         }
1442 
1443         Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;(newFields.size());
1444 
1445         for (Map.Entry&lt;String, FieldMetadata&gt; newField : newFields.entrySet()) {
1446             final FieldMetadata fieldMetadata = newField.getValue();
1447             final String key = newField.getKey();
1448 
1449             convertedFields.put(propertyName + &#x27;.&#x27; + key, fieldMetadata);
1450 
1451             if (fieldMetadata instanceof BasicFieldMetadata) {
<abbr title="1452                 for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldMetadata) fieldMetadata).getValidationConfigurations().entrySet()) {">1452                 for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldðŸ”µ</abbr>
1453                     Class&lt;?&gt; validatorImpl = null;
1454 
1455                     try {
1456                         validatorImpl = Class.forName(validationConfigurations.getKey());
1457                     } catch (ClassNotFoundException e) {
1458                         Object bean = applicationContext.getBean(validationConfigurations.getKey());
1459 
1460                         if (bean != null) {
1461                             validatorImpl = bean.getClass();
1462                         }
1463                     }
1464 
<abbr title="1465                     if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validatorImpl)) {">1465                     if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validaðŸ”µ</abbr>
1466                         for (Map&lt;String, String&gt; configs : validationConfigurations.getValue()) {
1467                             for (Map.Entry&lt;String, String&gt; config : configs.entrySet()) {
1468                                 final String value = config.getValue();
1469 
1470                                 if (newFields.containsKey(value)) {
1471                                     config.setValue(propertyName + &quot;.&quot; + value);
1472                                 }
1473                             }
1474                         }
1475                     }
1476                 }
1477             }
1478 
1479             if (isForeignKey(fieldMetadata)) {
1480                 setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1481             }
1482         }
1483 
1484         fields.putAll(convertedFields);
1485     }
1486 
1487     protected boolean isForeignKey(FieldMetadata fieldMetadata) {
1488         return fieldMetadata instanceof BasicCollectionMetadata
<abbr title="1489                 &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().isEmpty()">1489                 &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePðŸ”µ</abbr>
<abbr title="1490                 &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().containsKey(PersistencePerspectiveItemType.FOREIGNKEY);">1490                 &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePeðŸ”µ</abbr>
1491     }
1492 
1493     /*
1494      * There may be multiple pathways to this foreign key which may have come from a cached source.
1495      * Since ForeignKey contains an originating field concept that is occurrence specific, we need
1496      * to make sure it is set appropriately here.
1497      *
1498      * A known use case is vendorPortal.embeddableMultitenantSite.adminUsers and
1499      * owningSite.embeddableMultitenantSite.adminUsers.
1500      */
<abbr title="1501     protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMetadata) {">1501     protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMðŸ”µ</abbr>
<abbr title="1502         ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1502         ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePersðŸ”µ</abbr>
1503         foreignKey.setOriginatingField(propertyName + &#x27;.&#x27; + key);
1504     }
1505 
1506     protected void buildComponentProperties(
1507             Class&lt;?&gt; targetClass,
1508             ForeignKey foreignField,
1509             ForeignKey[] additionalForeignFields,
1510             String[] additionalNonPersistentProperties,
1511             MergedPropertyType mergedPropertyType,
1512             Map&lt;String, FieldMetadata&gt; fields,
1513             String idProperty,
1514             Boolean populateManyToOneFields,
1515             String[] includeFields,
1516             String[] excludeFields,
1517             String configurationKey,
1518             String ceilingEntityFullyQualifiedClassname,
1519             String propertyName,
1520             Type type,
1521             Class&lt;?&gt; returnedClass,
1522             List&lt;Class&lt;?&gt;&gt; parentClasses,
1523             Boolean isParentExcluded,
1524             String prefix,
1525             String parentPrefix) {
1526         String[] componentProperties = ((ComponentType) type).getPropertyNames();
1527         List&lt;String&gt; componentPropertyNames = Arrays.asList(componentProperties);
1528         Type[] componentTypes = ((ComponentType) type).getSubtypes();
1529         List&lt;Type&gt; componentPropertyTypes = Arrays.asList(componentTypes);
1530         String tempPrefix = &quot;&quot;;
1531 
1532         int pos = prefix.indexOf(&quot;.&quot;);
1533         final int prefixLength = prefix.length();
1534 
1535         if (pos &gt; 0 &amp;&amp; pos &lt; prefixLength - 1) {
1536             //only use part of the prefix if it&#x27;s more than one layer deep
1537             tempPrefix = prefix.substring(pos + 1, prefixLength);
1538         }
1539 
<abbr title="1540         Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClass(targetClass, returnedClass, this, tempPrefix + propertyName + &quot;.&quot;);">1540         Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClðŸ”µ</abbr>
1541 
1542         if (isParentExcluded) {
1543             for (String key : componentPresentationAttributes.keySet()) {
<abbr title="1544                 LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excluded&quot;);">1544                 LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excludedðŸ”µ</abbr>
1545                 componentPresentationAttributes.get(key).setExcluded(true);
1546             }
1547         }
1548 
1549         PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1550         Property property;
1551 
1552         try {
1553             property = persistentClass.getProperty(propertyName);
1554         } catch (MappingException e) {
1555             property = persistentClass.getProperty(prefix + propertyName);
1556         }
1557 
<abbr title="1558         Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPropertyIterator();">1558         Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPðŸ”µ</abbr>
1559         List&lt;Property&gt; componentPropertyList = new ArrayList&lt;&gt;();
1560 
1561         while (componentPropertyIterator.hasNext()) {
1562             componentPropertyList.add((Property) componentPropertyIterator.next());
1563         }
1564 
1565         Map&lt;String, FieldMetadata&gt; newFields = new HashMap&lt;&gt;();
1566         buildProperties(
1567                 targetClass,
1568                 foreignField,
1569                 additionalForeignFields,
1570                 additionalNonPersistentProperties,
1571                 mergedPropertyType,
1572                 componentPresentationAttributes,
1573                 componentPropertyList,
1574                 newFields,
1575                 componentPropertyNames,
1576                 componentPropertyTypes,
1577                 idProperty,
1578                 populateManyToOneFields,
1579                 includeFields,
1580                 excludeFields,
1581                 configurationKey,
1582                 ceilingEntityFullyQualifiedClassname,
1583                 parentClasses,
1584                 propertyName + &quot;.&quot;,
1585                 isParentExcluded,
1586                 true,
1587                 parentPrefix + prefix
1588         );
1589 
1590         Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;();
1591 
1592         for (String key : newFields.keySet()) {
1593             final FieldMetadata fieldMetadata = newFields.get(key);
1594             convertedFields.put(propertyName + &quot;.&quot; + key, fieldMetadata);
1595 
1596             if (isForeignKey(fieldMetadata)) {
1597                 setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1598             }
1599         }
1600         fields.putAll(convertedFields);
1601     }
1602 
1603     @Override
1604     public EntityManager getStandardEntityManager() {
1605         return standardEntityManager;
1606     }
1607 
1608     @Override
1609     public void setStandardEntityManager(EntityManager entityManager) {
1610         this.standardEntityManager = entityManager;
1611         fieldManager = new FieldManager(entityConfiguration, entityManager);
1612     }
1613 
1614     @Override
1615     public FieldManager getFieldManager() {
1616         return this.getFieldManager(true);
1617     }
1618 
1619     @Override
1620     public FieldManager getFieldManager(boolean cleanFieldManager) {
1621         if (fieldManager == null) {
1622             //keep in mind that getStandardEntityManager() can return null, this is in general OK,
1623             // we re-init fieldManager in setStandardEntityManager method
1624             fieldManager = new FieldManager(entityConfiguration, getStandardEntityManager());
1625         } else if (cleanFieldManager){
1626             fieldManager.clearMiddleFields();
1627         }
1628         return fieldManager;
1629     }
1630 
1631     @Override
1632     public EntityConfiguration getEntityConfiguration() {
1633         return entityConfiguration;
1634     }
1635 
1636     @Override
1637     public void setEntityConfiguration(EntityConfiguration entityConfiguration) {
1638         this.entityConfiguration = entityConfiguration;
1639     }
1640 
1641     @Override
1642     public Metadata getMetadata() {
1643         return metadata;
1644     }
1645 
1646     @Override
1647     public void setMetadata(Metadata metadata) {
1648         this.metadata = metadata;
1649     }
1650 
1651     public List&lt;FieldMetadataProvider&gt; getFieldMetadataProviders() {
1652         return fieldMetadataProviders;
1653     }
1654 
1655     public void setFieldMetadataProviders(List&lt;FieldMetadataProvider&gt; fieldMetadataProviders) {
1656         this.fieldMetadataProviders = fieldMetadataProviders;
1657     }
1658 
1659     @Override
1660     public FieldMetadataProvider getDefaultFieldMetadataProvider() {
1661         return defaultFieldMetadataProvider;
1662     }
1663 
1664     public void setDefaultFieldMetadataProvider(FieldMetadataProvider defaultFieldMetadataProvider) {
1665         this.defaultFieldMetadataProvider = defaultFieldMetadataProvider;
1666     }
1667 
1668     protected boolean isExcludeClassFromPolymorphism(Class&lt;?&gt; clazz) {
1669         return dynamicDaoHelper.isExcludeClassFromPolymorphism(clazz);
1670     }
1671 
1672     @Override
1673     public DynamicDaoHelper getDynamicDaoHelper() {
1674         return dynamicDaoHelper;
1675     }
1676 
1677     public void setDynamicDaoHelper(DynamicDaoHelper dynamicDaoHelper) {
1678         this.dynamicDaoHelper = dynamicDaoHelper;
1679     }
1680 
1681 }</pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.server.dao;
  19 
  20 
  21 import org.apache.commons.collections4.map.LRUMap;
  22 import org.apache.commons.lang.StringUtils;
  23 import org.apache.commons.lang3.ArrayUtils;
  24 import org.apache.commons.logging.Log;
  25 import org.apache.commons.logging.LogFactory;
  26 import org.broadleafcommerce.common.money.Money;
  27 import org.broadleafcommerce.common.persistence.EntityConfiguration;
  28 import org.broadleafcommerce.common.persistence.Status;
  29 import org.broadleafcommerce.common.presentation.AdminPresentationClass;
  30 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  31 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  32 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  33 import org.broadleafcommerce.common.util.dao.DynamicDaoHelper;
  34 import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
  35 import org.broadleafcommerce.common.util.dao.HibernateMappingProvider;
  36 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  37 import org.broadleafcommerce.openadmin.dto.BasicCollectionMetadata;
  38 import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  39 import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  40 import org.broadleafcommerce.openadmin.dto.ClassTree;
  41 import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  42 import org.broadleafcommerce.openadmin.dto.ForeignKey;
  43 import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  44 import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  45 import org.broadleafcommerce.openadmin.dto.TabMetadata;
  46 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.BasicFieldMetadataProvider;
  47 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.FieldMetadataProvider;
<abbr title="  48 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequest;">  48 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequeðŸ”µ</abbr>
  49 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.LateStageAddMetadataRequest;
  50 import org.broadleafcommerce.openadmin.server.service.persistence.module.FieldManager;
  51 import org.broadleafcommerce.openadmin.server.service.persistence.validation.FieldNamePropertyValidator;
  52 import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  53 import org.hibernate.Criteria;
  54 import org.hibernate.MappingException;
  55 import org.hibernate.Session;
  56 import org.hibernate.mapping.PersistentClass;
  57 import org.hibernate.mapping.Property;
  58 import org.hibernate.type.ComponentType;
  59 import org.hibernate.type.Type;
  60 import org.springframework.beans.BeansException;
  61 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
  62 import org.springframework.beans.factory.annotation.Value;
  63 import org.springframework.context.ApplicationContext;
  64 import org.springframework.context.ApplicationContextAware;
  65 import org.springframework.context.annotation.Scope;
  66 import org.springframework.core.annotation.AnnotationUtils;
  67 import org.springframework.stereotype.Component;
  68 
  69 import java.io.Serializable;
  70 import java.lang.reflect.Field;
  71 import java.lang.reflect.Method;
  72 import java.lang.reflect.Modifier;
  73 import java.math.BigDecimal;
  74 import java.math.BigInteger;
  75 import java.security.MessageDigest;
  76 import java.security.NoSuchAlgorithmException;
  77 import java.text.DecimalFormat;
  78 import java.text.NumberFormat;
  79 import java.util.ArrayList;
  80 import java.util.Arrays;
  81 import java.util.Collections;
  82 import java.util.Comparator;
  83 import java.util.Date;
  84 import java.util.HashMap;
  85 import java.util.HashSet;
  86 import java.util.Iterator;
  87 import java.util.List;
  88 import java.util.Map;
  89 import java.util.Set;
  90 
  91 import javax.annotation.Nonnull;
  92 import javax.annotation.Resource;
  93 import javax.persistence.EntityManager;
  94 import javax.persistence.criteria.CriteriaBuilder;
  95 import javax.persistence.criteria.CriteriaQuery;
  96 import javax.persistence.criteria.Path;
  97 import javax.persistence.criteria.Predicate;
  98 import javax.persistence.criteria.Root;
  99 
 100 /**
 101  * @author jfischer
 102  */
 103 @Component(&quot;blDynamicEntityDao&quot;)
 104 @Scope(&quot;prototype&quot;)
 105 public class DynamicEntityDaoImpl implements DynamicEntityDao, ApplicationContextAware {
 106 
 107     private static final Log LOG = LogFactory.getLog(DynamicEntityDaoImpl.class);
 108 
 109     protected static final Map&lt;String, Map&lt;String, FieldMetadata&gt;&gt; METADATA_CACHE = new LRUMap&lt;&gt;(1000);
 110 
 111     /**
<abbr title=" 112      * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we have cached in METADATA_CACHE over the lifetime"> 112      * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we hðŸ”µ</abbr>
<abbr title=" 113      * of the application. This should survive evictions from METADATA_CACHE because it is for the purpose of diagnosing when we store different property"> 113      * of the application. This should survive evictions from METADATA_CACHE because it is for the purposðŸ”µ</abbr>
 114      * counts in METADATA_CACHE as a result of cache eviction
 115      */
 116     protected static final Map&lt;String, Integer&gt; METADATA_CACHE_SIZES = new HashMap&lt;&gt;();
 117 
 118     /*
<abbr title=" 119      * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are abstract or have been marked for exclusion"> 119      * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are absðŸ”µ</abbr>
 120      * from polymorphism
 121      */
 122 
 123     protected EntityManager standardEntityManager;
 124 
 125     @Resource(name = &quot;blMetadata&quot;)
 126     protected Metadata metadata;
 127 
 128     @Resource(name = &quot;blEntityConfiguration&quot;)
 129     protected EntityConfiguration entityConfiguration;
 130 
 131     @Resource(name = &quot;blFieldMetadataProviders&quot;)
 132     protected List&lt;FieldMetadataProvider&gt; fieldMetadataProviders = new ArrayList&lt;&gt;();
 133 
 134     @Resource(name = &quot;blDefaultFieldMetadataProvider&quot;)
 135     protected FieldMetadataProvider defaultFieldMetadataProvider;
 136 
 137     @Resource(name = &quot;blBasicFieldMetadataProvider&quot;)
 138     protected BasicFieldMetadataProvider basicFieldMetadataProvider;
 139 
 140     @Resource(name = &quot;blAppConfigurationMap&quot;)
 141     protected Map&lt;String, String&gt; propertyConfigurations = new HashMap&lt;&gt;();
 142 
 143     protected DynamicDaoHelper dynamicDaoHelper = new DynamicDaoHelperImpl();
 144 
 145     @Value(&quot;${cache.entity.dao.metadata.ttl}&quot;)
 146     protected int cacheEntityMetaDataTtl;
 147 
 148     /**
<abbr title=" 149      * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the application"> 149      * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the applicatioðŸ”µ</abbr>
 150      */
 151     @Value(&quot;${validate.metadata.cache.sizes:false}&quot;)
 152     protected boolean validateMetadataCacheSizes;
 153 
 154     protected long lastCacheFlushTime = System.currentTimeMillis();
 155 
 156     protected ApplicationContext applicationContext;
 157 
 158     protected FieldManager fieldManager;
 159 
 160     @Override
 161     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 162         this.applicationContext = applicationContext;
 163     }
 164 
 165     @Override
 166     public Criteria createCriteria(Class&lt;?&gt; entityClass) {
 167         return getStandardEntityManager().unwrap(Session.class).createCriteria(entityClass);
 168     }
 169 
 170     @Override
 171     public &lt;T&gt; T persist(T entity) {
 172         standardEntityManager.persist(entity);
 173         standardEntityManager.flush();
 174         return entity;
 175     }
 176 
 177     @Override
 178     public Object find(Class&lt;?&gt; entityClass, Object key) {
 179         return standardEntityManager.find(entityClass, key);
 180     }
 181 
 182     @Override
 183     public &lt;T&gt; T merge(T entity) {
 184         T response = standardEntityManager.merge(entity);
 185         standardEntityManager.flush();
 186         return response;
 187     }
 188 
 189     @Override
 190     public void flush() {
 191         standardEntityManager.flush();
 192     }
 193 
 194     @Override
 195     public void detach(Serializable entity) {
 196         standardEntityManager.detach(entity);
 197     }
 198 
 199     @Override
 200     public void refresh(Serializable entity) {
 201         standardEntityManager.refresh(entity);
 202     }
 203 
 204     @Override
 205     public Serializable retrieve(Class&lt;?&gt; entityClass, Object primaryKey) {
 206         return (Serializable) standardEntityManager.find(entityClass, primaryKey);
 207     }
 208 
 209     @Override
 210     public void remove(Serializable entity) {
 211         standardEntityManager.remove(entity);
 212         standardEntityManager.flush();
 213     }
 214 
 215     @Override
 216     public void clear() {
 217         standardEntityManager.clear();
 218     }
 219 
 220     @Override
 221     public PersistentClass getPersistentClass(String targetClassName) {
 222         return HibernateMappingProvider.getMapping(targetClassName);
 223     }
 224 
 225     @Override
 226     public boolean useCache() {
 227         if (cacheEntityMetaDataTtl &lt; 0) {
 228             return true;
 229         }
 230         if (cacheEntityMetaDataTtl == 0) {
 231             return false;
 232         } else {
 233             if ((System.currentTimeMillis() - lastCacheFlushTime) &gt; cacheEntityMetaDataTtl) {
 234                 lastCacheFlushTime = System.currentTimeMillis();
 235                 METADATA_CACHE.clear();
 236                 DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE.clear();
 237                 DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE_WO_EXCLUSIONS.clear();
 238                 LOG.trace(&quot;Metadata cache evicted&quot;);
 239                 return true; // cache is empty
 240             } else {
 241                 return true;
 242             }
 243         }
 244     }
 245 
 246     @Override
 247     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass) {
 248         return getAllPolymorphicEntitiesFromCeiling(ceilingClass, true);
 249     }
 250 
 251     @Override
<abbr title=" 252     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymorphicEntities) {"> 252     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifðŸ”µ</abbr>
<abbr title=" 253         return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolymorphicEntities, useCache());"> 253         return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolyðŸ”µ</abbr>
 254     }
 255 
 256     @Override
 257     public Class&lt;?&gt;[] getUpDownInheritance(Class&lt;?&gt; testClass) {
 258         return dynamicDaoHelper.getUpDownInheritance(testClass, true, useCache());
 259     }
 260 
 261     @Override
 262     public Class&lt;?&gt; getImplClass(String className) {
 263         Class&lt;?&gt; clazz = null;
 264         try {
 265             clazz = entityConfiguration.lookupEntityClass(className);
 266         } catch (NoSuchBeanDefinitionException e) {
 267             //do nothing
 268         }
 269         if (clazz == null) {
 270             try {
 271                 clazz = Class.forName(className);
 272             } catch (ClassNotFoundException e) {
 273                 throw new RuntimeException(e);
 274             }
 275             clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 276         }
 277         return clazz;
 278     }
 279 
 280     @Override
 281     public Class&lt;?&gt; getCeilingImplClass(String className) {
 282         Class&lt;?&gt; clazz;
 283         try {
 284             clazz = Class.forName(className);
 285         } catch (ClassNotFoundException e) {
 286             throw new RuntimeException(e);
 287         }
 288         Class&lt;?&gt;[] entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 289         if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
 290             clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 291             entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 292         }
 293         if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
<abbr title=" 294             throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for the requested class name (%s)&quot;, className));"> 294             throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for tðŸ”µ</abbr>
 295         }
 296         clazz = entitiesFromCeiling[entitiesFromCeiling.length - 1];
 297         return clazz;
 298     }
 299 
 300     @Override
<abbr title=" 301     public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, String value) {"> 301     public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, StriðŸ”µ</abbr>
<abbr title=" 302         Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass());"> 302         Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass())ðŸ”µ</abbr>
 303         CriteriaBuilder builder = this.standardEntityManager.getCriteriaBuilder();
 304         CriteriaQuery&lt;Long&gt; criteria = builder.createQuery(Long.class);
 305         Root root = criteria.from(clazz);
 306         Path idField = root.get(this.getIdField(clazz).getName());
 307         criteria.select(idField.as(Long.class));
 308         List&lt;Predicate&gt; restrictions = new ArrayList();
 309 
 310         Path path = null;
 311 
 312         // Support property name such as &quot;defaultSku.name&quot;
 313         if (propertyName.contains(&quot;.&quot;)) {
 314             String[] split = propertyName.split(&quot;\\.&quot;);
 315             for (String splitResult : split) {
 316                 if (path == null) {
 317                     path = root.get(splitResult);
 318                 } else {
 319                     path = path.get(splitResult);
 320                 }
 321             }
 322         } else {
 323             path = root.get(propertyName);
 324         }
 325 
 326         restrictions.add(builder.equal(path, value));
 327         Serializable identifier = this.getIdentifier(instance);
 328         //when we creating the new item identifier is not exists
 329         if (identifier != null) {
 330             restrictions.add(builder.notEqual(idField, identifier));
 331         }
 332 
 333         if (instance instanceof Status) {
<abbr title=" 334             restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), builder.equal(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;), &#x27;N&#x27;)));"> 334             restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), buildeðŸ”µ</abbr>
 335         }
 336 
 337         criteria.where(restrictions.toArray(new Predicate[restrictions.size()]));
 338         return this.standardEntityManager.createQuery(criteria).getResultList();
 339     }
 340 
 341     @Override
 342     public Serializable getIdentifier(Object entity) {
 343         return dynamicDaoHelper.getIdentifier(entity);
 344     }
 345 
 346     protected Field getIdField(Class&lt;?&gt; clazz) {
 347         return dynamicDaoHelper.getIdField(clazz);
 348     }
 349 
 350     public Class&lt;?&gt;[] sortEntities(Class&lt;?&gt; ceilingClass, List&lt;Class&lt;?&gt;&gt; entities) {
 351         return dynamicDaoHelper.sortEntities(ceilingClass, entities);
 352     }
 353 
 354     protected void addClassToTree(Class&lt;?&gt; clazz, ClassTree tree) {
 355         Class&lt;?&gt; testClass;
 356         try {
 357             testClass = Class.forName(tree.getFullyQualifiedClassname());
 358         } catch (ClassNotFoundException e) {
 359             throw new RuntimeException(e);
 360         }
 361         if (clazz.equals(testClass)) {
 362             return;
 363         }
 364         if (clazz.getSuperclass().equals(testClass)) {
 365             ClassTree myTree = new ClassTree(clazz.getName(), isExcludeClassFromPolymorphism(clazz));
 366             createClassTreeFromAnnotation(clazz, myTree);
 367             tree.setChildren(ArrayUtils.add(tree.getChildren(), myTree));
 368         } else {
 369             for (ClassTree child : tree.getChildren()) {
 370                 addClassToTree(clazz, child);
 371             }
 372         }
 373     }
 374 
 375     protected void createClassTreeFromAnnotation(Class&lt;?&gt; clazz, ClassTree myTree) {
<abbr title=" 376         AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 376         AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentatioðŸ”µ</abbr>
 377         if (classPresentation != null) {
 378             String friendlyName = classPresentation.friendlyName();
 379             if (!StringUtils.isEmpty(friendlyName)) {
 380                 myTree.setFriendlyName(friendlyName);
 381             }
 382         }
 383     }
 384 
 385     @Override
 386     public ClassTree getClassTree(Class&lt;?&gt;[] polymorphicClasses) {
 387         String ceilingClass = null;
 388         for (Class&lt;?&gt; clazz : polymorphicClasses) {
<abbr title=" 389             AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 389             AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentðŸ”µ</abbr>
 390             if (classPresentation != null) {
 391                 String ceilingEntity = classPresentation.ceilingDisplayEntity();
 392                 if (!StringUtils.isEmpty(ceilingEntity)) {
 393                     ceilingClass = ceilingEntity;
 394                     break;
 395                 }
 396             }
 397         }
 398         if (ceilingClass != null) {
 399             int pos = -1;
 400             int j = 0;
 401             for (Class&lt;?&gt; clazz : polymorphicClasses) {
 402                 if (clazz.getName().equals(ceilingClass)) {
 403                     pos = j;
 404                     break;
 405                 }
 406                 j++;
 407             }
 408             if (pos &gt;= 0) {
 409                 Class&lt;?&gt;[] temp = new Class&lt;?&gt;[pos + 1];
 410                 System.arraycopy(polymorphicClasses, 0, temp, 0, j + 1);
 411                 polymorphicClasses = temp;
 412             }
 413         }
 414 
 415         ClassTree classTree = null;
 416         if (!ArrayUtils.isEmpty(polymorphicClasses)) {
 417             Class&lt;?&gt; topClass = polymorphicClasses[polymorphicClasses.length - 1];
 418             classTree = new ClassTree(topClass.getName(), isExcludeClassFromPolymorphism(topClass));
 419             createClassTreeFromAnnotation(topClass, classTree);
 420             for (int j = polymorphicClasses.length - 1; j &gt;= 0; j--) {
 421                 addClassToTree(polymorphicClasses[j], classTree);
 422             }
 423             classTree.finalizeStructure(1);
 424         }
 425         return classTree;
 426     }
 427 
 428     @Override
 429     public ClassTree getClassTreeFromCeiling(Class&lt;?&gt; ceilingClass) {
 430         Class&lt;?&gt;[] sortedEntities = getAllPolymorphicEntitiesFromCeiling(ceilingClass);
 431         return getClassTree(sortedEntities);
 432     }
 433 
 434     @Override
<abbr title=" 435     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 435     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspectiveðŸ”µ</abbr>
 436         Class&lt;?&gt;[] entityClasses;
 437         try {
 438             entityClasses = getAllPolymorphicEntitiesFromCeiling(Class.forName(entityName));
 439         } catch (ClassNotFoundException e) {
 440             throw new RuntimeException(e);
 441         }
 442         if (!ArrayUtils.isEmpty(entityClasses)) {
 443             return getMergedProperties(
 444                     entityName,
 445                     entityClasses,
<abbr title=" 446                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 446                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePðŸ”µ</abbr>
 447                     persistencePerspective.getAdditionalNonPersistentProperties(),
 448                     persistencePerspective.getAdditionalForeignKeys(),
 449                     MergedPropertyType.PRIMARY,
 450                     persistencePerspective.getPopulateToOneFields(),
 451                     persistencePerspective.getIncludeFields(),
 452                     persistencePerspective.getExcludeFields(),
 453                     persistencePerspective.getConfigurationKey(),
 454                     &quot;&quot;
 455             );
 456         } else {
 457             Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 458             Class&lt;?&gt; targetClass;
 459             try {
 460                 targetClass = Class.forName(entityName);
 461             } catch (ClassNotFoundException e) {
 462                 throw new RuntimeException(e);
 463             }
<abbr title=" 464             Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 464             Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targðŸ”µ</abbr>
 465             for (String property : attributesMap.keySet()) {
 466                 FieldMetadata presentationAttribute = attributesMap.get(property);
 467                 if (!presentationAttribute.getExcluded()) {
 468                     Field field = FieldManager.getSingleField(targetClass, property);
 469                     if (!Modifier.isStatic(field.getModifiers())) {
 470                         boolean handled = false;
 471                         for (FieldMetadataProvider provider : fieldMetadataProviders) {
 472                             MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title=" 473                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 473                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForðŸ”µ</abbr>
 474                                             MergedPropertyType.PRIMARY, null, null, &quot;&quot;,
<abbr title=" 475                                             property, null, false, 0, attributesMap, presentationAttribute,"> 475                                             property, null, false, 0, attributesMap, presentationAttributðŸ”µ</abbr>
<abbr title=" 476                                             ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(), field.getType(), this),"> 476                                             ((BasicFieldMetadata) presentationAttribute).getExplicitFieldðŸ”µ</abbr>
 477                                     mergedProperties);
 478                             if (MetadataProviderResponse.NOT_HANDLED != response) {
 479                                 handled = true;
 480                             }
 481                             if (MetadataProviderResponse.HANDLED_BREAK == response) {
 482                                 break;
 483                             }
 484                         }
 485                         if (!handled) {
<abbr title=" 486                             //this provider is not included in the provider list on purpose - it is designed to handle basic"> 486                             //this provider is not included in the provider list on purpose - it is desigðŸ”µ</abbr>
<abbr title=" 487                             //AdminPresentation fields, and those fields not admin presentation annotated at all"> 487                             //AdminPresentation fields, and those fields not admin presentation annotatedðŸ”µ</abbr>
 488                             defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title=" 489                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 489                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForðŸ”µ</abbr>
 490                                             MergedPropertyType.PRIMARY, null, null, &quot;&quot;, property,
<abbr title=" 491                                             null, false, 0, attributesMap, presentationAttribute, ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(),"> 491                                             null, false, 0, attributesMap, presentationAttribute, ((BasicðŸ”µ</abbr>
 492                                             field.getType(), this), mergedProperties);
 493                         }
 494                     }
 495                 }
 496             }
 497 
 498             return mergedProperties;
 499         }
 500     }
 501 
 502     @Override
 503     public Map&lt;String, FieldMetadata&gt; getMergedProperties(@Nonnull Class&lt;?&gt; cls) {
 504         Class&lt;?&gt;[] polymorphicTypes = getAllPolymorphicEntitiesFromCeiling(cls);
 505         return getMergedProperties(
 506                 cls.getName(),
 507                 polymorphicTypes,
 508                 null,
 509                 new String[]{},
 510                 new ForeignKey[]{},
 511                 MergedPropertyType.PRIMARY,
 512                 true,
 513                 new String[]{},
 514                 new String[]{},
 515                 null,
 516                 &quot;&quot;
 517         );
 518     }
 519 
 520     @Override
 521     public Map&lt;String, FieldMetadata&gt; getMergedProperties(
 522             String ceilingEntityFullyQualifiedClassname,
 523             Class&lt;?&gt;[] entities,
 524             ForeignKey foreignField,
 525             String[] additionalNonPersistentProperties,
 526             ForeignKey[] additionalForeignFields,
 527             MergedPropertyType mergedPropertyType,
 528             Boolean populateManyToOneFields,
 529             String[] includeFields,
 530             String[] excludeFields,
 531             String configurationKey,
 532             String prefix) {
 533         Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedPropertiesRecursively(
 534                 ceilingEntityFullyQualifiedClassname,
 535                 entities,
 536                 foreignField,
 537                 additionalNonPersistentProperties,
 538                 additionalForeignFields,
 539                 mergedPropertyType,
 540                 populateManyToOneFields,
 541                 includeFields,
 542                 excludeFields,
 543                 configurationKey,
 544                 new ArrayList&lt;Class&lt;?&gt;&gt;(),
 545                 prefix,
 546                 false,
 547                 &quot;&quot;);
 548 
 549         final List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 550 
 551         for (final String key : mergedProperties.keySet()) {
<abbr title=" 552             if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded()) {"> 552             if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded(ðŸ”µ</abbr>
 553                 removeKeys.add(key);
 554             }
 555         }
 556 
 557         for (String removeKey : removeKeys) {
 558             mergedProperties.remove(removeKey);
 559         }
 560 
<abbr title=" 561         // Allow field metadata providers to contribute additional fields here. These latestage handlers take place"> 561         // Allow field metadata providers to contribute additional fields here. These latestage handlers ðŸ”µ</abbr>
<abbr title=" 562         // after any cached lookups occur, and are ideal for adding in dynamic properties that are not globally cacheable"> 562         // after any cached lookups occur, and are ideal for adding in dynamic properties that are not glðŸ”µ</abbr>
 563         // like properties gleaned from reflection typically are.
 564         Set&lt;String&gt; keys = new HashSet&lt;&gt;(mergedProperties.keySet());
 565         for (Class&lt;?&gt; targetClass : entities) {
 566             for (String key : keys) {
<abbr title=" 567                 LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass, this, &quot;&quot;);"> 567                 LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass,ðŸ”µ</abbr>
 568 
 569                 boolean foundOneOrMoreHandlers = false;
 570                 for (FieldMetadataProvider fieldMetadataProvider : fieldMetadataProviders) {
<abbr title=" 571                     MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);"> 571                     MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mðŸ”µ</abbr>
 572                     if (MetadataProviderResponse.NOT_HANDLED != response) {
 573                         foundOneOrMoreHandlers = true;
 574                     }
 575                     if (MetadataProviderResponse.HANDLED_BREAK == response) {
 576                         break;
 577                     }
 578                 }
 579                 if (!foundOneOrMoreHandlers) {
 580                     defaultFieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);
 581                 }
 582             }
 583         }
 584 
 585         return mergedProperties;
 586     }
 587 
 588     protected Map&lt;String, FieldMetadata&gt; getMergedPropertiesRecursively(
 589             final String ceilingEntityFullyQualifiedClassname,
 590             final Class&lt;?&gt;[] entities,
 591             final ForeignKey foreignField,
 592             final String[] additionalNonPersistentProperties,
 593             final ForeignKey[] additionalForeignFields,
 594             final MergedPropertyType mergedPropertyType,
 595             final Boolean populateManyToOneFields,
 596             final String[] includeFields,
 597             final String[] excludeFields,
 598             final String configurationKey,
 599             final List&lt;Class&lt;?&gt;&gt; parentClasses,
 600             final String prefix,
 601             final Boolean isParentExcluded,
 602             final String parentPrefix) {
 603         PropertyBuilder propertyBuilder = new PropertyBuilder() {
 604             @Override
 605             public Map&lt;String, FieldMetadata&gt; execute(Boolean overridePopulateManyToOne) {
 606                 Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 607                 Boolean classAnnotatedPopulateManyToOneFields;
 608                 if (overridePopulateManyToOne != null) {
 609                     classAnnotatedPopulateManyToOneFields = overridePopulateManyToOne;
 610                 } else {
 611                     classAnnotatedPopulateManyToOneFields = populateManyToOneFields;
 612                 }
 613 
 614                 buildPropertiesFromPolymorphicEntities(
 615                         entities,
 616                         foreignField,
 617                         additionalNonPersistentProperties,
 618                         additionalForeignFields,
 619                         mergedPropertyType,
 620                         classAnnotatedPopulateManyToOneFields,
 621                         includeFields,
 622                         excludeFields,
 623                         configurationKey,
 624                         ceilingEntityFullyQualifiedClassname,
 625                         mergedProperties,
 626                         parentClasses,
 627                         prefix,
 628                         isParentExcluded,
 629                         parentPrefix);
 630 
 631                 return mergedProperties;
 632             }
 633         };
 634 
<abbr title=" 635         Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilder, prefix, isParentExcluded, ceilingEntityFullyQualifiedClassname, configurationKey, this);"> 635         Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilderðŸ”µ</abbr>
<abbr title=" 636         applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedProperties);"> 636         applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedPropertiesðŸ”µ</abbr>
 637         applyForeignKeyPrecedence(foreignField, additionalForeignFields, mergedProperties);
 638 
 639         return mergedProperties;
 640     }
 641 
<abbr title=" 642     protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFields, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 642     protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFieldðŸ”µ</abbr>
 643         for (String key : mergedProperties.keySet()) {
 644             boolean isForeign = false;
 645             if (foreignField != null) {
 646                 isForeign = foreignField.getManyToField().equals(key);
 647             }
 648             if (!isForeign &amp;&amp; !ArrayUtils.isEmpty(additionalForeignFields)) {
 649                 for (ForeignKey foreignKey : additionalForeignFields) {
 650                     isForeign = foreignKey.getManyToField().equals(key);
 651                     if (isForeign) {
 652                         break;
 653                     }
 654                 }
 655             }
 656             if (isForeign) {
 657                 FieldMetadata metadata = mergedProperties.get(key);
 658                 metadata.setExcluded(false);
 659             }
 660         }
 661     }
 662 
<abbr title=" 663     protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefix, Boolean isParentExcluded, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 663     protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefixðŸ”µ</abbr>
 664         //check includes
 665         if (!ArrayUtils.isEmpty(includeFields)) {
 666             for (String include : includeFields) {
 667                 for (String key : mergedProperties.keySet()) {
 668                     String testKey = prefix + key;
 669                     if (!(testKey.startsWith(include + &quot;.&quot;) || testKey.equals(include))) {
 670                         FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 671                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did not appear in the explicit includeFields list&quot;);"> 671                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did ðŸ”µ</abbr>
 672                         metadata.setExcluded(true);
 673                     } else {
 674                         FieldMetadata metadata = mergedProperties.get(key);
 675                         if (!isParentExcluded) {
<abbr title=" 676                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field appears in the explicit includeFields list&quot;);"> 676                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field apðŸ”µ</abbr>
 677                             metadata.setExcluded(false);
 678                         }
 679                     }
 680                 }
 681             }
 682         } else if (!ArrayUtils.isEmpty(excludeFields)) {
 683             //check excludes
 684             for (String exclude : excludeFields) {
 685                 for (String key : mergedProperties.keySet()) {
 686                     String testKey = prefix + key;
 687                     if (testKey.startsWith(exclude + &quot;.&quot;) || testKey.equals(exclude)) {
 688                         FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 689                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appears in the explicit excludeFields list&quot;);"> 689                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appeðŸ”µ</abbr>
 690                         metadata.setExcluded(true);
 691                     } else {
 692                         FieldMetadata metadata = mergedProperties.get(key);
 693                         if (!isParentExcluded) {
<abbr title=" 694                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field did not appear in the explicit excludeFields list&quot;);"> 694                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field diðŸ”µ</abbr>
 695                             metadata.setExcluded(false);
 696                         }
 697                     }
 698                 }
 699             }
 700         }
 701     }
 702 
 703     protected String pad(String s, int length, char pad) {
 704         StringBuilder buffer = new StringBuilder(s);
 705         while (buffer.length() &lt; length) {
 706             buffer.insert(0, pad);
 707         }
 708         return buffer.toString();
 709     }
 710 
<abbr title=" 711     protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, String[] additionalNonPersistentProperties, ForeignKey[] additionalForeignFields, MergedPropertyType mergedPropertyType, Boolean populateManyToOneFields, Class&lt;?&gt; clazz, String configurationKey, Boolean isParentExcluded) {"> 711     protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, StðŸ”µ</abbr>
 712         StringBuilder sb = new StringBuilder(150);
 713         sb.append(ceilingEntityFullyQualifiedClassname);
 714         sb.append(clazz.hashCode());
 715         sb.append(foreignField == null ? &quot;&quot; : foreignField.toString());
 716         sb.append(configurationKey);
 717         sb.append(isParentExcluded);
 718         if (additionalNonPersistentProperties != null) {
 719             for (String prop : additionalNonPersistentProperties) {
 720                 sb.append(prop);
 721             }
 722         }
 723         if (additionalForeignFields != null) {
 724             for (ForeignKey key : additionalForeignFields) {
 725                 sb.append(key.toString());
 726             }
 727         }
 728         sb.append(mergedPropertyType);
 729         sb.append(populateManyToOneFields);
 730 
 731         String digest;
 732         try {
 733             MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
 734             byte[] messageDigest = md.digest(sb.toString().getBytes());
 735             BigInteger number = new BigInteger(1, messageDigest);
 736             digest = number.toString(16);
 737         } catch (NoSuchAlgorithmException e) {
 738             throw new RuntimeException(e);
 739         }
 740 
 741         String key = pad(digest, 32, &#x27;0&#x27;);
 742 
 743         if (LOG.isDebugEnabled()) {
 744             LOG.debug(&quot;Created cache key: &quot; + key + &quot; from the following string: &quot; + sb.toString());
 745         }
 746         return key;
 747     }
 748 
 749     protected void buildPropertiesFromPolymorphicEntities(
 750             Class&lt;?&gt;[] entities,
 751             ForeignKey foreignField,
 752             String[] additionalNonPersistentProperties,
 753             ForeignKey[] additionalForeignFields,
 754             MergedPropertyType mergedPropertyType,
 755             Boolean populateManyToOneFields,
 756             String[] includeFields,
 757             String[] excludeFields,
 758             String configurationKey,
 759             String ceilingEntityFullyQualifiedClassname,
 760             Map&lt;String, FieldMetadata&gt; mergedProperties,
 761             List&lt;Class&lt;?&gt;&gt; parentClasses,
 762             String prefix,
 763             Boolean isParentExcluded,
 764             String parentPrefix) {
 765         for (Class&lt;?&gt; clazz : entities) {
<abbr title=" 766             String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNonPersistentProperties, additionalForeignFields, mergedPropertyType, populateManyToOneFields, clazz, configurationKey, isParentExcluded);"> 766             String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNðŸ”µ</abbr>
 767 
 768             Map&lt;String, FieldMetadata&gt; cacheData = null;
 769             synchronized (DynamicDaoHelperImpl.LOCK_OBJECT) {
 770                 if (useCache()) {
 771                     cacheData = METADATA_CACHE.get(cacheKey);
 772                 }
 773 
 774                 if (cacheData == null) {
 775                     Map&lt;String, FieldMetadata&gt; props = getPropertiesForEntityClass(
 776                             clazz,
 777                             foreignField,
 778                             additionalNonPersistentProperties,
 779                             additionalForeignFields,
 780                             mergedPropertyType,
 781                             populateManyToOneFields,
 782                             includeFields,
 783                             excludeFields,
 784                             configurationKey,
 785                             ceilingEntityFullyQualifiedClassname,
 786                             parentClasses,
 787                             prefix,
 788                             isParentExcluded,
 789                             parentPrefix);
<abbr title=" 790                     //first check all the properties currently in there to see if my entity inherits from them"> 790                     //first check all the properties currently in there to see if my entity inherits fromðŸ”µ</abbr>
 791                     for (Class&lt;?&gt; clazz2 : entities) {
 792                         if (!clazz2.getName().equals(clazz.getName())) {
 793                             for (Map.Entry&lt;String, FieldMetadata&gt; entry : props.entrySet()) {
 794                                 FieldMetadata metadata = entry.getValue();
 795                                 try {
<abbr title=" 796                                     if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(clazz2)) {"> 796                                     if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(cðŸ”µ</abbr>
<abbr title=" 797                                         String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(), new String[]{clazz2.getName()});"> 797                                         String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(),ðŸ”µ</abbr>
 798                                         metadata.setAvailableToTypes(both);
 799                                     }
 800                                 } catch (ClassNotFoundException e) {
 801                                     throw new RuntimeException(e);
 802                                 }
 803                             }
 804                         }
 805                     }
 806                     METADATA_CACHE.put(cacheKey, props);
 807 
 808                     if (LOG.isTraceEnabled()) {
<abbr title=" 809                         LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 809                         LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKeyðŸ”µ</abbr>
 810                     }
 811 
 812                     if (validateMetadataCacheSizes) {
 813                         Integer previousSize = METADATA_CACHE_SIZES.get(cacheKey);
 814                         Integer currentSize = props.size();
 815                         if (previousSize == null) {
 816                             METADATA_CACHE_SIZES.put(cacheKey, currentSize);
 817                         } else if (!currentSize.equals(previousSize)) {
<abbr title=" 818                             String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache for the key &quot; + cacheKey + &quot; but we had previously stored &quot; + previousSize + &quot; properties&quot;;"> 818                             String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache ðŸ”µ</abbr>
 819                             LOG.error(msg);
 820                             throw new RuntimeException(msg);
 821                         }
 822                     }
 823 
 824                     cacheData = props;
 825                 } else {
 826                     if (LOG.isTraceEnabled()) {
<abbr title=" 827                         LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 827                         LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheðŸ”µ</abbr>
 828                     }
 829 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 830                     //in case of MT different sites can potentially have different data driven enums, as we don&#x27;t take into account"> 830                     //in case of MT different sites can potentially have different data driven enums, as ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 831                     //site during cache key calculation(have metadata per-site is overkill) we want to refresh data driven enums"> 831                     //site during cache key calculation(have metadata per-site is overkill) we want to reðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 832                     for (FieldMetadata value : cacheData.values()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 833                         if(value instanceof BasicFieldMetadata &amp;&amp; StringUtils.isNotEmpty(((BasicFieldMetadata)value).getOptionListEntity())){"> 833                         if(value instanceof BasicFieldMetadata &amp;&amp; StringUtils.isNotEmpty(((BasicFieldMetaðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 834                             basicFieldMetadataProvider.refreshDataDrivenEnumMetadata((BasicFieldMetadata) value);"> 834                             basicFieldMetadataProvider.refreshDataDrivenEnumMetadata((BasicFieldMetadata)ðŸ”µ</abbr></span>
 835 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 836                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 837             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 838             //clone the metadata before passing to the system</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 839             Map&lt;String, FieldMetadata&gt; clonedCache = new HashMap&lt;&gt;(cacheData.size());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 840             for (Map.Entry&lt;String, FieldMetadata&gt; entry : cacheData.entrySet()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 841                 clonedCache.put(entry.getKey(), entry.getValue().cloneFieldMetadata());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 842             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 843             mergedProperties.putAll(clonedCache);</span>
 844 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 845                     for (FieldMetadata value : cacheData.values()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 846                         //that&#x27;s for the case when metadata cache is enabled(cache.entity.dao.metadata.ttl=-1) and you cache metadata for en locale"> 846                         //that&#x27;s for the case when metadata cache is enabled(cache.entity.dao.metadata.ttðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 847                         //then switch to FR that has comma as decimal separator</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 848                         if (value instanceof BasicFieldMetadata) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 849                             BasicFieldMetadata v = (BasicFieldMetadata) value;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 850                             if (SupportedFieldType.DECIMAL.equals(v.getSecondaryType()) || SupportedFieldType.INTEGER.equals(v.getSecondaryType())"> 850                             if (SupportedFieldType.DECIMAL.equals(v.getSecondaryType()) || SupportedFieldðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 851                                     || SupportedFieldType.INTEGER.equals(v.getFieldType()) || SupportedFieldType.DECIMAL.equals(v.getFieldType())) {"> 851                                     || SupportedFieldType.INTEGER.equals(v.getFieldType()) || SupportedFiðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 852                                 refreshDecimalDefaultValue(v);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 853                             }</span>
 854 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 855                         }
 856                     }
 857                 }
 858             }
 859             //clone the metadata before passing to the system
 860             Map&lt;String, FieldMetadata&gt; clonedCache = new HashMap&lt;&gt;(cacheData.size());
 861             for (Map.Entry&lt;String, FieldMetadata&gt; entry : cacheData.entrySet()) {
 862                 clonedCache.put(entry.getKey(), entry.getValue().cloneFieldMetadata());
 863             }
 864             mergedProperties.putAll(clonedCache);
 865         }
 866     }
 867 
 868     public void refreshDecimalDefaultValue(BasicFieldMetadata value) {
<abbr title=" 869         DecimalFormat instance = (DecimalFormat) NumberFormat.getInstance(BroadleafRequestContext.getBroadleafRequestContext().getJavaLocale());"> 869         DecimalFormat instance = (DecimalFormat) NumberFormat.getInstance(BroadleafRequestContext.getBroaðŸ”µ</abbr>
<abbr title=" 870         if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;.&quot;) &amp;&amp; instance.getDecimalFormatSymbols().getDecimalSeparator()!=&#x27;.&#x27;){"> 870         if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;.&quot;) &amp;&amp; inðŸ”µ</abbr>
<abbr title=" 871             value.setDefaultValue(value.getDefaultValue().replace(&#x27;.&#x27;, instance.getDecimalFormatSymbols().getDecimalSeparator()));"> 871             value.setDefaultValue(value.getDefaultValue().replace(&#x27;.&#x27;, instance.getDecimalFormatSymbols()ðŸ”µ</abbr>
<abbr title=" 872         }else if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;,&quot;) &amp;&amp; instance.getDecimalFormatSymbols().getDecimalSeparator()!=&#x27;,&#x27;){"> 872         }else if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;,&quot;)ðŸ”µ</abbr>
<abbr title=" 873             value.setDefaultValue(value.getDefaultValue().replace(&#x27;,&#x27;, instance.getDecimalFormatSymbols().getDecimalSeparator()));"> 873             value.setDefaultValue(value.getDefaultValue().replace(&#x27;,&#x27;, instance.getDecimalFormatSymbols()ðŸ”µ</abbr>
 874         }
 875 
 876     }
 877 
 878     @Override
 879     public Field[] getAllFields(Class&lt;?&gt; targetClass) {
 880         Field[] allFields = new Field[]{};
 881         boolean eof = false;
 882         Class&lt;?&gt; currentClass = targetClass;
 883         while (!eof) {
 884             Field[] fields = currentClass.getDeclaredFields();
 885             allFields = ArrayUtils.addAll(allFields, fields);
 886             if (currentClass.getSuperclass() != null) {
 887                 currentClass = currentClass.getSuperclass();
 888             } else {
 889                 eof = true;
 890             }
 891         }
 892 
 893         return allFields;
 894     }
 895 
 896     @Override
 897     public Map&lt;String, FieldMetadata&gt; getPropertiesForPrimitiveClass(
 898             String propertyName,
 899             String friendlyPropertyName,
 900             Class&lt;?&gt; targetClass,
 901             Class&lt;?&gt; parentClass,
 902             MergedPropertyType mergedPropertyType
 903     ) {
 904         Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 905         BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
 906         presentationAttribute.setFriendlyName(friendlyPropertyName);
 907         if (String.class.isAssignableFrom(targetClass)) {
 908             presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
 909             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 910             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.STRING, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 910             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 911         } else if (Boolean.class.isAssignableFrom(targetClass)) {
 912             presentationAttribute.setExplicitFieldType(SupportedFieldType.BOOLEAN);
 913             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 914             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.BOOLEAN, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 914             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 915         } else if (Date.class.isAssignableFrom(targetClass)) {
 916             presentationAttribute.setExplicitFieldType(SupportedFieldType.DATE);
 917             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 918             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DATE, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 918             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 919         } else if (Money.class.isAssignableFrom(targetClass)) {
 920             presentationAttribute.setExplicitFieldType(SupportedFieldType.MONEY);
 921             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 922             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.MONEY, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 922             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 923         } else if (
 924                 Byte.class.isAssignableFrom(targetClass) ||
 925                         Integer.class.isAssignableFrom(targetClass) ||
 926                         Long.class.isAssignableFrom(targetClass) ||
 927                         Short.class.isAssignableFrom(targetClass)
 928                 ) {
 929             presentationAttribute.setExplicitFieldType(SupportedFieldType.INTEGER);
 930             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 931             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.INTEGER, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 931             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 932         } else if (
 933                 Double.class.isAssignableFrom(targetClass) ||
 934                         BigDecimal.class.isAssignableFrom(targetClass)
 935                 ) {
 936             presentationAttribute.setExplicitFieldType(SupportedFieldType.DECIMAL);
 937             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 938             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DECIMAL, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 938             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 939         }
 940         ((BasicFieldMetadata) fields.get(propertyName)).setLength(255);
 941         ((BasicFieldMetadata) fields.get(propertyName)).setForeignKeyCollection(false);
 942         ((BasicFieldMetadata) fields.get(propertyName)).setRequired(true);
 943         ((BasicFieldMetadata) fields.get(propertyName)).setUnique(true);
 944         ((BasicFieldMetadata) fields.get(propertyName)).setScale(100);
 945         ((BasicFieldMetadata) fields.get(propertyName)).setPrecision(100);
 946 
 947         return fields;
 948     }
 949 
 950     @Override
 951     public Map&lt;String, Object&gt; getIdMetadata(Class&lt;?&gt; entityClass) {
 952         return dynamicDaoHelper.getIdMetadata(entityClass, standardEntityManager);
 953     }
 954 
 955     @Override
 956     public List&lt;String&gt; getPropertyNames(Class&lt;?&gt; entityClass) {
 957         return dynamicDaoHelper.getPropertyNames(entityClass);
 958     }
 959 
 960     @Override
 961     public List&lt;Type&gt; getPropertyTypes(Class&lt;?&gt; entityClass) {
 962         return dynamicDaoHelper.getPropertyTypes(entityClass);
 963     }
 964 
 965     @Override
 966     public Map&lt;String, TabMetadata&gt; getTabAndGroupMetadata(Class&lt;?&gt;[] entities, ClassMetadata cmd) {
 967         Class&lt;?&gt;[] superClassEntities = getSuperClassHierarchy(entities[entities.length - 1]);
 968 
<abbr title=" 969         Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entities);"> 969         Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entitiesðŸ”µ</abbr>
 970         metadata.applyTabAndGroupMetadataOverrides(superClassEntities, mergedTabAndGroupMetadata);
 971         metadata.buildAdditionalTabAndGroupMetadataFromCmdProperties(cmd, mergedTabAndGroupMetadata);
 972 
 973         return mergedTabAndGroupMetadata;
 974     }
 975 
 976     public Class&lt;?&gt;[] getSuperClassHierarchy(Class&lt;?&gt; ceilingEntity) {
 977         Class&lt;?&gt;[] entities = new Class&lt;?&gt;[]{};
 978 
 979         if (ceilingEntity != null) {
 980             entities = ArrayUtils.add(entities, ceilingEntity);
 981             while (!ceilingEntity.getSuperclass().equals(Object.class)) {
 982                 entities = ArrayUtils.add(entities, ceilingEntity.getSuperclass());
 983                 ceilingEntity = ceilingEntity.getSuperclass();
 984             }
 985         }
 986         return entities;
 987     }
 988 
 989     protected Map&lt;String, FieldMetadata&gt; getPropertiesForEntityClass(
 990             Class&lt;?&gt; targetClass,
 991             ForeignKey foreignField,
 992             String[] additionalNonPersistentProperties,
 993             ForeignKey[] additionalForeignFields,
 994             MergedPropertyType mergedPropertyType,
 995             Boolean populateManyToOneFields,
 996             String[] includeFields,
 997             String[] excludeFields,
 998             String configurationKey,
 999             String ceilingEntityFullyQualifiedClassname,
1000             List&lt;Class&lt;?&gt;&gt; parentClasses,
1001             String prefix,
1002             Boolean isParentExcluded,
1003             String parentPrefix) {
<abbr title="1004         Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);">1004         Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null,ðŸ”µ</abbr>
1005         if (isParentExcluded) {
1006             for (String key : presentationAttributes.keySet()) {
<abbr title="1007                 LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;);">1007                 LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;ðŸ”µ</abbr>
1008                 presentationAttributes.get(key).setExcluded(true);
1009             }
1010         }
1011 
1012         Map idMetadata = getIdMetadata(targetClass);
1013         Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
1014         String idProperty = (String) idMetadata.get(&quot;name&quot;);
1015         List&lt;String&gt; propertyNames = getPropertyNames(targetClass);
1016         propertyNames.add(idProperty);
1017         Type idType = (Type) idMetadata.get(&quot;type&quot;);
1018         List&lt;Type&gt; propertyTypes = getPropertyTypes(targetClass);
1019         propertyTypes.add(idType);
1020 
1021         PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1022         Iterator testIter = persistentClass.getPropertyIterator();
1023         List&lt;Property&gt; propertyList = new ArrayList&lt;&gt;();
1024 
1025         //check the properties for problems
1026         while (testIter.hasNext()) {
1027             Property property = (Property) testIter.next();
1028             if (property.getName().contains(&quot;.&quot;)) {
<abbr title="1029                 throw new IllegalArgumentException(&quot;Properties from entities that utilize a period character (&#x27;.&#x27;) in their name are incompatible with this system. The property name in question is: (&quot; + property.getName() + &quot;) from the class: (&quot; + targetClass.getName() + &quot;)&quot;);">1029                 throw new IllegalArgumentException(&quot;Properties from entities that utilize a period characðŸ”µ</abbr>
1030             }
1031             propertyList.add(property);
1032         }
1033 
1034         buildProperties(
1035                 targetClass,
1036                 foreignField,
1037                 additionalForeignFields,
1038                 additionalNonPersistentProperties,
1039                 mergedPropertyType,
1040                 presentationAttributes,
1041                 propertyList,
1042                 fields,
1043                 propertyNames,
1044                 propertyTypes,
1045                 idProperty,
1046                 populateManyToOneFields,
1047                 includeFields,
1048                 excludeFields,
1049                 configurationKey,
1050                 ceilingEntityFullyQualifiedClassname,
1051                 parentClasses,
1052                 prefix,
1053                 isParentExcluded,
1054                 false,
1055                 parentPrefix
1056         );
1057         BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
1058         presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
1059         presentationAttribute.setVisibility(VisibilityEnum.HIDDEN_ALL);
1060         if (!ArrayUtils.isEmpty(additionalNonPersistentProperties)) {
1061             Class&lt;?&gt;[] entities = getAllPolymorphicEntitiesFromCeiling(targetClass);
1062             for (String additionalNonPersistentProperty : additionalNonPersistentProperties) {
<abbr title="1063                 if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersistentProperty.startsWith(prefix))) {">1063                 if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersisteðŸ”µ</abbr>
1064                     String myAdditionalNonPersistentProperty = additionalNonPersistentProperty;
1065                     //get final property if this is a dot delimited property
1066                     int finalDotPos = additionalNonPersistentProperty.lastIndexOf(&#x27;.&#x27;);
1067                     if (finalDotPos &gt;= 0) {
<abbr title="1068                         myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(finalDotPos + 1, myAdditionalNonPersistentProperty.length());">1068                         myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(fðŸ”µ</abbr>
1069                     }
<abbr title="1070                     //check all the polymorphic types on this target class to see if the end property exists">1070                     //check all the polymorphic types on this target class to see if the end property exiðŸ”µ</abbr>
1071                     Field testField = null;
1072                     Method testMethod = null;
1073                     for (Class&lt;?&gt; clazz : entities) {
1074                         try {
1075                             testMethod = clazz.getMethod(myAdditionalNonPersistentProperty);
1076                             if (testMethod != null) {
1077                                 break;
1078                             }
1079                         } catch (NoSuchMethodException e) {
1080                             //do nothing - method does not exist
1081                         }
1082                         testField = getFieldManager().getField(clazz, myAdditionalNonPersistentProperty);
1083                         if (testField != null) {
1084                             break;
1085                         }
1086                     }
1087                     //if the property exists, add it to the metadata for this class
1088                     if (testField != null || testMethod != null) {
<abbr title="1089                         fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, additionalNonPersistentProperty, propertyList, SupportedFieldType.STRING, null, targetClass, presentationAttribute, mergedPropertyType, this));">1089                         fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, addðŸ”µ</abbr>
1090                     }
1091                 }
1092             }
1093         }
1094 
1095         return fields;
1096     }
1097 
1098     protected void buildProperties(
1099             Class&lt;?&gt; targetClass,
1100             ForeignKey foreignField,
1101             ForeignKey[] additionalForeignFields,
1102             String[] additionalNonPersistentProperties,
1103             MergedPropertyType mergedPropertyType,
1104             Map&lt;String, FieldMetadata&gt; presentationAttributes,
1105             List&lt;Property&gt; componentProperties,
1106             Map&lt;String, FieldMetadata&gt; fields,
1107             List&lt;String&gt; propertyNames,
1108             List&lt;Type&gt; propertyTypes,
1109             String idProperty,
1110             Boolean populateManyToOneFields,
1111             String[] includeFields,
1112             String[] excludeFields,
1113             String configurationKey,
1114             String ceilingEntityFullyQualifiedClassname,
1115             List&lt;Class&lt;?&gt;&gt; parentClasses,
1116             String prefix,
1117             Boolean isParentExcluded,
1118             Boolean isComponentPrefix,
1119             String parentPrefix) {
1120         int j = 0;
1121         Comparator&lt;String&gt; propertyComparator = new Comparator&lt;String&gt;() {
1122             @Override
1123             public int compare(String o1, String o2) {
1124                 //check for property name equality and for map field properties
<abbr title="1125                 if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FieldManager.MAPFIELDSEPARATOR)) {">1125                 if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(ðŸ”µ</abbr>
1126                     return 0;
1127                 }
1128                 return o1.compareTo(o2);
1129             }
1130         };
1131         List&lt;String&gt; presentationKeyList = new ArrayList&lt;&gt;(presentationAttributes.keySet());
1132         Collections.sort(presentationKeyList);
1133 
1134         for (String propertyName : propertyNames) {
1135             final Type type = propertyTypes.get(j);
1136             boolean isPropertyForeignKey = testForeignProperty(foreignField, prefix, propertyName);
<abbr title="1137             int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFields, prefix, propertyName);">1137             int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFieldsðŸ”µ</abbr>
1138             j++;
1139             Field myField = getFieldManager().getField(targetClass, propertyName);
1140             if (myField == null) {
<abbr title="1141                 //try to get the field with the prefix - needed for advanced collections that appear in @Embedded classes">1141                 //try to get the field with the prefix - needed for advanced collections that appear in @ðŸ”µ</abbr>
1142                 myField = getFieldManager().getField(targetClass, prefix + propertyName);
1143             }
1144             if (
1145                     !type.isAnyType() &amp;&amp; !type.isCollectionType() ||
1146                             isPropertyForeignKey ||
1147                             additionalForeignKeyIndexPosition &gt;= 0 ||
<abbr title="1148                             Collections.binarySearch(presentationKeyList, propertyName, propertyComparator) &gt;= 0">1148                             Collections.binarySearch(presentationKeyList, propertyName, propertyComparatoðŸ”µ</abbr>
1149                     ) {
1150                 if (myField != null) {
1151                     boolean handled = false;
1152                     for (FieldMetadataProvider provider : fieldMetadataProviders) {
1153                         FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1154                         if (presentationAttribute != null) {
1155                             setExcludedBasedOnShowIfProperty(presentationAttribute);
1156                         }
1157                         MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title="1158                                 new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, additionalForeignFields,">1158                                 new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, aðŸ”µ</abbr>
1159                                         mergedPropertyType, componentProperties, idProperty, prefix,
<abbr title="1160                                         propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition,">1160                                         propertyName, type, isPropertyForeignKey, additionalForeignKeyIndðŸ”µ</abbr>
<abbr title="1161                                         presentationAttributes, presentationAttribute, null, type.getReturnedClass(), this), fields);">1161                                         presentationAttributes, presentationAttribute, null, type.getRetuðŸ”µ</abbr>
1162                         if (MetadataProviderResponse.NOT_HANDLED != response) {
1163                             handled = true;
1164                         }
1165                         if (MetadataProviderResponse.HANDLED_BREAK == response) {
1166                             break;
1167                         }
1168                     }
1169                     if (!handled) {
1170                         buildBasicProperty(myField, targetClass, foreignField, additionalForeignFields,
<abbr title="1171                                 additionalNonPersistentProperties, mergedPropertyType, presentationAttributes,">1171                                 additionalNonPersistentProperties, mergedPropertyType, presentationAttribðŸ”µ</abbr>
<abbr title="1172                                 componentProperties, fields, idProperty, populateManyToOneFields, includeFields,">1172                                 componentProperties, fields, idProperty, populateManyToOneFields, includeðŸ”µ</abbr>
<abbr title="1173                                 excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClasses,">1173                                 excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, paðŸ”µ</abbr>
<abbr title="1174                                 prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition, isComponentPrefix, parentPrefix);">1174                                 prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additðŸ”µ</abbr>
1175                     }
1176                 }
1177             }
1178         }
1179     }
1180 
1181     public Boolean testPropertyInclusion(FieldMetadata presentationAttribute) {
1182         setExcludedBasedOnShowIfProperty(presentationAttribute);
1183 
<abbr title="1184         return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presentationAttribute.getExcluded()) || (presentationAttribute.getChildrenExcluded() != null &amp;&amp; presentationAttribute.getChildrenExcluded())));">1184         return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presenðŸ”µ</abbr>
1185 
1186     }
1187 
1188     protected void setExcludedBasedOnShowIfProperty(FieldMetadata fieldMetadata) {
1189         if (fieldMetadata != null
1190                 &amp;&amp; StringUtils.isNotEmpty(fieldMetadata.getShowIfProperty())
1191                 &amp;&amp; propertyConfigurations.get(fieldMetadata.getShowIfProperty()) != null
1192                 &amp;&amp; !Boolean.valueOf(propertyConfigurations.get(fieldMetadata.getShowIfProperty()))) {
1193 
1194             //do not include this in the display if it returns false.
1195             fieldMetadata.setExcluded(true);
1196         }
1197     }
1198 
<abbr title="1199     protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyName, Class&lt;?&gt; targetClass,">1199     protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyNðŸ”µ</abbr>
<abbr title="1200                                             String ceilingEntityFullyQualifiedClassname, Boolean isComponentPrefix, String parentPrefix) {">1200                                             String ceilingEntityFullyQualifiedClassname, Boolean isComponðŸ”µ</abbr>
1201 
<abbr title="1202         Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyName, targetClass,">1202         Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyðŸ”µ</abbr>
1203                 ceilingEntityFullyQualifiedClassname, isComponentPrefix);
1204 
<abbr title="1205         Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isComponentPrefix,">1205         Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isCompoðŸ”µ</abbr>
1206                 parentPrefix, propertyName);
1207 
1208         return standardRecursionDetected || multiLevelEmbeddableRecursionDetected;
1209     }
1210 
<abbr title="1211     protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String parentPrefix, String propertyName) {">1211     protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String ðŸ”µ</abbr>
1212         return isComponentPrefix &amp;&amp; parentPrefix.contains(&quot;.&quot; + prefix + propertyName);
1213     }
1214 
1215     protected Boolean testStandardPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String
1216             propertyName, Class&lt;?&gt; targetClass, String ceilingEntityFullyQualifiedClassname, Boolean
1217                                                             isComponentPrefix) {
1218         Boolean response = false;
1219         //don&#x27;t want to shun a self-referencing property in an @Embeddable
<abbr title="1220         boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).length &gt; 1);">1220         boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).lðŸ”µ</abbr>
1221         if (shouldTest) {
1222             Field testField = getFieldManager().getField(targetClass, propertyName);
1223             if (testField == null) {
1224                 Class&lt;?&gt;[] entities;
1225                 try {
<abbr title="1226                     entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1226                     entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualiðŸ”µ</abbr>
1227                 } catch (ClassNotFoundException e) {
1228                     throw new RuntimeException(e);
1229                 }
1230                 for (Class&lt;?&gt; clazz : entities) {
1231                     testField = getFieldManager().getField(clazz, propertyName);
1232                     if (testField != null) {
1233                         break;
1234                     }
1235                 }
1236                 String testProperty = prefix + propertyName;
1237                 if (testField == null) {
1238                     testField = getFieldManager().getField(targetClass, testProperty);
1239                 }
1240                 if (testField == null) {
1241                     for (Class&lt;?&gt; clazz : entities) {
1242                         testField = getFieldManager().getField(clazz, testProperty);
1243                         if (testField != null) {
1244                             break;
1245                         }
1246                     }
1247                 }
1248             }
1249             response = determineExclusionForField(parentClasses, targetClass, testField);
1250         }
1251         return response;
1252     }
1253 
<abbr title="1254     protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, Field testField) {">1254     protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, FielðŸ”µ</abbr>
1255         Boolean response = false;
1256         if (testField != null) {
1257             Class&lt;?&gt; testType = testField.getType();
1258             for (Class&lt;?&gt; parentClass : parentClasses) {
1259                 if (parentClass.isAssignableFrom(testType) || testType.isAssignableFrom(parentClass)) {
1260                     response = true;
1261                     break;
1262                 }
1263             }
<abbr title="1264             if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetClass))) {">1264             if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetCðŸ”µ</abbr>
1265                 response = true;
1266             }
1267         }
1268         return response;
1269     }
1270 
1271     protected void buildBasicProperty(
1272             Field field,
1273             Class&lt;?&gt; targetClass,
1274             ForeignKey foreignField,
1275             ForeignKey[] additionalForeignFields,
1276             String[] additionalNonPersistentProperties,
1277             MergedPropertyType mergedPropertyType,
1278             Map&lt;String, FieldMetadata&gt; presentationAttributes,
1279             List&lt;Property&gt; componentProperties,
1280             Map&lt;String, FieldMetadata&gt; fields,
1281             String idProperty,
1282             Boolean populateManyToOneFields,
1283             String[] includeFields,
1284             String[] excludeFields,
1285             String configurationKey,
1286             String ceilingEntityFullyQualifiedClassname,
1287             List&lt;Class&lt;?&gt;&gt; parentClasses,
1288             String prefix,
1289             Boolean isParentExcluded,
1290             String propertyName,
1291             Type type,
1292             boolean propertyForeignKey,
1293             int additionalForeignKeyIndexPosition,
1294             Boolean isComponentPrefix,
1295             String parentPrefix) {
1296         FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1297         Boolean amIExcluded = isParentExcluded || !testPropertyInclusion(presentationAttribute);
1298         Boolean includeField = !testPropertyRecursion(prefix, parentClasses, propertyName, targetClass,
1299                 ceilingEntityFullyQualifiedClassname, isComponentPrefix, parentPrefix);
1300 
1301         SupportedFieldType explicitType = null;
1302         if (presentationAttribute != null &amp;&amp; presentationAttribute instanceof BasicFieldMetadata) {
1303             explicitType = ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType();
1304         }
1305         Class&lt;?&gt; returnedClass = type.getReturnedClass();
1306         checkProp:
1307         {
1308             if (type.isComponentType() &amp;&amp; includeField) {
1309                 buildComponentProperties(
1310                         targetClass,
1311                         foreignField,
1312                         additionalForeignFields,
1313                         additionalNonPersistentProperties,
1314                         mergedPropertyType,
1315                         fields,
1316                         idProperty,
1317                         populateManyToOneFields,
1318                         includeFields,
1319                         excludeFields,
1320                         configurationKey,
1321                         ceilingEntityFullyQualifiedClassname,
1322                         propertyName,
1323                         type,
1324                         returnedClass,
1325                         parentClasses,
1326                         amIExcluded,
1327                         prefix,
1328                         parentPrefix);
1329                 break checkProp;
1330             }
1331             /*
1332              * Currently we do not support ManyToOne fields whose class type is the same
1333              * as the target type, since this forms an infinite loop and will cause a stack overflow.
1334              */
1335             if (
1336                     type.isEntityType() &amp;&amp;
1337                             !returnedClass.isAssignableFrom(targetClass) &amp;&amp;
1338                             populateManyToOneFields &amp;&amp;
1339                             includeField
1340                     ) {
1341                 buildEntityProperties(
1342                         fields,
1343                         foreignField,
1344                         additionalForeignFields,
1345                         additionalNonPersistentProperties,
1346                         populateManyToOneFields,
1347                         includeFields,
1348                         excludeFields,
1349                         configurationKey,
1350                         ceilingEntityFullyQualifiedClassname,
1351                         propertyName,
1352                         returnedClass,
1353                         targetClass,
1354                         parentClasses,
1355                         prefix,
1356                         amIExcluded,
1357                         parentPrefix
1358                 );
1359                 break checkProp;
1360             }
1361         }
1362         //Don&#x27;t include this property if it failed manyToOne inclusion and is not a specified foreign key
1363         if (includeField || propertyForeignKey || additionalForeignKeyIndexPosition &gt;= 0) {
1364             defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title="1365                     new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeignFields,">1365                     new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeiðŸ”µ</abbr>
<abbr title="1366                             mergedPropertyType, componentProperties, idProperty, prefix, propertyName, type,">1366                             mergedPropertyType, componentProperties, idProperty, prefix, propertyName, tyðŸ”µ</abbr>
<abbr title="1367                             propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributes,">1367                             propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributesðŸ”µ</abbr>
1368                             presentationAttribute, explicitType, returnedClass, this), fields);
1369         }
1370     }
1371 
1372     protected boolean testForeignProperty(ForeignKey foreignField, String prefix, String propertyName) {
1373         boolean isPropertyForeignKey = false;
1374         if (foreignField != null) {
1375             isPropertyForeignKey = foreignField.getManyToField().equals(prefix + propertyName);
1376         }
1377         return isPropertyForeignKey;
1378     }
1379 
<abbr title="1380     protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, String propertyName) {">1380     protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, StriðŸ”µ</abbr>
1381         int additionalForeignKeyIndexPosition = -1;
1382         if (additionalForeignFields != null) {
<abbr title="1383             additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKey(prefix + propertyName, null, null), new Comparator&lt;ForeignKey&gt;() {">1383             additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKðŸ”µ</abbr>
1384                 @Override
1385                 public int compare(ForeignKey o1, ForeignKey o2) {
1386                     return o1.getManyToField().compareTo(o2.getManyToField());
1387                 }
1388             });
1389         }
1390         return additionalForeignKeyIndexPosition;
1391     }
1392 
1393     protected void buildEntityProperties(
1394             Map&lt;String, FieldMetadata&gt; fields,
1395             ForeignKey foreignField,
1396             ForeignKey[] additionalForeignFields,
1397             String[] additionalNonPersistentProperties,
1398             Boolean populateManyToOneFields,
1399             String[] includeFields,
1400             String[] excludeFields,
1401             String configurationKey,
1402             String ceilingEntityFullyQualifiedClassname,
1403             String propertyName,
1404             Class&lt;?&gt; returnedClass,
1405             Class&lt;?&gt; targetClass,
1406             List&lt;Class&lt;?&gt;&gt; parentClasses,
1407             String prefix,
1408             Boolean isParentExcluded,
1409             String parentPrefix) {
1410         Class&lt;?&gt;[] polymorphicEntities = getAllPolymorphicEntitiesFromCeiling(returnedClass);
1411         List&lt;Class&lt;?&gt;&gt; clonedParentClasses = new ArrayList&lt;&gt;();
1412 
1413         for (Class&lt;?&gt; parentClass : parentClasses) {
1414             clonedParentClasses.add(parentClass);
1415         }
1416 
1417         clonedParentClasses.add(targetClass);
1418 
1419         Map&lt;String, FieldMetadata&gt; newFields = getMergedPropertiesRecursively(
1420                 ceilingEntityFullyQualifiedClassname,
1421                 polymorphicEntities,
1422                 foreignField,
1423                 additionalNonPersistentProperties,
1424                 additionalForeignFields,
1425                 MergedPropertyType.PRIMARY,
1426                 populateManyToOneFields,
1427                 includeFields,
1428                 excludeFields,
1429                 configurationKey,
1430                 clonedParentClasses,
1431                 prefix + propertyName + &#x27;.&#x27;,
1432                 isParentExcluded,
1433                 parentPrefix);
1434 
1435         final String targetClassName = targetClass.getName();
1436 
1437         for (FieldMetadata newMetadata : newFields.values()) {
1438             newMetadata.setInheritedFromType(targetClassName);
1439             newMetadata.setAvailableToTypes(new String[]{targetClassName});
1440         }
1441 
1442         Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;(newFields.size());
1443 
1444         for (Map.Entry&lt;String, FieldMetadata&gt; newField : newFields.entrySet()) {
1445             final FieldMetadata fieldMetadata = newField.getValue();
1446             final String key = newField.getKey();
1447 
1448             convertedFields.put(propertyName + &#x27;.&#x27; + key, fieldMetadata);
1449 
1450             if (fieldMetadata instanceof BasicFieldMetadata) {
<abbr title="1451                 for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldMetadata) fieldMetadata).getValidationConfigurations().entrySet()) {">1451                 for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldðŸ”µ</abbr>
1452                     Class&lt;?&gt; validatorImpl = null;
1453 
1454                     try {
1455                         validatorImpl = Class.forName(validationConfigurations.getKey());
1456                     } catch (ClassNotFoundException e) {
1457                         Object bean = applicationContext.getBean(validationConfigurations.getKey());
1458 
1459                         if (bean != null) {
1460                             validatorImpl = bean.getClass();
1461                         }
1462                     }
1463 
<abbr title="1464                     if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validatorImpl)) {">1464                     if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validaðŸ”µ</abbr>
1465                         for (Map&lt;String, String&gt; configs : validationConfigurations.getValue()) {
1466                             for (Map.Entry&lt;String, String&gt; config : configs.entrySet()) {
1467                                 final String value = config.getValue();
1468 
1469                                 if (newFields.containsKey(value)) {
1470                                     config.setValue(propertyName + &quot;.&quot; + value);
1471                                 }
1472                             }
1473                         }
1474                     }
1475                 }
1476             }
1477 
1478             if (isForeignKey(fieldMetadata)) {
1479                 setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1480             }
1481         }
1482 
1483         fields.putAll(convertedFields);
1484     }
1485 
1486     protected boolean isForeignKey(FieldMetadata fieldMetadata) {
1487         return fieldMetadata instanceof BasicCollectionMetadata
<abbr title="1488                 &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().isEmpty()">1488                 &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePðŸ”µ</abbr>
<abbr title="1489                 &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().containsKey(PersistencePerspectiveItemType.FOREIGNKEY);">1489                 &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePeðŸ”µ</abbr>
1490     }
1491 
1492     /*
1493      * There may be multiple pathways to this foreign key which may have come from a cached source.
1494      * Since ForeignKey contains an originating field concept that is occurrence specific, we need
1495      * to make sure it is set appropriately here.
1496      *
1497      * A known use case is vendorPortal.embeddableMultitenantSite.adminUsers and
1498      * owningSite.embeddableMultitenantSite.adminUsers.
1499      */
<abbr title="1500     protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMetadata) {">1500     protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMðŸ”µ</abbr>
<abbr title="1501         ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1501         ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePersðŸ”µ</abbr>
1502         foreignKey.setOriginatingField(propertyName + &#x27;.&#x27; + key);
1503     }
1504 
1505     protected void buildComponentProperties(
1506             Class&lt;?&gt; targetClass,
1507             ForeignKey foreignField,
1508             ForeignKey[] additionalForeignFields,
1509             String[] additionalNonPersistentProperties,
1510             MergedPropertyType mergedPropertyType,
1511             Map&lt;String, FieldMetadata&gt; fields,
1512             String idProperty,
1513             Boolean populateManyToOneFields,
1514             String[] includeFields,
1515             String[] excludeFields,
1516             String configurationKey,
1517             String ceilingEntityFullyQualifiedClassname,
1518             String propertyName,
1519             Type type,
1520             Class&lt;?&gt; returnedClass,
1521             List&lt;Class&lt;?&gt;&gt; parentClasses,
1522             Boolean isParentExcluded,
1523             String prefix,
1524             String parentPrefix) {
1525         String[] componentProperties = ((ComponentType) type).getPropertyNames();
1526         List&lt;String&gt; componentPropertyNames = Arrays.asList(componentProperties);
1527         Type[] componentTypes = ((ComponentType) type).getSubtypes();
1528         List&lt;Type&gt; componentPropertyTypes = Arrays.asList(componentTypes);
1529         String tempPrefix = &quot;&quot;;
1530 
1531         int pos = prefix.indexOf(&quot;.&quot;);
1532         final int prefixLength = prefix.length();
1533 
1534         if (pos &gt; 0 &amp;&amp; pos &lt; prefixLength - 1) {
1535             //only use part of the prefix if it&#x27;s more than one layer deep
1536             tempPrefix = prefix.substring(pos + 1, prefixLength);
1537         }
1538 
<abbr title="1539         Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClass(targetClass, returnedClass, this, tempPrefix + propertyName + &quot;.&quot;);">1539         Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClðŸ”µ</abbr>
1540 
1541         if (isParentExcluded) {
1542             for (String key : componentPresentationAttributes.keySet()) {
<abbr title="1543                 LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excluded&quot;);">1543                 LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excludedðŸ”µ</abbr>
1544                 componentPresentationAttributes.get(key).setExcluded(true);
1545             }
1546         }
1547 
1548         PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1549         Property property;
1550 
1551         try {
1552             property = persistentClass.getProperty(propertyName);
1553         } catch (MappingException e) {
1554             property = persistentClass.getProperty(prefix + propertyName);
1555         }
1556 
<abbr title="1557         Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPropertyIterator();">1557         Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPðŸ”µ</abbr>
1558         List&lt;Property&gt; componentPropertyList = new ArrayList&lt;&gt;();
1559 
1560         while (componentPropertyIterator.hasNext()) {
1561             componentPropertyList.add((Property) componentPropertyIterator.next());
1562         }
1563 
1564         Map&lt;String, FieldMetadata&gt; newFields = new HashMap&lt;&gt;();
1565         buildProperties(
1566                 targetClass,
1567                 foreignField,
1568                 additionalForeignFields,
1569                 additionalNonPersistentProperties,
1570                 mergedPropertyType,
1571                 componentPresentationAttributes,
1572                 componentPropertyList,
1573                 newFields,
1574                 componentPropertyNames,
1575                 componentPropertyTypes,
1576                 idProperty,
1577                 populateManyToOneFields,
1578                 includeFields,
1579                 excludeFields,
1580                 configurationKey,
1581                 ceilingEntityFullyQualifiedClassname,
1582                 parentClasses,
1583                 propertyName + &quot;.&quot;,
1584                 isParentExcluded,
1585                 true,
1586                 parentPrefix + prefix
1587         );
1588 
1589         Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;();
1590 
1591         for (String key : newFields.keySet()) {
1592             final FieldMetadata fieldMetadata = newFields.get(key);
1593             convertedFields.put(propertyName + &quot;.&quot; + key, fieldMetadata);
1594 
1595             if (isForeignKey(fieldMetadata)) {
1596                 setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1597             }
1598         }
1599         fields.putAll(convertedFields);
1600     }
1601 
1602     @Override
1603     public EntityManager getStandardEntityManager() {
1604         return standardEntityManager;
1605     }
1606 
1607     @Override
1608     public void setStandardEntityManager(EntityManager entityManager) {
1609         this.standardEntityManager = entityManager;
1610         fieldManager = new FieldManager(entityConfiguration, entityManager);
1611     }
1612 
1613     @Override
1614     public FieldManager getFieldManager() {
1615         return this.getFieldManager(true);
1616     }
1617 
1618     @Override
1619     public FieldManager getFieldManager(boolean cleanFieldManager) {
1620         if (fieldManager == null) {
1621             //keep in mind that getStandardEntityManager() can return null, this is in general OK,
1622             // we re-init fieldManager in setStandardEntityManager method
1623             fieldManager = new FieldManager(entityConfiguration, getStandardEntityManager());
1624         } else if (cleanFieldManager){
1625             fieldManager.clearMiddleFields();
1626         }
1627         return fieldManager;
1628     }
1629 
1630     @Override
1631     public EntityConfiguration getEntityConfiguration() {
1632         return entityConfiguration;
1633     }
1634 
1635     @Override
1636     public void setEntityConfiguration(EntityConfiguration entityConfiguration) {
1637         this.entityConfiguration = entityConfiguration;
1638     }
1639 
1640     @Override
1641     public Metadata getMetadata() {
1642         return metadata;
1643     }
1644 
1645     @Override
1646     public void setMetadata(Metadata metadata) {
1647         this.metadata = metadata;
1648     }
1649 
1650     public List&lt;FieldMetadataProvider&gt; getFieldMetadataProviders() {
1651         return fieldMetadataProviders;
1652     }
1653 
1654     public void setFieldMetadataProviders(List&lt;FieldMetadataProvider&gt; fieldMetadataProviders) {
1655         this.fieldMetadataProviders = fieldMetadataProviders;
1656     }
1657 
1658     @Override
1659     public FieldMetadataProvider getDefaultFieldMetadataProvider() {
1660         return defaultFieldMetadataProvider;
1661     }
1662 
1663     public void setDefaultFieldMetadataProvider(FieldMetadataProvider defaultFieldMetadataProvider) {
1664         this.defaultFieldMetadataProvider = defaultFieldMetadataProvider;
1665     }
1666 
1667     protected boolean isExcludeClassFromPolymorphism(Class&lt;?&gt; clazz) {
1668         return dynamicDaoHelper.isExcludeClassFromPolymorphism(clazz);
1669     }
1670 
1671     @Override
1672     public DynamicDaoHelper getDynamicDaoHelper() {
1673         return dynamicDaoHelper;
1674     }
1675 
1676     public void setDynamicDaoHelper(DynamicDaoHelper dynamicDaoHelper) {
1677         this.dynamicDaoHelper = dynamicDaoHelper;
1678     }
1679 
1680 }</pre></td>
                            <td><pre>   1 /*
   2  * #%L
   3  * BroadleafCommerce Open Admin Platform
   4  * %%
   5  * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.openadmin.server.dao;
  19 
  20 import java.io.Serializable;
  21 import java.lang.reflect.Field;
  22 import java.lang.reflect.Method;
  23 import java.lang.reflect.Modifier;
  24 import java.math.BigDecimal;
  25 import java.math.BigInteger;
  26 import java.security.MessageDigest;
  27 import java.security.NoSuchAlgorithmException;
  28 import java.text.DecimalFormat;
  29 import java.text.NumberFormat;
  30 import java.util.ArrayList;
  31 import java.util.Arrays;
  32 import java.util.Collections;
  33 import java.util.Comparator;
  34 import java.util.Date;
  35 import java.util.HashMap;
  36 import java.util.HashSet;
  37 import java.util.Iterator;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.Set;
  41 import javax.annotation.Nonnull;
  42 import javax.annotation.Resource;
  43 import javax.persistence.EntityManager;
  44 import javax.persistence.criteria.CriteriaBuilder;
  45 import javax.persistence.criteria.CriteriaQuery;
  46 import javax.persistence.criteria.Path;
  47 import javax.persistence.criteria.Predicate;
  48 import javax.persistence.criteria.Root;
  49 import org.apache.commons.collections4.map.LRUMap;
  50 import org.apache.commons.lang.StringUtils;
  51 import org.apache.commons.lang3.ArrayUtils;
  52 import org.apache.commons.logging.Log;
  53 import org.apache.commons.logging.LogFactory;
  54 import org.broadleafcommerce.common.money.Money;
  55 import org.broadleafcommerce.common.persistence.EntityConfiguration;
  56 import org.broadleafcommerce.common.persistence.Status;
  57 import org.broadleafcommerce.common.presentation.AdminPresentationClass;
  58 import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  59 import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  60 import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  61 import org.broadleafcommerce.common.util.dao.DynamicDaoHelper;
  62 import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
  63 import org.broadleafcommerce.common.util.dao.HibernateMappingProvider;
  64 import org.broadleafcommerce.common.web.BroadleafRequestContext;
  65 import org.broadleafcommerce.openadmin.dto.BasicCollectionMetadata;
  66 import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  67 import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  68 import org.broadleafcommerce.openadmin.dto.ClassTree;
  69 import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  70 import org.broadleafcommerce.openadmin.dto.ForeignKey;
  71 import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  72 import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  73 import org.broadleafcommerce.openadmin.dto.TabMetadata;
  74 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.BasicFieldMetadataProvider;
  75 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.FieldMetadataProvider;
<abbr title="  76 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequest;">  76 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequeðŸ”µ</abbr>
  77 import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.LateStageAddMetadataRequest;
  78 import org.broadleafcommerce.openadmin.server.service.persistence.module.FieldManager;
  79 import org.broadleafcommerce.openadmin.server.service.persistence.validation.FieldNamePropertyValidator;
  80 import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  81 import org.hibernate.Criteria;
  82 import org.hibernate.MappingException;
  83 import org.hibernate.Session;
  84 import org.hibernate.mapping.PersistentClass;
  85 import org.hibernate.mapping.Property;
  86 import org.hibernate.type.ComponentType;
  87 import org.hibernate.type.Type;
  88 import org.springframework.beans.BeansException;
  89 import org.springframework.beans.factory.NoSuchBeanDefinitionException;
  90 import org.springframework.beans.factory.annotation.Value;
  91 import org.springframework.context.ApplicationContext;
  92 import org.springframework.context.ApplicationContextAware;
  93 import org.springframework.context.annotation.Scope;
  94 import org.springframework.core.annotation.AnnotationUtils;
  95 import org.springframework.stereotype.Component;
  96 
  97 
  98 /**
  99  * @author jfischer
 100  */
 101 @Component(&quot;blDynamicEntityDao&quot;)
 102 @Scope(&quot;prototype&quot;)
 103 public class DynamicEntityDaoImpl implements DynamicEntityDao , ApplicationContextAware {
 104     private static final Log LOG = LogFactory.getLog(DynamicEntityDaoImpl.class);
 105 
 106     protected static final Map&lt;String, Map&lt;String, FieldMetadata&gt;&gt; METADATA_CACHE = new LRUMap&lt;&gt;(1000);
 107 
 108     /**
<abbr title=" 109      * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we have cached in METADATA_CACHE over the lifetime"> 109      * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we hðŸ”µ</abbr>
<abbr title=" 110      * of the application. This should survive evictions from METADATA_CACHE because it is for the purpose of diagnosing when we store different property"> 110      * of the application. This should survive evictions from METADATA_CACHE because it is for the purposðŸ”µ</abbr>
 111      * counts in METADATA_CACHE as a result of cache eviction
 112      */
 113     protected static final Map&lt;String, Integer&gt; METADATA_CACHE_SIZES = new HashMap&lt;&gt;();
 114 
<abbr title=" 115     /* This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are abstract or have been marked for exclusion"> 115     /* This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are absðŸ”µ</abbr>
 116     from polymorphism
 117      */
 118     protected EntityManager standardEntityManager;
 119 
 120     @Resource(name = &quot;blMetadata&quot;)
 121     protected Metadata metadata;
 122 
 123     @Resource(name = &quot;blEntityConfiguration&quot;)
 124     protected EntityConfiguration entityConfiguration;
 125 
 126     @Resource(name = &quot;blFieldMetadataProviders&quot;)
 127     protected List&lt;FieldMetadataProvider&gt; fieldMetadataProviders = new ArrayList&lt;&gt;();
 128 
 129     @Resource(name = &quot;blDefaultFieldMetadataProvider&quot;)
 130     protected FieldMetadataProvider defaultFieldMetadataProvider;
 131 
 132     @Resource(name = &quot;blBasicFieldMetadataProvider&quot;)
 133     protected BasicFieldMetadataProvider basicFieldMetadataProvider;
 134 
 135     @Resource(name = &quot;blAppConfigurationMap&quot;)
 136     protected Map&lt;String, String&gt; propertyConfigurations = new HashMap&lt;&gt;();
 137 
 138     protected DynamicDaoHelper dynamicDaoHelper = new DynamicDaoHelperImpl();
 139 
 140     @Value(&quot;${cache.entity.dao.metadata.ttl}&quot;)
 141     protected int cacheEntityMetaDataTtl;
 142 
 143     /**
<abbr title=" 144      * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the application"> 144      * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the applicatioðŸ”µ</abbr>
 145      */
 146     @Value(&quot;${validate.metadata.cache.sizes:false}&quot;)
 147     protected boolean validateMetadataCacheSizes;
 148 
 149     protected long lastCacheFlushTime = System.currentTimeMillis();
 150 
 151     protected ApplicationContext applicationContext;
 152 
 153     protected FieldManager fieldManager;
 154 
 155     @Override
 156     public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 157         this.applicationContext = applicationContext;
 158     }
 159 
 160     @Override
 161     public Criteria createCriteria(Class&lt;?&gt; entityClass) {
 162         return getStandardEntityManager().unwrap(Session.class).createCriteria(entityClass);
 163     }
 164 
 165     @Override
 166     public &lt;T&gt; T persist(T entity) {
 167         standardEntityManager.persist(entity);
 168         standardEntityManager.flush();
 169         return entity;
 170     }
 171 
 172     @Override
 173     public Object find(Class&lt;?&gt; entityClass, Object key) {
 174         return standardEntityManager.find(entityClass, key);
 175     }
 176 
 177     @Override
 178     public &lt;T&gt; T merge(T entity) {
 179         T response = standardEntityManager.merge(entity);
 180         standardEntityManager.flush();
 181         return response;
 182     }
 183 
 184     @Override
 185     public void flush() {
 186         standardEntityManager.flush();
 187     }
 188 
 189     @Override
 190     public void detach(Serializable entity) {
 191         standardEntityManager.detach(entity);
 192     }
 193 
 194     @Override
 195     public void refresh(Serializable entity) {
 196         standardEntityManager.refresh(entity);
 197     }
 198 
 199     @Override
 200     public Serializable retrieve(Class&lt;?&gt; entityClass, Object primaryKey) {
 201         return (Serializable) standardEntityManager.find(entityClass, primaryKey);
 202     }
 203 
 204     @Override
 205     public void remove(Serializable entity) {
 206         standardEntityManager.remove(entity);
 207         standardEntityManager.flush();
 208     }
 209 
 210     @Override
 211     public void clear() {
 212         standardEntityManager.clear();
 213     }
 214 
 215     @Override
 216     public PersistentClass getPersistentClass(String targetClassName) {
 217         return HibernateMappingProvider.getMapping(targetClassName);
 218     }
 219 
 220     @Override
 221     public boolean useCache() {
 222         if (cacheEntityMetaDataTtl &lt; 0) {
 223             return true;
 224         }
 225         if (cacheEntityMetaDataTtl == 0) {
 226             return false;
 227         } else {
 228             if ((System.currentTimeMillis() - lastCacheFlushTime) &gt; cacheEntityMetaDataTtl) {
 229                 lastCacheFlushTime = System.currentTimeMillis();
 230                 METADATA_CACHE.clear();
 231                 DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE.clear();
 232                 DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE_WO_EXCLUSIONS.clear();
 233                 LOG.trace(&quot;Metadata cache evicted&quot;);
 234                 return true; // cache is empty
 235             } else {
 236                 return true;
 237             }
 238         }
 239     }
 240 
 241     @Override
 242     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass) {
 243         return getAllPolymorphicEntitiesFromCeiling(ceilingClass, true);
 244     }
 245 
 246     @Override
<abbr title=" 247     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymorphicEntities) {"> 247     public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifðŸ”µ</abbr>
<abbr title=" 248         return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolymorphicEntities, useCache());"> 248         return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolyðŸ”µ</abbr>
 249     }
 250 
 251     @Override
 252     public Class&lt;?&gt;[] getUpDownInheritance(Class&lt;?&gt; testClass) {
 253         return dynamicDaoHelper.getUpDownInheritance(testClass, true, useCache());
 254     }
 255 
 256     @Override
 257     public Class&lt;?&gt; getImplClass(String className) {
 258         Class&lt;?&gt; clazz = null;
 259         try {
 260             clazz = entityConfiguration.lookupEntityClass(className);
 261         } catch (NoSuchBeanDefinitionException e) {
 262             //do nothing
 263         }
 264         if (clazz == null) {
 265             try {
 266                 clazz = Class.forName(className);
 267             } catch (ClassNotFoundException e) {
 268                 throw new RuntimeException(e);
 269             }
 270             clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 271         }
 272         return clazz;
 273     }
 274 
 275     @Override
 276     public Class&lt;?&gt; getCeilingImplClass(String className) {
 277         Class&lt;?&gt; clazz;
 278         try {
 279             clazz = Class.forName(className);
 280         } catch (ClassNotFoundException e) {
 281             throw new RuntimeException(e);
 282         }
 283         Class&lt;?&gt;[] entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 284         if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
 285             clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 286             entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 287         }
 288         if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
<abbr title=" 289             throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for the requested class name (%s)&quot;, className));"> 289             throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for tðŸ”µ</abbr>
 290         }
 291         clazz = entitiesFromCeiling[entitiesFromCeiling.length - 1];
 292         return clazz;
 293     }
 294 
 295     @Override
<abbr title=" 296     public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, String value) {"> 296     public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, StriðŸ”µ</abbr>
<abbr title=" 297         Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass());"> 297         Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass())ðŸ”µ</abbr>
 298         CriteriaBuilder builder = this.standardEntityManager.getCriteriaBuilder();
 299         CriteriaQuery&lt;Long&gt; criteria = builder.createQuery(Long.class);
 300         Root root = criteria.from(clazz);
 301         Path idField = root.get(this.getIdField(clazz).getName());
 302         criteria.select(idField.as(Long.class));
 303         List&lt;Predicate&gt; restrictions = new ArrayList();
 304 
 305         Path path = null;
 306 
 307         // Support property name such as &quot;defaultSku.name&quot;
 308         if (propertyName.contains(&quot;.&quot;)) {
 309             String[] split = propertyName.split(&quot;\\.&quot;);
 310             for (String splitResult : split) {
 311                 if (path == null) {
 312                     path = root.get(splitResult);
 313                 } else {
 314                     path = path.get(splitResult);
 315                 }
 316             }
 317         } else {
 318             path = root.get(propertyName);
 319         }
 320 
 321         restrictions.add(builder.equal(path, value));
 322         Serializable identifier = this.getIdentifier(instance);
 323         //when we creating the new item identifier is not exists
 324         if (identifier != null) {
 325             restrictions.add(builder.notEqual(idField, identifier));
 326         }
 327 
 328         if (instance instanceof Status) {
<abbr title=" 329             restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), builder.equal(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;), &#x27;N&#x27;)));"> 329             restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), buildeðŸ”µ</abbr>
 330         }
 331 
 332         criteria.where(restrictions.toArray(new Predicate[restrictions.size()]));
 333         return this.standardEntityManager.createQuery(criteria).getResultList();
 334     }
 335 
 336     @Override
 337     public Serializable getIdentifier(Object entity) {
 338         return dynamicDaoHelper.getIdentifier(entity);
 339     }
 340 
 341     protected Field getIdField(Class&lt;?&gt; clazz) {
 342         return dynamicDaoHelper.getIdField(clazz);
 343     }
 344 
 345     public Class&lt;?&gt;[] sortEntities(Class&lt;?&gt; ceilingClass, List&lt;Class&lt;?&gt;&gt; entities) {
 346         return dynamicDaoHelper.sortEntities(ceilingClass, entities);
 347     }
 348 
 349     protected void addClassToTree(Class&lt;?&gt; clazz, ClassTree tree) {
 350         Class&lt;?&gt; testClass;
 351         try {
 352             testClass = Class.forName(tree.getFullyQualifiedClassname());
 353         } catch (ClassNotFoundException e) {
 354             throw new RuntimeException(e);
 355         }
 356         if (clazz.equals(testClass)) {
 357             return;
 358         }
 359         if (clazz.getSuperclass().equals(testClass)) {
 360             ClassTree myTree = new ClassTree(clazz.getName(), isExcludeClassFromPolymorphism(clazz));
 361             createClassTreeFromAnnotation(clazz, myTree);
 362             tree.setChildren(ArrayUtils.add(tree.getChildren(), myTree));
 363         } else {
 364             for (ClassTree child : tree.getChildren()) {
 365                 addClassToTree(clazz, child);
 366             }
 367         }
 368     }
 369 
 370     protected void createClassTreeFromAnnotation(Class&lt;?&gt; clazz, ClassTree myTree) {
<abbr title=" 371         AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 371         AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentatioðŸ”µ</abbr>
 372         if (classPresentation != null) {
 373             String friendlyName = classPresentation.friendlyName();
 374             if (!StringUtils.isEmpty(friendlyName)) {
 375                 myTree.setFriendlyName(friendlyName);
 376             }
 377         }
 378     }
 379 
 380     @Override
 381     public ClassTree getClassTree(Class&lt;?&gt;[] polymorphicClasses) {
 382         String ceilingClass = null;
 383         for (Class&lt;?&gt; clazz : polymorphicClasses) {
<abbr title=" 384             AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 384             AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentðŸ”µ</abbr>
 385             if (classPresentation != null) {
 386                 String ceilingEntity = classPresentation.ceilingDisplayEntity();
 387                 if (!StringUtils.isEmpty(ceilingEntity)) {
 388                     ceilingClass = ceilingEntity;
 389                     break;
 390                 }
 391             }
 392         }
 393         if (ceilingClass != null) {
 394             int pos = -1;
 395             int j = 0;
 396             for (Class&lt;?&gt; clazz : polymorphicClasses) {
 397                 if (clazz.getName().equals(ceilingClass)) {
 398                     pos = j;
 399                     break;
 400                 }
 401                 j++;
 402             }
 403             if (pos &gt;= 0) {
 404                 Class&lt;?&gt;[] temp = new Class&lt;?&gt;[pos + 1];
 405                 System.arraycopy(polymorphicClasses, 0, temp, 0, j + 1);
 406                 polymorphicClasses = temp;
 407             }
 408         }
 409 
 410         ClassTree classTree = null;
 411         if (!ArrayUtils.isEmpty(polymorphicClasses)) {
 412             Class&lt;?&gt; topClass = polymorphicClasses[polymorphicClasses.length - 1];
 413             classTree = new ClassTree(topClass.getName(), isExcludeClassFromPolymorphism(topClass));
 414             createClassTreeFromAnnotation(topClass, classTree);
 415             for (int j = polymorphicClasses.length - 1; j &gt;= 0; j--) {
 416                 addClassToTree(polymorphicClasses[j], classTree);
 417             }
 418             classTree.finalizeStructure(1);
 419         }
 420         return classTree;
 421     }
 422 
 423     @Override
 424     public ClassTree getClassTreeFromCeiling(Class&lt;?&gt; ceilingClass) {
 425         Class&lt;?&gt;[] sortedEntities = getAllPolymorphicEntitiesFromCeiling(ceilingClass);
 426         return getClassTree(sortedEntities);
 427     }
 428 
 429     @Override
<abbr title=" 430     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 430     public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspectiveðŸ”µ</abbr>
 431         Class&lt;?&gt;[] entityClasses;
 432         try {
 433             entityClasses = getAllPolymorphicEntitiesFromCeiling(Class.forName(entityName));
 434         } catch (ClassNotFoundException e) {
 435             throw new RuntimeException(e);
 436         }
 437         if (!ArrayUtils.isEmpty(entityClasses)) {
 438             return getMergedProperties(
 439                     entityName,
 440                     entityClasses,
<abbr title=" 441                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 441                     (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePðŸ”µ</abbr>
 442                     persistencePerspective.getAdditionalNonPersistentProperties(),
 443                     persistencePerspective.getAdditionalForeignKeys(),
 444                     MergedPropertyType.PRIMARY,
 445                     persistencePerspective.getPopulateToOneFields(),
 446                     persistencePerspective.getIncludeFields(),
 447                     persistencePerspective.getExcludeFields(),
 448                     persistencePerspective.getConfigurationKey(),
 449                     &quot;&quot;
 450             );
 451         } else {
 452             Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 453             Class&lt;?&gt; targetClass;
 454             try {
 455                 targetClass = Class.forName(entityName);
 456             } catch (ClassNotFoundException e) {
 457                 throw new RuntimeException(e);
 458             }
<abbr title=" 459             Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 459             Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targðŸ”µ</abbr>
 460             for (String property : attributesMap.keySet()) {
 461                 FieldMetadata presentationAttribute = attributesMap.get(property);
 462                 if (!presentationAttribute.getExcluded()) {
 463                     Field field = FieldManager.getSingleField(targetClass, property);
 464                     if (!Modifier.isStatic(field.getModifiers())) {
 465                         boolean handled = false;
 466                         for (FieldMetadataProvider provider : fieldMetadataProviders) {
 467                             MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title=" 468                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 468                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForðŸ”µ</abbr>
 469                                             MergedPropertyType.PRIMARY, null, null, &quot;&quot;,
<abbr title=" 470                                             property, null, false, 0, attributesMap, presentationAttribute,"> 470                                             property, null, false, 0, attributesMap, presentationAttributðŸ”µ</abbr>
<abbr title=" 471                                             ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(), field.getType(), this),"> 471                                             ((BasicFieldMetadata) presentationAttribute).getExplicitFieldðŸ”µ</abbr>
 472                                     mergedProperties);
 473                             if (MetadataProviderResponse.NOT_HANDLED != response) {
 474                                 handled = true;
 475                             }
 476                             if (MetadataProviderResponse.HANDLED_BREAK == response) {
 477                                 break;
 478                             }
 479                         }
 480                         if (!handled) {
<abbr title=" 481                             //this provider is not included in the provider list on purpose - it is designed to handle basic"> 481                             //this provider is not included in the provider list on purpose - it is desigðŸ”µ</abbr>
<abbr title=" 482                             //AdminPresentation fields, and those fields not admin presentation annotated at all"> 482                             //AdminPresentation fields, and those fields not admin presentation annotatedðŸ”µ</abbr>
 483                             defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title=" 484                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 484                                     new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForðŸ”µ</abbr>
 485                                             MergedPropertyType.PRIMARY, null, null, &quot;&quot;, property,
<abbr title=" 486                                             null, false, 0, attributesMap, presentationAttribute, ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(),"> 486                                             null, false, 0, attributesMap, presentationAttribute, ((BasicðŸ”µ</abbr>
 487                                             field.getType(), this), mergedProperties);
 488                         }
 489                     }
 490                 }
 491             }
 492 
 493             return mergedProperties;
 494         }
 495     }
 496 
 497     @Override
 498     public Map&lt;String, FieldMetadata&gt; getMergedProperties(@Nonnull Class&lt;?&gt; cls) {
 499         Class&lt;?&gt;[] polymorphicTypes = getAllPolymorphicEntitiesFromCeiling(cls);
 500         return getMergedProperties(
 501                 cls.getName(),
 502                 polymorphicTypes,
 503                 null,
 504                 new String[]{},
 505                 new ForeignKey[]{},
 506                 MergedPropertyType.PRIMARY,
 507                 true,
 508                 new String[]{},
 509                 new String[]{},
 510                 null,
 511                 &quot;&quot;
 512         );
 513     }
 514 
 515     @Override
 516     public Map&lt;String, FieldMetadata&gt; getMergedProperties(
 517             String ceilingEntityFullyQualifiedClassname,
 518             Class&lt;?&gt;[] entities,
 519             ForeignKey foreignField,
 520             String[] additionalNonPersistentProperties,
 521             ForeignKey[] additionalForeignFields,
 522             MergedPropertyType mergedPropertyType,
 523             Boolean populateManyToOneFields,
 524             String[] includeFields,
 525             String[] excludeFields,
 526             String configurationKey,
 527             String prefix) {
 528         Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedPropertiesRecursively(
 529                 ceilingEntityFullyQualifiedClassname,
 530                 entities,
 531                 foreignField,
 532                 additionalNonPersistentProperties,
 533                 additionalForeignFields,
 534                 mergedPropertyType,
 535                 populateManyToOneFields,
 536                 includeFields,
 537                 excludeFields,
 538                 configurationKey,
 539                 new ArrayList&lt;Class&lt;?&gt;&gt;(),
 540                 prefix,
 541                 false,
 542                 &quot;&quot;);
 543 
 544         final List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 545 
 546         for (final String key : mergedProperties.keySet()) {
<abbr title=" 547             if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded()) {"> 547             if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded(ðŸ”µ</abbr>
 548                 removeKeys.add(key);
 549             }
 550         }
 551 
 552         for (String removeKey : removeKeys) {
 553             mergedProperties.remove(removeKey);
 554         }
 555 
<abbr title=" 556         // Allow field metadata providers to contribute additional fields here. These latestage handlers take place"> 556         // Allow field metadata providers to contribute additional fields here. These latestage handlers ðŸ”µ</abbr>
<abbr title=" 557         // after any cached lookups occur, and are ideal for adding in dynamic properties that are not globally cacheable"> 557         // after any cached lookups occur, and are ideal for adding in dynamic properties that are not glðŸ”µ</abbr>
 558         // like properties gleaned from reflection typically are.
 559         Set&lt;String&gt; keys = new HashSet&lt;&gt;(mergedProperties.keySet());
 560         for (Class&lt;?&gt; targetClass : entities) {
 561             for (String key : keys) {
<abbr title=" 562                 LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass, this, &quot;&quot;);"> 562                 LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass,ðŸ”µ</abbr>
 563 
 564                 boolean foundOneOrMoreHandlers = false;
 565                 for (FieldMetadataProvider fieldMetadataProvider : fieldMetadataProviders) {
<abbr title=" 566                     MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);"> 566                     MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mðŸ”µ</abbr>
 567                     if (MetadataProviderResponse.NOT_HANDLED != response) {
 568                         foundOneOrMoreHandlers = true;
 569                     }
 570                     if (MetadataProviderResponse.HANDLED_BREAK == response) {
 571                         break;
 572                     }
 573                 }
 574                 if (!foundOneOrMoreHandlers) {
 575                     defaultFieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);
 576                 }
 577             }
 578         }
 579 
 580         return mergedProperties;
 581     }
 582 
 583     protected Map&lt;String, FieldMetadata&gt; getMergedPropertiesRecursively(
 584             final String ceilingEntityFullyQualifiedClassname,
 585             final Class&lt;?&gt;[] entities,
 586             final ForeignKey foreignField,
 587             final String[] additionalNonPersistentProperties,
 588             final ForeignKey[] additionalForeignFields,
 589             final MergedPropertyType mergedPropertyType,
 590             final Boolean populateManyToOneFields,
 591             final String[] includeFields,
 592             final String[] excludeFields,
 593             final String configurationKey,
 594             final List&lt;Class&lt;?&gt;&gt; parentClasses,
 595             final String prefix,
 596             final Boolean isParentExcluded,
 597             final String parentPrefix) {
 598         PropertyBuilder propertyBuilder = new PropertyBuilder() {
 599             @Override
 600             public Map&lt;String, FieldMetadata&gt; execute(Boolean overridePopulateManyToOne) {
 601                 Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 602                 Boolean classAnnotatedPopulateManyToOneFields;
 603                 if (overridePopulateManyToOne != null) {
 604                     classAnnotatedPopulateManyToOneFields = overridePopulateManyToOne;
 605                 } else {
 606                     classAnnotatedPopulateManyToOneFields = populateManyToOneFields;
 607                 }
 608 
 609                 buildPropertiesFromPolymorphicEntities(
 610                         entities,
 611                         foreignField,
 612                         additionalNonPersistentProperties,
 613                         additionalForeignFields,
 614                         mergedPropertyType,
 615                         classAnnotatedPopulateManyToOneFields,
 616                         includeFields,
 617                         excludeFields,
 618                         configurationKey,
 619                         ceilingEntityFullyQualifiedClassname,
 620                         mergedProperties,
 621                         parentClasses,
 622                         prefix,
 623                         isParentExcluded,
 624                         parentPrefix);
 625 
 626                 return mergedProperties;
 627             }
 628         };
 629 
<abbr title=" 630         Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilder, prefix, isParentExcluded, ceilingEntityFullyQualifiedClassname, configurationKey, this);"> 630         Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilderðŸ”µ</abbr>
<abbr title=" 631         applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedProperties);"> 631         applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedPropertiesðŸ”µ</abbr>
 632         applyForeignKeyPrecedence(foreignField, additionalForeignFields, mergedProperties);
 633 
 634         return mergedProperties;
 635     }
 636 
<abbr title=" 637     protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFields, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 637     protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFieldðŸ”µ</abbr>
 638         for (String key : mergedProperties.keySet()) {
 639             boolean isForeign = false;
 640             if (foreignField != null) {
 641                 isForeign = foreignField.getManyToField().equals(key);
 642             }
 643             if (!isForeign &amp;&amp; !ArrayUtils.isEmpty(additionalForeignFields)) {
 644                 for (ForeignKey foreignKey : additionalForeignFields) {
 645                     isForeign = foreignKey.getManyToField().equals(key);
 646                     if (isForeign) {
 647                         break;
 648                     }
 649                 }
 650             }
 651             if (isForeign) {
 652                 FieldMetadata metadata = mergedProperties.get(key);
 653                 metadata.setExcluded(false);
 654             }
 655         }
 656     }
 657 
<abbr title=" 658     protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefix, Boolean isParentExcluded, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 658     protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefixðŸ”µ</abbr>
 659         //check includes
 660         if (!ArrayUtils.isEmpty(includeFields)) {
 661             for (String include : includeFields) {
 662                 for (String key : mergedProperties.keySet()) {
 663                     String testKey = prefix + key;
 664                     if (!(testKey.startsWith(include + &quot;.&quot;) || testKey.equals(include))) {
 665                         FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 666                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did not appear in the explicit includeFields list&quot;);"> 666                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did ðŸ”µ</abbr>
 667                         metadata.setExcluded(true);
 668                     } else {
 669                         FieldMetadata metadata = mergedProperties.get(key);
 670                         if (!isParentExcluded) {
<abbr title=" 671                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field appears in the explicit includeFields list&quot;);"> 671                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field apðŸ”µ</abbr>
 672                             metadata.setExcluded(false);
 673                         }
 674                     }
 675                 }
 676             }
 677         } else if (!ArrayUtils.isEmpty(excludeFields)) {
 678             //check excludes
 679             for (String exclude : excludeFields) {
 680                 for (String key : mergedProperties.keySet()) {
 681                     String testKey = prefix + key;
 682                     if (testKey.startsWith(exclude + &quot;.&quot;) || testKey.equals(exclude)) {
 683                         FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 684                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appears in the explicit excludeFields list&quot;);"> 684                         LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appeðŸ”µ</abbr>
 685                         metadata.setExcluded(true);
 686                     } else {
 687                         FieldMetadata metadata = mergedProperties.get(key);
 688                         if (!isParentExcluded) {
<abbr title=" 689                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field did not appear in the explicit excludeFields list&quot;);"> 689                             LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field diðŸ”µ</abbr>
 690                             metadata.setExcluded(false);
 691                         }
 692                     }
 693                 }
 694             }
 695         }
 696     }
 697 
 698     protected String pad(String s, int length, char pad) {
 699         StringBuilder buffer = new StringBuilder(s);
 700         while (buffer.length() &lt; length) {
 701             buffer.insert(0, pad);
 702         }
 703         return buffer.toString();
 704     }
 705 
<abbr title=" 706     protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, String[] additionalNonPersistentProperties, ForeignKey[] additionalForeignFields, MergedPropertyType mergedPropertyType, Boolean populateManyToOneFields, Class&lt;?&gt; clazz, String configurationKey, Boolean isParentExcluded) {"> 706     protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, StðŸ”µ</abbr>
 707         StringBuilder sb = new StringBuilder(150);
 708         sb.append(ceilingEntityFullyQualifiedClassname);
 709         sb.append(clazz.hashCode());
 710         sb.append(foreignField == null ? &quot;&quot; : foreignField.toString());
 711         sb.append(configurationKey);
 712         sb.append(isParentExcluded);
 713         if (additionalNonPersistentProperties != null) {
 714             for (String prop : additionalNonPersistentProperties) {
 715                 sb.append(prop);
 716             }
 717         }
 718         if (additionalForeignFields != null) {
 719             for (ForeignKey key : additionalForeignFields) {
 720                 sb.append(key.toString());
 721             }
 722         }
 723         sb.append(mergedPropertyType);
 724         sb.append(populateManyToOneFields);
 725 
 726         String digest;
 727         try {
 728             MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
 729             byte[] messageDigest = md.digest(sb.toString().getBytes());
 730             BigInteger number = new BigInteger(1, messageDigest);
 731             digest = number.toString(16);
 732         } catch (NoSuchAlgorithmException e) {
 733             throw new RuntimeException(e);
 734         }
 735 
 736         String key = pad(digest, 32, &#x27;0&#x27;);
 737 
 738         if (LOG.isDebugEnabled()) {
 739             LOG.debug(&quot;Created cache key: &quot; + key + &quot; from the following string: &quot; + sb.toString());
 740         }
 741         return key;
 742     }
 743 
<abbr title=" 744     protected void buildPropertiesFromPolymorphicEntities(Class&lt;?&gt;[] entities, ForeignKey foreignField, String[] additionalNonPersistentProperties, ForeignKey[] additionalForeignFields, MergedPropertyType mergedPropertyType, Boolean populateManyToOneFields, String[] includeFields, String[] excludeFields, String configurationKey, String ceilingEntityFullyQualifiedClassname, Map&lt;String, FieldMetadata&gt; mergedProperties, List&lt;Class&lt;?&gt;&gt; parentClasses, String prefix, Boolean isParentExcluded, String parentPrefix) {"> 744     protected void buildPropertiesFromPolymorphicEntities(Class&lt;?&gt;[] entities, ForeignKey foreignField, SðŸ”µ</abbr>
 745         for (Class&lt;?&gt; clazz : entities) {
<abbr title=" 746             String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNonPersistentProperties, additionalForeignFields, mergedPropertyType, populateManyToOneFields, clazz, configurationKey, isParentExcluded);"> 746             String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNðŸ”µ</abbr>
 747             Map&lt;String, FieldMetadata&gt; cacheData = null;
 748             synchronized(DynamicDaoHelperImpl.LOCK_OBJECT) {
 749                 if (useCache()) {
 750                     cacheData = METADATA_CACHE.get(cacheKey);
 751                 }
 752                 if (cacheData == null) {
<abbr title=" 753                     Map&lt;String, FieldMetadata&gt; props = getPropertiesForEntityClass(clazz, foreignField, additionalNonPersistentProperties, additionalForeignFields, mergedPropertyType, populateManyToOneFields, includeFields, excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClasses, prefix, isParentExcluded, parentPrefix);"> 753                     Map&lt;String, FieldMetadata&gt; props = getPropertiesForEntityClass(clazz, foreignField, aðŸ”µ</abbr>
<abbr title=" 754                     // first check all the properties currently in there to see if my entity inherits from them"> 754                     // first check all the properties currently in there to see if my entity inherits froðŸ”µ</abbr>
 755                     for (Class&lt;?&gt; clazz2 : entities) {
 756                         if (!clazz2.getName().equals(clazz.getName())) {
 757                             for (Map.Entry&lt;String, FieldMetadata&gt; entry : props.entrySet()) {
 758                                 FieldMetadata metadata = entry.getValue();
 759                                 try {
<abbr title=" 760                                     if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(clazz2)) {"> 760                                     if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(cðŸ”µ</abbr>
<abbr title=" 761                                         String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(), new String[]{ clazz2.getName() });"> 761                                         String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(),ðŸ”µ</abbr>
 762                                         metadata.setAvailableToTypes(both);
 763                                     }
 764                                 } catch (java.lang.ClassNotFoundException e) {
 765                                     throw new RuntimeException(e);
 766                                 }
 767                             }
 768                         }
 769                     }
 770                     METADATA_CACHE.put(cacheKey, props);
 771                     if (LOG.isTraceEnabled()) {
<abbr title=" 772                         LOG.trace(((((&quot;Added &quot; + props.size()) + &quot; to the metadata cache with key &quot;) + cacheKey) + &quot; for the class &quot;) + ceilingEntityFullyQualifiedClassname);"> 772                         LOG.trace(((((&quot;Added &quot; + props.size()) + &quot; to the metadata cache with key &quot;) + caðŸ”µ</abbr>
 773                     }
 774                     if (validateMetadataCacheSizes) {
 775                         Integer previousSize = METADATA_CACHE_SIZES.get(cacheKey);
 776                         Integer currentSize = props.size();
 777                         if (previousSize == null) {
 778                             METADATA_CACHE_SIZES.put(cacheKey, currentSize);
 779                         } else if (!currentSize.equals(previousSize)) {
<abbr title=" 780                             String msg = (((((&quot;Attempted to store &quot; + currentSize) + &quot; properties in the cache for the key &quot;) + cacheKey) + &quot; but we had previously stored &quot;) + previousSize) + &quot; properties&quot;;"> 780                             String msg = (((((&quot;Attempted to store &quot; + currentSize) + &quot; properties in the ðŸ”µ</abbr>
 781                             LOG.error(msg);
 782                             throw new RuntimeException(msg);
 783                         }
 784                     }
 785                     cacheData = props;
 786                 } else {
 787                     if (LOG.isTraceEnabled()) {
<abbr title=" 788                         LOG.trace(((((&quot;Read &quot; + cacheData.size()) + &quot; from the metada cache with key &quot;) + cacheKey) + &quot; for the class &quot;) + ceilingEntityFullyQualifiedClassname);"> 788                         LOG.trace(((((&quot;Read &quot; + cacheData.size()) + &quot; from the metada cache with key &quot;) +ðŸ”µ</abbr>
 789                     }
 790 
 791 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 792                     for (FieldMetadata value : cacheData.values()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 793                         if(value instanceof BasicFieldMetadata &amp;&amp; StringUtils.isNotEmpty(((BasicFieldMetadata)value).getOptionListEntity())){"> 793                         if(value instanceof BasicFieldMetadata &amp;&amp; StringUtils.isNotEmpty(((BasicFieldMetaðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"><abbr title=" 794                             basicFieldMetadataProvider.refreshDataDrivenEnumMetadata((BasicFieldMetadata) value);"> 794                             basicFieldMetadataProvider.refreshDataDrivenEnumMetadata((BasicFieldMetadata)ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 795                         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 796                     }</span>
 797 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 798 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 798 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwðŸ”µ</abbr></span>
 799 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 800 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 801                     for (FieldMetadata value : cacheData.values()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 802                         //that&#x27;s for the case when metadata cache is enabled(cache.entity.dao.metadata.ttl=-1) and you cache metadata for en locale"> 802                         //that&#x27;s for the case when metadata cache is enabled(cache.entity.dao.metadata.ttðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 803                         //then switch to FR that has comma as decimal separator</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 804                         if (value instanceof BasicFieldMetadata) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 805                             BasicFieldMetadata v = (BasicFieldMetadata) value;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 806                             if (SupportedFieldType.DECIMAL.equals(v.getSecondaryType()) || SupportedFieldType.INTEGER.equals(v.getSecondaryType())"> 806                             if (SupportedFieldType.DECIMAL.equals(v.getSecondaryType()) || SupportedFieldðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 807                                     || SupportedFieldType.INTEGER.equals(v.getFieldType()) || SupportedFieldType.DECIMAL.equals(v.getFieldType())) {"> 807                                     || SupportedFieldType.INTEGER.equals(v.getFieldType()) || SupportedFiðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 808                                 refreshDecimalDefaultValue(v);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 809                             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 810                         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 811                     }</span>
 812 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 813 
 814                 }
 815             }
 816             // clone the metadata before passing to the system
 817             Map&lt;String, FieldMetadata&gt; clonedCache = new HashMap&lt;&gt;(cacheData.size());
 818             for (Map.Entry&lt;String, FieldMetadata&gt; entry : cacheData.entrySet()) {
 819                 clonedCache.put(entry.getKey(), entry.getValue().cloneFieldMetadata());
 820             }
 821             mergedProperties.putAll(clonedCache);
 822         }
 823     }
 824 
 825     public void refreshDecimalDefaultValue(BasicFieldMetadata value) {
<abbr title=" 826         DecimalFormat instance = (DecimalFormat) NumberFormat.getInstance(BroadleafRequestContext.getBroadleafRequestContext().getJavaLocale());"> 826         DecimalFormat instance = (DecimalFormat) NumberFormat.getInstance(BroadleafRequestContext.getBroaðŸ”µ</abbr>
<abbr title=" 827         if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;.&quot;) &amp;&amp; instance.getDecimalFormatSymbols().getDecimalSeparator()!=&#x27;.&#x27;){"> 827         if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;.&quot;) &amp;&amp; inðŸ”µ</abbr>
<abbr title=" 828             value.setDefaultValue(value.getDefaultValue().replace(&#x27;.&#x27;, instance.getDecimalFormatSymbols().getDecimalSeparator()));"> 828             value.setDefaultValue(value.getDefaultValue().replace(&#x27;.&#x27;, instance.getDecimalFormatSymbols()ðŸ”µ</abbr>
<abbr title=" 829         }else if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;,&quot;) &amp;&amp; instance.getDecimalFormatSymbols().getDecimalSeparator()!=&#x27;,&#x27;){"> 829         }else if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;,&quot;)ðŸ”µ</abbr>
<abbr title=" 830             value.setDefaultValue(value.getDefaultValue().replace(&#x27;,&#x27;, instance.getDecimalFormatSymbols().getDecimalSeparator()));"> 830             value.setDefaultValue(value.getDefaultValue().replace(&#x27;,&#x27;, instance.getDecimalFormatSymbols()ðŸ”µ</abbr>
 831         }
 832 
 833     }
 834 
 835     @Override
 836     public Field[] getAllFields(Class&lt;?&gt; targetClass) {
 837         Field[] allFields = new Field[]{};
 838         boolean eof = false;
 839         Class&lt;?&gt; currentClass = targetClass;
 840         while (!eof) {
 841             Field[] fields = currentClass.getDeclaredFields();
 842             allFields = ArrayUtils.addAll(allFields, fields);
 843             if (currentClass.getSuperclass() != null) {
 844                 currentClass = currentClass.getSuperclass();
 845             } else {
 846                 eof = true;
 847             }
 848         }
 849 
 850         return allFields;
 851     }
 852 
 853     @Override
 854     public Map&lt;String, FieldMetadata&gt; getPropertiesForPrimitiveClass(
 855             String propertyName,
 856             String friendlyPropertyName,
 857             Class&lt;?&gt; targetClass,
 858             Class&lt;?&gt; parentClass,
 859             MergedPropertyType mergedPropertyType
 860     ) {
 861         Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 862         BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
 863         presentationAttribute.setFriendlyName(friendlyPropertyName);
 864         if (String.class.isAssignableFrom(targetClass)) {
 865             presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
 866             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 867             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.STRING, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 867             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 868         } else if (Boolean.class.isAssignableFrom(targetClass)) {
 869             presentationAttribute.setExplicitFieldType(SupportedFieldType.BOOLEAN);
 870             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 871             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.BOOLEAN, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 871             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 872         } else if (Date.class.isAssignableFrom(targetClass)) {
 873             presentationAttribute.setExplicitFieldType(SupportedFieldType.DATE);
 874             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 875             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DATE, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 875             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 876         } else if (Money.class.isAssignableFrom(targetClass)) {
 877             presentationAttribute.setExplicitFieldType(SupportedFieldType.MONEY);
 878             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 879             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.MONEY, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 879             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 880         } else if (
 881                 Byte.class.isAssignableFrom(targetClass) ||
 882                         Integer.class.isAssignableFrom(targetClass) ||
 883                         Long.class.isAssignableFrom(targetClass) ||
 884                         Short.class.isAssignableFrom(targetClass)
 885                 ) {
 886             presentationAttribute.setExplicitFieldType(SupportedFieldType.INTEGER);
 887             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 888             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.INTEGER, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 888             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 889         } else if (
 890                 Double.class.isAssignableFrom(targetClass) ||
 891                         BigDecimal.class.isAssignableFrom(targetClass)
 892                 ) {
 893             presentationAttribute.setExplicitFieldType(SupportedFieldType.DECIMAL);
 894             presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 895             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DECIMAL, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 895             fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldTypeðŸ”µ</abbr>
 896         }
 897         ((BasicFieldMetadata) fields.get(propertyName)).setLength(255);
 898         ((BasicFieldMetadata) fields.get(propertyName)).setForeignKeyCollection(false);
 899         ((BasicFieldMetadata) fields.get(propertyName)).setRequired(true);
 900         ((BasicFieldMetadata) fields.get(propertyName)).setUnique(true);
 901         ((BasicFieldMetadata) fields.get(propertyName)).setScale(100);
 902         ((BasicFieldMetadata) fields.get(propertyName)).setPrecision(100);
 903 
 904         return fields;
 905     }
 906 
 907     @Override
 908     public Map&lt;String, Object&gt; getIdMetadata(Class&lt;?&gt; entityClass) {
 909         return dynamicDaoHelper.getIdMetadata(entityClass, standardEntityManager);
 910     }
 911 
 912     @Override
 913     public List&lt;String&gt; getPropertyNames(Class&lt;?&gt; entityClass) {
 914         return dynamicDaoHelper.getPropertyNames(entityClass);
 915     }
 916 
 917     @Override
 918     public List&lt;Type&gt; getPropertyTypes(Class&lt;?&gt; entityClass) {
 919         return dynamicDaoHelper.getPropertyTypes(entityClass);
 920     }
 921 
 922     @Override
 923     public Map&lt;String, TabMetadata&gt; getTabAndGroupMetadata(Class&lt;?&gt;[] entities, ClassMetadata cmd) {
 924         Class&lt;?&gt;[] superClassEntities = getSuperClassHierarchy(entities[entities.length - 1]);
 925 
<abbr title=" 926         Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entities);"> 926         Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entitiesðŸ”µ</abbr>
 927         metadata.applyTabAndGroupMetadataOverrides(superClassEntities, mergedTabAndGroupMetadata);
 928         metadata.buildAdditionalTabAndGroupMetadataFromCmdProperties(cmd, mergedTabAndGroupMetadata);
 929 
 930         return mergedTabAndGroupMetadata;
 931     }
 932 
 933     public Class&lt;?&gt;[] getSuperClassHierarchy(Class&lt;?&gt; ceilingEntity) {
 934         Class&lt;?&gt;[] entities = new Class&lt;?&gt;[]{};
 935 
 936         if (ceilingEntity != null) {
 937             entities = ArrayUtils.add(entities, ceilingEntity);
 938             while (!ceilingEntity.getSuperclass().equals(Object.class)) {
 939                 entities = ArrayUtils.add(entities, ceilingEntity.getSuperclass());
 940                 ceilingEntity = ceilingEntity.getSuperclass();
 941             }
 942         }
 943         return entities;
 944     }
 945 
 946     protected Map&lt;String, FieldMetadata&gt; getPropertiesForEntityClass(
 947             Class&lt;?&gt; targetClass,
 948             ForeignKey foreignField,
 949             String[] additionalNonPersistentProperties,
 950             ForeignKey[] additionalForeignFields,
 951             MergedPropertyType mergedPropertyType,
 952             Boolean populateManyToOneFields,
 953             String[] includeFields,
 954             String[] excludeFields,
 955             String configurationKey,
 956             String ceilingEntityFullyQualifiedClassname,
 957             List&lt;Class&lt;?&gt;&gt; parentClasses,
 958             String prefix,
 959             Boolean isParentExcluded,
 960             String parentPrefix) {
<abbr title=" 961         Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 961         Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null,ðŸ”µ</abbr>
 962         if (isParentExcluded) {
 963             for (String key : presentationAttributes.keySet()) {
<abbr title=" 964                 LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;);"> 964                 LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;ðŸ”µ</abbr>
 965                 presentationAttributes.get(key).setExcluded(true);
 966             }
 967         }
 968 
 969         Map idMetadata = getIdMetadata(targetClass);
 970         Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 971         String idProperty = (String) idMetadata.get(&quot;name&quot;);
 972         List&lt;String&gt; propertyNames = getPropertyNames(targetClass);
 973         propertyNames.add(idProperty);
 974         Type idType = (Type) idMetadata.get(&quot;type&quot;);
 975         List&lt;Type&gt; propertyTypes = getPropertyTypes(targetClass);
 976         propertyTypes.add(idType);
 977 
 978         PersistentClass persistentClass = getPersistentClass(targetClass.getName());
 979         Iterator testIter = persistentClass.getPropertyIterator();
 980         List&lt;Property&gt; propertyList = new ArrayList&lt;&gt;();
 981 
 982         //check the properties for problems
 983         while (testIter.hasNext()) {
 984             Property property = (Property) testIter.next();
 985             if (property.getName().contains(&quot;.&quot;)) {
<abbr title=" 986                 throw new IllegalArgumentException(&quot;Properties from entities that utilize a period character (&#x27;.&#x27;) in their name are incompatible with this system. The property name in question is: (&quot; + property.getName() + &quot;) from the class: (&quot; + targetClass.getName() + &quot;)&quot;);"> 986                 throw new IllegalArgumentException(&quot;Properties from entities that utilize a period characðŸ”µ</abbr>
 987             }
 988             propertyList.add(property);
 989         }
 990 
 991         buildProperties(
 992                 targetClass,
 993                 foreignField,
 994                 additionalForeignFields,
 995                 additionalNonPersistentProperties,
 996                 mergedPropertyType,
 997                 presentationAttributes,
 998                 propertyList,
 999                 fields,
1000                 propertyNames,
1001                 propertyTypes,
1002                 idProperty,
1003                 populateManyToOneFields,
1004                 includeFields,
1005                 excludeFields,
1006                 configurationKey,
1007                 ceilingEntityFullyQualifiedClassname,
1008                 parentClasses,
1009                 prefix,
1010                 isParentExcluded,
1011                 false,
1012                 parentPrefix
1013         );
1014         BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
1015         presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
1016         presentationAttribute.setVisibility(VisibilityEnum.HIDDEN_ALL);
1017         if (!ArrayUtils.isEmpty(additionalNonPersistentProperties)) {
1018             Class&lt;?&gt;[] entities = getAllPolymorphicEntitiesFromCeiling(targetClass);
1019             for (String additionalNonPersistentProperty : additionalNonPersistentProperties) {
<abbr title="1020                 if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersistentProperty.startsWith(prefix))) {">1020                 if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersisteðŸ”µ</abbr>
1021                     String myAdditionalNonPersistentProperty = additionalNonPersistentProperty;
1022                     //get final property if this is a dot delimited property
1023                     int finalDotPos = additionalNonPersistentProperty.lastIndexOf(&#x27;.&#x27;);
1024                     if (finalDotPos &gt;= 0) {
<abbr title="1025                         myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(finalDotPos + 1, myAdditionalNonPersistentProperty.length());">1025                         myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(fðŸ”µ</abbr>
1026                     }
<abbr title="1027                     //check all the polymorphic types on this target class to see if the end property exists">1027                     //check all the polymorphic types on this target class to see if the end property exiðŸ”µ</abbr>
1028                     Field testField = null;
1029                     Method testMethod = null;
1030                     for (Class&lt;?&gt; clazz : entities) {
1031                         try {
1032                             testMethod = clazz.getMethod(myAdditionalNonPersistentProperty);
1033                             if (testMethod != null) {
1034                                 break;
1035                             }
1036                         } catch (NoSuchMethodException e) {
1037                             //do nothing - method does not exist
1038                         }
1039                         testField = getFieldManager().getField(clazz, myAdditionalNonPersistentProperty);
1040                         if (testField != null) {
1041                             break;
1042                         }
1043                     }
1044                     //if the property exists, add it to the metadata for this class
1045                     if (testField != null || testMethod != null) {
<abbr title="1046                         fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, additionalNonPersistentProperty, propertyList, SupportedFieldType.STRING, null, targetClass, presentationAttribute, mergedPropertyType, this));">1046                         fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, addðŸ”µ</abbr>
1047                     }
1048                 }
1049             }
1050         }
1051 
1052         return fields;
1053     }
1054 
1055     protected void buildProperties(
1056             Class&lt;?&gt; targetClass,
1057             ForeignKey foreignField,
1058             ForeignKey[] additionalForeignFields,
1059             String[] additionalNonPersistentProperties,
1060             MergedPropertyType mergedPropertyType,
1061             Map&lt;String, FieldMetadata&gt; presentationAttributes,
1062             List&lt;Property&gt; componentProperties,
1063             Map&lt;String, FieldMetadata&gt; fields,
1064             List&lt;String&gt; propertyNames,
1065             List&lt;Type&gt; propertyTypes,
1066             String idProperty,
1067             Boolean populateManyToOneFields,
1068             String[] includeFields,
1069             String[] excludeFields,
1070             String configurationKey,
1071             String ceilingEntityFullyQualifiedClassname,
1072             List&lt;Class&lt;?&gt;&gt; parentClasses,
1073             String prefix,
1074             Boolean isParentExcluded,
1075             Boolean isComponentPrefix,
1076             String parentPrefix) {
1077         int j = 0;
1078         Comparator&lt;String&gt; propertyComparator = new Comparator&lt;String&gt;() {
1079             @Override
1080             public int compare(String o1, String o2) {
1081                 //check for property name equality and for map field properties
<abbr title="1082                 if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FieldManager.MAPFIELDSEPARATOR)) {">1082                 if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(ðŸ”µ</abbr>
1083                     return 0;
1084                 }
1085                 return o1.compareTo(o2);
1086             }
1087         };
1088         List&lt;String&gt; presentationKeyList = new ArrayList&lt;&gt;(presentationAttributes.keySet());
1089         Collections.sort(presentationKeyList);
1090 
1091         for (String propertyName : propertyNames) {
1092             final Type type = propertyTypes.get(j);
1093             boolean isPropertyForeignKey = testForeignProperty(foreignField, prefix, propertyName);
<abbr title="1094             int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFields, prefix, propertyName);">1094             int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFieldsðŸ”µ</abbr>
1095             j++;
1096             Field myField = getFieldManager().getField(targetClass, propertyName);
1097             if (myField == null) {
<abbr title="1098                 //try to get the field with the prefix - needed for advanced collections that appear in @Embedded classes">1098                 //try to get the field with the prefix - needed for advanced collections that appear in @ðŸ”µ</abbr>
1099                 myField = getFieldManager().getField(targetClass, prefix + propertyName);
1100             }
1101             if (
1102                     !type.isAnyType() &amp;&amp; !type.isCollectionType() ||
1103                             isPropertyForeignKey ||
1104                             additionalForeignKeyIndexPosition &gt;= 0 ||
<abbr title="1105                             Collections.binarySearch(presentationKeyList, propertyName, propertyComparator) &gt;= 0">1105                             Collections.binarySearch(presentationKeyList, propertyName, propertyComparatoðŸ”µ</abbr>
1106                     ) {
1107                 if (myField != null) {
1108                     boolean handled = false;
1109                     for (FieldMetadataProvider provider : fieldMetadataProviders) {
1110                         FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1111                         if (presentationAttribute != null) {
1112                             setExcludedBasedOnShowIfProperty(presentationAttribute);
1113                         }
1114                         MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title="1115                                 new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, additionalForeignFields,">1115                                 new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, aðŸ”µ</abbr>
1116                                         mergedPropertyType, componentProperties, idProperty, prefix,
<abbr title="1117                                         propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition,">1117                                         propertyName, type, isPropertyForeignKey, additionalForeignKeyIndðŸ”µ</abbr>
<abbr title="1118                                         presentationAttributes, presentationAttribute, null, type.getReturnedClass(), this), fields);">1118                                         presentationAttributes, presentationAttribute, null, type.getRetuðŸ”µ</abbr>
1119                         if (MetadataProviderResponse.NOT_HANDLED != response) {
1120                             handled = true;
1121                         }
1122                         if (MetadataProviderResponse.HANDLED_BREAK == response) {
1123                             break;
1124                         }
1125                     }
1126                     if (!handled) {
1127                         buildBasicProperty(myField, targetClass, foreignField, additionalForeignFields,
<abbr title="1128                                 additionalNonPersistentProperties, mergedPropertyType, presentationAttributes,">1128                                 additionalNonPersistentProperties, mergedPropertyType, presentationAttribðŸ”µ</abbr>
<abbr title="1129                                 componentProperties, fields, idProperty, populateManyToOneFields, includeFields,">1129                                 componentProperties, fields, idProperty, populateManyToOneFields, includeðŸ”µ</abbr>
<abbr title="1130                                 excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClasses,">1130                                 excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, paðŸ”µ</abbr>
<abbr title="1131                                 prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition, isComponentPrefix, parentPrefix);">1131                                 prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additðŸ”µ</abbr>
1132                     }
1133                 }
1134             }
1135         }
1136     }
1137 
1138     public Boolean testPropertyInclusion(FieldMetadata presentationAttribute) {
1139         setExcludedBasedOnShowIfProperty(presentationAttribute);
1140 
<abbr title="1141         return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presentationAttribute.getExcluded()) || (presentationAttribute.getChildrenExcluded() != null &amp;&amp; presentationAttribute.getChildrenExcluded())));">1141         return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presenðŸ”µ</abbr>
1142 
1143     }
1144 
1145     protected void setExcludedBasedOnShowIfProperty(FieldMetadata fieldMetadata) {
1146         if (fieldMetadata != null
1147                 &amp;&amp; StringUtils.isNotEmpty(fieldMetadata.getShowIfProperty())
1148                 &amp;&amp; propertyConfigurations.get(fieldMetadata.getShowIfProperty()) != null
1149                 &amp;&amp; !Boolean.valueOf(propertyConfigurations.get(fieldMetadata.getShowIfProperty()))) {
1150 
1151             //do not include this in the display if it returns false.
1152             fieldMetadata.setExcluded(true);
1153         }
1154     }
1155 
<abbr title="1156     protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyName, Class&lt;?&gt; targetClass,">1156     protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyNðŸ”µ</abbr>
<abbr title="1157                                             String ceilingEntityFullyQualifiedClassname, Boolean isComponentPrefix, String parentPrefix) {">1157                                             String ceilingEntityFullyQualifiedClassname, Boolean isComponðŸ”µ</abbr>
1158 
<abbr title="1159         Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyName, targetClass,">1159         Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyðŸ”µ</abbr>
1160                 ceilingEntityFullyQualifiedClassname, isComponentPrefix);
1161 
<abbr title="1162         Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isComponentPrefix,">1162         Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isCompoðŸ”µ</abbr>
1163                 parentPrefix, propertyName);
1164 
1165         return standardRecursionDetected || multiLevelEmbeddableRecursionDetected;
1166     }
1167 
<abbr title="1168     protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String parentPrefix, String propertyName) {">1168     protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String ðŸ”µ</abbr>
1169         return isComponentPrefix &amp;&amp; parentPrefix.contains(&quot;.&quot; + prefix + propertyName);
1170     }
1171 
1172     protected Boolean testStandardPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String
1173             propertyName, Class&lt;?&gt; targetClass, String ceilingEntityFullyQualifiedClassname, Boolean
1174                                                             isComponentPrefix) {
1175         Boolean response = false;
1176         //don&#x27;t want to shun a self-referencing property in an @Embeddable
<abbr title="1177         boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).length &gt; 1);">1177         boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).lðŸ”µ</abbr>
1178         if (shouldTest) {
1179             Field testField = getFieldManager().getField(targetClass, propertyName);
1180             if (testField == null) {
1181                 Class&lt;?&gt;[] entities;
1182                 try {
<abbr title="1183                     entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1183                     entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualiðŸ”µ</abbr>
1184                 } catch (ClassNotFoundException e) {
1185                     throw new RuntimeException(e);
1186                 }
1187                 for (Class&lt;?&gt; clazz : entities) {
1188                     testField = getFieldManager().getField(clazz, propertyName);
1189                     if (testField != null) {
1190                         break;
1191                     }
1192                 }
1193                 String testProperty = prefix + propertyName;
1194                 if (testField == null) {
1195                     testField = getFieldManager().getField(targetClass, testProperty);
1196                 }
1197                 if (testField == null) {
1198                     for (Class&lt;?&gt; clazz : entities) {
1199                         testField = getFieldManager().getField(clazz, testProperty);
1200                         if (testField != null) {
1201                             break;
1202                         }
1203                     }
1204                 }
1205             }
1206             response = determineExclusionForField(parentClasses, targetClass, testField);
1207         }
1208         return response;
1209     }
1210 
<abbr title="1211     protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, Field testField) {">1211     protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, FielðŸ”µ</abbr>
1212         Boolean response = false;
1213         if (testField != null) {
1214             Class&lt;?&gt; testType = testField.getType();
1215             for (Class&lt;?&gt; parentClass : parentClasses) {
1216                 if (parentClass.isAssignableFrom(testType) || testType.isAssignableFrom(parentClass)) {
1217                     response = true;
1218                     break;
1219                 }
1220             }
<abbr title="1221             if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetClass))) {">1221             if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetCðŸ”µ</abbr>
1222                 response = true;
1223             }
1224         }
1225         return response;
1226     }
1227 
1228     protected void buildBasicProperty(
1229             Field field,
1230             Class&lt;?&gt; targetClass,
1231             ForeignKey foreignField,
1232             ForeignKey[] additionalForeignFields,
1233             String[] additionalNonPersistentProperties,
1234             MergedPropertyType mergedPropertyType,
1235             Map&lt;String, FieldMetadata&gt; presentationAttributes,
1236             List&lt;Property&gt; componentProperties,
1237             Map&lt;String, FieldMetadata&gt; fields,
1238             String idProperty,
1239             Boolean populateManyToOneFields,
1240             String[] includeFields,
1241             String[] excludeFields,
1242             String configurationKey,
1243             String ceilingEntityFullyQualifiedClassname,
1244             List&lt;Class&lt;?&gt;&gt; parentClasses,
1245             String prefix,
1246             Boolean isParentExcluded,
1247             String propertyName,
1248             Type type,
1249             boolean propertyForeignKey,
1250             int additionalForeignKeyIndexPosition,
1251             Boolean isComponentPrefix,
1252             String parentPrefix) {
1253         FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1254         Boolean amIExcluded = isParentExcluded || !testPropertyInclusion(presentationAttribute);
1255         Boolean includeField = !testPropertyRecursion(prefix, parentClasses, propertyName, targetClass,
1256                 ceilingEntityFullyQualifiedClassname, isComponentPrefix, parentPrefix);
1257 
1258         SupportedFieldType explicitType = null;
1259         if (presentationAttribute != null &amp;&amp; presentationAttribute instanceof BasicFieldMetadata) {
1260             explicitType = ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType();
1261         }
1262         Class&lt;?&gt; returnedClass = type.getReturnedClass();
1263         checkProp:
1264         {
1265             if (type.isComponentType() &amp;&amp; includeField) {
1266                 buildComponentProperties(
1267                         targetClass,
1268                         foreignField,
1269                         additionalForeignFields,
1270                         additionalNonPersistentProperties,
1271                         mergedPropertyType,
1272                         fields,
1273                         idProperty,
1274                         populateManyToOneFields,
1275                         includeFields,
1276                         excludeFields,
1277                         configurationKey,
1278                         ceilingEntityFullyQualifiedClassname,
1279                         propertyName,
1280                         type,
1281                         returnedClass,
1282                         parentClasses,
1283                         amIExcluded,
1284                         prefix,
1285                         parentPrefix);
1286                 break checkProp;
1287             }
1288             /*
1289              * Currently we do not support ManyToOne fields whose class type is the same
1290              * as the target type, since this forms an infinite loop and will cause a stack overflow.
1291              */
1292             if (
1293                     type.isEntityType() &amp;&amp;
1294                             !returnedClass.isAssignableFrom(targetClass) &amp;&amp;
1295                             populateManyToOneFields &amp;&amp;
1296                             includeField
1297                     ) {
1298                 buildEntityProperties(
1299                         fields,
1300                         foreignField,
1301                         additionalForeignFields,
1302                         additionalNonPersistentProperties,
1303                         populateManyToOneFields,
1304                         includeFields,
1305                         excludeFields,
1306                         configurationKey,
1307                         ceilingEntityFullyQualifiedClassname,
1308                         propertyName,
1309                         returnedClass,
1310                         targetClass,
1311                         parentClasses,
1312                         prefix,
1313                         amIExcluded,
1314                         parentPrefix
1315                 );
1316                 break checkProp;
1317             }
1318         }
1319         //Don&#x27;t include this property if it failed manyToOne inclusion and is not a specified foreign key
1320         if (includeField || propertyForeignKey || additionalForeignKeyIndexPosition &gt;= 0) {
1321             defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title="1322                     new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeignFields,">1322                     new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeiðŸ”µ</abbr>
<abbr title="1323                             mergedPropertyType, componentProperties, idProperty, prefix, propertyName, type,">1323                             mergedPropertyType, componentProperties, idProperty, prefix, propertyName, tyðŸ”µ</abbr>
<abbr title="1324                             propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributes,">1324                             propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributesðŸ”µ</abbr>
1325                             presentationAttribute, explicitType, returnedClass, this), fields);
1326         }
1327     }
1328 
1329     protected boolean testForeignProperty(ForeignKey foreignField, String prefix, String propertyName) {
1330         boolean isPropertyForeignKey = false;
1331         if (foreignField != null) {
1332             isPropertyForeignKey = foreignField.getManyToField().equals(prefix + propertyName);
1333         }
1334         return isPropertyForeignKey;
1335     }
1336 
<abbr title="1337     protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, String propertyName) {">1337     protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, StriðŸ”µ</abbr>
1338         int additionalForeignKeyIndexPosition = -1;
1339         if (additionalForeignFields != null) {
<abbr title="1340             additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKey(prefix + propertyName, null, null), new Comparator&lt;ForeignKey&gt;() {">1340             additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKðŸ”µ</abbr>
1341                 @Override
1342                 public int compare(ForeignKey o1, ForeignKey o2) {
1343                     return o1.getManyToField().compareTo(o2.getManyToField());
1344                 }
1345             });
1346         }
1347         return additionalForeignKeyIndexPosition;
1348     }
1349 
1350     protected void buildEntityProperties(
1351             Map&lt;String, FieldMetadata&gt; fields,
1352             ForeignKey foreignField,
1353             ForeignKey[] additionalForeignFields,
1354             String[] additionalNonPersistentProperties,
1355             Boolean populateManyToOneFields,
1356             String[] includeFields,
1357             String[] excludeFields,
1358             String configurationKey,
1359             String ceilingEntityFullyQualifiedClassname,
1360             String propertyName,
1361             Class&lt;?&gt; returnedClass,
1362             Class&lt;?&gt; targetClass,
1363             List&lt;Class&lt;?&gt;&gt; parentClasses,
1364             String prefix,
1365             Boolean isParentExcluded,
1366             String parentPrefix) {
1367         Class&lt;?&gt;[] polymorphicEntities = getAllPolymorphicEntitiesFromCeiling(returnedClass);
1368         List&lt;Class&lt;?&gt;&gt; clonedParentClasses = new ArrayList&lt;&gt;();
1369 
1370         for (Class&lt;?&gt; parentClass : parentClasses) {
1371             clonedParentClasses.add(parentClass);
1372         }
1373 
1374         clonedParentClasses.add(targetClass);
1375 
1376         Map&lt;String, FieldMetadata&gt; newFields = getMergedPropertiesRecursively(
1377                 ceilingEntityFullyQualifiedClassname,
1378                 polymorphicEntities,
1379                 foreignField,
1380                 additionalNonPersistentProperties,
1381                 additionalForeignFields,
1382                 MergedPropertyType.PRIMARY,
1383                 populateManyToOneFields,
1384                 includeFields,
1385                 excludeFields,
1386                 configurationKey,
1387                 clonedParentClasses,
1388                 prefix + propertyName + &#x27;.&#x27;,
1389                 isParentExcluded,
1390                 parentPrefix);
1391 
1392         final String targetClassName = targetClass.getName();
1393 
1394         for (FieldMetadata newMetadata : newFields.values()) {
1395             newMetadata.setInheritedFromType(targetClassName);
1396             newMetadata.setAvailableToTypes(new String[]{targetClassName});
1397         }
1398 
1399         Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;(newFields.size());
1400 
1401         for (Map.Entry&lt;String, FieldMetadata&gt; newField : newFields.entrySet()) {
1402             final FieldMetadata fieldMetadata = newField.getValue();
1403             final String key = newField.getKey();
1404 
1405             convertedFields.put(propertyName + &#x27;.&#x27; + key, fieldMetadata);
1406 
1407             if (fieldMetadata instanceof BasicFieldMetadata) {
<abbr title="1408                 for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldMetadata) fieldMetadata).getValidationConfigurations().entrySet()) {">1408                 for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldðŸ”µ</abbr>
1409                     Class&lt;?&gt; validatorImpl = null;
1410 
1411                     try {
1412                         validatorImpl = Class.forName(validationConfigurations.getKey());
1413                     } catch (ClassNotFoundException e) {
1414                         Object bean = applicationContext.getBean(validationConfigurations.getKey());
1415 
1416                         if (bean != null) {
1417                             validatorImpl = bean.getClass();
1418                         }
1419                     }
1420 
<abbr title="1421                     if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validatorImpl)) {">1421                     if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validaðŸ”µ</abbr>
1422                         for (Map&lt;String, String&gt; configs : validationConfigurations.getValue()) {
1423                             for (Map.Entry&lt;String, String&gt; config : configs.entrySet()) {
1424                                 final String value = config.getValue();
1425 
1426                                 if (newFields.containsKey(value)) {
1427                                     config.setValue(propertyName + &quot;.&quot; + value);
1428                                 }
1429                             }
1430                         }
1431                     }
1432                 }
1433             }
1434 
1435             if (isForeignKey(fieldMetadata)) {
1436                 setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1437             }
1438         }
1439 
1440         fields.putAll(convertedFields);
1441     }
1442 
1443     protected boolean isForeignKey(FieldMetadata fieldMetadata) {
1444         return fieldMetadata instanceof BasicCollectionMetadata
<abbr title="1445                 &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().isEmpty()">1445                 &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePðŸ”µ</abbr>
<abbr title="1446                 &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().containsKey(PersistencePerspectiveItemType.FOREIGNKEY);">1446                 &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePeðŸ”µ</abbr>
1447     }
1448 
1449     /*
1450      * There may be multiple pathways to this foreign key which may have come from a cached source.
1451      * Since ForeignKey contains an originating field concept that is occurrence specific, we need
1452      * to make sure it is set appropriately here.
1453      *
1454      * A known use case is vendorPortal.embeddableMultitenantSite.adminUsers and
1455      * owningSite.embeddableMultitenantSite.adminUsers.
1456      */
<abbr title="1457     protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMetadata) {">1457     protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMðŸ”µ</abbr>
<abbr title="1458         ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1458         ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePersðŸ”µ</abbr>
1459         foreignKey.setOriginatingField(propertyName + &#x27;.&#x27; + key);
1460     }
1461 
1462     protected void buildComponentProperties(
1463             Class&lt;?&gt; targetClass,
1464             ForeignKey foreignField,
1465             ForeignKey[] additionalForeignFields,
1466             String[] additionalNonPersistentProperties,
1467             MergedPropertyType mergedPropertyType,
1468             Map&lt;String, FieldMetadata&gt; fields,
1469             String idProperty,
1470             Boolean populateManyToOneFields,
1471             String[] includeFields,
1472             String[] excludeFields,
1473             String configurationKey,
1474             String ceilingEntityFullyQualifiedClassname,
1475             String propertyName,
1476             Type type,
1477             Class&lt;?&gt; returnedClass,
1478             List&lt;Class&lt;?&gt;&gt; parentClasses,
1479             Boolean isParentExcluded,
1480             String prefix,
1481             String parentPrefix) {
1482         String[] componentProperties = ((ComponentType) type).getPropertyNames();
1483         List&lt;String&gt; componentPropertyNames = Arrays.asList(componentProperties);
1484         Type[] componentTypes = ((ComponentType) type).getSubtypes();
1485         List&lt;Type&gt; componentPropertyTypes = Arrays.asList(componentTypes);
1486         String tempPrefix = &quot;&quot;;
1487 
1488         int pos = prefix.indexOf(&quot;.&quot;);
1489         final int prefixLength = prefix.length();
1490 
1491         if (pos &gt; 0 &amp;&amp; pos &lt; prefixLength - 1) {
1492             //only use part of the prefix if it&#x27;s more than one layer deep
1493             tempPrefix = prefix.substring(pos + 1, prefixLength);
1494         }
1495 
<abbr title="1496         Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClass(targetClass, returnedClass, this, tempPrefix + propertyName + &quot;.&quot;);">1496         Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClðŸ”µ</abbr>
1497 
1498         if (isParentExcluded) {
1499             for (String key : componentPresentationAttributes.keySet()) {
<abbr title="1500                 LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excluded&quot;);">1500                 LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excludedðŸ”µ</abbr>
1501                 componentPresentationAttributes.get(key).setExcluded(true);
1502             }
1503         }
1504 
1505         PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1506         Property property;
1507 
1508         try {
1509             property = persistentClass.getProperty(propertyName);
1510         } catch (MappingException e) {
1511             property = persistentClass.getProperty(prefix + propertyName);
1512         }
1513 
<abbr title="1514         Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPropertyIterator();">1514         Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPðŸ”µ</abbr>
1515         List&lt;Property&gt; componentPropertyList = new ArrayList&lt;&gt;();
1516 
1517         while (componentPropertyIterator.hasNext()) {
1518             componentPropertyList.add((Property) componentPropertyIterator.next());
1519         }
1520 
1521         Map&lt;String, FieldMetadata&gt; newFields = new HashMap&lt;&gt;();
1522         buildProperties(
1523                 targetClass,
1524                 foreignField,
1525                 additionalForeignFields,
1526                 additionalNonPersistentProperties,
1527                 mergedPropertyType,
1528                 componentPresentationAttributes,
1529                 componentPropertyList,
1530                 newFields,
1531                 componentPropertyNames,
1532                 componentPropertyTypes,
1533                 idProperty,
1534                 populateManyToOneFields,
1535                 includeFields,
1536                 excludeFields,
1537                 configurationKey,
1538                 ceilingEntityFullyQualifiedClassname,
1539                 parentClasses,
1540                 propertyName + &quot;.&quot;,
1541                 isParentExcluded,
1542                 true,
1543                 parentPrefix + prefix
1544         );
1545 
1546         Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;();
1547 
1548         for (String key : newFields.keySet()) {
1549             final FieldMetadata fieldMetadata = newFields.get(key);
1550             convertedFields.put(propertyName + &quot;.&quot; + key, fieldMetadata);
1551 
1552             if (isForeignKey(fieldMetadata)) {
1553                 setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1554             }
1555         }
1556         fields.putAll(convertedFields);
1557     }
1558 
1559     @Override
1560     public EntityManager getStandardEntityManager() {
1561         return standardEntityManager;
1562     }
1563 
1564     @Override
1565     public void setStandardEntityManager(EntityManager entityManager) {
1566         this.standardEntityManager = entityManager;
1567         fieldManager = new FieldManager(entityConfiguration, entityManager);
1568     }
1569 
1570     @Override
1571     public FieldManager getFieldManager() {
1572         return this.getFieldManager(true);
1573     }
1574 
1575     @Override
1576     public FieldManager getFieldManager(boolean cleanFieldManager) {
1577         if (fieldManager == null) {
1578             //keep in mind that getStandardEntityManager() can return null, this is in general OK,
1579             // we re-init fieldManager in setStandardEntityManager method
1580             fieldManager = new FieldManager(entityConfiguration, getStandardEntityManager());
1581         } else if (cleanFieldManager){
1582             fieldManager.clearMiddleFields();
1583         }
1584         return fieldManager;
1585     }
1586 
1587     @Override
1588     public EntityConfiguration getEntityConfiguration() {
1589         return entityConfiguration;
1590     }
1591 
1592     @Override
1593     public void setEntityConfiguration(EntityConfiguration entityConfiguration) {
1594         this.entityConfiguration = entityConfiguration;
1595     }
1596 
1597     @Override
1598     public Metadata getMetadata() {
1599         return metadata;
1600     }
1601 
1602     @Override
1603     public void setMetadata(Metadata metadata) {
1604         this.metadata = metadata;
1605     }
1606 
1607     public List&lt;FieldMetadataProvider&gt; getFieldMetadataProviders() {
1608         return fieldMetadataProviders;
1609     }
1610 
1611     public void setFieldMetadataProviders(List&lt;FieldMetadataProvider&gt; fieldMetadataProviders) {
1612         this.fieldMetadataProviders = fieldMetadataProviders;
1613     }
1614 
1615     @Override
1616     public FieldMetadataProvider getDefaultFieldMetadataProvider() {
1617         return defaultFieldMetadataProvider;
1618     }
1619 
1620     public void setDefaultFieldMetadataProvider(FieldMetadataProvider defaultFieldMetadataProvider) {
1621         this.defaultFieldMetadataProvider = defaultFieldMetadataProvider;
1622     }
1623 
1624     protected boolean isExcludeClassFromPolymorphism(Class&lt;?&gt; clazz) {
1625         return dynamicDaoHelper.isExcludeClassFromPolymorphism(clazz);
1626     }
1627 
1628     @Override
1629     public DynamicDaoHelper getDynamicDaoHelper() {
1630         return dynamicDaoHelper;
1631     }
1632 
1633     public void setDynamicDaoHelper(DynamicDaoHelper dynamicDaoHelper) {
1634         this.dynamicDaoHelper = dynamicDaoHelper;
1635     }
1636 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Open Admin Platform
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.openadmin.server.dao;
  19  
  20  
  21  import org.apache.commons.collections4.map.LRUMap;
  22  import org.apache.commons.lang.StringUtils;
  23  import org.apache.commons.lang3.ArrayUtils;
  24  import org.apache.commons.logging.Log;
  25  import org.apache.commons.logging.LogFactory;
  26  import org.broadleafcommerce.common.money.Money;
  27  import org.broadleafcommerce.common.persistence.EntityConfiguration;
  28  import org.broadleafcommerce.common.persistence.Status;
  29  import org.broadleafcommerce.common.presentation.AdminPresentationClass;
  30  import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  31  import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  32  import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  33  import org.broadleafcommerce.common.util.dao.DynamicDaoHelper;
  34  import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
  35  import org.broadleafcommerce.common.util.dao.HibernateMappingProvider;

  36  import org.broadleafcommerce.openadmin.dto.BasicCollectionMetadata;
  37  import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  38  import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  39  import org.broadleafcommerce.openadmin.dto.ClassTree;
  40  import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  41  import org.broadleafcommerce.openadmin.dto.ForeignKey;
  42  import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  43  import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  44  import org.broadleafcommerce.openadmin.dto.TabMetadata;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +import org.broadleafcommerce.openadmin.server.dao.provider.metadata.BasicFieldMetadataProvider;</span>
  46  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.FieldMetadataProvider;
  47  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequest;
  48  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.LateStageAddMetadataRequest;
  49  import org.broadleafcommerce.openadmin.server.service.persistence.module.FieldManager;
  50  import org.broadleafcommerce.openadmin.server.service.persistence.validation.FieldNamePropertyValidator;
  51  import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  52  import org.hibernate.Criteria;
  53  import org.hibernate.MappingException;
  54  import org.hibernate.Session;
  55  import org.hibernate.mapping.PersistentClass;
  56  import org.hibernate.mapping.Property;
  57  import org.hibernate.type.ComponentType;
  58  import org.hibernate.type.Type;
  59  import org.springframework.beans.BeansException;
  60  import org.springframework.beans.factory.NoSuchBeanDefinitionException;
  61  import org.springframework.beans.factory.annotation.Value;
  62  import org.springframework.context.ApplicationContext;
  63  import org.springframework.context.ApplicationContextAware;
  64  import org.springframework.context.annotation.Scope;
  65  import org.springframework.core.annotation.AnnotationUtils;
  66  import org.springframework.stereotype.Component;
  67  
  68  import java.io.Serializable;
  69  import java.lang.reflect.Field;
  70  import java.lang.reflect.Method;
  71  import java.lang.reflect.Modifier;
  72  import java.math.BigDecimal;
  73  import java.math.BigInteger;
  74  import java.security.MessageDigest;
  75  import java.security.NoSuchAlgorithmException;


  76  import java.util.ArrayList;
  77  import java.util.Arrays;
  78  import java.util.Collections;
  79  import java.util.Comparator;
  80  import java.util.Date;
  81  import java.util.HashMap;
  82  import java.util.HashSet;
  83  import java.util.Iterator;
  84  import java.util.List;
  85  import java.util.Map;
  86  import java.util.Set;
  87  
  88  import javax.annotation.Nonnull;
  89  import javax.annotation.Resource;
  90  import javax.persistence.EntityManager;
  91  import javax.persistence.criteria.CriteriaBuilder;
  92  import javax.persistence.criteria.CriteriaQuery;
  93  import javax.persistence.criteria.Path;
  94  import javax.persistence.criteria.Predicate;
  95  import javax.persistence.criteria.Root;
  96  
  97  /**
  98   * @author jfischer
  99   */
 100  @Component(&quot;blDynamicEntityDao&quot;)
 101  @Scope(&quot;prototype&quot;)
 102  public class DynamicEntityDaoImpl implements DynamicEntityDao, ApplicationContextAware {
 103  
 104      private static final Log LOG = LogFactory.getLog(DynamicEntityDaoImpl.class);
 105  
 106      protected static final Map&lt;String, Map&lt;String, FieldMetadata&gt;&gt; METADATA_CACHE = new LRUMap&lt;&gt;(1000);
 107  
 108      /**
<abbr title=" 109       * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we have cached in METADATA_CACHE over the lifetime"> 109       * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we have cacheðŸ”µ</abbr>
<abbr title=" 110       * of the application. This should survive evictions from METADATA_CACHE because it is for the purpose of diagnosing when we store different property"> 110       * of the application. This should survive evictions from METADATA_CACHE because it is for the purpose of diagðŸ”µ</abbr>
 111       * counts in METADATA_CACHE as a result of cache eviction
 112       */
 113      protected static final Map&lt;String, Integer&gt; METADATA_CACHE_SIZES = new HashMap&lt;&gt;();
 114  
 115      /*
<abbr title=" 116       * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are abstract or have been marked for exclusion"> 116       * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are abstract or ðŸ”µ</abbr>
 117       * from polymorphism
 118       */
 119  
 120      protected EntityManager standardEntityManager;
 121  
 122      @Resource(name = &quot;blMetadata&quot;)
 123      protected Metadata metadata;
 124  
 125      @Resource(name = &quot;blEntityConfiguration&quot;)
 126      protected EntityConfiguration entityConfiguration;
 127  
 128      @Resource(name = &quot;blFieldMetadataProviders&quot;)
 129      protected List&lt;FieldMetadataProvider&gt; fieldMetadataProviders = new ArrayList&lt;&gt;();
 130  
 131      @Resource(name = &quot;blDefaultFieldMetadataProvider&quot;)
 132      protected FieldMetadataProvider defaultFieldMetadataProvider;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 134 +    @Resource(name = &quot;blBasicFieldMetadataProvider&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 135 +    protected BasicFieldMetadataProvider basicFieldMetadataProvider;</span>
 136  
 137      @Resource(name = &quot;blAppConfigurationMap&quot;)
 138      protected Map&lt;String, String&gt; propertyConfigurations = new HashMap&lt;&gt;();
 139  
 140      protected DynamicDaoHelper dynamicDaoHelper = new DynamicDaoHelperImpl();
 141  
 142      @Value(&quot;${cache.entity.dao.metadata.ttl}&quot;)
 143      protected int cacheEntityMetaDataTtl;
 144  
 145      /**
 146       * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the application
 147       */
 148      @Value(&quot;${validate.metadata.cache.sizes:false}&quot;)
 149      protected boolean validateMetadataCacheSizes;
 150  
 151      protected long lastCacheFlushTime = System.currentTimeMillis();
 152  
 153      protected ApplicationContext applicationContext;
 154  
 155      protected FieldManager fieldManager;
 156  
 157      @Override
 158      public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 159          this.applicationContext = applicationContext;
 160      }
 161  
 162      @Override
 163      public Criteria createCriteria(Class&lt;?&gt; entityClass) {
 164          return getStandardEntityManager().unwrap(Session.class).createCriteria(entityClass);
 165      }
 166  
 167      @Override
 168      public &lt;T&gt; T persist(T entity) {
 169          standardEntityManager.persist(entity);
 170          standardEntityManager.flush();
 171          return entity;
 172      }
 173  
 174      @Override
 175      public Object find(Class&lt;?&gt; entityClass, Object key) {
 176          return standardEntityManager.find(entityClass, key);
 177      }
 178  
 179      @Override
 180      public &lt;T&gt; T merge(T entity) {
 181          T response = standardEntityManager.merge(entity);
 182          standardEntityManager.flush();
 183          return response;
 184      }
 185  
 186      @Override
 187      public void flush() {
 188          standardEntityManager.flush();
 189      }
 190  
 191      @Override
 192      public void detach(Serializable entity) {
 193          standardEntityManager.detach(entity);
 194      }
 195  
 196      @Override
 197      public void refresh(Serializable entity) {
 198          standardEntityManager.refresh(entity);
 199      }
 200  
 201      @Override
 202      public Serializable retrieve(Class&lt;?&gt; entityClass, Object primaryKey) {
 203          return (Serializable) standardEntityManager.find(entityClass, primaryKey);
 204      }
 205  
 206      @Override
 207      public void remove(Serializable entity) {
 208          standardEntityManager.remove(entity);
 209          standardEntityManager.flush();
 210      }
 211  
 212      @Override
 213      public void clear() {
 214          standardEntityManager.clear();
 215      }
 216  
 217      @Override
 218      public PersistentClass getPersistentClass(String targetClassName) {
 219          return HibernateMappingProvider.getMapping(targetClassName);
 220      }
 221  
 222      @Override
 223      public boolean useCache() {
 224          if (cacheEntityMetaDataTtl &lt; 0) {
 225              return true;
 226          }
 227          if (cacheEntityMetaDataTtl == 0) {
 228              return false;
 229          } else {
 230              if ((System.currentTimeMillis() - lastCacheFlushTime) &gt; cacheEntityMetaDataTtl) {
 231                  lastCacheFlushTime = System.currentTimeMillis();
 232                  METADATA_CACHE.clear();
 233                  DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE.clear();
 234                  DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE_WO_EXCLUSIONS.clear();
 235                  LOG.trace(&quot;Metadata cache evicted&quot;);
 236                  return true; // cache is empty
 237              } else {
 238                  return true;
 239              }
 240          }
 241      }
 242  
 243      @Override
 244      public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass) {
 245          return getAllPolymorphicEntitiesFromCeiling(ceilingClass, true);
 246      }
 247  
 248      @Override
<abbr title=" 249      public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymorphicEntities) {"> 249      public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymoðŸ”µ</abbr>
<abbr title=" 250          return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolymorphicEntities, useCache());"> 250          return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolymorphicEnðŸ”µ</abbr>
 251      }
 252  
 253      @Override
 254      public Class&lt;?&gt;[] getUpDownInheritance(Class&lt;?&gt; testClass) {
 255          return dynamicDaoHelper.getUpDownInheritance(testClass, true, useCache());
 256      }
 257  
 258      @Override
 259      public Class&lt;?&gt; getImplClass(String className) {
 260          Class&lt;?&gt; clazz = null;
 261          try {
 262              clazz = entityConfiguration.lookupEntityClass(className);
 263          } catch (NoSuchBeanDefinitionException e) {
 264              //do nothing
 265          }
 266          if (clazz == null) {
 267              try {
 268                  clazz = Class.forName(className);
 269              } catch (ClassNotFoundException e) {
 270                  throw new RuntimeException(e);
 271              }
 272              clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 273          }
 274          return clazz;
 275      }
 276  
 277      @Override
 278      public Class&lt;?&gt; getCeilingImplClass(String className) {
 279          Class&lt;?&gt; clazz;
 280          try {
 281              clazz = Class.forName(className);
 282          } catch (ClassNotFoundException e) {
 283              throw new RuntimeException(e);
 284          }
 285          Class&lt;?&gt;[] entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 286          if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
 287              clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 288              entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 289          }
 290          if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
<abbr title=" 291              throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for the requested class name (%s)&quot;, className));"> 291              throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for the requesðŸ”µ</abbr>
 292          }
 293          clazz = entitiesFromCeiling[entitiesFromCeiling.length - 1];
 294          return clazz;
 295      }
 296  
 297      @Override
<abbr title=" 298      public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, String value) {"> 298      public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, String value)ðŸ”µ</abbr>
 299          Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass());
 300          CriteriaBuilder builder = this.standardEntityManager.getCriteriaBuilder();
 301          CriteriaQuery&lt;Long&gt; criteria = builder.createQuery(Long.class);
 302          Root root = criteria.from(clazz);
 303          Path idField = root.get(this.getIdField(clazz).getName());
 304          criteria.select(idField.as(Long.class));
 305          List&lt;Predicate&gt; restrictions = new ArrayList();
 306  
 307          Path path = null;
 308  
 309          // Support property name such as &quot;defaultSku.name&quot;
 310          if (propertyName.contains(&quot;.&quot;)) {
 311              String[] split = propertyName.split(&quot;\\.&quot;);
 312              for (String splitResult : split) {
 313                  if (path == null) {
 314                      path = root.get(splitResult);
 315                  } else {
 316                      path = path.get(splitResult);
 317                  }
 318              }
 319          } else {
 320              path = root.get(propertyName);
 321          }
 322  
 323          restrictions.add(builder.equal(path, value));
 324          Serializable identifier = this.getIdentifier(instance);
 325          //when we creating the new item identifier is not exists
 326          if (identifier != null) {
 327              restrictions.add(builder.notEqual(idField, identifier));
 328          }
 329  
 330          if (instance instanceof Status) {
<abbr title=" 331              restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), builder.equal(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;), &#x27;N&#x27;)));"> 331              restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), builder.equal(rðŸ”µ</abbr>
 332          }
 333  
 334          criteria.where(restrictions.toArray(new Predicate[restrictions.size()]));
 335          return this.standardEntityManager.createQuery(criteria).getResultList();
 336      }
 337  
 338      @Override
 339      public Serializable getIdentifier(Object entity) {
 340          return dynamicDaoHelper.getIdentifier(entity);
 341      }
 342  
 343      protected Field getIdField(Class&lt;?&gt; clazz) {
 344          return dynamicDaoHelper.getIdField(clazz);
 345      }
 346  
 347      public Class&lt;?&gt;[] sortEntities(Class&lt;?&gt; ceilingClass, List&lt;Class&lt;?&gt;&gt; entities) {
 348          return dynamicDaoHelper.sortEntities(ceilingClass, entities);
 349      }
 350  
 351      protected void addClassToTree(Class&lt;?&gt; clazz, ClassTree tree) {
 352          Class&lt;?&gt; testClass;
 353          try {
 354              testClass = Class.forName(tree.getFullyQualifiedClassname());
 355          } catch (ClassNotFoundException e) {
 356              throw new RuntimeException(e);
 357          }
 358          if (clazz.equals(testClass)) {
 359              return;
 360          }
 361          if (clazz.getSuperclass().equals(testClass)) {
 362              ClassTree myTree = new ClassTree(clazz.getName(), isExcludeClassFromPolymorphism(clazz));
 363              createClassTreeFromAnnotation(clazz, myTree);
 364              tree.setChildren(ArrayUtils.add(tree.getChildren(), myTree));
 365          } else {
 366              for (ClassTree child : tree.getChildren()) {
 367                  addClassToTree(clazz, child);
 368              }
 369          }
 370      }
 371  
 372      protected void createClassTreeFromAnnotation(Class&lt;?&gt; clazz, ClassTree myTree) {
<abbr title=" 373          AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 373          AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.clðŸ”µ</abbr>
 374          if (classPresentation != null) {
 375              String friendlyName = classPresentation.friendlyName();
 376              if (!StringUtils.isEmpty(friendlyName)) {
 377                  myTree.setFriendlyName(friendlyName);
 378              }
 379          }
 380      }
 381  
 382      @Override
 383      public ClassTree getClassTree(Class&lt;?&gt;[] polymorphicClasses) {
 384          String ceilingClass = null;
 385          for (Class&lt;?&gt; clazz : polymorphicClasses) {
<abbr title=" 386              AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 386              AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClasðŸ”µ</abbr>
 387              if (classPresentation != null) {
 388                  String ceilingEntity = classPresentation.ceilingDisplayEntity();
 389                  if (!StringUtils.isEmpty(ceilingEntity)) {
 390                      ceilingClass = ceilingEntity;
 391                      break;
 392                  }
 393              }
 394          }
 395          if (ceilingClass != null) {
 396              int pos = -1;
 397              int j = 0;
 398              for (Class&lt;?&gt; clazz : polymorphicClasses) {
 399                  if (clazz.getName().equals(ceilingClass)) {
 400                      pos = j;
 401                      break;
 402                  }
 403                  j++;
 404              }
 405              if (pos &gt;= 0) {
 406                  Class&lt;?&gt;[] temp = new Class&lt;?&gt;[pos + 1];
 407                  System.arraycopy(polymorphicClasses, 0, temp, 0, j + 1);
 408                  polymorphicClasses = temp;
 409              }
 410          }
 411  
 412          ClassTree classTree = null;
 413          if (!ArrayUtils.isEmpty(polymorphicClasses)) {
 414              Class&lt;?&gt; topClass = polymorphicClasses[polymorphicClasses.length - 1];
 415              classTree = new ClassTree(topClass.getName(), isExcludeClassFromPolymorphism(topClass));
 416              createClassTreeFromAnnotation(topClass, classTree);
 417              for (int j = polymorphicClasses.length - 1; j &gt;= 0; j--) {
 418                  addClassToTree(polymorphicClasses[j], classTree);
 419              }
 420              classTree.finalizeStructure(1);
 421          }
 422          return classTree;
 423      }
 424  
 425      @Override
 426      public ClassTree getClassTreeFromCeiling(Class&lt;?&gt; ceilingClass) {
 427          Class&lt;?&gt;[] sortedEntities = getAllPolymorphicEntitiesFromCeiling(ceilingClass);
 428          return getClassTree(sortedEntities);
 429      }
 430  
 431      @Override
<abbr title=" 432      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 432      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persisteðŸ”µ</abbr>
 433          Class&lt;?&gt;[] entityClasses;
 434          try {
 435              entityClasses = getAllPolymorphicEntitiesFromCeiling(Class.forName(entityName));
 436          } catch (ClassNotFoundException e) {
 437              throw new RuntimeException(e);
 438          }
 439          if (!ArrayUtils.isEmpty(entityClasses)) {
 440              return getMergedProperties(
 441                      entityName,
 442                      entityClasses,
<abbr title=" 443                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 443                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectivðŸ”µ</abbr>
 444                      persistencePerspective.getAdditionalNonPersistentProperties(),
 445                      persistencePerspective.getAdditionalForeignKeys(),
 446                      MergedPropertyType.PRIMARY,
 447                      persistencePerspective.getPopulateToOneFields(),
 448                      persistencePerspective.getIncludeFields(),
 449                      persistencePerspective.getExcludeFields(),
 450                      persistencePerspective.getConfigurationKey(),
 451                      &quot;&quot;
 452              );
 453          } else {
 454              Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 455              Class&lt;?&gt; targetClass;
 456              try {
 457                  targetClass = Class.forName(entityName);
 458              } catch (ClassNotFoundException e) {
 459                  throw new RuntimeException(e);
 460              }
<abbr title=" 461              Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 461              Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targetClass, ðŸ”µ</abbr>
 462              for (String property : attributesMap.keySet()) {
 463                  FieldMetadata presentationAttribute = attributesMap.get(property);
 464                  if (!presentationAttribute.getExcluded()) {
 465                      Field field = FieldManager.getSingleField(targetClass, property);
 466                      if (!Modifier.isStatic(field.getModifiers())) {
 467                          boolean handled = false;
 468                          for (FieldMetadataProvider provider : fieldMetadataProviders) {
 469                              MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title=" 470                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 470                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]ðŸ”µ</abbr>
 471                                              MergedPropertyType.PRIMARY, null, null, &quot;&quot;,
 472                                              property, null, false, 0, attributesMap, presentationAttribute,
<abbr title=" 473                                              ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(), field.getType(), this),"> 473                                              ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(), fðŸ”µ</abbr>
 474                                      mergedProperties);
 475                              if (MetadataProviderResponse.NOT_HANDLED != response) {
 476                                  handled = true;
 477                              }
 478                              if (MetadataProviderResponse.HANDLED_BREAK == response) {
 479                                  break;
 480                              }
 481                          }
 482                          if (!handled) {
<abbr title=" 483                              //this provider is not included in the provider list on purpose - it is designed to handle basic"> 483                              //this provider is not included in the provider list on purpose - it is designed to haðŸ”µ</abbr>
 484                              //AdminPresentation fields, and those fields not admin presentation annotated at all
 485                              defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title=" 486                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 486                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]ðŸ”µ</abbr>
 487                                              MergedPropertyType.PRIMARY, null, null, &quot;&quot;, property,
<abbr title=" 488                                              null, false, 0, attributesMap, presentationAttribute, ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(),"> 488                                              null, false, 0, attributesMap, presentationAttribute, ((BasicFieldMetaðŸ”µ</abbr>
 489                                              field.getType(), this), mergedProperties);
 490                          }
 491                      }
 492                  }
 493              }
 494  
 495              return mergedProperties;
 496          }
 497      }
 498  
 499      @Override
 500      public Map&lt;String, FieldMetadata&gt; getMergedProperties(@Nonnull Class&lt;?&gt; cls) {
 501          Class&lt;?&gt;[] polymorphicTypes = getAllPolymorphicEntitiesFromCeiling(cls);
 502          return getMergedProperties(
 503                  cls.getName(),
 504                  polymorphicTypes,
 505                  null,
 506                  new String[]{},
 507                  new ForeignKey[]{},
 508                  MergedPropertyType.PRIMARY,
 509                  true,
 510                  new String[]{},
 511                  new String[]{},
 512                  null,
 513                  &quot;&quot;
 514          );
 515      }
 516  
 517      @Override
 518      public Map&lt;String, FieldMetadata&gt; getMergedProperties(
 519              String ceilingEntityFullyQualifiedClassname,
 520              Class&lt;?&gt;[] entities,
 521              ForeignKey foreignField,
 522              String[] additionalNonPersistentProperties,
 523              ForeignKey[] additionalForeignFields,
 524              MergedPropertyType mergedPropertyType,
 525              Boolean populateManyToOneFields,
 526              String[] includeFields,
 527              String[] excludeFields,
 528              String configurationKey,
 529              String prefix) {
 530          Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedPropertiesRecursively(
 531                  ceilingEntityFullyQualifiedClassname,
 532                  entities,
 533                  foreignField,
 534                  additionalNonPersistentProperties,
 535                  additionalForeignFields,
 536                  mergedPropertyType,
 537                  populateManyToOneFields,
 538                  includeFields,
 539                  excludeFields,
 540                  configurationKey,
 541                  new ArrayList&lt;Class&lt;?&gt;&gt;(),
 542                  prefix,
 543                  false,
 544                  &quot;&quot;);
 545  
 546          final List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 547  
 548          for (final String key : mergedProperties.keySet()) {
 549              if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded()) {
 550                  removeKeys.add(key);
 551              }
 552          }
 553  
 554          for (String removeKey : removeKeys) {
 555              mergedProperties.remove(removeKey);
 556          }
 557  
<abbr title=" 558          // Allow field metadata providers to contribute additional fields here. These latestage handlers take place"> 558          // Allow field metadata providers to contribute additional fields here. These latestage handlers take placðŸ”µ</abbr>
<abbr title=" 559          // after any cached lookups occur, and are ideal for adding in dynamic properties that are not globally cacheable"> 559          // after any cached lookups occur, and are ideal for adding in dynamic properties that are not globally caðŸ”µ</abbr>
 560          // like properties gleaned from reflection typically are.
 561          Set&lt;String&gt; keys = new HashSet&lt;&gt;(mergedProperties.keySet());
 562          for (Class&lt;?&gt; targetClass : entities) {
 563              for (String key : keys) {
<abbr title=" 564                  LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass, this, &quot;&quot;);"> 564                  LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass, this, &quot;&quot;ðŸ”µ</abbr>
 565  
 566                  boolean foundOneOrMoreHandlers = false;
 567                  for (FieldMetadataProvider fieldMetadataProvider : fieldMetadataProviders) {
<abbr title=" 568                      MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);"> 568                      MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mergedPropðŸ”µ</abbr>
 569                      if (MetadataProviderResponse.NOT_HANDLED != response) {
 570                          foundOneOrMoreHandlers = true;
 571                      }
 572                      if (MetadataProviderResponse.HANDLED_BREAK == response) {
 573                          break;
 574                      }
 575                  }
 576                  if (!foundOneOrMoreHandlers) {
 577                      defaultFieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);
 578                  }
 579              }
 580          }
 581  
 582          return mergedProperties;
 583      }
 584  
 585      protected Map&lt;String, FieldMetadata&gt; getMergedPropertiesRecursively(
 586              final String ceilingEntityFullyQualifiedClassname,
 587              final Class&lt;?&gt;[] entities,
 588              final ForeignKey foreignField,
 589              final String[] additionalNonPersistentProperties,
 590              final ForeignKey[] additionalForeignFields,
 591              final MergedPropertyType mergedPropertyType,
 592              final Boolean populateManyToOneFields,
 593              final String[] includeFields,
 594              final String[] excludeFields,
 595              final String configurationKey,
 596              final List&lt;Class&lt;?&gt;&gt; parentClasses,
 597              final String prefix,
 598              final Boolean isParentExcluded,
 599              final String parentPrefix) {
 600          PropertyBuilder propertyBuilder = new PropertyBuilder() {
 601              @Override
 602              public Map&lt;String, FieldMetadata&gt; execute(Boolean overridePopulateManyToOne) {
 603                  Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 604                  Boolean classAnnotatedPopulateManyToOneFields;
 605                  if (overridePopulateManyToOne != null) {
 606                      classAnnotatedPopulateManyToOneFields = overridePopulateManyToOne;
 607                  } else {
 608                      classAnnotatedPopulateManyToOneFields = populateManyToOneFields;
 609                  }
 610  
 611                  buildPropertiesFromPolymorphicEntities(
 612                          entities,
 613                          foreignField,
 614                          additionalNonPersistentProperties,
 615                          additionalForeignFields,
 616                          mergedPropertyType,
 617                          classAnnotatedPopulateManyToOneFields,
 618                          includeFields,
 619                          excludeFields,
 620                          configurationKey,
 621                          ceilingEntityFullyQualifiedClassname,
 622                          mergedProperties,
 623                          parentClasses,
 624                          prefix,
 625                          isParentExcluded,
 626                          parentPrefix);
 627  
 628                  return mergedProperties;
 629              }
 630          };
 631  
<abbr title=" 632          Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilder, prefix, isParentExcluded, ceilingEntityFullyQualifiedClassname, configurationKey, this);"> 632          Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilder, prefix,ðŸ”µ</abbr>
 633          applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedProperties);
 634          applyForeignKeyPrecedence(foreignField, additionalForeignFields, mergedProperties);
 635  
 636          return mergedProperties;
 637      }
 638  
<abbr title=" 639      protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFields, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 639      protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFields, Map&lt;StðŸ”µ</abbr>
 640          for (String key : mergedProperties.keySet()) {
 641              boolean isForeign = false;
 642              if (foreignField != null) {
 643                  isForeign = foreignField.getManyToField().equals(key);
 644              }
 645              if (!isForeign &amp;&amp; !ArrayUtils.isEmpty(additionalForeignFields)) {
 646                  for (ForeignKey foreignKey : additionalForeignFields) {
 647                      isForeign = foreignKey.getManyToField().equals(key);
 648                      if (isForeign) {
 649                          break;
 650                      }
 651                  }
 652              }
 653              if (isForeign) {
 654                  FieldMetadata metadata = mergedProperties.get(key);
 655                  metadata.setExcluded(false);
 656              }
 657          }
 658      }
 659  
<abbr title=" 660      protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefix, Boolean isParentExcluded, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 660      protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefix, BooleanðŸ”µ</abbr>
 661          //check includes
 662          if (!ArrayUtils.isEmpty(includeFields)) {
 663              for (String include : includeFields) {
 664                  for (String key : mergedProperties.keySet()) {
 665                      String testKey = prefix + key;
 666                      if (!(testKey.startsWith(include + &quot;.&quot;) || testKey.equals(include))) {
 667                          FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 668                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did not appear in the explicit includeFields list&quot;);"> 668                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did not appeaðŸ”µ</abbr>
 669                          metadata.setExcluded(true);
 670                      } else {
 671                          FieldMetadata metadata = mergedProperties.get(key);
 672                          if (!isParentExcluded) {
<abbr title=" 673                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field appears in the explicit includeFields list&quot;);"> 673                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field appears in ðŸ”µ</abbr>
 674                              metadata.setExcluded(false);
 675                          }
 676                      }
 677                  }
 678              }
 679          } else if (!ArrayUtils.isEmpty(excludeFields)) {
 680              //check excludes
 681              for (String exclude : excludeFields) {
 682                  for (String key : mergedProperties.keySet()) {
 683                      String testKey = prefix + key;
 684                      if (testKey.startsWith(exclude + &quot;.&quot;) || testKey.equals(exclude)) {
 685                          FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 686                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appears in the explicit excludeFields list&quot;);"> 686                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appears in thðŸ”µ</abbr>
 687                          metadata.setExcluded(true);
 688                      } else {
 689                          FieldMetadata metadata = mergedProperties.get(key);
 690                          if (!isParentExcluded) {
<abbr title=" 691                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field did not appear in the explicit excludeFields list&quot;);"> 691                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field did not appðŸ”µ</abbr>
 692                              metadata.setExcluded(false);
 693                          }
 694                      }
 695                  }
 696              }
 697          }
 698      }
 699  
 700      protected String pad(String s, int length, char pad) {
 701          StringBuilder buffer = new StringBuilder(s);
 702          while (buffer.length() &lt; length) {
 703              buffer.insert(0, pad);
 704          }
 705          return buffer.toString();
 706      }
 707  
<abbr title=" 708      protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, String[] additionalNonPersistentProperties, ForeignKey[] additionalForeignFields, MergedPropertyType mergedPropertyType, Boolean populateManyToOneFields, Class&lt;?&gt; clazz, String configurationKey, Boolean isParentExcluded) {"> 708      protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, String[] adðŸ”µ</abbr>
 709          StringBuilder sb = new StringBuilder(150);
 710          sb.append(ceilingEntityFullyQualifiedClassname);
 711          sb.append(clazz.hashCode());
 712          sb.append(foreignField == null ? &quot;&quot; : foreignField.toString());
 713          sb.append(configurationKey);
 714          sb.append(isParentExcluded);
 715          if (additionalNonPersistentProperties != null) {
 716              for (String prop : additionalNonPersistentProperties) {
 717                  sb.append(prop);
 718              }
 719          }
 720          if (additionalForeignFields != null) {
 721              for (ForeignKey key : additionalForeignFields) {
 722                  sb.append(key.toString());
 723              }
 724          }
 725          sb.append(mergedPropertyType);
 726          sb.append(populateManyToOneFields);
 727  
 728          String digest;
 729          try {
 730              MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
 731              byte[] messageDigest = md.digest(sb.toString().getBytes());
 732              BigInteger number = new BigInteger(1, messageDigest);
 733              digest = number.toString(16);
 734          } catch (NoSuchAlgorithmException e) {
 735              throw new RuntimeException(e);
 736          }
 737  
 738          String key = pad(digest, 32, &#x27;0&#x27;);
 739  
 740          if (LOG.isDebugEnabled()) {
 741              LOG.debug(&quot;Created cache key: &quot; + key + &quot; from the following string: &quot; + sb.toString());
 742          }
 743          return key;
 744      }
 745  
 746      protected void buildPropertiesFromPolymorphicEntities(
 747              Class&lt;?&gt;[] entities,
 748              ForeignKey foreignField,
 749              String[] additionalNonPersistentProperties,
 750              ForeignKey[] additionalForeignFields,
 751              MergedPropertyType mergedPropertyType,
 752              Boolean populateManyToOneFields,
 753              String[] includeFields,
 754              String[] excludeFields,
 755              String configurationKey,
 756              String ceilingEntityFullyQualifiedClassname,
 757              Map&lt;String, FieldMetadata&gt; mergedProperties,
 758              List&lt;Class&lt;?&gt;&gt; parentClasses,
 759              String prefix,
 760              Boolean isParentExcluded,
 761              String parentPrefix) {
 762          for (Class&lt;?&gt; clazz : entities) {
<abbr title=" 763              String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNonPersistentProperties, additionalForeignFields, mergedPropertyType, populateManyToOneFields, clazz, configurationKey, isParentExcluded);"> 763              String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNonPersistðŸ”µ</abbr>
 764  
 765              Map&lt;String, FieldMetadata&gt; cacheData = null;
 766              synchronized (DynamicDaoHelperImpl.LOCK_OBJECT) {
 767                  if (useCache()) {
 768                      cacheData = METADATA_CACHE.get(cacheKey);
 769                  }
 770  
 771                  if (cacheData == null) {
 772                      Map&lt;String, FieldMetadata&gt; props = getPropertiesForEntityClass(
 773                              clazz,
 774                              foreignField,
 775                              additionalNonPersistentProperties,
 776                              additionalForeignFields,
 777                              mergedPropertyType,
 778                              populateManyToOneFields,
 779                              includeFields,
 780                              excludeFields,
 781                              configurationKey,
 782                              ceilingEntityFullyQualifiedClassname,
 783                              parentClasses,
 784                              prefix,
 785                              isParentExcluded,
 786                              parentPrefix);
 787                      //first check all the properties currently in there to see if my entity inherits from them
 788                      for (Class&lt;?&gt; clazz2 : entities) {
 789                          if (!clazz2.getName().equals(clazz.getName())) {
 790                              for (Map.Entry&lt;String, FieldMetadata&gt; entry : props.entrySet()) {
 791                                  FieldMetadata metadata = entry.getValue();
 792                                  try {
 793                                      if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(clazz2)) {
<abbr title=" 794                                          String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(), new String[]{clazz2.getName()});"> 794                                          String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(), new StriðŸ”µ</abbr>
 795                                          metadata.setAvailableToTypes(both);
 796                                      }
 797                                  } catch (ClassNotFoundException e) {
 798                                      throw new RuntimeException(e);
 799                                  }
 800                              }
 801                          }
 802                      }
 803                      METADATA_CACHE.put(cacheKey, props);
 804  
 805                      if (LOG.isTraceEnabled()) {
<abbr title=" 806                          LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 806                          LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKey + &quot; for ðŸ”µ</abbr>
 807                      }
 808  
 809                      if (validateMetadataCacheSizes) {
 810                          Integer previousSize = METADATA_CACHE_SIZES.get(cacheKey);
 811                          Integer currentSize = props.size();
 812                          if (previousSize == null) {
 813                              METADATA_CACHE_SIZES.put(cacheKey, currentSize);
 814                          } else if (!currentSize.equals(previousSize)) {
<abbr title=" 815                              String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache for the key &quot; + cacheKey + &quot; but we had previously stored &quot; + previousSize + &quot; properties&quot;;"> 815                              String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache for the kðŸ”µ</abbr>
 816                              LOG.error(msg);
 817                              throw new RuntimeException(msg);
 818                          }
 819                      }
 820  
 821                      cacheData = props;
 822                  } else {
 823                      if (LOG.isTraceEnabled()) {
<abbr title=" 824                          LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 824                          LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheKey + &quot; fðŸ”µ</abbr>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 825 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 826 +                    //in case of MT different sites can potentially have different data driven enums, as we don&#x27;t take into account"> 826 +                    //in case of MT different sites can potentially have different data driven enums, as we don&#x27;t ðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 827 +                    //site during cache key calculation(have metadata per-site is overkill) we want to refresh data driven enums"> 827 +                    //site during cache key calculation(have metadata per-site is overkill) we want to refresh datðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 828 +                    for (FieldMetadata value : cacheData.values()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 829 +                        if(value instanceof BasicFieldMetadata &amp;&amp; StringUtils.isNotEmpty(((BasicFieldMetadata)value).getOptionListEntity())){"> 829 +                        if(value instanceof BasicFieldMetadata &amp;&amp; StringUtils.isNotEmpty(((BasicFieldMetadata)valuðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 830 +                            basicFieldMetadataProvider.refreshDataDrivenEnumMetadata((BasicFieldMetadata) value);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 831 +                        }</span>
 832                      }











 833                  }
 834              }
 835              //clone the metadata before passing to the system
 836              Map&lt;String, FieldMetadata&gt; clonedCache = new HashMap&lt;&gt;(cacheData.size());
 837              for (Map.Entry&lt;String, FieldMetadata&gt; entry : cacheData.entrySet()) {
 838                  clonedCache.put(entry.getKey(), entry.getValue().cloneFieldMetadata());
 839              }
 840              mergedProperties.putAll(clonedCache);
 841          }










 842      }
 843  
 844      @Override
 845      public Field[] getAllFields(Class&lt;?&gt; targetClass) {
 846          Field[] allFields = new Field[]{};
 847          boolean eof = false;
 848          Class&lt;?&gt; currentClass = targetClass;
 849          while (!eof) {
 850              Field[] fields = currentClass.getDeclaredFields();
 851              allFields = ArrayUtils.addAll(allFields, fields);
 852              if (currentClass.getSuperclass() != null) {
 853                  currentClass = currentClass.getSuperclass();
 854              } else {
 855                  eof = true;
 856              }
 857          }
 858  
 859          return allFields;
 860      }
 861  
 862      @Override
 863      public Map&lt;String, FieldMetadata&gt; getPropertiesForPrimitiveClass(
 864              String propertyName,
 865              String friendlyPropertyName,
 866              Class&lt;?&gt; targetClass,
 867              Class&lt;?&gt; parentClass,
 868              MergedPropertyType mergedPropertyType
 869      ) {
 870          Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 871          BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
 872          presentationAttribute.setFriendlyName(friendlyPropertyName);
 873          if (String.class.isAssignableFrom(targetClass)) {
 874              presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
 875              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 876              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.STRING, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 876              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.STRING, ðŸ”µ</abbr>
 877          } else if (Boolean.class.isAssignableFrom(targetClass)) {
 878              presentationAttribute.setExplicitFieldType(SupportedFieldType.BOOLEAN);
 879              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 880              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.BOOLEAN, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 880              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.BOOLEAN,ðŸ”µ</abbr>
 881          } else if (Date.class.isAssignableFrom(targetClass)) {
 882              presentationAttribute.setExplicitFieldType(SupportedFieldType.DATE);
 883              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 884              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DATE, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 884              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DATE, nuðŸ”µ</abbr>
 885          } else if (Money.class.isAssignableFrom(targetClass)) {
 886              presentationAttribute.setExplicitFieldType(SupportedFieldType.MONEY);
 887              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 888              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.MONEY, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 888              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.MONEY, nðŸ”µ</abbr>
 889          } else if (
 890                  Byte.class.isAssignableFrom(targetClass) ||
 891                          Integer.class.isAssignableFrom(targetClass) ||
 892                          Long.class.isAssignableFrom(targetClass) ||
 893                          Short.class.isAssignableFrom(targetClass)
 894                  ) {
 895              presentationAttribute.setExplicitFieldType(SupportedFieldType.INTEGER);
 896              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 897              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.INTEGER, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 897              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.INTEGER,ðŸ”µ</abbr>
 898          } else if (
 899                  Double.class.isAssignableFrom(targetClass) ||
 900                          BigDecimal.class.isAssignableFrom(targetClass)
 901                  ) {
 902              presentationAttribute.setExplicitFieldType(SupportedFieldType.DECIMAL);
 903              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 904              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DECIMAL, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 904              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DECIMAL,ðŸ”µ</abbr>
 905          }
 906          ((BasicFieldMetadata) fields.get(propertyName)).setLength(255);
 907          ((BasicFieldMetadata) fields.get(propertyName)).setForeignKeyCollection(false);
 908          ((BasicFieldMetadata) fields.get(propertyName)).setRequired(true);
 909          ((BasicFieldMetadata) fields.get(propertyName)).setUnique(true);
 910          ((BasicFieldMetadata) fields.get(propertyName)).setScale(100);
 911          ((BasicFieldMetadata) fields.get(propertyName)).setPrecision(100);
 912  
 913          return fields;
 914      }
 915  
 916      @Override
 917      public Map&lt;String, Object&gt; getIdMetadata(Class&lt;?&gt; entityClass) {
 918          return dynamicDaoHelper.getIdMetadata(entityClass, standardEntityManager);
 919      }
 920  
 921      @Override
 922      public List&lt;String&gt; getPropertyNames(Class&lt;?&gt; entityClass) {
 923          return dynamicDaoHelper.getPropertyNames(entityClass);
 924      }
 925  
 926      @Override
 927      public List&lt;Type&gt; getPropertyTypes(Class&lt;?&gt; entityClass) {
 928          return dynamicDaoHelper.getPropertyTypes(entityClass);
 929      }
 930  
 931      @Override
 932      public Map&lt;String, TabMetadata&gt; getTabAndGroupMetadata(Class&lt;?&gt;[] entities, ClassMetadata cmd) {
 933          Class&lt;?&gt;[] superClassEntities = getSuperClassHierarchy(entities[entities.length - 1]);
 934  
 935          Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entities);
 936          metadata.applyTabAndGroupMetadataOverrides(superClassEntities, mergedTabAndGroupMetadata);
 937          metadata.buildAdditionalTabAndGroupMetadataFromCmdProperties(cmd, mergedTabAndGroupMetadata);
 938  
 939          return mergedTabAndGroupMetadata;
 940      }
 941  
 942      public Class&lt;?&gt;[] getSuperClassHierarchy(Class&lt;?&gt; ceilingEntity) {
 943          Class&lt;?&gt;[] entities = new Class&lt;?&gt;[]{};
 944  
 945          if (ceilingEntity != null) {
 946              entities = ArrayUtils.add(entities, ceilingEntity);
 947              while (!ceilingEntity.getSuperclass().equals(Object.class)) {
 948                  entities = ArrayUtils.add(entities, ceilingEntity.getSuperclass());
 949                  ceilingEntity = ceilingEntity.getSuperclass();
 950              }
 951          }
 952          return entities;
 953      }
 954  
 955      protected Map&lt;String, FieldMetadata&gt; getPropertiesForEntityClass(
 956              Class&lt;?&gt; targetClass,
 957              ForeignKey foreignField,
 958              String[] additionalNonPersistentProperties,
 959              ForeignKey[] additionalForeignFields,
 960              MergedPropertyType mergedPropertyType,
 961              Boolean populateManyToOneFields,
 962              String[] includeFields,
 963              String[] excludeFields,
 964              String configurationKey,
 965              String ceilingEntityFullyQualifiedClassname,
 966              List&lt;Class&lt;?&gt;&gt; parentClasses,
 967              String prefix,
 968              Boolean isParentExcluded,
 969              String parentPrefix) {
<abbr title=" 970          Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 970          Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null, targetClðŸ”µ</abbr>
 971          if (isParentExcluded) {
 972              for (String key : presentationAttributes.keySet()) {
 973                  LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;);
 974                  presentationAttributes.get(key).setExcluded(true);
 975              }
 976          }
 977  
 978          Map idMetadata = getIdMetadata(targetClass);
 979          Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 980          String idProperty = (String) idMetadata.get(&quot;name&quot;);
 981          List&lt;String&gt; propertyNames = getPropertyNames(targetClass);
 982          propertyNames.add(idProperty);
 983          Type idType = (Type) idMetadata.get(&quot;type&quot;);
 984          List&lt;Type&gt; propertyTypes = getPropertyTypes(targetClass);
 985          propertyTypes.add(idType);
 986  
 987          PersistentClass persistentClass = getPersistentClass(targetClass.getName());
 988          Iterator testIter = persistentClass.getPropertyIterator();
 989          List&lt;Property&gt; propertyList = new ArrayList&lt;&gt;();
 990  
 991          //check the properties for problems
 992          while (testIter.hasNext()) {
 993              Property property = (Property) testIter.next();
 994              if (property.getName().contains(&quot;.&quot;)) {
<abbr title=" 995                  throw new IllegalArgumentException(&quot;Properties from entities that utilize a period character (&#x27;.&#x27;) in their name are incompatible with this system. The property name in question is: (&quot; + property.getName() + &quot;) from the class: (&quot; + targetClass.getName() + &quot;)&quot;);"> 995                  throw new IllegalArgumentException(&quot;Properties from entities that utilize a period character (&#x27;.&#x27;)ðŸ”µ</abbr>
 996              }
 997              propertyList.add(property);
 998          }
 999  
1000          buildProperties(
1001                  targetClass,
1002                  foreignField,
1003                  additionalForeignFields,
1004                  additionalNonPersistentProperties,
1005                  mergedPropertyType,
1006                  presentationAttributes,
1007                  propertyList,
1008                  fields,
1009                  propertyNames,
1010                  propertyTypes,
1011                  idProperty,
1012                  populateManyToOneFields,
1013                  includeFields,
1014                  excludeFields,
1015                  configurationKey,
1016                  ceilingEntityFullyQualifiedClassname,
1017                  parentClasses,
1018                  prefix,
1019                  isParentExcluded,
1020                  false,
1021                  parentPrefix
1022          );
1023          BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
1024          presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
1025          presentationAttribute.setVisibility(VisibilityEnum.HIDDEN_ALL);
1026          if (!ArrayUtils.isEmpty(additionalNonPersistentProperties)) {
1027              Class&lt;?&gt;[] entities = getAllPolymorphicEntitiesFromCeiling(targetClass);
1028              for (String additionalNonPersistentProperty : additionalNonPersistentProperties) {
<abbr title="1029                  if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersistentProperty.startsWith(prefix))) {">1029                  if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersistentPropertðŸ”µ</abbr>
1030                      String myAdditionalNonPersistentProperty = additionalNonPersistentProperty;
1031                      //get final property if this is a dot delimited property
1032                      int finalDotPos = additionalNonPersistentProperty.lastIndexOf(&#x27;.&#x27;);
1033                      if (finalDotPos &gt;= 0) {
<abbr title="1034                          myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(finalDotPos + 1, myAdditionalNonPersistentProperty.length());">1034                          myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(finalDotPoðŸ”µ</abbr>
1035                      }
1036                      //check all the polymorphic types on this target class to see if the end property exists
1037                      Field testField = null;
1038                      Method testMethod = null;
1039                      for (Class&lt;?&gt; clazz : entities) {
1040                          try {
1041                              testMethod = clazz.getMethod(myAdditionalNonPersistentProperty);
1042                              if (testMethod != null) {
1043                                  break;
1044                              }
1045                          } catch (NoSuchMethodException e) {
1046                              //do nothing - method does not exist
1047                          }
1048                          testField = getFieldManager().getField(clazz, myAdditionalNonPersistentProperty);
1049                          if (testField != null) {
1050                              break;
1051                          }
1052                      }
1053                      //if the property exists, add it to the metadata for this class
1054                      if (testField != null || testMethod != null) {
<abbr title="1055                          fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, additionalNonPersistentProperty, propertyList, SupportedFieldType.STRING, null, targetClass, presentationAttribute, mergedPropertyType, this));">1055                          fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, additionalNoðŸ”µ</abbr>
1056                      }
1057                  }
1058              }
1059          }
1060  
1061          return fields;
1062      }
1063  
1064      protected void buildProperties(
1065              Class&lt;?&gt; targetClass,
1066              ForeignKey foreignField,
1067              ForeignKey[] additionalForeignFields,
1068              String[] additionalNonPersistentProperties,
1069              MergedPropertyType mergedPropertyType,
1070              Map&lt;String, FieldMetadata&gt; presentationAttributes,
1071              List&lt;Property&gt; componentProperties,
1072              Map&lt;String, FieldMetadata&gt; fields,
1073              List&lt;String&gt; propertyNames,
1074              List&lt;Type&gt; propertyTypes,
1075              String idProperty,
1076              Boolean populateManyToOneFields,
1077              String[] includeFields,
1078              String[] excludeFields,
1079              String configurationKey,
1080              String ceilingEntityFullyQualifiedClassname,
1081              List&lt;Class&lt;?&gt;&gt; parentClasses,
1082              String prefix,
1083              Boolean isParentExcluded,
1084              Boolean isComponentPrefix,
1085              String parentPrefix) {
1086          int j = 0;
1087          Comparator&lt;String&gt; propertyComparator = new Comparator&lt;String&gt;() {
1088              @Override
1089              public int compare(String o1, String o2) {
1090                  //check for property name equality and for map field properties
<abbr title="1091                  if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FieldManager.MAPFIELDSEPARATOR)) {">1091                  if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FielðŸ”µ</abbr>
1092                      return 0;
1093                  }
1094                  return o1.compareTo(o2);
1095              }
1096          };
1097          List&lt;String&gt; presentationKeyList = new ArrayList&lt;&gt;(presentationAttributes.keySet());
1098          Collections.sort(presentationKeyList);
1099  
1100          for (String propertyName : propertyNames) {
1101              final Type type = propertyTypes.get(j);
1102              boolean isPropertyForeignKey = testForeignProperty(foreignField, prefix, propertyName);
<abbr title="1103              int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFields, prefix, propertyName);">1103              int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFields, prefix,ðŸ”µ</abbr>
1104              j++;
1105              Field myField = getFieldManager().getField(targetClass, propertyName);
1106              if (myField == null) {
<abbr title="1107                  //try to get the field with the prefix - needed for advanced collections that appear in @Embedded classes">1107                  //try to get the field with the prefix - needed for advanced collections that appear in @Embedded ðŸ”µ</abbr>
1108                  myField = getFieldManager().getField(targetClass, prefix + propertyName);
1109              }
1110              if (
1111                      !type.isAnyType() &amp;&amp; !type.isCollectionType() ||
1112                              isPropertyForeignKey ||
1113                              additionalForeignKeyIndexPosition &gt;= 0 ||
1114                              Collections.binarySearch(presentationKeyList, propertyName, propertyComparator) &gt;= 0
1115                      ) {
1116                  if (myField != null) {
1117                      boolean handled = false;
1118                      for (FieldMetadataProvider provider : fieldMetadataProviders) {
1119                          FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1120                          if (presentationAttribute != null) {
1121                              setExcludedBasedOnShowIfProperty(presentationAttribute);
1122                          }
1123                          MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title="1124                                  new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, additionalForeignFields,">1124                                  new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, additionalðŸ”µ</abbr>
1125                                          mergedPropertyType, componentProperties, idProperty, prefix,
<abbr title="1126                                          propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition,">1126                                          propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPositioðŸ”µ</abbr>
<abbr title="1127                                          presentationAttributes, presentationAttribute, null, type.getReturnedClass(), this), fields);">1127                                          presentationAttributes, presentationAttribute, null, type.getReturnedClassðŸ”µ</abbr>
1128                          if (MetadataProviderResponse.NOT_HANDLED != response) {
1129                              handled = true;
1130                          }
1131                          if (MetadataProviderResponse.HANDLED_BREAK == response) {
1132                              break;
1133                          }
1134                      }
1135                      if (!handled) {
1136                          buildBasicProperty(myField, targetClass, foreignField, additionalForeignFields,
1137                                  additionalNonPersistentProperties, mergedPropertyType, presentationAttributes,
1138                                  componentProperties, fields, idProperty, populateManyToOneFields, includeFields,
<abbr title="1139                                  excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClasses,">1139                                  excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClassðŸ”µ</abbr>
<abbr title="1140                                  prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition, isComponentPrefix, parentPrefix);">1140                                  prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeðŸ”µ</abbr>
1141                      }
1142                  }
1143              }
1144          }
1145      }
1146  
1147      public Boolean testPropertyInclusion(FieldMetadata presentationAttribute) {
1148          setExcludedBasedOnShowIfProperty(presentationAttribute);
1149  
<abbr title="1150          return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presentationAttribute.getExcluded()) || (presentationAttribute.getChildrenExcluded() != null &amp;&amp; presentationAttribute.getChildrenExcluded())));">1150          return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presentationAttðŸ”µ</abbr>
1151  
1152      }
1153  
1154      protected void setExcludedBasedOnShowIfProperty(FieldMetadata fieldMetadata) {
1155          if (fieldMetadata != null
1156                  &amp;&amp; StringUtils.isNotEmpty(fieldMetadata.getShowIfProperty())
1157                  &amp;&amp; propertyConfigurations.get(fieldMetadata.getShowIfProperty()) != null
1158                  &amp;&amp; !Boolean.valueOf(propertyConfigurations.get(fieldMetadata.getShowIfProperty()))) {
1159  
1160              //do not include this in the display if it returns false.
1161              fieldMetadata.setExcluded(true);
1162          }
1163      }
1164  
<abbr title="1165      protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyName, Class&lt;?&gt; targetClass,">1165      protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyName, ClasðŸ”µ</abbr>
<abbr title="1166                                              String ceilingEntityFullyQualifiedClassname, Boolean isComponentPrefix, String parentPrefix) {">1166                                              String ceilingEntityFullyQualifiedClassname, Boolean isComponentPrefixðŸ”µ</abbr>
1167  
<abbr title="1168          Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyName, targetClass,">1168          Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyName, tarðŸ”µ</abbr>
1169                  ceilingEntityFullyQualifiedClassname, isComponentPrefix);
1170  
<abbr title="1171          Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isComponentPrefix,">1171          Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isComponentPrefiðŸ”µ</abbr>
1172                  parentPrefix, propertyName);
1173  
1174          return standardRecursionDetected || multiLevelEmbeddableRecursionDetected;
1175      }
1176  
<abbr title="1177      protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String parentPrefix, String propertyName) {">1177      protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String parentPreðŸ”µ</abbr>
1178          return isComponentPrefix &amp;&amp; parentPrefix.contains(&quot;.&quot; + prefix + propertyName);
1179      }
1180  
1181      protected Boolean testStandardPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String
1182              propertyName, Class&lt;?&gt; targetClass, String ceilingEntityFullyQualifiedClassname, Boolean
1183                                                              isComponentPrefix) {
1184          Boolean response = false;
1185          //don&#x27;t want to shun a self-referencing property in an @Embeddable
<abbr title="1186          boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).length &gt; 1);">1186          boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).length &gt; 1ðŸ”µ</abbr>
1187          if (shouldTest) {
1188              Field testField = getFieldManager().getField(targetClass, propertyName);
1189              if (testField == null) {
1190                  Class&lt;?&gt;[] entities;
1191                  try {
<abbr title="1192                      entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1192                      entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassðŸ”µ</abbr>
1193                  } catch (ClassNotFoundException e) {
1194                      throw new RuntimeException(e);
1195                  }
1196                  for (Class&lt;?&gt; clazz : entities) {
1197                      testField = getFieldManager().getField(clazz, propertyName);
1198                      if (testField != null) {
1199                          break;
1200                      }
1201                  }
1202                  String testProperty = prefix + propertyName;
1203                  if (testField == null) {
1204                      testField = getFieldManager().getField(targetClass, testProperty);
1205                  }
1206                  if (testField == null) {
1207                      for (Class&lt;?&gt; clazz : entities) {
1208                          testField = getFieldManager().getField(clazz, testProperty);
1209                          if (testField != null) {
1210                              break;
1211                          }
1212                      }
1213                  }
1214              }
1215              response = determineExclusionForField(parentClasses, targetClass, testField);
1216          }
1217          return response;
1218      }
1219  
<abbr title="1220      protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, Field testField) {">1220      protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, Field testFieðŸ”µ</abbr>
1221          Boolean response = false;
1222          if (testField != null) {
1223              Class&lt;?&gt; testType = testField.getType();
1224              for (Class&lt;?&gt; parentClass : parentClasses) {
1225                  if (parentClass.isAssignableFrom(testType) || testType.isAssignableFrom(parentClass)) {
1226                      response = true;
1227                      break;
1228                  }
1229              }
1230              if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetClass))) {
1231                  response = true;
1232              }
1233          }
1234          return response;
1235      }
1236  
1237      protected void buildBasicProperty(
1238              Field field,
1239              Class&lt;?&gt; targetClass,
1240              ForeignKey foreignField,
1241              ForeignKey[] additionalForeignFields,
1242              String[] additionalNonPersistentProperties,
1243              MergedPropertyType mergedPropertyType,
1244              Map&lt;String, FieldMetadata&gt; presentationAttributes,
1245              List&lt;Property&gt; componentProperties,
1246              Map&lt;String, FieldMetadata&gt; fields,
1247              String idProperty,
1248              Boolean populateManyToOneFields,
1249              String[] includeFields,
1250              String[] excludeFields,
1251              String configurationKey,
1252              String ceilingEntityFullyQualifiedClassname,
1253              List&lt;Class&lt;?&gt;&gt; parentClasses,
1254              String prefix,
1255              Boolean isParentExcluded,
1256              String propertyName,
1257              Type type,
1258              boolean propertyForeignKey,
1259              int additionalForeignKeyIndexPosition,
1260              Boolean isComponentPrefix,
1261              String parentPrefix) {
1262          FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1263          Boolean amIExcluded = isParentExcluded || !testPropertyInclusion(presentationAttribute);
1264          Boolean includeField = !testPropertyRecursion(prefix, parentClasses, propertyName, targetClass,
1265                  ceilingEntityFullyQualifiedClassname, isComponentPrefix, parentPrefix);
1266  
1267          SupportedFieldType explicitType = null;
1268          if (presentationAttribute != null &amp;&amp; presentationAttribute instanceof BasicFieldMetadata) {
1269              explicitType = ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType();
1270          }
1271          Class&lt;?&gt; returnedClass = type.getReturnedClass();
1272          checkProp:
1273          {
1274              if (type.isComponentType() &amp;&amp; includeField) {
1275                  buildComponentProperties(
1276                          targetClass,
1277                          foreignField,
1278                          additionalForeignFields,
1279                          additionalNonPersistentProperties,
1280                          mergedPropertyType,
1281                          fields,
1282                          idProperty,
1283                          populateManyToOneFields,
1284                          includeFields,
1285                          excludeFields,
1286                          configurationKey,
1287                          ceilingEntityFullyQualifiedClassname,
1288                          propertyName,
1289                          type,
1290                          returnedClass,
1291                          parentClasses,
1292                          amIExcluded,
1293                          prefix,
1294                          parentPrefix);
1295                  break checkProp;
1296              }
1297              /*
1298               * Currently we do not support ManyToOne fields whose class type is the same
1299               * as the target type, since this forms an infinite loop and will cause a stack overflow.
1300               */
1301              if (
1302                      type.isEntityType() &amp;&amp;
1303                              !returnedClass.isAssignableFrom(targetClass) &amp;&amp;
1304                              populateManyToOneFields &amp;&amp;
1305                              includeField
1306                      ) {
1307                  buildEntityProperties(
1308                          fields,
1309                          foreignField,
1310                          additionalForeignFields,
1311                          additionalNonPersistentProperties,
1312                          populateManyToOneFields,
1313                          includeFields,
1314                          excludeFields,
1315                          configurationKey,
1316                          ceilingEntityFullyQualifiedClassname,
1317                          propertyName,
1318                          returnedClass,
1319                          targetClass,
1320                          parentClasses,
1321                          prefix,
1322                          amIExcluded,
1323                          parentPrefix
1324                  );
1325                  break checkProp;
1326              }
1327          }
1328          //Don&#x27;t include this property if it failed manyToOne inclusion and is not a specified foreign key
1329          if (includeField || propertyForeignKey || additionalForeignKeyIndexPosition &gt;= 0) {
1330              defaultFieldMetadataProvider.addMetadataFromFieldType(
1331                      new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeignFields,
1332                              mergedPropertyType, componentProperties, idProperty, prefix, propertyName, type,
1333                              propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributes,
1334                              presentationAttribute, explicitType, returnedClass, this), fields);
1335          }
1336      }
1337  
1338      protected boolean testForeignProperty(ForeignKey foreignField, String prefix, String propertyName) {
1339          boolean isPropertyForeignKey = false;
1340          if (foreignField != null) {
1341              isPropertyForeignKey = foreignField.getManyToField().equals(prefix + propertyName);
1342          }
1343          return isPropertyForeignKey;
1344      }
1345  
<abbr title="1346      protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, String propertyName) {">1346      protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, String properðŸ”µ</abbr>
1347          int additionalForeignKeyIndexPosition = -1;
1348          if (additionalForeignFields != null) {
<abbr title="1349              additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKey(prefix + propertyName, null, null), new Comparator&lt;ForeignKey&gt;() {">1349              additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKey(prefixðŸ”µ</abbr>
1350                  @Override
1351                  public int compare(ForeignKey o1, ForeignKey o2) {
1352                      return o1.getManyToField().compareTo(o2.getManyToField());
1353                  }
1354              });
1355          }
1356          return additionalForeignKeyIndexPosition;
1357      }
1358  
1359      protected void buildEntityProperties(
1360              Map&lt;String, FieldMetadata&gt; fields,
1361              ForeignKey foreignField,
1362              ForeignKey[] additionalForeignFields,
1363              String[] additionalNonPersistentProperties,
1364              Boolean populateManyToOneFields,
1365              String[] includeFields,
1366              String[] excludeFields,
1367              String configurationKey,
1368              String ceilingEntityFullyQualifiedClassname,
1369              String propertyName,
1370              Class&lt;?&gt; returnedClass,
1371              Class&lt;?&gt; targetClass,
1372              List&lt;Class&lt;?&gt;&gt; parentClasses,
1373              String prefix,
1374              Boolean isParentExcluded,
1375              String parentPrefix) {
1376          Class&lt;?&gt;[] polymorphicEntities = getAllPolymorphicEntitiesFromCeiling(returnedClass);
1377          List&lt;Class&lt;?&gt;&gt; clonedParentClasses = new ArrayList&lt;&gt;();
1378  
1379          for (Class&lt;?&gt; parentClass : parentClasses) {
1380              clonedParentClasses.add(parentClass);
1381          }
1382  
1383          clonedParentClasses.add(targetClass);
1384  
1385          Map&lt;String, FieldMetadata&gt; newFields = getMergedPropertiesRecursively(
1386                  ceilingEntityFullyQualifiedClassname,
1387                  polymorphicEntities,
1388                  foreignField,
1389                  additionalNonPersistentProperties,
1390                  additionalForeignFields,
1391                  MergedPropertyType.PRIMARY,
1392                  populateManyToOneFields,
1393                  includeFields,
1394                  excludeFields,
1395                  configurationKey,
1396                  clonedParentClasses,
1397                  prefix + propertyName + &#x27;.&#x27;,
1398                  isParentExcluded,
1399                  parentPrefix);
1400  
1401          final String targetClassName = targetClass.getName();
1402  
1403          for (FieldMetadata newMetadata : newFields.values()) {
1404              newMetadata.setInheritedFromType(targetClassName);
1405              newMetadata.setAvailableToTypes(new String[]{targetClassName});
1406          }
1407  
1408          Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;(newFields.size());
1409  
1410          for (Map.Entry&lt;String, FieldMetadata&gt; newField : newFields.entrySet()) {
1411              final FieldMetadata fieldMetadata = newField.getValue();
1412              final String key = newField.getKey();
1413  
1414              convertedFields.put(propertyName + &#x27;.&#x27; + key, fieldMetadata);
1415  
1416              if (fieldMetadata instanceof BasicFieldMetadata) {
<abbr title="1417                  for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldMetadata) fieldMetadata).getValidationConfigurations().entrySet()) {">1417                  for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldMetadata)ðŸ”µ</abbr>
1418                      Class&lt;?&gt; validatorImpl = null;
1419  
1420                      try {
1421                          validatorImpl = Class.forName(validationConfigurations.getKey());
1422                      } catch (ClassNotFoundException e) {
1423                          Object bean = applicationContext.getBean(validationConfigurations.getKey());
1424  
1425                          if (bean != null) {
1426                              validatorImpl = bean.getClass();
1427                          }
1428                      }
1429  
<abbr title="1430                      if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validatorImpl)) {">1430                      if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validatorImpl))ðŸ”µ</abbr>
1431                          for (Map&lt;String, String&gt; configs : validationConfigurations.getValue()) {
1432                              for (Map.Entry&lt;String, String&gt; config : configs.entrySet()) {
1433                                  final String value = config.getValue();
1434  
1435                                  if (newFields.containsKey(value)) {
1436                                      config.setValue(propertyName + &quot;.&quot; + value);
1437                                  }
1438                              }
1439                          }
1440                      }
1441                  }
1442              }
1443  
1444              if (isForeignKey(fieldMetadata)) {
1445                  setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1446              }
1447          }
1448  
1449          fields.putAll(convertedFields);
1450      }
1451  
1452      protected boolean isForeignKey(FieldMetadata fieldMetadata) {
1453          return fieldMetadata instanceof BasicCollectionMetadata
<abbr title="1454                  &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().isEmpty()">1454                  &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectivðŸ”µ</abbr>
<abbr title="1455                  &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().containsKey(PersistencePerspectiveItemType.FOREIGNKEY);">1455                  &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveðŸ”µ</abbr>
1456      }
1457  
1458      /*
1459       * There may be multiple pathways to this foreign key which may have come from a cached source.
1460       * Since ForeignKey contains an originating field concept that is occurrence specific, we need
1461       * to make sure it is set appropriately here.
1462       *
1463       * A known use case is vendorPortal.embeddableMultitenantSite.adminUsers and
1464       * owningSite.embeddableMultitenantSite.adminUsers.
1465       */
<abbr title="1466      protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMetadata) {">1466      protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMetadata) ðŸ”µ</abbr>
<abbr title="1467          ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1467          ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective()ðŸ”µ</abbr>
1468          foreignKey.setOriginatingField(propertyName + &#x27;.&#x27; + key);
1469      }
1470  
1471      protected void buildComponentProperties(
1472              Class&lt;?&gt; targetClass,
1473              ForeignKey foreignField,
1474              ForeignKey[] additionalForeignFields,
1475              String[] additionalNonPersistentProperties,
1476              MergedPropertyType mergedPropertyType,
1477              Map&lt;String, FieldMetadata&gt; fields,
1478              String idProperty,
1479              Boolean populateManyToOneFields,
1480              String[] includeFields,
1481              String[] excludeFields,
1482              String configurationKey,
1483              String ceilingEntityFullyQualifiedClassname,
1484              String propertyName,
1485              Type type,
1486              Class&lt;?&gt; returnedClass,
1487              List&lt;Class&lt;?&gt;&gt; parentClasses,
1488              Boolean isParentExcluded,
1489              String prefix,
1490              String parentPrefix) {
1491          String[] componentProperties = ((ComponentType) type).getPropertyNames();
1492          List&lt;String&gt; componentPropertyNames = Arrays.asList(componentProperties);
1493          Type[] componentTypes = ((ComponentType) type).getSubtypes();
1494          List&lt;Type&gt; componentPropertyTypes = Arrays.asList(componentTypes);
1495          String tempPrefix = &quot;&quot;;
1496  
1497          int pos = prefix.indexOf(&quot;.&quot;);
1498          final int prefixLength = prefix.length();
1499  
1500          if (pos &gt; 0 &amp;&amp; pos &lt; prefixLength - 1) {
1501              //only use part of the prefix if it&#x27;s more than one layer deep
1502              tempPrefix = prefix.substring(pos + 1, prefixLength);
1503          }
1504  
<abbr title="1505          Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClass(targetClass, returnedClass, this, tempPrefix + propertyName + &quot;.&quot;);">1505          Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClass(targeðŸ”µ</abbr>
1506  
1507          if (isParentExcluded) {
1508              for (String key : componentPresentationAttributes.keySet()) {
1509                  LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excluded&quot;);
1510                  componentPresentationAttributes.get(key).setExcluded(true);
1511              }
1512          }
1513  
1514          PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1515          Property property;
1516  
1517          try {
1518              property = persistentClass.getProperty(propertyName);
1519          } catch (MappingException e) {
1520              property = persistentClass.getProperty(prefix + propertyName);
1521          }
1522  
<abbr title="1523          Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPropertyIterator();">1523          Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPropertyItðŸ”µ</abbr>
1524          List&lt;Property&gt; componentPropertyList = new ArrayList&lt;&gt;();
1525  
1526          while (componentPropertyIterator.hasNext()) {
1527              componentPropertyList.add((Property) componentPropertyIterator.next());
1528          }
1529  
1530          Map&lt;String, FieldMetadata&gt; newFields = new HashMap&lt;&gt;();
1531          buildProperties(
1532                  targetClass,
1533                  foreignField,
1534                  additionalForeignFields,
1535                  additionalNonPersistentProperties,
1536                  mergedPropertyType,
1537                  componentPresentationAttributes,
1538                  componentPropertyList,
1539                  newFields,
1540                  componentPropertyNames,
1541                  componentPropertyTypes,
1542                  idProperty,
1543                  populateManyToOneFields,
1544                  includeFields,
1545                  excludeFields,
1546                  configurationKey,
1547                  ceilingEntityFullyQualifiedClassname,
1548                  parentClasses,
1549                  propertyName + &quot;.&quot;,
1550                  isParentExcluded,
1551                  true,
1552                  parentPrefix + prefix
1553          );
1554  
1555          Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;();
1556  
1557          for (String key : newFields.keySet()) {
1558              final FieldMetadata fieldMetadata = newFields.get(key);
1559              convertedFields.put(propertyName + &quot;.&quot; + key, fieldMetadata);
1560  
1561              if (isForeignKey(fieldMetadata)) {
1562                  setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1563              }
1564          }
1565          fields.putAll(convertedFields);
1566      }
1567  
1568      @Override
1569      public EntityManager getStandardEntityManager() {
1570          return standardEntityManager;
1571      }
1572  
1573      @Override
1574      public void setStandardEntityManager(EntityManager entityManager) {
1575          this.standardEntityManager = entityManager;
1576          fieldManager = new FieldManager(entityConfiguration, entityManager);
1577      }
1578  
1579      @Override
1580      public FieldManager getFieldManager() {
1581          return this.getFieldManager(true);
1582      }
1583  
1584      @Override
1585      public FieldManager getFieldManager(boolean cleanFieldManager) {
1586          if (fieldManager == null) {
1587              //keep in mind that getStandardEntityManager() can return null, this is in general OK,
1588              // we re-init fieldManager in setStandardEntityManager method
1589              fieldManager = new FieldManager(entityConfiguration, getStandardEntityManager());
1590          } else if (cleanFieldManager){
1591              fieldManager.clearMiddleFields();
1592          }
1593          return fieldManager;
1594      }
1595  
1596      @Override
1597      public EntityConfiguration getEntityConfiguration() {
1598          return entityConfiguration;
1599      }
1600  
1601      @Override
1602      public void setEntityConfiguration(EntityConfiguration entityConfiguration) {
1603          this.entityConfiguration = entityConfiguration;
1604      }
1605  
1606      @Override
1607      public Metadata getMetadata() {
1608          return metadata;
1609      }
1610  
1611      @Override
1612      public void setMetadata(Metadata metadata) {
1613          this.metadata = metadata;
1614      }
1615  
1616      public List&lt;FieldMetadataProvider&gt; getFieldMetadataProviders() {
1617          return fieldMetadataProviders;
1618      }
1619  
1620      public void setFieldMetadataProviders(List&lt;FieldMetadataProvider&gt; fieldMetadataProviders) {
1621          this.fieldMetadataProviders = fieldMetadataProviders;
1622      }
1623  
1624      @Override
1625      public FieldMetadataProvider getDefaultFieldMetadataProvider() {
1626          return defaultFieldMetadataProvider;
1627      }
1628  
1629      public void setDefaultFieldMetadataProvider(FieldMetadataProvider defaultFieldMetadataProvider) {
1630          this.defaultFieldMetadataProvider = defaultFieldMetadataProvider;
1631      }
1632  
1633      protected boolean isExcludeClassFromPolymorphism(Class&lt;?&gt; clazz) {
1634          return dynamicDaoHelper.isExcludeClassFromPolymorphism(clazz);
1635      }
1636  
1637      @Override
1638      public DynamicDaoHelper getDynamicDaoHelper() {
1639          return dynamicDaoHelper;
1640      }
1641  
1642      public void setDynamicDaoHelper(DynamicDaoHelper dynamicDaoHelper) {
1643          this.dynamicDaoHelper = dynamicDaoHelper;
1644      }
1645  
1646  }</pre></td>
                            <td><pre>   1  /*
   2   * #%L
   3   * BroadleafCommerce Open Admin Platform
   4   * %%
   5   * Copyright (C) 2009 - 2016 Broadleaf Commerce
   6   * %%
   7   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10   * the Broadleaf End User License Agreement (EULA), Version 1.1
  11   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12   * shall apply.
  13   *
<abbr title="  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  15   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  16   * #L%
  17   */
  18  package org.broadleafcommerce.openadmin.server.dao;
  19  
  20  
  21  import org.apache.commons.collections4.map.LRUMap;
  22  import org.apache.commons.lang.StringUtils;
  23  import org.apache.commons.lang3.ArrayUtils;
  24  import org.apache.commons.logging.Log;
  25  import org.apache.commons.logging.LogFactory;
  26  import org.broadleafcommerce.common.money.Money;
  27  import org.broadleafcommerce.common.persistence.EntityConfiguration;
  28  import org.broadleafcommerce.common.persistence.Status;
  29  import org.broadleafcommerce.common.presentation.AdminPresentationClass;
  30  import org.broadleafcommerce.common.presentation.client.PersistencePerspectiveItemType;
  31  import org.broadleafcommerce.common.presentation.client.SupportedFieldType;
  32  import org.broadleafcommerce.common.presentation.client.VisibilityEnum;
  33  import org.broadleafcommerce.common.util.dao.DynamicDaoHelper;
  34  import org.broadleafcommerce.common.util.dao.DynamicDaoHelperImpl;
  35  import org.broadleafcommerce.common.util.dao.HibernateMappingProvider;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +import org.broadleafcommerce.common.web.BroadleafRequestContext;</span>
  37  import org.broadleafcommerce.openadmin.dto.BasicCollectionMetadata;
  38  import org.broadleafcommerce.openadmin.dto.BasicFieldMetadata;
  39  import org.broadleafcommerce.openadmin.dto.ClassMetadata;
  40  import org.broadleafcommerce.openadmin.dto.ClassTree;
  41  import org.broadleafcommerce.openadmin.dto.FieldMetadata;
  42  import org.broadleafcommerce.openadmin.dto.ForeignKey;
  43  import org.broadleafcommerce.openadmin.dto.MergedPropertyType;
  44  import org.broadleafcommerce.openadmin.dto.PersistencePerspective;
  45  import org.broadleafcommerce.openadmin.dto.TabMetadata;

  46  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.FieldMetadataProvider;
  47  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.AddMetadataFromFieldTypeRequest;
  48  import org.broadleafcommerce.openadmin.server.dao.provider.metadata.request.LateStageAddMetadataRequest;
  49  import org.broadleafcommerce.openadmin.server.service.persistence.module.FieldManager;
  50  import org.broadleafcommerce.openadmin.server.service.persistence.validation.FieldNamePropertyValidator;
  51  import org.broadleafcommerce.openadmin.server.service.type.MetadataProviderResponse;
  52  import org.hibernate.Criteria;
  53  import org.hibernate.MappingException;
  54  import org.hibernate.Session;
  55  import org.hibernate.mapping.PersistentClass;
  56  import org.hibernate.mapping.Property;
  57  import org.hibernate.type.ComponentType;
  58  import org.hibernate.type.Type;
  59  import org.springframework.beans.BeansException;
  60  import org.springframework.beans.factory.NoSuchBeanDefinitionException;
  61  import org.springframework.beans.factory.annotation.Value;
  62  import org.springframework.context.ApplicationContext;
  63  import org.springframework.context.ApplicationContextAware;
  64  import org.springframework.context.annotation.Scope;
  65  import org.springframework.core.annotation.AnnotationUtils;
  66  import org.springframework.stereotype.Component;
  67  
  68  import java.io.Serializable;
  69  import java.lang.reflect.Field;
  70  import java.lang.reflect.Method;
  71  import java.lang.reflect.Modifier;
  72  import java.math.BigDecimal;
  73  import java.math.BigInteger;
  74  import java.security.MessageDigest;
  75  import java.security.NoSuchAlgorithmException;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  76 +import java.text.DecimalFormat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  77 +import java.text.NumberFormat;</span>
  78  import java.util.ArrayList;
  79  import java.util.Arrays;
  80  import java.util.Collections;
  81  import java.util.Comparator;
  82  import java.util.Date;
  83  import java.util.HashMap;
  84  import java.util.HashSet;
  85  import java.util.Iterator;
  86  import java.util.List;
  87  import java.util.Map;
  88  import java.util.Set;
  89  
  90  import javax.annotation.Nonnull;
  91  import javax.annotation.Resource;
  92  import javax.persistence.EntityManager;
  93  import javax.persistence.criteria.CriteriaBuilder;
  94  import javax.persistence.criteria.CriteriaQuery;
  95  import javax.persistence.criteria.Path;
  96  import javax.persistence.criteria.Predicate;
  97  import javax.persistence.criteria.Root;
  98  
  99  /**
 100   * @author jfischer
 101   */
 102  @Component(&quot;blDynamicEntityDao&quot;)
 103  @Scope(&quot;prototype&quot;)
 104  public class DynamicEntityDaoImpl implements DynamicEntityDao, ApplicationContextAware {
 105  
 106      private static final Log LOG = LogFactory.getLog(DynamicEntityDaoImpl.class);
 107  
 108      protected static final Map&lt;String, Map&lt;String, FieldMetadata&gt;&gt; METADATA_CACHE = new LRUMap&lt;&gt;(1000);
 109  
 110      /**
<abbr title=" 111       * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we have cached in METADATA_CACHE over the lifetime"> 111       * Lifetime cache for the existence of DynamicEntityDaoImpl that just stores how many properties we have cacheðŸ”µ</abbr>
<abbr title=" 112       * of the application. This should survive evictions from METADATA_CACHE because it is for the purpose of diagnosing when we store different property"> 112       * of the application. This should survive evictions from METADATA_CACHE because it is for the purpose of diagðŸ”µ</abbr>
 113       * counts in METADATA_CACHE as a result of cache eviction
 114       */
 115      protected static final Map&lt;String, Integer&gt; METADATA_CACHE_SIZES = new HashMap&lt;&gt;();
 116  
 117      /*
<abbr title=" 118       * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are abstract or have been marked for exclusion"> 118       * This is the same as POLYMORPHIC_ENTITY_CACHE, except that it does not contain classes that are abstract or ðŸ”µ</abbr>
 119       * from polymorphism
 120       */
 121  
 122      protected EntityManager standardEntityManager;
 123  
 124      @Resource(name = &quot;blMetadata&quot;)
 125      protected Metadata metadata;
 126  
 127      @Resource(name = &quot;blEntityConfiguration&quot;)
 128      protected EntityConfiguration entityConfiguration;
 129  
 130      @Resource(name = &quot;blFieldMetadataProviders&quot;)
 131      protected List&lt;FieldMetadataProvider&gt; fieldMetadataProviders = new ArrayList&lt;&gt;();
 132  
 133      @Resource(name = &quot;blDefaultFieldMetadataProvider&quot;)
 134      protected FieldMetadataProvider defaultFieldMetadataProvider;



 135  
 136      @Resource(name = &quot;blAppConfigurationMap&quot;)
 137      protected Map&lt;String, String&gt; propertyConfigurations = new HashMap&lt;&gt;();
 138  
 139      protected DynamicDaoHelper dynamicDaoHelper = new DynamicDaoHelperImpl();
 140  
 141      @Value(&quot;${cache.entity.dao.metadata.ttl}&quot;)
 142      protected int cacheEntityMetaDataTtl;
 143  
 144      /**
 145       * Whether or not we should use {@link #METADATA_CACHE_SIZES} in the normal runtime of the application
 146       */
 147      @Value(&quot;${validate.metadata.cache.sizes:false}&quot;)
 148      protected boolean validateMetadataCacheSizes;
 149  
 150      protected long lastCacheFlushTime = System.currentTimeMillis();
 151  
 152      protected ApplicationContext applicationContext;
 153  
 154      protected FieldManager fieldManager;
 155  
 156      @Override
 157      public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
 158          this.applicationContext = applicationContext;
 159      }
 160  
 161      @Override
 162      public Criteria createCriteria(Class&lt;?&gt; entityClass) {
 163          return getStandardEntityManager().unwrap(Session.class).createCriteria(entityClass);
 164      }
 165  
 166      @Override
 167      public &lt;T&gt; T persist(T entity) {
 168          standardEntityManager.persist(entity);
 169          standardEntityManager.flush();
 170          return entity;
 171      }
 172  
 173      @Override
 174      public Object find(Class&lt;?&gt; entityClass, Object key) {
 175          return standardEntityManager.find(entityClass, key);
 176      }
 177  
 178      @Override
 179      public &lt;T&gt; T merge(T entity) {
 180          T response = standardEntityManager.merge(entity);
 181          standardEntityManager.flush();
 182          return response;
 183      }
 184  
 185      @Override
 186      public void flush() {
 187          standardEntityManager.flush();
 188      }
 189  
 190      @Override
 191      public void detach(Serializable entity) {
 192          standardEntityManager.detach(entity);
 193      }
 194  
 195      @Override
 196      public void refresh(Serializable entity) {
 197          standardEntityManager.refresh(entity);
 198      }
 199  
 200      @Override
 201      public Serializable retrieve(Class&lt;?&gt; entityClass, Object primaryKey) {
 202          return (Serializable) standardEntityManager.find(entityClass, primaryKey);
 203      }
 204  
 205      @Override
 206      public void remove(Serializable entity) {
 207          standardEntityManager.remove(entity);
 208          standardEntityManager.flush();
 209      }
 210  
 211      @Override
 212      public void clear() {
 213          standardEntityManager.clear();
 214      }
 215  
 216      @Override
 217      public PersistentClass getPersistentClass(String targetClassName) {
 218          return HibernateMappingProvider.getMapping(targetClassName);
 219      }
 220  
 221      @Override
 222      public boolean useCache() {
 223          if (cacheEntityMetaDataTtl &lt; 0) {
 224              return true;
 225          }
 226          if (cacheEntityMetaDataTtl == 0) {
 227              return false;
 228          } else {
 229              if ((System.currentTimeMillis() - lastCacheFlushTime) &gt; cacheEntityMetaDataTtl) {
 230                  lastCacheFlushTime = System.currentTimeMillis();
 231                  METADATA_CACHE.clear();
 232                  DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE.clear();
 233                  DynamicDaoHelperImpl.POLYMORPHIC_ENTITY_CACHE_WO_EXCLUSIONS.clear();
 234                  LOG.trace(&quot;Metadata cache evicted&quot;);
 235                  return true; // cache is empty
 236              } else {
 237                  return true;
 238              }
 239          }
 240      }
 241  
 242      @Override
 243      public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass) {
 244          return getAllPolymorphicEntitiesFromCeiling(ceilingClass, true);
 245      }
 246  
 247      @Override
<abbr title=" 248      public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymorphicEntities) {"> 248      public Class&lt;?&gt;[] getAllPolymorphicEntitiesFromCeiling(Class&lt;?&gt; ceilingClass, boolean includeUnqualifiedPolymoðŸ”µ</abbr>
<abbr title=" 249          return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolymorphicEntities, useCache());"> 249          return dynamicDaoHelper.getAllPolymorphicEntitiesFromCeiling(ceilingClass, includeUnqualifiedPolymorphicEnðŸ”µ</abbr>
 250      }
 251  
 252      @Override
 253      public Class&lt;?&gt;[] getUpDownInheritance(Class&lt;?&gt; testClass) {
 254          return dynamicDaoHelper.getUpDownInheritance(testClass, true, useCache());
 255      }
 256  
 257      @Override
 258      public Class&lt;?&gt; getImplClass(String className) {
 259          Class&lt;?&gt; clazz = null;
 260          try {
 261              clazz = entityConfiguration.lookupEntityClass(className);
 262          } catch (NoSuchBeanDefinitionException e) {
 263              //do nothing
 264          }
 265          if (clazz == null) {
 266              try {
 267                  clazz = Class.forName(className);
 268              } catch (ClassNotFoundException e) {
 269                  throw new RuntimeException(e);
 270              }
 271              clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 272          }
 273          return clazz;
 274      }
 275  
 276      @Override
 277      public Class&lt;?&gt; getCeilingImplClass(String className) {
 278          Class&lt;?&gt; clazz;
 279          try {
 280              clazz = Class.forName(className);
 281          } catch (ClassNotFoundException e) {
 282              throw new RuntimeException(e);
 283          }
 284          Class&lt;?&gt;[] entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 285          if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
 286              clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(clazz);
 287              entitiesFromCeiling = getAllPolymorphicEntitiesFromCeiling(clazz, true);
 288          }
 289          if (entitiesFromCeiling == null || entitiesFromCeiling.length &lt; 1) {
<abbr title=" 290              throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for the requested class name (%s)&quot;, className));"> 290              throw new IllegalArgumentException(String.format(&quot;Unable to find ceiling implementation for the requesðŸ”µ</abbr>
 291          }
 292          clazz = entitiesFromCeiling[entitiesFromCeiling.length - 1];
 293          return clazz;
 294      }
 295  
 296      @Override
<abbr title=" 297      public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, String value) {"> 297      public List&lt;Long&gt; readOtherEntitiesWithPropertyValue(Serializable instance, String propertyName, String value)ðŸ”µ</abbr>
 298          Class clazz = DynamicDaoHelperImpl.getNonProxyImplementationClassIfNecessary(instance.getClass());
 299          CriteriaBuilder builder = this.standardEntityManager.getCriteriaBuilder();
 300          CriteriaQuery&lt;Long&gt; criteria = builder.createQuery(Long.class);
 301          Root root = criteria.from(clazz);
 302          Path idField = root.get(this.getIdField(clazz).getName());
 303          criteria.select(idField.as(Long.class));
 304          List&lt;Predicate&gt; restrictions = new ArrayList();
 305  
 306          Path path = null;
 307  
 308          // Support property name such as &quot;defaultSku.name&quot;
 309          if (propertyName.contains(&quot;.&quot;)) {
 310              String[] split = propertyName.split(&quot;\\.&quot;);
 311              for (String splitResult : split) {
 312                  if (path == null) {
 313                      path = root.get(splitResult);
 314                  } else {
 315                      path = path.get(splitResult);
 316                  }
 317              }
 318          } else {
 319              path = root.get(propertyName);
 320          }
 321  
 322          restrictions.add(builder.equal(path, value));
 323          Serializable identifier = this.getIdentifier(instance);
 324          //when we creating the new item identifier is not exists
 325          if (identifier != null) {
 326              restrictions.add(builder.notEqual(idField, identifier));
 327          }
 328  
 329          if (instance instanceof Status) {
<abbr title=" 330              restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), builder.equal(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;), &#x27;N&#x27;)));"> 330              restrictions.add(builder.or(builder.isNull(root.get(&quot;archiveStatus&quot;).get(&quot;archived&quot;)), builder.equal(rðŸ”µ</abbr>
 331          }
 332  
 333          criteria.where(restrictions.toArray(new Predicate[restrictions.size()]));
 334          return this.standardEntityManager.createQuery(criteria).getResultList();
 335      }
 336  
 337      @Override
 338      public Serializable getIdentifier(Object entity) {
 339          return dynamicDaoHelper.getIdentifier(entity);
 340      }
 341  
 342      protected Field getIdField(Class&lt;?&gt; clazz) {
 343          return dynamicDaoHelper.getIdField(clazz);
 344      }
 345  
 346      public Class&lt;?&gt;[] sortEntities(Class&lt;?&gt; ceilingClass, List&lt;Class&lt;?&gt;&gt; entities) {
 347          return dynamicDaoHelper.sortEntities(ceilingClass, entities);
 348      }
 349  
 350      protected void addClassToTree(Class&lt;?&gt; clazz, ClassTree tree) {
 351          Class&lt;?&gt; testClass;
 352          try {
 353              testClass = Class.forName(tree.getFullyQualifiedClassname());
 354          } catch (ClassNotFoundException e) {
 355              throw new RuntimeException(e);
 356          }
 357          if (clazz.equals(testClass)) {
 358              return;
 359          }
 360          if (clazz.getSuperclass().equals(testClass)) {
 361              ClassTree myTree = new ClassTree(clazz.getName(), isExcludeClassFromPolymorphism(clazz));
 362              createClassTreeFromAnnotation(clazz, myTree);
 363              tree.setChildren(ArrayUtils.add(tree.getChildren(), myTree));
 364          } else {
 365              for (ClassTree child : tree.getChildren()) {
 366                  addClassToTree(clazz, child);
 367              }
 368          }
 369      }
 370  
 371      protected void createClassTreeFromAnnotation(Class&lt;?&gt; clazz, ClassTree myTree) {
<abbr title=" 372          AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 372          AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.clðŸ”µ</abbr>
 373          if (classPresentation != null) {
 374              String friendlyName = classPresentation.friendlyName();
 375              if (!StringUtils.isEmpty(friendlyName)) {
 376                  myTree.setFriendlyName(friendlyName);
 377              }
 378          }
 379      }
 380  
 381      @Override
 382      public ClassTree getClassTree(Class&lt;?&gt;[] polymorphicClasses) {
 383          String ceilingClass = null;
 384          for (Class&lt;?&gt; clazz : polymorphicClasses) {
<abbr title=" 385              AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClass.class);"> 385              AdminPresentationClass classPresentation = AnnotationUtils.findAnnotation(clazz, AdminPresentationClasðŸ”µ</abbr>
 386              if (classPresentation != null) {
 387                  String ceilingEntity = classPresentation.ceilingDisplayEntity();
 388                  if (!StringUtils.isEmpty(ceilingEntity)) {
 389                      ceilingClass = ceilingEntity;
 390                      break;
 391                  }
 392              }
 393          }
 394          if (ceilingClass != null) {
 395              int pos = -1;
 396              int j = 0;
 397              for (Class&lt;?&gt; clazz : polymorphicClasses) {
 398                  if (clazz.getName().equals(ceilingClass)) {
 399                      pos = j;
 400                      break;
 401                  }
 402                  j++;
 403              }
 404              if (pos &gt;= 0) {
 405                  Class&lt;?&gt;[] temp = new Class&lt;?&gt;[pos + 1];
 406                  System.arraycopy(polymorphicClasses, 0, temp, 0, j + 1);
 407                  polymorphicClasses = temp;
 408              }
 409          }
 410  
 411          ClassTree classTree = null;
 412          if (!ArrayUtils.isEmpty(polymorphicClasses)) {
 413              Class&lt;?&gt; topClass = polymorphicClasses[polymorphicClasses.length - 1];
 414              classTree = new ClassTree(topClass.getName(), isExcludeClassFromPolymorphism(topClass));
 415              createClassTreeFromAnnotation(topClass, classTree);
 416              for (int j = polymorphicClasses.length - 1; j &gt;= 0; j--) {
 417                  addClassToTree(polymorphicClasses[j], classTree);
 418              }
 419              classTree.finalizeStructure(1);
 420          }
 421          return classTree;
 422      }
 423  
 424      @Override
 425      public ClassTree getClassTreeFromCeiling(Class&lt;?&gt; ceilingClass) {
 426          Class&lt;?&gt;[] sortedEntities = getAllPolymorphicEntitiesFromCeiling(ceilingClass);
 427          return getClassTree(sortedEntities);
 428      }
 429  
 430      @Override
<abbr title=" 431      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persistencePerspective) {"> 431      public Map&lt;String, FieldMetadata&gt; getSimpleMergedProperties(String entityName, PersistencePerspective persisteðŸ”µ</abbr>
 432          Class&lt;?&gt;[] entityClasses;
 433          try {
 434              entityClasses = getAllPolymorphicEntitiesFromCeiling(Class.forName(entityName));
 435          } catch (ClassNotFoundException e) {
 436              throw new RuntimeException(e);
 437          }
 438          if (!ArrayUtils.isEmpty(entityClasses)) {
 439              return getMergedProperties(
 440                      entityName,
 441                      entityClasses,
<abbr title=" 442                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY),"> 442                      (ForeignKey) persistencePerspective.getPersistencePerspectiveItems().get(PersistencePerspectivðŸ”µ</abbr>
 443                      persistencePerspective.getAdditionalNonPersistentProperties(),
 444                      persistencePerspective.getAdditionalForeignKeys(),
 445                      MergedPropertyType.PRIMARY,
 446                      persistencePerspective.getPopulateToOneFields(),
 447                      persistencePerspective.getIncludeFields(),
 448                      persistencePerspective.getExcludeFields(),
 449                      persistencePerspective.getConfigurationKey(),
 450                      &quot;&quot;
 451              );
 452          } else {
 453              Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 454              Class&lt;?&gt; targetClass;
 455              try {
 456                  targetClass = Class.forName(entityName);
 457              } catch (ClassNotFoundException e) {
 458                  throw new RuntimeException(e);
 459              }
<abbr title=" 460              Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 460              Map&lt;String, FieldMetadata&gt; attributesMap = metadata.getFieldMetadataForTargetClass(null, targetClass, ðŸ”µ</abbr>
 461              for (String property : attributesMap.keySet()) {
 462                  FieldMetadata presentationAttribute = attributesMap.get(property);
 463                  if (!presentationAttribute.getExcluded()) {
 464                      Field field = FieldManager.getSingleField(targetClass, property);
 465                      if (!Modifier.isStatic(field.getModifiers())) {
 466                          boolean handled = false;
 467                          for (FieldMetadataProvider provider : fieldMetadataProviders) {
 468                              MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title=" 469                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 469                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]ðŸ”µ</abbr>
 470                                              MergedPropertyType.PRIMARY, null, null, &quot;&quot;,
 471                                              property, null, false, 0, attributesMap, presentationAttribute,
<abbr title=" 472                                              ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(), field.getType(), this),"> 472                                              ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(), fðŸ”µ</abbr>
 473                                      mergedProperties);
 474                              if (MetadataProviderResponse.NOT_HANDLED != response) {
 475                                  handled = true;
 476                              }
 477                              if (MetadataProviderResponse.HANDLED_BREAK == response) {
 478                                  break;
 479                              }
 480                          }
 481                          if (!handled) {
<abbr title=" 482                              //this provider is not included in the provider list on purpose - it is designed to handle basic"> 482                              //this provider is not included in the provider list on purpose - it is designed to haðŸ”µ</abbr>
 483                              //AdminPresentation fields, and those fields not admin presentation annotated at all
 484                              defaultFieldMetadataProvider.addMetadataFromFieldType(
<abbr title=" 485                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]{},"> 485                                      new AddMetadataFromFieldTypeRequest(field, targetClass, null, new ForeignKey[]ðŸ”µ</abbr>
 486                                              MergedPropertyType.PRIMARY, null, null, &quot;&quot;, property,
<abbr title=" 487                                              null, false, 0, attributesMap, presentationAttribute, ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType(),"> 487                                              null, false, 0, attributesMap, presentationAttribute, ((BasicFieldMetaðŸ”µ</abbr>
 488                                              field.getType(), this), mergedProperties);
 489                          }
 490                      }
 491                  }
 492              }
 493  
 494              return mergedProperties;
 495          }
 496      }
 497  
 498      @Override
 499      public Map&lt;String, FieldMetadata&gt; getMergedProperties(@Nonnull Class&lt;?&gt; cls) {
 500          Class&lt;?&gt;[] polymorphicTypes = getAllPolymorphicEntitiesFromCeiling(cls);
 501          return getMergedProperties(
 502                  cls.getName(),
 503                  polymorphicTypes,
 504                  null,
 505                  new String[]{},
 506                  new ForeignKey[]{},
 507                  MergedPropertyType.PRIMARY,
 508                  true,
 509                  new String[]{},
 510                  new String[]{},
 511                  null,
 512                  &quot;&quot;
 513          );
 514      }
 515  
 516      @Override
 517      public Map&lt;String, FieldMetadata&gt; getMergedProperties(
 518              String ceilingEntityFullyQualifiedClassname,
 519              Class&lt;?&gt;[] entities,
 520              ForeignKey foreignField,
 521              String[] additionalNonPersistentProperties,
 522              ForeignKey[] additionalForeignFields,
 523              MergedPropertyType mergedPropertyType,
 524              Boolean populateManyToOneFields,
 525              String[] includeFields,
 526              String[] excludeFields,
 527              String configurationKey,
 528              String prefix) {
 529          Map&lt;String, FieldMetadata&gt; mergedProperties = getMergedPropertiesRecursively(
 530                  ceilingEntityFullyQualifiedClassname,
 531                  entities,
 532                  foreignField,
 533                  additionalNonPersistentProperties,
 534                  additionalForeignFields,
 535                  mergedPropertyType,
 536                  populateManyToOneFields,
 537                  includeFields,
 538                  excludeFields,
 539                  configurationKey,
 540                  new ArrayList&lt;Class&lt;?&gt;&gt;(),
 541                  prefix,
 542                  false,
 543                  &quot;&quot;);
 544  
 545          final List&lt;String&gt; removeKeys = new ArrayList&lt;&gt;();
 546  
 547          for (final String key : mergedProperties.keySet()) {
 548              if (mergedProperties.get(key).getExcluded() != null &amp;&amp; mergedProperties.get(key).getExcluded()) {
 549                  removeKeys.add(key);
 550              }
 551          }
 552  
 553          for (String removeKey : removeKeys) {
 554              mergedProperties.remove(removeKey);
 555          }
 556  
<abbr title=" 557          // Allow field metadata providers to contribute additional fields here. These latestage handlers take place"> 557          // Allow field metadata providers to contribute additional fields here. These latestage handlers take placðŸ”µ</abbr>
<abbr title=" 558          // after any cached lookups occur, and are ideal for adding in dynamic properties that are not globally cacheable"> 558          // after any cached lookups occur, and are ideal for adding in dynamic properties that are not globally caðŸ”µ</abbr>
 559          // like properties gleaned from reflection typically are.
 560          Set&lt;String&gt; keys = new HashSet&lt;&gt;(mergedProperties.keySet());
 561          for (Class&lt;?&gt; targetClass : entities) {
 562              for (String key : keys) {
<abbr title=" 563                  LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass, this, &quot;&quot;);"> 563                  LateStageAddMetadataRequest amr = new LateStageAddMetadataRequest(key, null, targetClass, this, &quot;&quot;ðŸ”µ</abbr>
 564  
 565                  boolean foundOneOrMoreHandlers = false;
 566                  for (FieldMetadataProvider fieldMetadataProvider : fieldMetadataProviders) {
<abbr title=" 567                      MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);"> 567                      MetadataProviderResponse response = fieldMetadataProvider.lateStageAddMetadata(amr, mergedPropðŸ”µ</abbr>
 568                      if (MetadataProviderResponse.NOT_HANDLED != response) {
 569                          foundOneOrMoreHandlers = true;
 570                      }
 571                      if (MetadataProviderResponse.HANDLED_BREAK == response) {
 572                          break;
 573                      }
 574                  }
 575                  if (!foundOneOrMoreHandlers) {
 576                      defaultFieldMetadataProvider.lateStageAddMetadata(amr, mergedProperties);
 577                  }
 578              }
 579          }
 580  
 581          return mergedProperties;
 582      }
 583  
 584      protected Map&lt;String, FieldMetadata&gt; getMergedPropertiesRecursively(
 585              final String ceilingEntityFullyQualifiedClassname,
 586              final Class&lt;?&gt;[] entities,
 587              final ForeignKey foreignField,
 588              final String[] additionalNonPersistentProperties,
 589              final ForeignKey[] additionalForeignFields,
 590              final MergedPropertyType mergedPropertyType,
 591              final Boolean populateManyToOneFields,
 592              final String[] includeFields,
 593              final String[] excludeFields,
 594              final String configurationKey,
 595              final List&lt;Class&lt;?&gt;&gt; parentClasses,
 596              final String prefix,
 597              final Boolean isParentExcluded,
 598              final String parentPrefix) {
 599          PropertyBuilder propertyBuilder = new PropertyBuilder() {
 600              @Override
 601              public Map&lt;String, FieldMetadata&gt; execute(Boolean overridePopulateManyToOne) {
 602                  Map&lt;String, FieldMetadata&gt; mergedProperties = new HashMap&lt;&gt;();
 603                  Boolean classAnnotatedPopulateManyToOneFields;
 604                  if (overridePopulateManyToOne != null) {
 605                      classAnnotatedPopulateManyToOneFields = overridePopulateManyToOne;
 606                  } else {
 607                      classAnnotatedPopulateManyToOneFields = populateManyToOneFields;
 608                  }
 609  
 610                  buildPropertiesFromPolymorphicEntities(
 611                          entities,
 612                          foreignField,
 613                          additionalNonPersistentProperties,
 614                          additionalForeignFields,
 615                          mergedPropertyType,
 616                          classAnnotatedPopulateManyToOneFields,
 617                          includeFields,
 618                          excludeFields,
 619                          configurationKey,
 620                          ceilingEntityFullyQualifiedClassname,
 621                          mergedProperties,
 622                          parentClasses,
 623                          prefix,
 624                          isParentExcluded,
 625                          parentPrefix);
 626  
 627                  return mergedProperties;
 628              }
 629          };
 630  
<abbr title=" 631          Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilder, prefix, isParentExcluded, ceilingEntityFullyQualifiedClassname, configurationKey, this);"> 631          Map&lt;String, FieldMetadata&gt; mergedProperties = metadata.overrideMetadata(entities, propertyBuilder, prefix,ðŸ”µ</abbr>
 632          applyIncludesAndExcludes(includeFields, excludeFields, prefix, isParentExcluded, mergedProperties);
 633          applyForeignKeyPrecedence(foreignField, additionalForeignFields, mergedProperties);
 634  
 635          return mergedProperties;
 636      }
 637  
<abbr title=" 638      protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFields, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 638      protected void applyForeignKeyPrecedence(ForeignKey foreignField, ForeignKey[] additionalForeignFields, Map&lt;StðŸ”µ</abbr>
 639          for (String key : mergedProperties.keySet()) {
 640              boolean isForeign = false;
 641              if (foreignField != null) {
 642                  isForeign = foreignField.getManyToField().equals(key);
 643              }
 644              if (!isForeign &amp;&amp; !ArrayUtils.isEmpty(additionalForeignFields)) {
 645                  for (ForeignKey foreignKey : additionalForeignFields) {
 646                      isForeign = foreignKey.getManyToField().equals(key);
 647                      if (isForeign) {
 648                          break;
 649                      }
 650                  }
 651              }
 652              if (isForeign) {
 653                  FieldMetadata metadata = mergedProperties.get(key);
 654                  metadata.setExcluded(false);
 655              }
 656          }
 657      }
 658  
<abbr title=" 659      protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefix, Boolean isParentExcluded, Map&lt;String, FieldMetadata&gt; mergedProperties) {"> 659      protected void applyIncludesAndExcludes(String[] includeFields, String[] excludeFields, String prefix, BooleanðŸ”µ</abbr>
 660          //check includes
 661          if (!ArrayUtils.isEmpty(includeFields)) {
 662              for (String include : includeFields) {
 663                  for (String key : mergedProperties.keySet()) {
 664                      String testKey = prefix + key;
 665                      if (!(testKey.startsWith(include + &quot;.&quot;) || testKey.equals(include))) {
 666                          FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 667                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did not appear in the explicit includeFields list&quot;);"> 667                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field did not appeaðŸ”µ</abbr>
 668                          metadata.setExcluded(true);
 669                      } else {
 670                          FieldMetadata metadata = mergedProperties.get(key);
 671                          if (!isParentExcluded) {
<abbr title=" 672                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field appears in the explicit includeFields list&quot;);"> 672                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field appears in ðŸ”µ</abbr>
 673                              metadata.setExcluded(false);
 674                          }
 675                      }
 676                  }
 677              }
 678          } else if (!ArrayUtils.isEmpty(excludeFields)) {
 679              //check excludes
 680              for (String exclude : excludeFields) {
 681                  for (String key : mergedProperties.keySet()) {
 682                      String testKey = prefix + key;
 683                      if (testKey.startsWith(exclude + &quot;.&quot;) || testKey.equals(exclude)) {
 684                          FieldMetadata metadata = mergedProperties.get(key);
<abbr title=" 685                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appears in the explicit excludeFields list&quot;);"> 685                          LOG.debug(&quot;applyIncludesAndExcludes:Excluding &quot; + key + &quot; because this field appears in thðŸ”µ</abbr>
 686                          metadata.setExcluded(true);
 687                      } else {
 688                          FieldMetadata metadata = mergedProperties.get(key);
 689                          if (!isParentExcluded) {
<abbr title=" 690                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field did not appear in the explicit excludeFields list&quot;);"> 690                              LOG.debug(&quot;applyIncludesAndExcludes:Showing &quot; + key + &quot; because this field did not appðŸ”µ</abbr>
 691                              metadata.setExcluded(false);
 692                          }
 693                      }
 694                  }
 695              }
 696          }
 697      }
 698  
 699      protected String pad(String s, int length, char pad) {
 700          StringBuilder buffer = new StringBuilder(s);
 701          while (buffer.length() &lt; length) {
 702              buffer.insert(0, pad);
 703          }
 704          return buffer.toString();
 705      }
 706  
<abbr title=" 707      protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, String[] additionalNonPersistentProperties, ForeignKey[] additionalForeignFields, MergedPropertyType mergedPropertyType, Boolean populateManyToOneFields, Class&lt;?&gt; clazz, String configurationKey, Boolean isParentExcluded) {"> 707      protected String getCacheKey(String ceilingEntityFullyQualifiedClassname, ForeignKey foreignField, String[] adðŸ”µ</abbr>
 708          StringBuilder sb = new StringBuilder(150);
 709          sb.append(ceilingEntityFullyQualifiedClassname);
 710          sb.append(clazz.hashCode());
 711          sb.append(foreignField == null ? &quot;&quot; : foreignField.toString());
 712          sb.append(configurationKey);
 713          sb.append(isParentExcluded);
 714          if (additionalNonPersistentProperties != null) {
 715              for (String prop : additionalNonPersistentProperties) {
 716                  sb.append(prop);
 717              }
 718          }
 719          if (additionalForeignFields != null) {
 720              for (ForeignKey key : additionalForeignFields) {
 721                  sb.append(key.toString());
 722              }
 723          }
 724          sb.append(mergedPropertyType);
 725          sb.append(populateManyToOneFields);
 726  
 727          String digest;
 728          try {
 729              MessageDigest md = MessageDigest.getInstance(&quot;MD5&quot;);
 730              byte[] messageDigest = md.digest(sb.toString().getBytes());
 731              BigInteger number = new BigInteger(1, messageDigest);
 732              digest = number.toString(16);
 733          } catch (NoSuchAlgorithmException e) {
 734              throw new RuntimeException(e);
 735          }
 736  
 737          String key = pad(digest, 32, &#x27;0&#x27;);
 738  
 739          if (LOG.isDebugEnabled()) {
 740              LOG.debug(&quot;Created cache key: &quot; + key + &quot; from the following string: &quot; + sb.toString());
 741          }
 742          return key;
 743      }
 744  
 745      protected void buildPropertiesFromPolymorphicEntities(
 746              Class&lt;?&gt;[] entities,
 747              ForeignKey foreignField,
 748              String[] additionalNonPersistentProperties,
 749              ForeignKey[] additionalForeignFields,
 750              MergedPropertyType mergedPropertyType,
 751              Boolean populateManyToOneFields,
 752              String[] includeFields,
 753              String[] excludeFields,
 754              String configurationKey,
 755              String ceilingEntityFullyQualifiedClassname,
 756              Map&lt;String, FieldMetadata&gt; mergedProperties,
 757              List&lt;Class&lt;?&gt;&gt; parentClasses,
 758              String prefix,
 759              Boolean isParentExcluded,
 760              String parentPrefix) {
 761          for (Class&lt;?&gt; clazz : entities) {
<abbr title=" 762              String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNonPersistentProperties, additionalForeignFields, mergedPropertyType, populateManyToOneFields, clazz, configurationKey, isParentExcluded);"> 762              String cacheKey = getCacheKey(ceilingEntityFullyQualifiedClassname, foreignField, additionalNonPersistðŸ”µ</abbr>
 763  
 764              Map&lt;String, FieldMetadata&gt; cacheData = null;
 765              synchronized (DynamicDaoHelperImpl.LOCK_OBJECT) {
 766                  if (useCache()) {
 767                      cacheData = METADATA_CACHE.get(cacheKey);
 768                  }
 769  
 770                  if (cacheData == null) {
 771                      Map&lt;String, FieldMetadata&gt; props = getPropertiesForEntityClass(
 772                              clazz,
 773                              foreignField,
 774                              additionalNonPersistentProperties,
 775                              additionalForeignFields,
 776                              mergedPropertyType,
 777                              populateManyToOneFields,
 778                              includeFields,
 779                              excludeFields,
 780                              configurationKey,
 781                              ceilingEntityFullyQualifiedClassname,
 782                              parentClasses,
 783                              prefix,
 784                              isParentExcluded,
 785                              parentPrefix);
 786                      //first check all the properties currently in there to see if my entity inherits from them
 787                      for (Class&lt;?&gt; clazz2 : entities) {
 788                          if (!clazz2.getName().equals(clazz.getName())) {
 789                              for (Map.Entry&lt;String, FieldMetadata&gt; entry : props.entrySet()) {
 790                                  FieldMetadata metadata = entry.getValue();
 791                                  try {
 792                                      if (Class.forName(metadata.getInheritedFromType()).isAssignableFrom(clazz2)) {
<abbr title=" 793                                          String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(), new String[]{clazz2.getName()});"> 793                                          String[] both = ArrayUtils.addAll(metadata.getAvailableToTypes(), new StriðŸ”µ</abbr>
 794                                          metadata.setAvailableToTypes(both);
 795                                      }
 796                                  } catch (ClassNotFoundException e) {
 797                                      throw new RuntimeException(e);
 798                                  }
 799                              }
 800                          }
 801                      }
 802                      METADATA_CACHE.put(cacheKey, props);
 803  
 804                      if (LOG.isTraceEnabled()) {
<abbr title=" 805                          LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 805                          LOG.trace(&quot;Added &quot; + props.size() + &quot; to the metadata cache with key &quot; + cacheKey + &quot; for ðŸ”µ</abbr>
 806                      }
 807  
 808                      if (validateMetadataCacheSizes) {
 809                          Integer previousSize = METADATA_CACHE_SIZES.get(cacheKey);
 810                          Integer currentSize = props.size();
 811                          if (previousSize == null) {
 812                              METADATA_CACHE_SIZES.put(cacheKey, currentSize);
 813                          } else if (!currentSize.equals(previousSize)) {
<abbr title=" 814                              String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache for the key &quot; + cacheKey + &quot; but we had previously stored &quot; + previousSize + &quot; properties&quot;;"> 814                              String msg = &quot;Attempted to store &quot; + currentSize + &quot; properties in the cache for the kðŸ”µ</abbr>
 815                              LOG.error(msg);
 816                              throw new RuntimeException(msg);
 817                          }
 818                      }
 819  
 820                      cacheData = props;
 821                  } else {
 822                      if (LOG.isTraceEnabled()) {
<abbr title=" 823                          LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheKey + &quot; for the class &quot; + ceilingEntityFullyQualifiedClassname);"> 823                          LOG.trace(&quot;Read &quot; + cacheData.size() + &quot; from the metada cache with key &quot; + cacheKey + &quot; fðŸ”µ</abbr>







 824                      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 825 +                    for (FieldMetadata value : cacheData.values()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 826 +                        //that&#x27;s for the case when metadata cache is enabled(cache.entity.dao.metadata.ttl=-1) and you cache metadata for en locale"> 826 +                        //that&#x27;s for the case when metadata cache is enabled(cache.entity.dao.metadata.ttl=-1) andðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 827 +                        //then switch to FR that has comma as decimal separator</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 828 +                        if (value instanceof BasicFieldMetadata) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 829 +                            BasicFieldMetadata v = (BasicFieldMetadata) value;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 830 +                            if (SupportedFieldType.DECIMAL.equals(v.getSecondaryType()) || SupportedFieldType.INTEGER.equals(v.getSecondaryType())"> 830 +                            if (SupportedFieldType.DECIMAL.equals(v.getSecondaryType()) || SupportedFieldType.INTEðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 831 +                                    || SupportedFieldType.INTEGER.equals(v.getFieldType()) || SupportedFieldType.DECIMAL.equals(v.getFieldType())) {"> 831 +                                    || SupportedFieldType.INTEGER.equals(v.getFieldType()) || SupportedFieldType.DðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 832 +                                refreshDecimalDefaultValue(v);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 833 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 834 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 835 +                    }</span>
 836                  }
 837              }
 838              //clone the metadata before passing to the system
 839              Map&lt;String, FieldMetadata&gt; clonedCache = new HashMap&lt;&gt;(cacheData.size());
 840              for (Map.Entry&lt;String, FieldMetadata&gt; entry : cacheData.entrySet()) {
 841                  clonedCache.put(entry.getKey(), entry.getValue().cloneFieldMetadata());
 842              }
 843              mergedProperties.putAll(clonedCache);
 844          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 845 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 846 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 847 +    public void refreshDecimalDefaultValue(BasicFieldMetadata value) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 848 +        DecimalFormat instance = (DecimalFormat) NumberFormat.getInstance(BroadleafRequestContext.getBroadleafRequestContext().getJavaLocale());"> 848 +        DecimalFormat instance = (DecimalFormat) NumberFormat.getInstance(BroadleafRequestContext.getBroadleafRequðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 849 +        if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;.&quot;) &amp;&amp; instance.getDecimalFormatSymbols().getDecimalSeparator()!=&#x27;.&#x27;){"> 849 +        if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;.&quot;) &amp;&amp; instance.geðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 850 +            value.setDefaultValue(value.getDefaultValue().replace(&#x27;.&#x27;, instance.getDecimalFormatSymbols().getDecimalSeparator()));"> 850 +            value.setDefaultValue(value.getDefaultValue().replace(&#x27;.&#x27;, instance.getDecimalFormatSymbols().getDecimðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 851 +        }else if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;,&quot;) &amp;&amp; instance.getDecimalFormatSymbols().getDecimalSeparator()!=&#x27;,&#x27;){"> 851 +        }else if(StringUtils.isNotEmpty(value.getDefaultValue()) &amp;&amp; value.getDefaultValue().contains(&quot;,&quot;) &amp;&amp; instaðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 852 +            value.setDefaultValue(value.getDefaultValue().replace(&#x27;,&#x27;, instance.getDecimalFormatSymbols().getDecimalSeparator()));"> 852 +            value.setDefaultValue(value.getDefaultValue().replace(&#x27;,&#x27;, instance.getDecimalFormatSymbols().getDecimðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 853 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 854 +</span>
 855      }
 856  
 857      @Override
 858      public Field[] getAllFields(Class&lt;?&gt; targetClass) {
 859          Field[] allFields = new Field[]{};
 860          boolean eof = false;
 861          Class&lt;?&gt; currentClass = targetClass;
 862          while (!eof) {
 863              Field[] fields = currentClass.getDeclaredFields();
 864              allFields = ArrayUtils.addAll(allFields, fields);
 865              if (currentClass.getSuperclass() != null) {
 866                  currentClass = currentClass.getSuperclass();
 867              } else {
 868                  eof = true;
 869              }
 870          }
 871  
 872          return allFields;
 873      }
 874  
 875      @Override
 876      public Map&lt;String, FieldMetadata&gt; getPropertiesForPrimitiveClass(
 877              String propertyName,
 878              String friendlyPropertyName,
 879              Class&lt;?&gt; targetClass,
 880              Class&lt;?&gt; parentClass,
 881              MergedPropertyType mergedPropertyType
 882      ) {
 883          Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 884          BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
 885          presentationAttribute.setFriendlyName(friendlyPropertyName);
 886          if (String.class.isAssignableFrom(targetClass)) {
 887              presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
 888              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 889              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.STRING, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 889              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.STRING, ðŸ”µ</abbr>
 890          } else if (Boolean.class.isAssignableFrom(targetClass)) {
 891              presentationAttribute.setExplicitFieldType(SupportedFieldType.BOOLEAN);
 892              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 893              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.BOOLEAN, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 893              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.BOOLEAN,ðŸ”µ</abbr>
 894          } else if (Date.class.isAssignableFrom(targetClass)) {
 895              presentationAttribute.setExplicitFieldType(SupportedFieldType.DATE);
 896              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 897              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DATE, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 897              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DATE, nuðŸ”µ</abbr>
 898          } else if (Money.class.isAssignableFrom(targetClass)) {
 899              presentationAttribute.setExplicitFieldType(SupportedFieldType.MONEY);
 900              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 901              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.MONEY, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 901              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.MONEY, nðŸ”µ</abbr>
 902          } else if (
 903                  Byte.class.isAssignableFrom(targetClass) ||
 904                          Integer.class.isAssignableFrom(targetClass) ||
 905                          Long.class.isAssignableFrom(targetClass) ||
 906                          Short.class.isAssignableFrom(targetClass)
 907                  ) {
 908              presentationAttribute.setExplicitFieldType(SupportedFieldType.INTEGER);
 909              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 910              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.INTEGER, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 910              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.INTEGER,ðŸ”µ</abbr>
 911          } else if (
 912                  Double.class.isAssignableFrom(targetClass) ||
 913                          BigDecimal.class.isAssignableFrom(targetClass)
 914                  ) {
 915              presentationAttribute.setExplicitFieldType(SupportedFieldType.DECIMAL);
 916              presentationAttribute.setVisibility(VisibilityEnum.VISIBLE_ALL);
<abbr title=" 917              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DECIMAL, null, parentClass, presentationAttribute, mergedPropertyType, this));"> 917              fields.put(propertyName, metadata.getFieldMetadata(&quot;&quot;, propertyName, null, SupportedFieldType.DECIMAL,ðŸ”µ</abbr>
 918          }
 919          ((BasicFieldMetadata) fields.get(propertyName)).setLength(255);
 920          ((BasicFieldMetadata) fields.get(propertyName)).setForeignKeyCollection(false);
 921          ((BasicFieldMetadata) fields.get(propertyName)).setRequired(true);
 922          ((BasicFieldMetadata) fields.get(propertyName)).setUnique(true);
 923          ((BasicFieldMetadata) fields.get(propertyName)).setScale(100);
 924          ((BasicFieldMetadata) fields.get(propertyName)).setPrecision(100);
 925  
 926          return fields;
 927      }
 928  
 929      @Override
 930      public Map&lt;String, Object&gt; getIdMetadata(Class&lt;?&gt; entityClass) {
 931          return dynamicDaoHelper.getIdMetadata(entityClass, standardEntityManager);
 932      }
 933  
 934      @Override
 935      public List&lt;String&gt; getPropertyNames(Class&lt;?&gt; entityClass) {
 936          return dynamicDaoHelper.getPropertyNames(entityClass);
 937      }
 938  
 939      @Override
 940      public List&lt;Type&gt; getPropertyTypes(Class&lt;?&gt; entityClass) {
 941          return dynamicDaoHelper.getPropertyTypes(entityClass);
 942      }
 943  
 944      @Override
 945      public Map&lt;String, TabMetadata&gt; getTabAndGroupMetadata(Class&lt;?&gt;[] entities, ClassMetadata cmd) {
 946          Class&lt;?&gt;[] superClassEntities = getSuperClassHierarchy(entities[entities.length - 1]);
 947  
 948          Map&lt;String, TabMetadata&gt; mergedTabAndGroupMetadata = metadata.getBaseTabAndGroupMetadata(entities);
 949          metadata.applyTabAndGroupMetadataOverrides(superClassEntities, mergedTabAndGroupMetadata);
 950          metadata.buildAdditionalTabAndGroupMetadataFromCmdProperties(cmd, mergedTabAndGroupMetadata);
 951  
 952          return mergedTabAndGroupMetadata;
 953      }
 954  
 955      public Class&lt;?&gt;[] getSuperClassHierarchy(Class&lt;?&gt; ceilingEntity) {
 956          Class&lt;?&gt;[] entities = new Class&lt;?&gt;[]{};
 957  
 958          if (ceilingEntity != null) {
 959              entities = ArrayUtils.add(entities, ceilingEntity);
 960              while (!ceilingEntity.getSuperclass().equals(Object.class)) {
 961                  entities = ArrayUtils.add(entities, ceilingEntity.getSuperclass());
 962                  ceilingEntity = ceilingEntity.getSuperclass();
 963              }
 964          }
 965          return entities;
 966      }
 967  
 968      protected Map&lt;String, FieldMetadata&gt; getPropertiesForEntityClass(
 969              Class&lt;?&gt; targetClass,
 970              ForeignKey foreignField,
 971              String[] additionalNonPersistentProperties,
 972              ForeignKey[] additionalForeignFields,
 973              MergedPropertyType mergedPropertyType,
 974              Boolean populateManyToOneFields,
 975              String[] includeFields,
 976              String[] excludeFields,
 977              String configurationKey,
 978              String ceilingEntityFullyQualifiedClassname,
 979              List&lt;Class&lt;?&gt;&gt; parentClasses,
 980              String prefix,
 981              Boolean isParentExcluded,
 982              String parentPrefix) {
<abbr title=" 983          Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null, targetClass, this, &quot;&quot;);"> 983          Map&lt;String, FieldMetadata&gt; presentationAttributes = metadata.getFieldMetadataForTargetClass(null, targetClðŸ”µ</abbr>
 984          if (isParentExcluded) {
 985              for (String key : presentationAttributes.keySet()) {
 986                  LOG.debug(&quot;getPropertiesForEntityClass:Excluding &quot; + key + &quot; because parent is excluded.&quot;);
 987                  presentationAttributes.get(key).setExcluded(true);
 988              }
 989          }
 990  
 991          Map idMetadata = getIdMetadata(targetClass);
 992          Map&lt;String, FieldMetadata&gt; fields = new HashMap&lt;&gt;();
 993          String idProperty = (String) idMetadata.get(&quot;name&quot;);
 994          List&lt;String&gt; propertyNames = getPropertyNames(targetClass);
 995          propertyNames.add(idProperty);
 996          Type idType = (Type) idMetadata.get(&quot;type&quot;);
 997          List&lt;Type&gt; propertyTypes = getPropertyTypes(targetClass);
 998          propertyTypes.add(idType);
 999  
1000          PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1001          Iterator testIter = persistentClass.getPropertyIterator();
1002          List&lt;Property&gt; propertyList = new ArrayList&lt;&gt;();
1003  
1004          //check the properties for problems
1005          while (testIter.hasNext()) {
1006              Property property = (Property) testIter.next();
1007              if (property.getName().contains(&quot;.&quot;)) {
<abbr title="1008                  throw new IllegalArgumentException(&quot;Properties from entities that utilize a period character (&#x27;.&#x27;) in their name are incompatible with this system. The property name in question is: (&quot; + property.getName() + &quot;) from the class: (&quot; + targetClass.getName() + &quot;)&quot;);">1008                  throw new IllegalArgumentException(&quot;Properties from entities that utilize a period character (&#x27;.&#x27;)ðŸ”µ</abbr>
1009              }
1010              propertyList.add(property);
1011          }
1012  
1013          buildProperties(
1014                  targetClass,
1015                  foreignField,
1016                  additionalForeignFields,
1017                  additionalNonPersistentProperties,
1018                  mergedPropertyType,
1019                  presentationAttributes,
1020                  propertyList,
1021                  fields,
1022                  propertyNames,
1023                  propertyTypes,
1024                  idProperty,
1025                  populateManyToOneFields,
1026                  includeFields,
1027                  excludeFields,
1028                  configurationKey,
1029                  ceilingEntityFullyQualifiedClassname,
1030                  parentClasses,
1031                  prefix,
1032                  isParentExcluded,
1033                  false,
1034                  parentPrefix
1035          );
1036          BasicFieldMetadata presentationAttribute = new BasicFieldMetadata();
1037          presentationAttribute.setExplicitFieldType(SupportedFieldType.STRING);
1038          presentationAttribute.setVisibility(VisibilityEnum.HIDDEN_ALL);
1039          if (!ArrayUtils.isEmpty(additionalNonPersistentProperties)) {
1040              Class&lt;?&gt;[] entities = getAllPolymorphicEntitiesFromCeiling(targetClass);
1041              for (String additionalNonPersistentProperty : additionalNonPersistentProperties) {
<abbr title="1042                  if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersistentProperty.startsWith(prefix))) {">1042                  if (StringUtils.isEmpty(prefix) || (!StringUtils.isEmpty(prefix) &amp;&amp; additionalNonPersistentPropertðŸ”µ</abbr>
1043                      String myAdditionalNonPersistentProperty = additionalNonPersistentProperty;
1044                      //get final property if this is a dot delimited property
1045                      int finalDotPos = additionalNonPersistentProperty.lastIndexOf(&#x27;.&#x27;);
1046                      if (finalDotPos &gt;= 0) {
<abbr title="1047                          myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(finalDotPos + 1, myAdditionalNonPersistentProperty.length());">1047                          myAdditionalNonPersistentProperty = myAdditionalNonPersistentProperty.substring(finalDotPoðŸ”µ</abbr>
1048                      }
1049                      //check all the polymorphic types on this target class to see if the end property exists
1050                      Field testField = null;
1051                      Method testMethod = null;
1052                      for (Class&lt;?&gt; clazz : entities) {
1053                          try {
1054                              testMethod = clazz.getMethod(myAdditionalNonPersistentProperty);
1055                              if (testMethod != null) {
1056                                  break;
1057                              }
1058                          } catch (NoSuchMethodException e) {
1059                              //do nothing - method does not exist
1060                          }
1061                          testField = getFieldManager().getField(clazz, myAdditionalNonPersistentProperty);
1062                          if (testField != null) {
1063                              break;
1064                          }
1065                      }
1066                      //if the property exists, add it to the metadata for this class
1067                      if (testField != null || testMethod != null) {
<abbr title="1068                          fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, additionalNonPersistentProperty, propertyList, SupportedFieldType.STRING, null, targetClass, presentationAttribute, mergedPropertyType, this));">1068                          fields.put(additionalNonPersistentProperty, metadata.getFieldMetadata(prefix, additionalNoðŸ”µ</abbr>
1069                      }
1070                  }
1071              }
1072          }
1073  
1074          return fields;
1075      }
1076  
1077      protected void buildProperties(
1078              Class&lt;?&gt; targetClass,
1079              ForeignKey foreignField,
1080              ForeignKey[] additionalForeignFields,
1081              String[] additionalNonPersistentProperties,
1082              MergedPropertyType mergedPropertyType,
1083              Map&lt;String, FieldMetadata&gt; presentationAttributes,
1084              List&lt;Property&gt; componentProperties,
1085              Map&lt;String, FieldMetadata&gt; fields,
1086              List&lt;String&gt; propertyNames,
1087              List&lt;Type&gt; propertyTypes,
1088              String idProperty,
1089              Boolean populateManyToOneFields,
1090              String[] includeFields,
1091              String[] excludeFields,
1092              String configurationKey,
1093              String ceilingEntityFullyQualifiedClassname,
1094              List&lt;Class&lt;?&gt;&gt; parentClasses,
1095              String prefix,
1096              Boolean isParentExcluded,
1097              Boolean isComponentPrefix,
1098              String parentPrefix) {
1099          int j = 0;
1100          Comparator&lt;String&gt; propertyComparator = new Comparator&lt;String&gt;() {
1101              @Override
1102              public int compare(String o1, String o2) {
1103                  //check for property name equality and for map field properties
<abbr title="1104                  if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FieldManager.MAPFIELDSEPARATOR)) {">1104                  if (o1.equals(o2) || o1.startsWith(o2 + FieldManager.MAPFIELDSEPARATOR) || o2.startsWith(o1 + FielðŸ”µ</abbr>
1105                      return 0;
1106                  }
1107                  return o1.compareTo(o2);
1108              }
1109          };
1110          List&lt;String&gt; presentationKeyList = new ArrayList&lt;&gt;(presentationAttributes.keySet());
1111          Collections.sort(presentationKeyList);
1112  
1113          for (String propertyName : propertyNames) {
1114              final Type type = propertyTypes.get(j);
1115              boolean isPropertyForeignKey = testForeignProperty(foreignField, prefix, propertyName);
<abbr title="1116              int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFields, prefix, propertyName);">1116              int additionalForeignKeyIndexPosition = findAdditionalForeignKeyIndex(additionalForeignFields, prefix,ðŸ”µ</abbr>
1117              j++;
1118              Field myField = getFieldManager().getField(targetClass, propertyName);
1119              if (myField == null) {
<abbr title="1120                  //try to get the field with the prefix - needed for advanced collections that appear in @Embedded classes">1120                  //try to get the field with the prefix - needed for advanced collections that appear in @Embedded ðŸ”µ</abbr>
1121                  myField = getFieldManager().getField(targetClass, prefix + propertyName);
1122              }
1123              if (
1124                      !type.isAnyType() &amp;&amp; !type.isCollectionType() ||
1125                              isPropertyForeignKey ||
1126                              additionalForeignKeyIndexPosition &gt;= 0 ||
1127                              Collections.binarySearch(presentationKeyList, propertyName, propertyComparator) &gt;= 0
1128                      ) {
1129                  if (myField != null) {
1130                      boolean handled = false;
1131                      for (FieldMetadataProvider provider : fieldMetadataProviders) {
1132                          FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1133                          if (presentationAttribute != null) {
1134                              setExcludedBasedOnShowIfProperty(presentationAttribute);
1135                          }
1136                          MetadataProviderResponse response = provider.addMetadataFromFieldType(
<abbr title="1137                                  new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, additionalForeignFields,">1137                                  new AddMetadataFromFieldTypeRequest(myField, targetClass, foreignField, additionalðŸ”µ</abbr>
1138                                          mergedPropertyType, componentProperties, idProperty, prefix,
<abbr title="1139                                          propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition,">1139                                          propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPositioðŸ”µ</abbr>
<abbr title="1140                                          presentationAttributes, presentationAttribute, null, type.getReturnedClass(), this), fields);">1140                                          presentationAttributes, presentationAttribute, null, type.getReturnedClassðŸ”µ</abbr>
1141                          if (MetadataProviderResponse.NOT_HANDLED != response) {
1142                              handled = true;
1143                          }
1144                          if (MetadataProviderResponse.HANDLED_BREAK == response) {
1145                              break;
1146                          }
1147                      }
1148                      if (!handled) {
1149                          buildBasicProperty(myField, targetClass, foreignField, additionalForeignFields,
1150                                  additionalNonPersistentProperties, mergedPropertyType, presentationAttributes,
1151                                  componentProperties, fields, idProperty, populateManyToOneFields, includeFields,
<abbr title="1152                                  excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClasses,">1152                                  excludeFields, configurationKey, ceilingEntityFullyQualifiedClassname, parentClassðŸ”µ</abbr>
<abbr title="1153                                  prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeignKeyIndexPosition, isComponentPrefix, parentPrefix);">1153                                  prefix, isParentExcluded, propertyName, type, isPropertyForeignKey, additionalForeðŸ”µ</abbr>
1154                      }
1155                  }
1156              }
1157          }
1158      }
1159  
1160      public Boolean testPropertyInclusion(FieldMetadata presentationAttribute) {
1161          setExcludedBasedOnShowIfProperty(presentationAttribute);
1162  
<abbr title="1163          return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presentationAttribute.getExcluded()) || (presentationAttribute.getChildrenExcluded() != null &amp;&amp; presentationAttribute.getChildrenExcluded())));">1163          return !(presentationAttribute != null &amp;&amp; ((presentationAttribute.getExcluded() != null &amp;&amp; presentationAttðŸ”µ</abbr>
1164  
1165      }
1166  
1167      protected void setExcludedBasedOnShowIfProperty(FieldMetadata fieldMetadata) {
1168          if (fieldMetadata != null
1169                  &amp;&amp; StringUtils.isNotEmpty(fieldMetadata.getShowIfProperty())
1170                  &amp;&amp; propertyConfigurations.get(fieldMetadata.getShowIfProperty()) != null
1171                  &amp;&amp; !Boolean.valueOf(propertyConfigurations.get(fieldMetadata.getShowIfProperty()))) {
1172  
1173              //do not include this in the display if it returns false.
1174              fieldMetadata.setExcluded(true);
1175          }
1176      }
1177  
<abbr title="1178      protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyName, Class&lt;?&gt; targetClass,">1178      protected Boolean testPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String propertyName, ClasðŸ”µ</abbr>
<abbr title="1179                                              String ceilingEntityFullyQualifiedClassname, Boolean isComponentPrefix, String parentPrefix) {">1179                                              String ceilingEntityFullyQualifiedClassname, Boolean isComponentPrefixðŸ”µ</abbr>
1180  
<abbr title="1181          Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyName, targetClass,">1181          Boolean standardRecursionDetected = testStandardPropertyRecursion(prefix, parentClasses, propertyName, tarðŸ”µ</abbr>
1182                  ceilingEntityFullyQualifiedClassname, isComponentPrefix);
1183  
<abbr title="1184          Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isComponentPrefix,">1184          Boolean multiLevelEmbeddableRecursionDetected = testMultiLevelEmbeddableRecursion(prefix, isComponentPrefiðŸ”µ</abbr>
1185                  parentPrefix, propertyName);
1186  
1187          return standardRecursionDetected || multiLevelEmbeddableRecursionDetected;
1188      }
1189  
<abbr title="1190      protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String parentPrefix, String propertyName) {">1190      protected Boolean testMultiLevelEmbeddableRecursion(String prefix, Boolean isComponentPrefix, String parentPreðŸ”µ</abbr>
1191          return isComponentPrefix &amp;&amp; parentPrefix.contains(&quot;.&quot; + prefix + propertyName);
1192      }
1193  
1194      protected Boolean testStandardPropertyRecursion(String prefix, List&lt;Class&lt;?&gt;&gt; parentClasses, String
1195              propertyName, Class&lt;?&gt; targetClass, String ceilingEntityFullyQualifiedClassname, Boolean
1196                                                              isComponentPrefix) {
1197          Boolean response = false;
1198          //don&#x27;t want to shun a self-referencing property in an @Embeddable
<abbr title="1199          boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).length &gt; 1);">1199          boolean shouldTest = !StringUtils.isEmpty(prefix) &amp;&amp; (!isComponentPrefix || prefix.split(&quot;\\.&quot;).length &gt; 1ðŸ”µ</abbr>
1200          if (shouldTest) {
1201              Field testField = getFieldManager().getField(targetClass, propertyName);
1202              if (testField == null) {
1203                  Class&lt;?&gt;[] entities;
1204                  try {
<abbr title="1205                      entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassname));">1205                      entities = getAllPolymorphicEntitiesFromCeiling(Class.forName(ceilingEntityFullyQualifiedClassðŸ”µ</abbr>
1206                  } catch (ClassNotFoundException e) {
1207                      throw new RuntimeException(e);
1208                  }
1209                  for (Class&lt;?&gt; clazz : entities) {
1210                      testField = getFieldManager().getField(clazz, propertyName);
1211                      if (testField != null) {
1212                          break;
1213                      }
1214                  }
1215                  String testProperty = prefix + propertyName;
1216                  if (testField == null) {
1217                      testField = getFieldManager().getField(targetClass, testProperty);
1218                  }
1219                  if (testField == null) {
1220                      for (Class&lt;?&gt; clazz : entities) {
1221                          testField = getFieldManager().getField(clazz, testProperty);
1222                          if (testField != null) {
1223                              break;
1224                          }
1225                      }
1226                  }
1227              }
1228              response = determineExclusionForField(parentClasses, targetClass, testField);
1229          }
1230          return response;
1231      }
1232  
<abbr title="1233      protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, Field testField) {">1233      protected Boolean determineExclusionForField(List&lt;Class&lt;?&gt;&gt; parentClasses, Class&lt;?&gt; targetClass, Field testFieðŸ”µ</abbr>
1234          Boolean response = false;
1235          if (testField != null) {
1236              Class&lt;?&gt; testType = testField.getType();
1237              for (Class&lt;?&gt; parentClass : parentClasses) {
1238                  if (parentClass.isAssignableFrom(testType) || testType.isAssignableFrom(parentClass)) {
1239                      response = true;
1240                      break;
1241                  }
1242              }
1243              if (!response &amp;&amp; (targetClass.isAssignableFrom(testType) || testType.isAssignableFrom(targetClass))) {
1244                  response = true;
1245              }
1246          }
1247          return response;
1248      }
1249  
1250      protected void buildBasicProperty(
1251              Field field,
1252              Class&lt;?&gt; targetClass,
1253              ForeignKey foreignField,
1254              ForeignKey[] additionalForeignFields,
1255              String[] additionalNonPersistentProperties,
1256              MergedPropertyType mergedPropertyType,
1257              Map&lt;String, FieldMetadata&gt; presentationAttributes,
1258              List&lt;Property&gt; componentProperties,
1259              Map&lt;String, FieldMetadata&gt; fields,
1260              String idProperty,
1261              Boolean populateManyToOneFields,
1262              String[] includeFields,
1263              String[] excludeFields,
1264              String configurationKey,
1265              String ceilingEntityFullyQualifiedClassname,
1266              List&lt;Class&lt;?&gt;&gt; parentClasses,
1267              String prefix,
1268              Boolean isParentExcluded,
1269              String propertyName,
1270              Type type,
1271              boolean propertyForeignKey,
1272              int additionalForeignKeyIndexPosition,
1273              Boolean isComponentPrefix,
1274              String parentPrefix) {
1275          FieldMetadata presentationAttribute = presentationAttributes.get(propertyName);
1276          Boolean amIExcluded = isParentExcluded || !testPropertyInclusion(presentationAttribute);
1277          Boolean includeField = !testPropertyRecursion(prefix, parentClasses, propertyName, targetClass,
1278                  ceilingEntityFullyQualifiedClassname, isComponentPrefix, parentPrefix);
1279  
1280          SupportedFieldType explicitType = null;
1281          if (presentationAttribute != null &amp;&amp; presentationAttribute instanceof BasicFieldMetadata) {
1282              explicitType = ((BasicFieldMetadata) presentationAttribute).getExplicitFieldType();
1283          }
1284          Class&lt;?&gt; returnedClass = type.getReturnedClass();
1285          checkProp:
1286          {
1287              if (type.isComponentType() &amp;&amp; includeField) {
1288                  buildComponentProperties(
1289                          targetClass,
1290                          foreignField,
1291                          additionalForeignFields,
1292                          additionalNonPersistentProperties,
1293                          mergedPropertyType,
1294                          fields,
1295                          idProperty,
1296                          populateManyToOneFields,
1297                          includeFields,
1298                          excludeFields,
1299                          configurationKey,
1300                          ceilingEntityFullyQualifiedClassname,
1301                          propertyName,
1302                          type,
1303                          returnedClass,
1304                          parentClasses,
1305                          amIExcluded,
1306                          prefix,
1307                          parentPrefix);
1308                  break checkProp;
1309              }
1310              /*
1311               * Currently we do not support ManyToOne fields whose class type is the same
1312               * as the target type, since this forms an infinite loop and will cause a stack overflow.
1313               */
1314              if (
1315                      type.isEntityType() &amp;&amp;
1316                              !returnedClass.isAssignableFrom(targetClass) &amp;&amp;
1317                              populateManyToOneFields &amp;&amp;
1318                              includeField
1319                      ) {
1320                  buildEntityProperties(
1321                          fields,
1322                          foreignField,
1323                          additionalForeignFields,
1324                          additionalNonPersistentProperties,
1325                          populateManyToOneFields,
1326                          includeFields,
1327                          excludeFields,
1328                          configurationKey,
1329                          ceilingEntityFullyQualifiedClassname,
1330                          propertyName,
1331                          returnedClass,
1332                          targetClass,
1333                          parentClasses,
1334                          prefix,
1335                          amIExcluded,
1336                          parentPrefix
1337                  );
1338                  break checkProp;
1339              }
1340          }
1341          //Don&#x27;t include this property if it failed manyToOne inclusion and is not a specified foreign key
1342          if (includeField || propertyForeignKey || additionalForeignKeyIndexPosition &gt;= 0) {
1343              defaultFieldMetadataProvider.addMetadataFromFieldType(
1344                      new AddMetadataFromFieldTypeRequest(field, targetClass, foreignField, additionalForeignFields,
1345                              mergedPropertyType, componentProperties, idProperty, prefix, propertyName, type,
1346                              propertyForeignKey, additionalForeignKeyIndexPosition, presentationAttributes,
1347                              presentationAttribute, explicitType, returnedClass, this), fields);
1348          }
1349      }
1350  
1351      protected boolean testForeignProperty(ForeignKey foreignField, String prefix, String propertyName) {
1352          boolean isPropertyForeignKey = false;
1353          if (foreignField != null) {
1354              isPropertyForeignKey = foreignField.getManyToField().equals(prefix + propertyName);
1355          }
1356          return isPropertyForeignKey;
1357      }
1358  
<abbr title="1359      protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, String propertyName) {">1359      protected int findAdditionalForeignKeyIndex(ForeignKey[] additionalForeignFields, String prefix, String properðŸ”µ</abbr>
1360          int additionalForeignKeyIndexPosition = -1;
1361          if (additionalForeignFields != null) {
<abbr title="1362              additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKey(prefix + propertyName, null, null), new Comparator&lt;ForeignKey&gt;() {">1362              additionalForeignKeyIndexPosition = Arrays.binarySearch(additionalForeignFields, new ForeignKey(prefixðŸ”µ</abbr>
1363                  @Override
1364                  public int compare(ForeignKey o1, ForeignKey o2) {
1365                      return o1.getManyToField().compareTo(o2.getManyToField());
1366                  }
1367              });
1368          }
1369          return additionalForeignKeyIndexPosition;
1370      }
1371  
1372      protected void buildEntityProperties(
1373              Map&lt;String, FieldMetadata&gt; fields,
1374              ForeignKey foreignField,
1375              ForeignKey[] additionalForeignFields,
1376              String[] additionalNonPersistentProperties,
1377              Boolean populateManyToOneFields,
1378              String[] includeFields,
1379              String[] excludeFields,
1380              String configurationKey,
1381              String ceilingEntityFullyQualifiedClassname,
1382              String propertyName,
1383              Class&lt;?&gt; returnedClass,
1384              Class&lt;?&gt; targetClass,
1385              List&lt;Class&lt;?&gt;&gt; parentClasses,
1386              String prefix,
1387              Boolean isParentExcluded,
1388              String parentPrefix) {
1389          Class&lt;?&gt;[] polymorphicEntities = getAllPolymorphicEntitiesFromCeiling(returnedClass);
1390          List&lt;Class&lt;?&gt;&gt; clonedParentClasses = new ArrayList&lt;&gt;();
1391  
1392          for (Class&lt;?&gt; parentClass : parentClasses) {
1393              clonedParentClasses.add(parentClass);
1394          }
1395  
1396          clonedParentClasses.add(targetClass);
1397  
1398          Map&lt;String, FieldMetadata&gt; newFields = getMergedPropertiesRecursively(
1399                  ceilingEntityFullyQualifiedClassname,
1400                  polymorphicEntities,
1401                  foreignField,
1402                  additionalNonPersistentProperties,
1403                  additionalForeignFields,
1404                  MergedPropertyType.PRIMARY,
1405                  populateManyToOneFields,
1406                  includeFields,
1407                  excludeFields,
1408                  configurationKey,
1409                  clonedParentClasses,
1410                  prefix + propertyName + &#x27;.&#x27;,
1411                  isParentExcluded,
1412                  parentPrefix);
1413  
1414          final String targetClassName = targetClass.getName();
1415  
1416          for (FieldMetadata newMetadata : newFields.values()) {
1417              newMetadata.setInheritedFromType(targetClassName);
1418              newMetadata.setAvailableToTypes(new String[]{targetClassName});
1419          }
1420  
1421          Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;(newFields.size());
1422  
1423          for (Map.Entry&lt;String, FieldMetadata&gt; newField : newFields.entrySet()) {
1424              final FieldMetadata fieldMetadata = newField.getValue();
1425              final String key = newField.getKey();
1426  
1427              convertedFields.put(propertyName + &#x27;.&#x27; + key, fieldMetadata);
1428  
1429              if (fieldMetadata instanceof BasicFieldMetadata) {
<abbr title="1430                  for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldMetadata) fieldMetadata).getValidationConfigurations().entrySet()) {">1430                  for (Map.Entry&lt;String, List&lt;Map&lt;String, String&gt;&gt;&gt; validationConfigurations : ((BasicFieldMetadata)ðŸ”µ</abbr>
1431                      Class&lt;?&gt; validatorImpl = null;
1432  
1433                      try {
1434                          validatorImpl = Class.forName(validationConfigurations.getKey());
1435                      } catch (ClassNotFoundException e) {
1436                          Object bean = applicationContext.getBean(validationConfigurations.getKey());
1437  
1438                          if (bean != null) {
1439                              validatorImpl = bean.getClass();
1440                          }
1441                      }
1442  
<abbr title="1443                      if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validatorImpl)) {">1443                      if (validatorImpl != null &amp;&amp; FieldNamePropertyValidator.class.isAssignableFrom(validatorImpl))ðŸ”µ</abbr>
1444                          for (Map&lt;String, String&gt; configs : validationConfigurations.getValue()) {
1445                              for (Map.Entry&lt;String, String&gt; config : configs.entrySet()) {
1446                                  final String value = config.getValue();
1447  
1448                                  if (newFields.containsKey(value)) {
1449                                      config.setValue(propertyName + &quot;.&quot; + value);
1450                                  }
1451                              }
1452                          }
1453                      }
1454                  }
1455              }
1456  
1457              if (isForeignKey(fieldMetadata)) {
1458                  setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1459              }
1460          }
1461  
1462          fields.putAll(convertedFields);
1463      }
1464  
1465      protected boolean isForeignKey(FieldMetadata fieldMetadata) {
1466          return fieldMetadata instanceof BasicCollectionMetadata
<abbr title="1467                  &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().isEmpty()">1467                  &amp;&amp; !((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectivðŸ”µ</abbr>
<abbr title="1468                  &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().containsKey(PersistencePerspectiveItemType.FOREIGNKEY);">1468                  &amp;&amp; ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveðŸ”µ</abbr>
1469      }
1470  
1471      /*
1472       * There may be multiple pathways to this foreign key which may have come from a cached source.
1473       * Since ForeignKey contains an originating field concept that is occurrence specific, we need
1474       * to make sure it is set appropriately here.
1475       *
1476       * A known use case is vendorPortal.embeddableMultitenantSite.adminUsers and
1477       * owningSite.embeddableMultitenantSite.adminUsers.
1478       */
<abbr title="1479      protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMetadata) {">1479      protected void setOriginatingFieldForForeignKey(String propertyName, String key, FieldMetadata fieldMetadata) ðŸ”µ</abbr>
<abbr title="1480          ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective().getPersistencePerspectiveItems().get(PersistencePerspectiveItemType.FOREIGNKEY);">1480          ForeignKey foreignKey = (ForeignKey) ((BasicCollectionMetadata) fieldMetadata).getPersistencePerspective()ðŸ”µ</abbr>
1481          foreignKey.setOriginatingField(propertyName + &#x27;.&#x27; + key);
1482      }
1483  
1484      protected void buildComponentProperties(
1485              Class&lt;?&gt; targetClass,
1486              ForeignKey foreignField,
1487              ForeignKey[] additionalForeignFields,
1488              String[] additionalNonPersistentProperties,
1489              MergedPropertyType mergedPropertyType,
1490              Map&lt;String, FieldMetadata&gt; fields,
1491              String idProperty,
1492              Boolean populateManyToOneFields,
1493              String[] includeFields,
1494              String[] excludeFields,
1495              String configurationKey,
1496              String ceilingEntityFullyQualifiedClassname,
1497              String propertyName,
1498              Type type,
1499              Class&lt;?&gt; returnedClass,
1500              List&lt;Class&lt;?&gt;&gt; parentClasses,
1501              Boolean isParentExcluded,
1502              String prefix,
1503              String parentPrefix) {
1504          String[] componentProperties = ((ComponentType) type).getPropertyNames();
1505          List&lt;String&gt; componentPropertyNames = Arrays.asList(componentProperties);
1506          Type[] componentTypes = ((ComponentType) type).getSubtypes();
1507          List&lt;Type&gt; componentPropertyTypes = Arrays.asList(componentTypes);
1508          String tempPrefix = &quot;&quot;;
1509  
1510          int pos = prefix.indexOf(&quot;.&quot;);
1511          final int prefixLength = prefix.length();
1512  
1513          if (pos &gt; 0 &amp;&amp; pos &lt; prefixLength - 1) {
1514              //only use part of the prefix if it&#x27;s more than one layer deep
1515              tempPrefix = prefix.substring(pos + 1, prefixLength);
1516          }
1517  
<abbr title="1518          Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClass(targetClass, returnedClass, this, tempPrefix + propertyName + &quot;.&quot;);">1518          Map&lt;String, FieldMetadata&gt; componentPresentationAttributes = metadata.getFieldMetadataForTargetClass(targeðŸ”µ</abbr>
1519  
1520          if (isParentExcluded) {
1521              for (String key : componentPresentationAttributes.keySet()) {
1522                  LOG.debug(&quot;buildComponentProperties:Excluding &quot; + key + &quot; because the parent was excluded&quot;);
1523                  componentPresentationAttributes.get(key).setExcluded(true);
1524              }
1525          }
1526  
1527          PersistentClass persistentClass = getPersistentClass(targetClass.getName());
1528          Property property;
1529  
1530          try {
1531              property = persistentClass.getProperty(propertyName);
1532          } catch (MappingException e) {
1533              property = persistentClass.getProperty(prefix + propertyName);
1534          }
1535  
<abbr title="1536          Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPropertyIterator();">1536          Iterator componentPropertyIterator = ((org.hibernate.mapping.Component) property.getValue()).getPropertyItðŸ”µ</abbr>
1537          List&lt;Property&gt; componentPropertyList = new ArrayList&lt;&gt;();
1538  
1539          while (componentPropertyIterator.hasNext()) {
1540              componentPropertyList.add((Property) componentPropertyIterator.next());
1541          }
1542  
1543          Map&lt;String, FieldMetadata&gt; newFields = new HashMap&lt;&gt;();
1544          buildProperties(
1545                  targetClass,
1546                  foreignField,
1547                  additionalForeignFields,
1548                  additionalNonPersistentProperties,
1549                  mergedPropertyType,
1550                  componentPresentationAttributes,
1551                  componentPropertyList,
1552                  newFields,
1553                  componentPropertyNames,
1554                  componentPropertyTypes,
1555                  idProperty,
1556                  populateManyToOneFields,
1557                  includeFields,
1558                  excludeFields,
1559                  configurationKey,
1560                  ceilingEntityFullyQualifiedClassname,
1561                  parentClasses,
1562                  propertyName + &quot;.&quot;,
1563                  isParentExcluded,
1564                  true,
1565                  parentPrefix + prefix
1566          );
1567  
1568          Map&lt;String, FieldMetadata&gt; convertedFields = new HashMap&lt;&gt;();
1569  
1570          for (String key : newFields.keySet()) {
1571              final FieldMetadata fieldMetadata = newFields.get(key);
1572              convertedFields.put(propertyName + &quot;.&quot; + key, fieldMetadata);
1573  
1574              if (isForeignKey(fieldMetadata)) {
1575                  setOriginatingFieldForForeignKey(propertyName, key, fieldMetadata);
1576              }
1577          }
1578          fields.putAll(convertedFields);
1579      }
1580  
1581      @Override
1582      public EntityManager getStandardEntityManager() {
1583          return standardEntityManager;
1584      }
1585  
1586      @Override
1587      public void setStandardEntityManager(EntityManager entityManager) {
1588          this.standardEntityManager = entityManager;
1589          fieldManager = new FieldManager(entityConfiguration, entityManager);
1590      }
1591  
1592      @Override
1593      public FieldManager getFieldManager() {
1594          return this.getFieldManager(true);
1595      }
1596  
1597      @Override
1598      public FieldManager getFieldManager(boolean cleanFieldManager) {
1599          if (fieldManager == null) {
1600              //keep in mind that getStandardEntityManager() can return null, this is in general OK,
1601              // we re-init fieldManager in setStandardEntityManager method
1602              fieldManager = new FieldManager(entityConfiguration, getStandardEntityManager());
1603          } else if (cleanFieldManager){
1604              fieldManager.clearMiddleFields();
1605          }
1606          return fieldManager;
1607      }
1608  
1609      @Override
1610      public EntityConfiguration getEntityConfiguration() {
1611          return entityConfiguration;
1612      }
1613  
1614      @Override
1615      public void setEntityConfiguration(EntityConfiguration entityConfiguration) {
1616          this.entityConfiguration = entityConfiguration;
1617      }
1618  
1619      @Override
1620      public Metadata getMetadata() {
1621          return metadata;
1622      }
1623  
1624      @Override
1625      public void setMetadata(Metadata metadata) {
1626          this.metadata = metadata;
1627      }
1628  
1629      public List&lt;FieldMetadataProvider&gt; getFieldMetadataProviders() {
1630          return fieldMetadataProviders;
1631      }
1632  
1633      public void setFieldMetadataProviders(List&lt;FieldMetadataProvider&gt; fieldMetadataProviders) {
1634          this.fieldMetadataProviders = fieldMetadataProviders;
1635      }
1636  
1637      @Override
1638      public FieldMetadataProvider getDefaultFieldMetadataProvider() {
1639          return defaultFieldMetadataProvider;
1640      }
1641  
1642      public void setDefaultFieldMetadataProvider(FieldMetadataProvider defaultFieldMetadataProvider) {
1643          this.defaultFieldMetadataProvider = defaultFieldMetadataProvider;
1644      }
1645  
1646      protected boolean isExcludeClassFromPolymorphism(Class&lt;?&gt; clazz) {
1647          return dynamicDaoHelper.isExcludeClassFromPolymorphism(clazz);
1648      }
1649  
1650      @Override
1651      public DynamicDaoHelper getDynamicDaoHelper() {
1652          return dynamicDaoHelper;
1653      }
1654  
1655      public void setDynamicDaoHelper(DynamicDaoHelper dynamicDaoHelper) {
1656          this.dynamicDaoHelper = dynamicDaoHelper;
1657      }
1658  
1659  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            