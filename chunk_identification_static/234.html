<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>234</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    234
                    <a href="233.html">prev</a>
                    <a href="235.html">next</a>
                    <a href="234_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_13ef17a37e683b8ad5800e9f542b411180fbec2f_src/com/android/launcher3/Utilities.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;13ef17a37e683b8ad5800e9f542b411180fbec2f:src/com/android/launcher3/Utilities.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;13ef17a37e683b8ad5800e9f542b411180fbec2f^1:src/com/android/launcher3/Utilities.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;13ef17a37e683b8ad5800e9f542b411180fbec2f^2:src/com/android/launcher3/Utilities.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;0250945759f7ac58aab912448d62dc108b1770c5:src/com/android/launcher3/Utilities.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.annotation.TargetApi;
  20 import android.app.Activity;
  21 import android.app.SearchManager;
  22 import android.appwidget.AppWidgetManager;
  23 import android.appwidget.AppWidgetProviderInfo;
  24 import android.content.ActivityNotFoundException;
  25 import android.content.ComponentName;
  26 import android.content.Context;
  27 import android.content.Intent;
  28 import android.content.SharedPreferences;
  29 import android.content.pm.ApplicationInfo;
  30 import android.content.pm.PackageInfo;
  31 import android.content.pm.PackageManager;
  32 import android.content.pm.PackageManager.NameNotFoundException;
  33 import android.content.pm.ResolveInfo;
  34 import android.content.res.Resources;
  35 import android.database.Cursor;
  36 import android.graphics.Bitmap;
  37 import android.graphics.BitmapFactory;
  38 import android.graphics.Canvas;
  39 import android.graphics.Color;
  40 import android.graphics.Matrix;
  41 import android.graphics.Paint;
  42 import android.graphics.PaintFlagsDrawFilter;
  43 import android.graphics.Rect;
  44 import android.graphics.drawable.BitmapDrawable;
  45 import android.graphics.drawable.Drawable;
  46 import android.graphics.drawable.PaintDrawable;
  47 import android.os.Build;
  48 import android.os.Bundle;
  49 import android.os.Process;
  50 import android.text.TextUtils;
  51 import android.util.DisplayMetrics;
  52 import android.util.Log;
  53 import android.util.Pair;
  54 import android.util.SparseArray;
  55 import android.util.TypedValue;
  56 import android.view.View;
  57 import android.widget.Toast;
  58 
  59 import java.io.ByteArrayOutputStream;
  60 import java.io.IOException;
  61 import java.util.ArrayList;
  62 import java.util.Locale;
  63 import java.util.Set;
  64 import java.util.regex.Matcher;
  65 import java.util.regex.Pattern;
  66 
  67 /**
  68  * Various utilities shared amongst the Launcher&#x27;s classes.
  69  */
  70 public final class Utilities {
  71 
  72     private static final String TAG = &quot;Launcher.Utilities&quot;;
  73 
  74     private static final Rect sOldBounds = new Rect();
  75     private static final Canvas sCanvas = new Canvas();
  76 
  77     private static final Pattern sTrimPattern =
  78             Pattern.compile(&quot;^[\\s|\\p{javaSpaceChar}]*(.*)[\\s|\\p{javaSpaceChar}]*$&quot;);
  79 
  80     static {
  81         sCanvas.setDrawFilter(new PaintFlagsDrawFilter(Paint.DITHER_FLAG,
  82                 Paint.FILTER_BITMAP_FLAG));
  83     }
  84     static int sColors[] = { 0xffff0000, 0xff00ff00, 0xff0000ff };
  85     static int sColorIndex = 0;
  86 
  87     private static final int[] sLoc0 = new int[2];
  88     private static final int[] sLoc1 = new int[2];
  89 
  90     // To turn on these properties, type
  91     // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
  92     private static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;
  93     private static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);
  94 
  95     public static final String ALLOW_ROTATION_PREFERENCE_KEY = &quot;pref_allowRotation&quot;;
  96 
  97     public static boolean isPropertyEnabled(String propertyName) {
  98         return Log.isLoggable(propertyName, Log.VERBOSE);
  99     }
 100 
 101     public static boolean isAllowRotationPrefEnabled(Context context, boolean multiProcess) {
 102         SharedPreferences sharedPrefs = context.getSharedPreferences(
 103                 LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE | (multiProcess ?
 104                         Context.MODE_MULTI_PROCESS : 0));
 105         boolean allowRotationPref = sharedPrefs.getBoolean(ALLOW_ROTATION_PREFERENCE_KEY, false);
 106         return sForceEnableRotation || allowRotationPref;
 107     }
 108 
 109     public static boolean isRotationAllowedForDevice(Context context) {
 110         return sForceEnableRotation || context.getResources().getBoolean(R.bool.allow_rotation);
 111     }
 112 
 113     /**
 114      * Indicates if the device is running LMP or higher.
 115      */
 116     public static boolean isLmpOrAbove() {
 117         return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP;
 118 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 119 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 120     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 121 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 122     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 123      * Returns a bitmap suitable for the all apps view. If the package or the resource do not</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 124      * exist, it returns null.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 125      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 126     static Bitmap createIconBitmap(String packageName, String resourceName, IconCache cache,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 127             Context context) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 128         PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 129         // the resource</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 130         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 131             Resources resources = packageManager.getResourcesForApplication(packageName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 132             if (resources != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 133                 final int id = resources.getIdentifier(resourceName, null, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 134                 return createIconBitmap(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 135                         resources.getDrawableForDensity(id, cache.getFullResIconDpi()), context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 136             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 137         } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 138             // Icon not found.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 139         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 140         return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 141     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 142 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 143     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 144      * Returns a bitmap which is of the appropriate size to be displayed as an icon</span>
 145 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 146     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 147 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 148     public static boolean isLmpMR1OrAbove() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 149         // TODO(adamcohen): update to Build.VERSION_CODES.LOLLIPOP_MR1 once building against 22;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 150         return Build.VERSION.SDK_INT &gt;= 22;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 151     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 152 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 153     public static boolean isLmpMR1() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 154         // TODO(adamcohen): update to Build.VERSION_CODES.LOLLIPOP_MR1 once building against 22;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 155         return Build.VERSION.SDK_INT == 22;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 156     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 157 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 158     public static Bitmap createIconBitmap(Cursor c, int iconIndex, Context context) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 159         byte[] data = c.getBlob(iconIndex);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 160         try {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 161             return createIconBitmap(BitmapFactory.decodeByteArray(data, 0, data.length), context);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 162         } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 163             return null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 164         }</span>
 165 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 166     }
 167 
 168     /**
 169      * Returns a bitmap suitable for the all apps view. If the package or the resource do not
 170      * exist, it returns null.
 171      */
 172     public static Bitmap createIconBitmap(String packageName, String resourceName,
 173             Context context) {
 174         PackageManager packageManager = context.getPackageManager();
 175         // the resource
 176         try {
 177             Resources resources = packageManager.getResourcesForApplication(packageName);
 178             if (resources != null) {
 179                 final int id = resources.getIdentifier(resourceName, null, null);
 180                 return createIconBitmap(
 181                         resources.getDrawableForDensity(id, LauncherAppState.getInstance()
 182                                 .getInvariantDeviceProfile().fillResIconDpi), context);
 183             }
 184         } catch (Exception e) {
 185             // Icon not found.
 186         }
 187         return null;
 188     }
 189 
 190     private static int getIconBitmapSize() {
 191         return LauncherAppState.getInstance().getInvariantDeviceProfile().iconBitmapSize;
 192     }
 193 
 194     /**
 195      * Returns a bitmap which is of the appropriate size to be displayed as an icon
 196      */
 197     public static Bitmap createIconBitmap(Bitmap icon, Context context) {
 198         final int iconBitmapSize = getIconBitmapSize();
 199         if (iconBitmapSize == icon.getWidth() &amp;&amp; iconBitmapSize == icon.getHeight()) {
 200             return icon;
 201         }
 202         return createIconBitmap(new BitmapDrawable(context.getResources(), icon), context);
 203     }
 204 
 205     /**
 206      * Returns a bitmap suitable for the all apps view.
 207      */
 208     public static Bitmap createIconBitmap(Drawable icon, Context context) {
 209         synchronized (sCanvas) {
 210             final int iconBitmapSize = getIconBitmapSize();
 211 
 212             int width = iconBitmapSize;
 213             int height = iconBitmapSize;
 214 
 215             if (icon instanceof PaintDrawable) {
 216                 PaintDrawable painter = (PaintDrawable) icon;
 217                 painter.setIntrinsicWidth(width);
 218                 painter.setIntrinsicHeight(height);
 219             } else if (icon instanceof BitmapDrawable) {
 220                 // Ensure the bitmap has a density.
 221                 BitmapDrawable bitmapDrawable = (BitmapDrawable) icon;
 222                 Bitmap bitmap = bitmapDrawable.getBitmap();
 223                 if (bitmap.getDensity() == Bitmap.DENSITY_NONE) {
 224                     bitmapDrawable.setTargetDensity(context.getResources().getDisplayMetrics());
 225                 }
 226             }
 227             int sourceWidth = icon.getIntrinsicWidth();
 228             int sourceHeight = icon.getIntrinsicHeight();
 229             if (sourceWidth &gt; 0 &amp;&amp; sourceHeight &gt; 0) {
 230                 // Scale the icon proportionally to the icon dimensions
 231                 final float ratio = (float) sourceWidth / sourceHeight;
 232                 if (sourceWidth &gt; sourceHeight) {
 233                     height = (int) (width / ratio);
 234                 } else if (sourceHeight &gt; sourceWidth) {
 235                     width = (int) (height * ratio);
 236                 }
 237             }
 238 
 239             // no intrinsic size --&gt; use default size
 240             int textureWidth = iconBitmapSize;
 241             int textureHeight = iconBitmapSize;
 242 
 243             final Bitmap bitmap = Bitmap.createBitmap(textureWidth, textureHeight,
 244                     Bitmap.Config.ARGB_8888);
 245             final Canvas canvas = sCanvas;
 246             canvas.setBitmap(bitmap);
 247 
 248             final int left = (textureWidth-width) / 2;
 249             final int top = (textureHeight-height) / 2;
 250 
 251             @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
 252             final boolean debug = false;
 253             if (debug) {
 254                 // draw a big box for the icon for debugging
 255                 canvas.drawColor(sColors[sColorIndex]);
 256                 if (++sColorIndex &gt;= sColors.length) sColorIndex = 0;
 257                 Paint debugPaint = new Paint();
 258                 debugPaint.setColor(0xffcccc00);
 259                 canvas.drawRect(left, top, left+width, top+height, debugPaint);
 260             }
 261 
 262             sOldBounds.set(icon.getBounds());
 263             icon.setBounds(left, top, left+width, top+height);
 264             icon.draw(canvas);
 265             icon.setBounds(sOldBounds);
 266             canvas.setBitmap(null);
 267 
 268             return bitmap;
 269         }
 270     }
 271 
 272     /**
 273      * Given a coordinate relative to the descendant, find the coordinate in a parent view&#x27;s
 274      * coordinates.
 275      *
 276      * @param descendant The descendant to which the passed coordinate is relative.
 277      * @param root The root view to make the coordinates relative to.
 278      * @param coord The coordinate that we want mapped.
 279      * @param includeRootScroll Whether or not to account for the scroll of the descendant:
 280      *          sometimes this is relevant as in a child&#x27;s coordinates within the descendant.
 281      * @return The factor by which this descendant is scaled relative to this DragLayer. Caution
 282      *         this scale factor is assumed to be equal in X and Y, and so if at any point this
 283      *         assumption fails, we will need to return a pair of scale factors.
 284      */
 285     public static float getDescendantCoordRelativeToParent(View descendant, View root,
 286                                                            int[] coord, boolean includeRootScroll) {
 287         ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 288 
 289         float[] pt = {coord[0], coord[1]};
 290 
 291         View v = descendant;
 292         while(v != root &amp;&amp; v != null) {
 293             ancestorChain.add(v);
 294             v = (View) v.getParent();
 295         }
 296         ancestorChain.add(root);
 297 
 298         float scale = 1.0f;
 299         int count = ancestorChain.size();
 300         for (int i = 0; i &lt; count; i++) {
 301             View v0 = ancestorChain.get(i);
 302             // For TextViews, scroll has a meaning which relates to the text position
 303             // which is very strange... ignore the scroll.
 304             if (v0 != descendant || includeRootScroll) {
 305                 pt[0] -= v0.getScrollX();
 306                 pt[1] -= v0.getScrollY();
 307             }
 308 
 309             v0.getMatrix().mapPoints(pt);
 310             pt[0] += v0.getLeft();
 311             pt[1] += v0.getTop();
 312             scale *= v0.getScaleX();
 313         }
 314 
 315         coord[0] = (int) Math.round(pt[0]);
 316         coord[1] = (int) Math.round(pt[1]);
 317         return scale;
 318     }
 319 
 320     /**
 321      * Inverse of {@link #getDescendantCoordRelativeToSelf(View, int[])}.
 322      */
 323     public static float mapCoordInSelfToDescendent(View descendant, View root,
 324                                                    int[] coord) {
 325         ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 326 
 327         float[] pt = {coord[0], coord[1]};
 328 
 329         View v = descendant;
 330         while(v != root) {
 331             ancestorChain.add(v);
 332             v = (View) v.getParent();
 333         }
 334         ancestorChain.add(root);
 335 
 336         float scale = 1.0f;
 337         Matrix inverse = new Matrix();
 338         int count = ancestorChain.size();
 339         for (int i = count - 1; i &gt;= 0; i--) {
 340             View ancestor = ancestorChain.get(i);
 341             View next = i &gt; 0 ? ancestorChain.get(i-1) : null;
 342 
 343             pt[0] += ancestor.getScrollX();
 344             pt[1] += ancestor.getScrollY();
 345 
 346             if (next != null) {
 347                 pt[0] -= next.getLeft();
 348                 pt[1] -= next.getTop();
 349                 next.getMatrix().invert(inverse);
 350                 inverse.mapPoints(pt);
 351                 scale *= next.getScaleX();
 352             }
 353         }
 354 
 355         coord[0] = (int) Math.round(pt[0]);
 356         coord[1] = (int) Math.round(pt[1]);
 357         return scale;
 358     }
 359 
 360     /**
 361      * Utility method to determine whether the given point, in local coordinates,
 362      * is inside the view, where the area of the view is expanded by the slop factor.
 363      * This method is called while processing touch-move events to determine if the event
 364      * is still within the view.
 365      */
 366     public static boolean pointInView(View v, float localX, float localY, float slop) {
 367         return localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; (v.getWidth() + slop) &amp;&amp;
 368                 localY &lt; (v.getHeight() + slop);
 369     }
 370 
 371     public static void scaleRect(Rect r, float scale) {
 372         if (scale != 1.0f) {
 373             r.left = (int) (r.left * scale + 0.5f);
 374             r.top = (int) (r.top * scale + 0.5f);
 375             r.right = (int) (r.right * scale + 0.5f);
 376             r.bottom = (int) (r.bottom * scale + 0.5f);
 377         }
 378     }
 379 
 380     public static int[] getCenterDeltaInScreenSpace(View v0, View v1, int[] delta) {
 381         v0.getLocationInWindow(sLoc0);
 382         v1.getLocationInWindow(sLoc1);
 383 
 384         sLoc0[0] += (v0.getMeasuredWidth() * v0.getScaleX()) / 2;
 385         sLoc0[1] += (v0.getMeasuredHeight() * v0.getScaleY()) / 2;
 386         sLoc1[0] += (v1.getMeasuredWidth() * v1.getScaleX()) / 2;
 387         sLoc1[1] += (v1.getMeasuredHeight() * v1.getScaleY()) / 2;
 388 
 389         if (delta == null) {
 390             delta = new int[2];
 391         }
 392 
 393         delta[0] = sLoc1[0] - sLoc0[0];
 394         delta[1] = sLoc1[1] - sLoc0[1];
 395 
 396         return delta;
 397     }
 398 
 399     public static void scaleRectAboutCenter(Rect r, float scale) {
 400         int cx = r.centerX();
 401         int cy = r.centerY();
 402         r.offset(-cx, -cy);
 403         Utilities.scaleRect(r, scale);
 404         r.offset(cx, cy);
 405     }
 406 
 407     public static void startActivityForResultSafely(
 408             Activity activity, Intent intent, int requestCode) {
 409         try {
 410             activity.startActivityForResult(intent, requestCode);
 411         } catch (ActivityNotFoundException e) {
 412             Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 413         } catch (SecurityException e) {
 414             Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 415             Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +
 416                     &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +
 417                     &quot;or use the exported attribute for this activity.&quot;, e);
 418         }
 419     }
 420 
 421     static boolean isSystemApp(Context context, Intent intent) {
 422         PackageManager pm = context.getPackageManager();
 423         ComponentName cn = intent.getComponent();
 424         String packageName = null;
 425         if (cn == null) {
 426             ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
 427             if ((info != null) &amp;&amp; (info.activityInfo != null)) {
 428                 packageName = info.activityInfo.packageName;
 429             }
 430         } else {
 431             packageName = cn.getPackageName();
 432         }
 433         if (packageName != null) {
 434             try {
 435                 PackageInfo info = pm.getPackageInfo(packageName, 0);
 436                 return (info != null) &amp;&amp; (info.applicationInfo != null) &amp;&amp;
 437                         ((info.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0);
 438             } catch (NameNotFoundException e) {
 439                 return false;
 440             }
 441         } else {
 442             return false;
 443         }
 444     }
 445 
 446     /**
 447      * This picks a dominant color, looking for high-saturation, high-value, repeated hues.
 448      * @param bitmap The bitmap to scan
 449      * @param samples The approximate max number of samples to use.
 450      */
 451     static int findDominantColorByHue(Bitmap bitmap, int samples) {
 452         final int height = bitmap.getHeight();
 453         final int width = bitmap.getWidth();
 454         int sampleStride = (int) Math.sqrt((height * width) / samples);
 455         if (sampleStride &lt; 1) {
 456             sampleStride = 1;
 457         }
 458 
 459         // This is an out-param, for getting the hsv values for an rgb
 460         float[] hsv = new float[3];
 461 
 462         // First get the best hue, by creating a histogram over 360 hue buckets,
 463         // where each pixel contributes a score weighted by saturation, value, and alpha.
 464         float[] hueScoreHistogram = new float[360];
 465         float highScore = -1;
 466         int bestHue = -1;
 467 
 468         for (int y = 0; y &lt; height; y += sampleStride) {
 469             for (int x = 0; x &lt; width; x += sampleStride) {
 470                 int argb = bitmap.getPixel(x, y);
 471                 int alpha = 0xFF &amp; (argb &gt;&gt; 24);
 472                 if (alpha &lt; 0x80) {
 473                     // Drop mostly-transparent pixels.
 474                     continue;
 475                 }
 476                 // Remove the alpha channel.
 477                 int rgb = argb | 0xFF000000;
 478                 Color.colorToHSV(rgb, hsv);
 479                 // Bucket colors by the 360 integer hues.
 480                 int hue = (int) hsv[0];
 481                 if (hue &lt; 0 || hue &gt;= hueScoreHistogram.length) {
 482                     // Defensively avoid array bounds violations.
 483                     continue;
 484                 }
 485                 float score = hsv[1] * hsv[2];
 486                 hueScoreHistogram[hue] += score;
 487                 if (hueScoreHistogram[hue] &gt; highScore) {
 488                     highScore = hueScoreHistogram[hue];
 489                     bestHue = hue;
 490                 }
 491             }
 492         }
 493 
 494         SparseArray&lt;Float&gt; rgbScores = new SparseArray&lt;Float&gt;();
 495         int bestColor = 0xff000000;
 496         highScore = -1;
 497         // Go back over the RGB colors that match the winning hue,
 498         // creating a histogram of weighted s*v scores, for up to 100*100 [s,v] buckets.
 499         // The highest-scoring RGB color wins.
 500         for (int y = 0; y &lt; height; y += sampleStride) {
 501             for (int x = 0; x &lt; width; x += sampleStride) {
 502                 int rgb = bitmap.getPixel(x, y) | 0xff000000;
 503                 Color.colorToHSV(rgb, hsv);
 504                 int hue = (int) hsv[0];
 505                 if (hue == bestHue) {
 506                     float s = hsv[1];
 507                     float v = hsv[2];
 508                     int bucket = (int) (s * 100) + (int) (v * 10000);
 509                     // Score by cumulative saturation * value.
 510                     float score = s * v;
 511                     Float oldTotal = rgbScores.get(bucket);
 512                     float newTotal = oldTotal == null ? score : oldTotal + score;
 513                     rgbScores.put(bucket, newTotal);
 514                     if (newTotal &gt; highScore) {
 515                         highScore = newTotal;
 516                         // All the colors in the winning bucket are very similar. Last in wins.
 517                         bestColor = rgb;
 518                     }
 519                 }
 520             }
 521         }
 522         return bestColor;
 523     }
 524 
 525     /*
 526      * Finds a system apk which had a broadcast receiver listening to a particular action.
 527      * @param action intent action used to find the apk
 528      * @return a pair of apk package name and the resources.
 529      */
 530     static Pair&lt;String, Resources&gt; findSystemApk(String action, PackageManager pm) {
 531         final Intent intent = new Intent(action);
 532         for (ResolveInfo info : pm.queryBroadcastReceivers(intent, 0)) {
 533             if (info.activityInfo != null &amp;&amp;
 534                     (info.activityInfo.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 535                 final String packageName = info.activityInfo.packageName;
 536                 try {
 537                     final Resources res = pm.getResourcesForApplication(packageName);
 538                     return Pair.create(packageName, res);
 539                 } catch (NameNotFoundException e) {
 540                     Log.w(TAG, &quot;Failed to find resources for &quot; + packageName);
 541                 }
 542             }
 543         }
 544         return null;
 545     }
 546 
 547     @TargetApi(Build.VERSION_CODES.KITKAT)
 548     public static boolean isViewAttachedToWindow(View v) {
 549         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
 550             return v.isAttachedToWindow();
 551         } else {
 552             // A proxy call which returns null, if the view is not attached to the window.
 553             return v.getKeyDispatcherState() != null;
 554         }
 555     }
 556 
 557     /**
 558      * Returns a widget with category {@link AppWidgetProviderInfo#WIDGET_CATEGORY_SEARCHBOX}
 559      * provided by the same package which is set to be global search activity.
 560      * If widgetCategory is not supported, or no such widget is found, returns the first widget
 561      * provided by the package.
 562      */
 563     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 564     public static AppWidgetProviderInfo getSearchWidgetProvider(Context context) {
 565         SearchManager searchManager =
 566                 (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
 567         ComponentName searchComponent = searchManager.getGlobalSearchActivity();
 568         if (searchComponent == null) return null;
 569         String providerPkg = searchComponent.getPackageName();
 570 
 571         AppWidgetProviderInfo defaultWidgetForSearchPackage = null;
 572 
 573         AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
 574         for (AppWidgetProviderInfo info : appWidgetManager.getInstalledProviders()) {
 575             if (info.provider.getPackageName().equals(providerPkg)) {
 576                 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {
 577                     if ((info.widgetCategory &amp; AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX) != 0) {
 578                         return info;
 579                     } else if (defaultWidgetForSearchPackage == null) {
 580                         defaultWidgetForSearchPackage = info;
 581                     }
 582                 } else {
 583                     return info;
 584                 }
 585             }
 586         }
 587         return defaultWidgetForSearchPackage;
 588     }
 589 
 590     /**
 591      * Compresses the bitmap to a byte array for serialization.
 592      */
 593     public static byte[] flattenBitmap(Bitmap bitmap) {
 594         // Try go guesstimate how much space the icon will take when serialized
 595         // to avoid unnecessary allocations/copies during the write.
 596         int size = bitmap.getWidth() * bitmap.getHeight() * 4;
 597         ByteArrayOutputStream out = new ByteArrayOutputStream(size);
 598         try {
 599             bitmap.compress(Bitmap.CompressFormat.PNG, 100, out);
 600             out.flush();
 601             out.close();
 602             return out.toByteArray();
 603         } catch (IOException e) {
 604             Log.w(TAG, &quot;Could not write bitmap&quot;);
 605             return null;
 606         }
 607     }
 608 
 609     /**
 610      * Find the first vacant cell, if there is one.
 611      *
 612      * @param vacant Holds the x and y coordinate of the vacant cell
 613      * @param spanX Horizontal cell span.
 614      * @param spanY Vertical cell span.
 615      *
 616      * @return true if a vacant cell was found
 617      */
 618     public static boolean findVacantCell(int[] vacant, int spanX, int spanY,
 619             int xCount, int yCount, boolean[][] occupied) {
 620 
 621         for (int y = 0; (y + spanY) &lt;= yCount; y++) {
 622             for (int x = 0; (x + spanX) &lt;= xCount; x++) {
 623                 boolean available = !occupied[x][y];
 624                 out:            for (int i = x; i &lt; x + spanX; i++) {
 625                     for (int j = y; j &lt; y + spanY; j++) {
 626                         available = available &amp;&amp; !occupied[i][j];
 627                         if (!available) break out;
 628                     }
 629                 }
 630 
 631                 if (available) {
 632                     vacant[0] = x;
 633                     vacant[1] = y;
 634                     return true;
 635                 }
 636             }
 637         }
 638 
 639         return false;
 640     }
 641 
 642     /**
 643      * Trims the string, removing all whitespace at the beginning and end of the string.
 644      * Non-breaking whitespaces are also removed.
 645      */
 646     public static String trim(CharSequence s) {
 647         if (s == null) {
 648             return null;
 649         }
 650 
 651         // Just strip any sequence of whitespace or java space characters from the beginning and end
 652         Matcher m = sTrimPattern.matcher(s);
 653         return m.replaceAll(&quot;$1&quot;);
 654     }
 655 
 656     /**
 657      * Calculates the height of a given string at a specific text size.
 658      */
 659     public static float calculateTextHeight(float textSizePx) {
 660         Paint p = new Paint();
 661         p.setTextSize(textSizePx);
 662         Paint.FontMetrics fm = p.getFontMetrics();
 663         return -fm.top + fm.bottom;
 664     }
 665 
 666     /**
 667      * Convenience println with multiple args.
 668      */
 669     public static void println(String key, Object... args) {
 670         StringBuilder b = new StringBuilder();
 671         b.append(key);
 672         b.append(&quot;: &quot;);
 673         boolean isFirstArgument = true;
 674         for (Object arg : args) {
 675             if (isFirstArgument) {
 676                 isFirstArgument = false;
 677             } else {
 678                 b.append(&quot;, &quot;);
 679             }
 680             b.append(arg);
 681         }
 682         System.out.println(b.toString());
 683     }
 684 
 685     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 686     public static boolean isRtl(Resources res) {
 687         return (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &amp;&amp;
 688                 (res.getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL);
 689     }
 690 
 691     public static void assertWorkerThread() {
 692         if (LauncherAppState.isDogfoodBuild() &amp;&amp;
 693                 (LauncherModel.sWorkerThread.getThreadId() != Process.myTid())) {
 694             throw new IllegalStateException();
 695         }
 696     }
 697 
 698     /**
 699      * Returns true if the intent is a valid launch intent for a launcher activity of an app.
 700      * This is used to identify shortcuts which are different from the ones exposed by the
 701      * applications&#x27; manifest file.
 702      *
 703      * @param launchIntent The intent that will be launched when the shortcut is clicked.
 704      */
 705     public static boolean isLauncherAppTarget(Intent launchIntent) {
 706         if (launchIntent != null
 707                 &amp;&amp; Intent.ACTION_MAIN.equals(launchIntent.getAction())
 708                 &amp;&amp; launchIntent.getComponent() != null
 709                 &amp;&amp; launchIntent.getCategories() != null
 710                 &amp;&amp; launchIntent.getCategories().size() == 1
 711                 &amp;&amp; launchIntent.hasCategory(Intent.CATEGORY_LAUNCHER)
 712                 &amp;&amp; TextUtils.isEmpty(launchIntent.getDataString())) {
 713             // An app target can either have no extra or have ItemInfo.EXTRA_PROFILE.
 714             Bundle extras = launchIntent.getExtras();
 715             if (extras == null) {
 716                 return true;
 717             } else {
 718                 Set&lt;String&gt; keys = extras.keySet();
 719                 return keys.size() == 1 &amp;&amp; keys.contains(ItemInfo.EXTRA_PROFILE);
 720             }
 721         };
 722         return false;
 723     }
 724 
 725     public static float dpiFromPx(int size, DisplayMetrics metrics){
 726         float densityRatio = (float) metrics.densityDpi / DisplayMetrics.DENSITY_DEFAULT;
 727         return (size / densityRatio);
 728     }
 729     public static int pxFromDp(float size, DisplayMetrics metrics) {
 730         return (int) Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
 731                 size, metrics));
 732     }
 733     public static int pxFromSp(float size, DisplayMetrics metrics) {
 734         return (int) Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,
 735                 size, metrics));
 736     }
 737 
 738     public static String createDbSelectionQuery(String columnName, Iterable&lt;?&gt; values) {
 739         return String.format(Locale.ENGLISH, &quot;%s IN (%s)&quot;, columnName, TextUtils.join(&quot;, &quot;, values));
 740     }
 741 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.annotation.TargetApi;
  20 import android.app.Activity;
  21 import android.app.SearchManager;
  22 import android.appwidget.AppWidgetManager;
  23 import android.appwidget.AppWidgetProviderInfo;
  24 import android.content.ActivityNotFoundException;
  25 import android.content.ComponentName;
  26 import android.content.Context;
  27 import android.content.Intent;
  28 import android.content.SharedPreferences;
  29 import android.content.pm.ApplicationInfo;
  30 import android.content.pm.PackageInfo;
  31 import android.content.pm.PackageManager;
  32 import android.content.pm.PackageManager.NameNotFoundException;
  33 import android.content.pm.ResolveInfo;
  34 import android.content.res.Resources;
  35 import android.database.Cursor;
  36 import android.graphics.Bitmap;
  37 import android.graphics.BitmapFactory;
  38 import android.graphics.Canvas;
  39 import android.graphics.Color;
  40 import android.graphics.Matrix;
  41 import android.graphics.Paint;
  42 import android.graphics.PaintFlagsDrawFilter;
  43 import android.graphics.Rect;
  44 import android.graphics.drawable.BitmapDrawable;
  45 import android.graphics.drawable.Drawable;
  46 import android.graphics.drawable.PaintDrawable;
  47 import android.os.Build;
  48 import android.os.Bundle;
  49 import android.os.Process;
  50 import android.text.TextUtils;
  51 import android.util.DisplayMetrics;
  52 import android.util.Log;
  53 import android.util.Pair;
  54 import android.util.SparseArray;
  55 import android.util.TypedValue;
  56 import android.view.View;
  57 import android.widget.Toast;
  58 
  59 import java.io.ByteArrayOutputStream;
  60 import java.io.IOException;
  61 import java.util.ArrayList;
  62 import java.util.Locale;
  63 import java.util.Set;
  64 import java.util.regex.Matcher;
  65 import java.util.regex.Pattern;
  66 
  67 /**
  68  * Various utilities shared amongst the Launcher&#x27;s classes.
  69  */
  70 public final class Utilities {
  71 
  72     private static final String TAG = &quot;Launcher.Utilities&quot;;
  73 
  74     private static final Rect sOldBounds = new Rect();
  75     private static final Canvas sCanvas = new Canvas();
  76 
  77     private static final Pattern sTrimPattern =
  78             Pattern.compile(&quot;^[\\s|\\p{javaSpaceChar}]*(.*)[\\s|\\p{javaSpaceChar}]*$&quot;);
  79 
  80     static {
  81         sCanvas.setDrawFilter(new PaintFlagsDrawFilter(Paint.DITHER_FLAG,
  82                 Paint.FILTER_BITMAP_FLAG));
  83     }
  84     static int sColors[] = { 0xffff0000, 0xff00ff00, 0xff0000ff };
  85     static int sColorIndex = 0;
  86 
  87     private static final int[] sLoc0 = new int[2];
  88     private static final int[] sLoc1 = new int[2];
  89 
  90     // To turn on these properties, type
  91     // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
  92     private static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;
  93     private static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);
  94 
  95     public static final String ALLOW_ROTATION_PREFERENCE_KEY = &quot;pref_allowRotation&quot;;
  96 
  97     public static boolean isPropertyEnabled(String propertyName) {
  98         return Log.isLoggable(propertyName, Log.VERBOSE);
  99     }
 100 
 101     public static boolean isAllowRotationPrefEnabled(Context context, boolean multiProcess) {
 102         SharedPreferences sharedPrefs = context.getSharedPreferences(
 103                 LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE | (multiProcess ?
 104                         Context.MODE_MULTI_PROCESS : 0));
 105         boolean allowRotationPref = sharedPrefs.getBoolean(ALLOW_ROTATION_PREFERENCE_KEY, false);
 106         return sForceEnableRotation || allowRotationPref;
 107     }
 108 
 109     public static boolean isRotationAllowedForDevice(Context context) {
 110         return sForceEnableRotation || context.getResources().getBoolean(R.bool.allow_rotation);
 111     }
 112 
 113     /**
 114      * Indicates if the device is running LMP or higher.
 115      */
 116     public static boolean isLmpOrAbove() {
 117         return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP;
 118     }
 119 
 120     /**
 121      * Returns a bitmap suitable for the all apps view. If the package or the resource do not
 122      * exist, it returns null.
 123      */
 124     public static Bitmap createIconBitmap(String packageName, String resourceName,
 125             Context context) {
 126         PackageManager packageManager = context.getPackageManager();
 127         // the resource
 128         try {
 129             Resources resources = packageManager.getResourcesForApplication(packageName);
 130             if (resources != null) {
 131                 final int id = resources.getIdentifier(resourceName, null, null);
 132                 return createIconBitmap(
 133                         resources.getDrawableForDensity(id, LauncherAppState.getInstance()
 134                                 .getInvariantDeviceProfile().fillResIconDpi), context);
 135             }
 136         } catch (Exception e) {
 137             // Icon not found.
 138         }
 139         return null;
 140     }
 141 
 142     public static boolean isLmpMR1OrAbove() {
 143         // TODO(adamcohen): update to Build.VERSION_CODES.LOLLIPOP_MR1 once building against 22;
 144         return Build.VERSION.SDK_INT &gt;= 22;
 145     }
 146 
 147     public static boolean isLmpMR1() {
 148         // TODO(adamcohen): update to Build.VERSION_CODES.LOLLIPOP_MR1 once building against 22;
 149         return Build.VERSION.SDK_INT == 22;
 150     }
 151 
 152     public static Bitmap createIconBitmap(Cursor c, int iconIndex, Context context) {
 153         byte[] data = c.getBlob(iconIndex);
 154         try {
 155             return createIconBitmap(BitmapFactory.decodeByteArray(data, 0, data.length), context);
 156         } catch (Exception e) {
 157             return null;
 158         }
 159     }
 160 
 161     private static int getIconBitmapSize() {
 162         return LauncherAppState.getInstance().getInvariantDeviceProfile().iconBitmapSize;
 163     }
 164 
 165     /**
 166      * Returns a bitmap which is of the appropriate size to be displayed as an icon
 167      */
 168     public static Bitmap createIconBitmap(Bitmap icon, Context context) {
 169         final int iconBitmapSize = getIconBitmapSize();
 170         if (iconBitmapSize == icon.getWidth() &amp;&amp; iconBitmapSize == icon.getHeight()) {
 171             return icon;
 172         }
 173         return createIconBitmap(new BitmapDrawable(context.getResources(), icon), context);
 174     }
 175 
 176     /**
 177      * Returns a bitmap suitable for the all apps view.
 178      */
 179     public static Bitmap createIconBitmap(Drawable icon, Context context) {
 180         synchronized (sCanvas) {
 181             final int iconBitmapSize = getIconBitmapSize();
 182 
 183             int width = iconBitmapSize;
 184             int height = iconBitmapSize;
 185 
 186             if (icon instanceof PaintDrawable) {
 187                 PaintDrawable painter = (PaintDrawable) icon;
 188                 painter.setIntrinsicWidth(width);
 189                 painter.setIntrinsicHeight(height);
 190             } else if (icon instanceof BitmapDrawable) {
 191                 // Ensure the bitmap has a density.
 192                 BitmapDrawable bitmapDrawable = (BitmapDrawable) icon;
 193                 Bitmap bitmap = bitmapDrawable.getBitmap();
 194                 if (bitmap.getDensity() == Bitmap.DENSITY_NONE) {
 195                     bitmapDrawable.setTargetDensity(context.getResources().getDisplayMetrics());
 196                 }
 197             }
 198             int sourceWidth = icon.getIntrinsicWidth();
 199             int sourceHeight = icon.getIntrinsicHeight();
 200             if (sourceWidth &gt; 0 &amp;&amp; sourceHeight &gt; 0) {
 201                 // Scale the icon proportionally to the icon dimensions
 202                 final float ratio = (float) sourceWidth / sourceHeight;
 203                 if (sourceWidth &gt; sourceHeight) {
 204                     height = (int) (width / ratio);
 205                 } else if (sourceHeight &gt; sourceWidth) {
 206                     width = (int) (height * ratio);
 207                 }
 208             }
 209 
 210             // no intrinsic size --&gt; use default size
 211             int textureWidth = iconBitmapSize;
 212             int textureHeight = iconBitmapSize;
 213 
 214             final Bitmap bitmap = Bitmap.createBitmap(textureWidth, textureHeight,
 215                     Bitmap.Config.ARGB_8888);
 216             final Canvas canvas = sCanvas;
 217             canvas.setBitmap(bitmap);
 218 
 219             final int left = (textureWidth-width) / 2;
 220             final int top = (textureHeight-height) / 2;
 221 
 222             @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
 223             final boolean debug = false;
 224             if (debug) {
 225                 // draw a big box for the icon for debugging
 226                 canvas.drawColor(sColors[sColorIndex]);
 227                 if (++sColorIndex &gt;= sColors.length) sColorIndex = 0;
 228                 Paint debugPaint = new Paint();
 229                 debugPaint.setColor(0xffcccc00);
 230                 canvas.drawRect(left, top, left+width, top+height, debugPaint);
 231             }
 232 
 233             sOldBounds.set(icon.getBounds());
 234             icon.setBounds(left, top, left+width, top+height);
 235             icon.draw(canvas);
 236             icon.setBounds(sOldBounds);
 237             canvas.setBitmap(null);
 238 
 239             return bitmap;
 240         }
 241     }
 242 
 243     /**
 244      * Given a coordinate relative to the descendant, find the coordinate in a parent view&#x27;s
 245      * coordinates.
 246      *
 247      * @param descendant The descendant to which the passed coordinate is relative.
 248      * @param root The root view to make the coordinates relative to.
 249      * @param coord The coordinate that we want mapped.
 250      * @param includeRootScroll Whether or not to account for the scroll of the descendant:
 251      *          sometimes this is relevant as in a child&#x27;s coordinates within the descendant.
 252      * @return The factor by which this descendant is scaled relative to this DragLayer. Caution
 253      *         this scale factor is assumed to be equal in X and Y, and so if at any point this
 254      *         assumption fails, we will need to return a pair of scale factors.
 255      */
 256     public static float getDescendantCoordRelativeToParent(View descendant, View root,
 257                                                            int[] coord, boolean includeRootScroll) {
 258         ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 259 
 260         float[] pt = {coord[0], coord[1]};
 261 
 262         View v = descendant;
 263         while(v != root &amp;&amp; v != null) {
 264             ancestorChain.add(v);
 265             v = (View) v.getParent();
 266         }
 267         ancestorChain.add(root);
 268 
 269         float scale = 1.0f;
 270         int count = ancestorChain.size();
 271         for (int i = 0; i &lt; count; i++) {
 272             View v0 = ancestorChain.get(i);
 273             // For TextViews, scroll has a meaning which relates to the text position
 274             // which is very strange... ignore the scroll.
 275             if (v0 != descendant || includeRootScroll) {
 276                 pt[0] -= v0.getScrollX();
 277                 pt[1] -= v0.getScrollY();
 278             }
 279 
 280             v0.getMatrix().mapPoints(pt);
 281             pt[0] += v0.getLeft();
 282             pt[1] += v0.getTop();
 283             scale *= v0.getScaleX();
 284         }
 285 
 286         coord[0] = (int) Math.round(pt[0]);
 287         coord[1] = (int) Math.round(pt[1]);
 288         return scale;
 289     }
 290 
 291     /**
 292      * Inverse of {@link #getDescendantCoordRelativeToSelf(View, int[])}.
 293      */
 294     public static float mapCoordInSelfToDescendent(View descendant, View root,
 295                                                    int[] coord) {
 296         ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 297 
 298         float[] pt = {coord[0], coord[1]};
 299 
 300         View v = descendant;
 301         while(v != root) {
 302             ancestorChain.add(v);
 303             v = (View) v.getParent();
 304         }
 305         ancestorChain.add(root);
 306 
 307         float scale = 1.0f;
 308         Matrix inverse = new Matrix();
 309         int count = ancestorChain.size();
 310         for (int i = count - 1; i &gt;= 0; i--) {
 311             View ancestor = ancestorChain.get(i);
 312             View next = i &gt; 0 ? ancestorChain.get(i-1) : null;
 313 
 314             pt[0] += ancestor.getScrollX();
 315             pt[1] += ancestor.getScrollY();
 316 
 317             if (next != null) {
 318                 pt[0] -= next.getLeft();
 319                 pt[1] -= next.getTop();
 320                 next.getMatrix().invert(inverse);
 321                 inverse.mapPoints(pt);
 322                 scale *= next.getScaleX();
 323             }
 324         }
 325 
 326         coord[0] = (int) Math.round(pt[0]);
 327         coord[1] = (int) Math.round(pt[1]);
 328         return scale;
 329     }
 330 
 331     /**
 332      * Utility method to determine whether the given point, in local coordinates,
 333      * is inside the view, where the area of the view is expanded by the slop factor.
 334      * This method is called while processing touch-move events to determine if the event
 335      * is still within the view.
 336      */
 337     public static boolean pointInView(View v, float localX, float localY, float slop) {
 338         return localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; (v.getWidth() + slop) &amp;&amp;
 339                 localY &lt; (v.getHeight() + slop);
 340     }
 341 
 342     public static void scaleRect(Rect r, float scale) {
 343         if (scale != 1.0f) {
 344             r.left = (int) (r.left * scale + 0.5f);
 345             r.top = (int) (r.top * scale + 0.5f);
 346             r.right = (int) (r.right * scale + 0.5f);
 347             r.bottom = (int) (r.bottom * scale + 0.5f);
 348         }
 349     }
 350 
 351     public static int[] getCenterDeltaInScreenSpace(View v0, View v1, int[] delta) {
 352         v0.getLocationInWindow(sLoc0);
 353         v1.getLocationInWindow(sLoc1);
 354 
 355         sLoc0[0] += (v0.getMeasuredWidth() * v0.getScaleX()) / 2;
 356         sLoc0[1] += (v0.getMeasuredHeight() * v0.getScaleY()) / 2;
 357         sLoc1[0] += (v1.getMeasuredWidth() * v1.getScaleX()) / 2;
 358         sLoc1[1] += (v1.getMeasuredHeight() * v1.getScaleY()) / 2;
 359 
 360         if (delta == null) {
 361             delta = new int[2];
 362         }
 363 
 364         delta[0] = sLoc1[0] - sLoc0[0];
 365         delta[1] = sLoc1[1] - sLoc0[1];
 366 
 367         return delta;
 368     }
 369 
 370     public static void scaleRectAboutCenter(Rect r, float scale) {
 371         int cx = r.centerX();
 372         int cy = r.centerY();
 373         r.offset(-cx, -cy);
 374         Utilities.scaleRect(r, scale);
 375         r.offset(cx, cy);
 376     }
 377 
 378     public static void startActivityForResultSafely(
 379             Activity activity, Intent intent, int requestCode) {
 380         try {
 381             activity.startActivityForResult(intent, requestCode);
 382         } catch (ActivityNotFoundException e) {
 383             Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 384         } catch (SecurityException e) {
 385             Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 386             Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +
 387                     &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +
 388                     &quot;or use the exported attribute for this activity.&quot;, e);
 389         }
 390     }
 391 
 392     static boolean isSystemApp(Context context, Intent intent) {
 393         PackageManager pm = context.getPackageManager();
 394         ComponentName cn = intent.getComponent();
 395         String packageName = null;
 396         if (cn == null) {
 397             ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
 398             if ((info != null) &amp;&amp; (info.activityInfo != null)) {
 399                 packageName = info.activityInfo.packageName;
 400             }
 401         } else {
 402             packageName = cn.getPackageName();
 403         }
 404         if (packageName != null) {
 405             try {
 406                 PackageInfo info = pm.getPackageInfo(packageName, 0);
 407                 return (info != null) &amp;&amp; (info.applicationInfo != null) &amp;&amp;
 408                         ((info.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0);
 409             } catch (NameNotFoundException e) {
 410                 return false;
 411             }
 412         } else {
 413             return false;
 414         }
 415     }
 416 
 417     /**
 418      * This picks a dominant color, looking for high-saturation, high-value, repeated hues.
 419      * @param bitmap The bitmap to scan
 420      * @param samples The approximate max number of samples to use.
 421      */
 422     static int findDominantColorByHue(Bitmap bitmap, int samples) {
 423         final int height = bitmap.getHeight();
 424         final int width = bitmap.getWidth();
 425         int sampleStride = (int) Math.sqrt((height * width) / samples);
 426         if (sampleStride &lt; 1) {
 427             sampleStride = 1;
 428         }
 429 
 430         // This is an out-param, for getting the hsv values for an rgb
 431         float[] hsv = new float[3];
 432 
 433         // First get the best hue, by creating a histogram over 360 hue buckets,
 434         // where each pixel contributes a score weighted by saturation, value, and alpha.
 435         float[] hueScoreHistogram = new float[360];
 436         float highScore = -1;
 437         int bestHue = -1;
 438 
 439         for (int y = 0; y &lt; height; y += sampleStride) {
 440             for (int x = 0; x &lt; width; x += sampleStride) {
 441                 int argb = bitmap.getPixel(x, y);
 442                 int alpha = 0xFF &amp; (argb &gt;&gt; 24);
 443                 if (alpha &lt; 0x80) {
 444                     // Drop mostly-transparent pixels.
 445                     continue;
 446                 }
 447                 // Remove the alpha channel.
 448                 int rgb = argb | 0xFF000000;
 449                 Color.colorToHSV(rgb, hsv);
 450                 // Bucket colors by the 360 integer hues.
 451                 int hue = (int) hsv[0];
 452                 if (hue &lt; 0 || hue &gt;= hueScoreHistogram.length) {
 453                     // Defensively avoid array bounds violations.
 454                     continue;
 455                 }
 456                 float score = hsv[1] * hsv[2];
 457                 hueScoreHistogram[hue] += score;
 458                 if (hueScoreHistogram[hue] &gt; highScore) {
 459                     highScore = hueScoreHistogram[hue];
 460                     bestHue = hue;
 461                 }
 462             }
 463         }
 464 
 465         SparseArray&lt;Float&gt; rgbScores = new SparseArray&lt;Float&gt;();
 466         int bestColor = 0xff000000;
 467         highScore = -1;
 468         // Go back over the RGB colors that match the winning hue,
 469         // creating a histogram of weighted s*v scores, for up to 100*100 [s,v] buckets.
 470         // The highest-scoring RGB color wins.
 471         for (int y = 0; y &lt; height; y += sampleStride) {
 472             for (int x = 0; x &lt; width; x += sampleStride) {
 473                 int rgb = bitmap.getPixel(x, y) | 0xff000000;
 474                 Color.colorToHSV(rgb, hsv);
 475                 int hue = (int) hsv[0];
 476                 if (hue == bestHue) {
 477                     float s = hsv[1];
 478                     float v = hsv[2];
 479                     int bucket = (int) (s * 100) + (int) (v * 10000);
 480                     // Score by cumulative saturation * value.
 481                     float score = s * v;
 482                     Float oldTotal = rgbScores.get(bucket);
 483                     float newTotal = oldTotal == null ? score : oldTotal + score;
 484                     rgbScores.put(bucket, newTotal);
 485                     if (newTotal &gt; highScore) {
 486                         highScore = newTotal;
 487                         // All the colors in the winning bucket are very similar. Last in wins.
 488                         bestColor = rgb;
 489                     }
 490                 }
 491             }
 492         }
 493         return bestColor;
 494     }
 495 
 496     /*
 497      * Finds a system apk which had a broadcast receiver listening to a particular action.
 498      * @param action intent action used to find the apk
 499      * @return a pair of apk package name and the resources.
 500      */
 501     static Pair&lt;String, Resources&gt; findSystemApk(String action, PackageManager pm) {
 502         final Intent intent = new Intent(action);
 503         for (ResolveInfo info : pm.queryBroadcastReceivers(intent, 0)) {
 504             if (info.activityInfo != null &amp;&amp;
 505                     (info.activityInfo.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 506                 final String packageName = info.activityInfo.packageName;
 507                 try {
 508                     final Resources res = pm.getResourcesForApplication(packageName);
 509                     return Pair.create(packageName, res);
 510                 } catch (NameNotFoundException e) {
 511                     Log.w(TAG, &quot;Failed to find resources for &quot; + packageName);
 512                 }
 513             }
 514         }
 515         return null;
 516     }
 517 
 518     @TargetApi(Build.VERSION_CODES.KITKAT)
 519     public static boolean isViewAttachedToWindow(View v) {
 520         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
 521             return v.isAttachedToWindow();
 522         } else {
 523             // A proxy call which returns null, if the view is not attached to the window.
 524             return v.getKeyDispatcherState() != null;
 525         }
 526     }
 527 
 528     /**
 529      * Returns a widget with category {@link AppWidgetProviderInfo#WIDGET_CATEGORY_SEARCHBOX}
 530      * provided by the same package which is set to be global search activity.
 531      * If widgetCategory is not supported, or no such widget is found, returns the first widget
 532      * provided by the package.
 533      */
 534     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 535     public static AppWidgetProviderInfo getSearchWidgetProvider(Context context) {
 536         SearchManager searchManager =
 537                 (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
 538         ComponentName searchComponent = searchManager.getGlobalSearchActivity();
 539         if (searchComponent == null) return null;
 540         String providerPkg = searchComponent.getPackageName();
 541 
 542         AppWidgetProviderInfo defaultWidgetForSearchPackage = null;
 543 
 544         AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
 545         for (AppWidgetProviderInfo info : appWidgetManager.getInstalledProviders()) {
 546             if (info.provider.getPackageName().equals(providerPkg)) {
 547                 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {
 548                     if ((info.widgetCategory &amp; AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX) != 0) {
 549                         return info;
 550                     } else if (defaultWidgetForSearchPackage == null) {
 551                         defaultWidgetForSearchPackage = info;
 552                     }
 553                 } else {
 554                     return info;
 555                 }
 556             }
 557         }
 558         return defaultWidgetForSearchPackage;
 559     }
 560 
 561     /**
 562      * Compresses the bitmap to a byte array for serialization.
 563      */
 564     public static byte[] flattenBitmap(Bitmap bitmap) {
 565         // Try go guesstimate how much space the icon will take when serialized
 566         // to avoid unnecessary allocations/copies during the write.
 567         int size = bitmap.getWidth() * bitmap.getHeight() * 4;
 568         ByteArrayOutputStream out = new ByteArrayOutputStream(size);
 569         try {
 570             bitmap.compress(Bitmap.CompressFormat.PNG, 100, out);
 571             out.flush();
 572             out.close();
 573             return out.toByteArray();
 574         } catch (IOException e) {
 575             Log.w(TAG, &quot;Could not write bitmap&quot;);
 576             return null;
 577         }
 578     }
 579 
 580     /**
 581      * Find the first vacant cell, if there is one.
 582      *
 583      * @param vacant Holds the x and y coordinate of the vacant cell
 584      * @param spanX Horizontal cell span.
 585      * @param spanY Vertical cell span.
 586      *
 587      * @return true if a vacant cell was found
 588      */
 589     public static boolean findVacantCell(int[] vacant, int spanX, int spanY,
 590             int xCount, int yCount, boolean[][] occupied) {
 591 
 592         for (int y = 0; (y + spanY) &lt;= yCount; y++) {
 593             for (int x = 0; (x + spanX) &lt;= xCount; x++) {
 594                 boolean available = !occupied[x][y];
 595                 out:            for (int i = x; i &lt; x + spanX; i++) {
 596                     for (int j = y; j &lt; y + spanY; j++) {
 597                         available = available &amp;&amp; !occupied[i][j];
 598                         if (!available) break out;
 599                     }
 600                 }
 601 
 602                 if (available) {
 603                     vacant[0] = x;
 604                     vacant[1] = y;
 605                     return true;
 606                 }
 607             }
 608         }
 609 
 610         return false;
 611     }
 612 
 613     /**
 614      * Trims the string, removing all whitespace at the beginning and end of the string.
 615      * Non-breaking whitespaces are also removed.
 616      */
 617     public static String trim(CharSequence s) {
 618         if (s == null) {
 619             return null;
 620         }
 621 
 622         // Just strip any sequence of whitespace or java space characters from the beginning and end
 623         Matcher m = sTrimPattern.matcher(s);
 624         return m.replaceAll(&quot;$1&quot;);
 625     }
 626 
 627     /**
 628      * Calculates the height of a given string at a specific text size.
 629      */
 630     public static float calculateTextHeight(float textSizePx) {
 631         Paint p = new Paint();
 632         p.setTextSize(textSizePx);
 633         Paint.FontMetrics fm = p.getFontMetrics();
 634         return -fm.top + fm.bottom;
 635     }
 636 
 637     /**
 638      * Convenience println with multiple args.
 639      */
 640     public static void println(String key, Object... args) {
 641         StringBuilder b = new StringBuilder();
 642         b.append(key);
 643         b.append(&quot;: &quot;);
 644         boolean isFirstArgument = true;
 645         for (Object arg : args) {
 646             if (isFirstArgument) {
 647                 isFirstArgument = false;
 648             } else {
 649                 b.append(&quot;, &quot;);
 650             }
 651             b.append(arg);
 652         }
 653         System.out.println(b.toString());
 654     }
 655 
 656     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 657     public static boolean isRtl(Resources res) {
 658         return (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &amp;&amp;
 659                 (res.getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL);
 660     }
 661 
 662     public static void assertWorkerThread() {
 663         if (LauncherAppState.isDogfoodBuild() &amp;&amp;
 664                 (LauncherModel.sWorkerThread.getThreadId() != Process.myTid())) {
 665             throw new IllegalStateException();
 666         }
 667     }
 668 
 669     /**
 670      * Returns true if the intent is a valid launch intent for a launcher activity of an app.
 671      * This is used to identify shortcuts which are different from the ones exposed by the
 672      * applications&#x27; manifest file.
 673      *
 674      * @param launchIntent The intent that will be launched when the shortcut is clicked.
 675      */
 676     public static boolean isLauncherAppTarget(Intent launchIntent) {
 677         if (launchIntent != null
 678                 &amp;&amp; Intent.ACTION_MAIN.equals(launchIntent.getAction())
 679                 &amp;&amp; launchIntent.getComponent() != null
 680                 &amp;&amp; launchIntent.getCategories() != null
 681                 &amp;&amp; launchIntent.getCategories().size() == 1
 682                 &amp;&amp; launchIntent.hasCategory(Intent.CATEGORY_LAUNCHER)
 683                 &amp;&amp; TextUtils.isEmpty(launchIntent.getDataString())) {
 684             // An app target can either have no extra or have ItemInfo.EXTRA_PROFILE.
 685             Bundle extras = launchIntent.getExtras();
 686             if (extras == null) {
 687                 return true;
 688             } else {
 689                 Set&lt;String&gt; keys = extras.keySet();
 690                 return keys.size() == 1 &amp;&amp; keys.contains(ItemInfo.EXTRA_PROFILE);
 691             }
 692         };
 693         return false;
 694     }
 695 
 696     public static float dpiFromPx(int size, DisplayMetrics metrics){
 697         float densityRatio = (float) metrics.densityDpi / DisplayMetrics.DENSITY_DEFAULT;
 698         return (size / densityRatio);
 699     }
 700     public static int pxFromDp(float size, DisplayMetrics metrics) {
 701         return (int) Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,
 702                 size, metrics));
 703     }
 704     public static int pxFromSp(float size, DisplayMetrics metrics) {
 705         return (int) Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,
 706                 size, metrics));
 707     }
 708 
 709     public static String createDbSelectionQuery(String columnName, Iterable&lt;?&gt; values) {
 710         return String.format(Locale.ENGLISH, &quot;%s IN (%s)&quot;, columnName, TextUtils.join(&quot;, &quot;, values));
 711     }
 712 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.annotation.TargetApi;
  19 import android.app.Activity;
  20 import android.app.SearchManager;
  21 import android.appwidget.AppWidgetManager;
  22 import android.appwidget.AppWidgetProviderInfo;
  23 import android.content.ActivityNotFoundException;
  24 import android.content.ComponentName;
  25 import android.content.Context;
  26 import android.content.Intent;
  27 import android.content.SharedPreferences;
  28 import android.content.pm.ApplicationInfo;
  29 import android.content.pm.PackageInfo;
  30 import android.content.pm.PackageManager.NameNotFoundException;
  31 import android.content.pm.PackageManager;
  32 import android.content.pm.ResolveInfo;
  33 import android.content.res.Resources;
  34 import android.database.Cursor;
  35 import android.graphics.Bitmap;
  36 import android.graphics.BitmapFactory;
  37 import android.graphics.Canvas;
  38 import android.graphics.Color;
  39 import android.graphics.Matrix;
  40 import android.graphics.Paint;
  41 import android.graphics.PaintFlagsDrawFilter;
  42 import android.graphics.Rect;
  43 import android.graphics.drawable.BitmapDrawable;
  44 import android.graphics.drawable.Drawable;
  45 import android.graphics.drawable.PaintDrawable;
  46 import android.os.Build;
  47 import android.os.Bundle;
  48 import android.os.Process;
  49 import android.text.TextUtils;
  50 import android.util.DisplayMetrics;
  51 import android.util.Log;
  52 import android.util.Pair;
  53 import android.util.SparseArray;
  54 import android.util.TypedValue;
  55 import android.view.View;
  56 import android.widget.Toast;
  57 import java.io.ByteArrayOutputStream;
  58 import java.io.IOException;
  59 import java.util.ArrayList;
  60 import java.util.Locale;
  61 import java.util.Set;
  62 import java.util.regex.Matcher;
  63 import java.util.regex.Pattern;
  64 
  65 
  66 /**
  67  * Various utilities shared amongst the Launcher&#x27;s classes.
  68  */
  69 public final class Utilities {
  70     private static final String TAG = &quot;Launcher.Utilities&quot;;
  71 
  72     private static final Rect sOldBounds = new Rect();
  73 
  74     private static final Canvas sCanvas = new Canvas();
  75 
<abbr title="  76     private static final Pattern sTrimPattern = Pattern.compile(&quot;^[\\s|\\p{javaSpaceChar}]*(.*)[\\s|\\p{javaSpaceChar}]*$&quot;);">  76     private static final Pattern sTrimPattern = Pattern.compile(&quot;^[\\s|\\p{javaSpaceChar}]*(.*)[\\s|\\p{j🔵</abbr>
  77 
  78     static {
  79         sCanvas.setDrawFilter(new PaintFlagsDrawFilter(Paint.DITHER_FLAG, Paint.FILTER_BITMAP_FLAG));
  80     }
  81 
  82     static int[] sColors = new int[]{ 0xffff0000, 0xff00ff00, 0xff0000ff };
  83 
  84     static int sColorIndex = 0;
  85 
  86     private static final int[] sLoc0 = new int[2];
  87 
  88     private static final int[] sLoc1 = new int[2];
  89 
  90     // To turn on these properties, type
  91     // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
  92     private static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;
  93 
  94     private static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);
  95 
  96     public static final String ALLOW_ROTATION_PREFERENCE_KEY = &quot;pref_allowRotation&quot;;
  97 
  98     public static boolean isPropertyEnabled(String propertyName) {
  99         return Log.isLoggable(propertyName, Log.VERBOSE);
 100     }
 101 
 102     public static boolean isAllowRotationPrefEnabled(Context context, boolean multiProcess) {
<abbr title=" 103         SharedPreferences sharedPrefs = context.getSharedPreferences(LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE | (multiProcess ? Context.MODE_MULTI_PROCESS : 0));"> 103         SharedPreferences sharedPrefs = context.getSharedPreferences(LauncherAppState.getSharedPreference🔵</abbr>
 104         boolean allowRotationPref = sharedPrefs.getBoolean(ALLOW_ROTATION_PREFERENCE_KEY, false);
 105         return sForceEnableRotation || allowRotationPref;
 106     }
 107 
 108     public static boolean isRotationAllowedForDevice(Context context) {
 109         return sForceEnableRotation || context.getResources().getBoolean(R.bool.allow_rotation);
 110     }
 111 
 112     /**
 113      * Indicates if the device is running LMP or higher.
 114      */
 115     public static boolean isLmpOrAbove() {
 116         return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP;
 117     }
 118 
 119     public static boolean isLmpMR1OrAbove() {
 120         // TODO(adamcohen): update to Build.VERSION_CODES.LOLLIPOP_MR1 once building against 22;
 121         return Build.VERSION.SDK_INT &gt;= 22;
 122     }
 123 
 124     public static boolean isLmpMR1() {
 125         // TODO(adamcohen): update to Build.VERSION_CODES.LOLLIPOP_MR1 once building against 22;
 126         return Build.VERSION.SDK_INT == 22;
 127     }
 128 
 129     public static Bitmap createIconBitmap(Cursor c, int iconIndex, Context context) {
 130         byte[] data = c.getBlob(iconIndex);
 131         try {
 132             return createIconBitmap(BitmapFactory.decodeByteArray(data, 0, data.length), context);
 133         } catch (java.lang.Exception e) {
 134             return null;
 135         }
 136     }
 137 
 138     /**
 139      * Returns a bitmap suitable for the all apps view. If the package or the resource do not
 140      * exist, it returns null.
 141      */
 142     public static Bitmap createIconBitmap(String packageName, String resourceName, Context context) {
 143         PackageManager packageManager = context.getPackageManager();
 144         // the resource
 145         try {
 146             Resources resources = packageManager.getResourcesForApplication(packageName);
 147             if (resources != null) {
 148                 final int id = resources.getIdentifier(resourceName, null, null);
<abbr title=" 149                 return createIconBitmap(resources.getDrawableForDensity(id, LauncherAppState.getInstance().getInvariantDeviceProfile().fillResIconDpi), context);"> 149                 return createIconBitmap(resources.getDrawableForDensity(id, LauncherAppState.getInstance(🔵</abbr>
 150             }
 151         } catch (java.lang.Exception e) {
 152             // Icon not found.
 153         }
 154         return null;
 155     }
 156 
 157     private static int getIconBitmapSize() {
 158         return LauncherAppState.getInstance().getInvariantDeviceProfile().iconBitmapSize;
 159     }
 160 
 161     /**
 162      * Returns a bitmap which is of the appropriate size to be displayed as an icon
 163      */
 164     public static Bitmap createIconBitmap(Bitmap icon, Context context) {
 165         final int iconBitmapSize = getIconBitmapSize();
 166         if ((iconBitmapSize == icon.getWidth()) &amp;&amp; (iconBitmapSize == icon.getHeight())) {
 167             return icon;
 168         }
 169         return createIconBitmap(new BitmapDrawable(context.getResources(), icon), context);
 170     }
 171 
 172     /**
 173      * Returns a bitmap suitable for the all apps view.
 174      */
 175     public static Bitmap createIconBitmap(Drawable icon, Context context) {
 176         synchronized(sCanvas) {
 177             final int iconBitmapSize = getIconBitmapSize();
 178             int width = iconBitmapSize;
 179             int height = iconBitmapSize;
 180             if (icon instanceof PaintDrawable) {
 181                 PaintDrawable painter = ((PaintDrawable) (icon));
 182                 painter.setIntrinsicWidth(width);
 183                 painter.setIntrinsicHeight(height);
 184             } else if (icon instanceof BitmapDrawable) {
 185                 // Ensure the bitmap has a density.
 186                 BitmapDrawable bitmapDrawable = ((BitmapDrawable) (icon));
 187                 Bitmap bitmap = bitmapDrawable.getBitmap();
 188                 if (bitmap.getDensity() == Bitmap.DENSITY_NONE) {
 189                     bitmapDrawable.setTargetDensity(context.getResources().getDisplayMetrics());
 190                 }
 191             }
 192             int sourceWidth = icon.getIntrinsicWidth();
 193             int sourceHeight = icon.getIntrinsicHeight();
 194             if ((sourceWidth &gt; 0) &amp;&amp; (sourceHeight &gt; 0)) {
 195                 // Scale the icon proportionally to the icon dimensions
 196                 final float ratio = ((float) (sourceWidth)) / sourceHeight;
 197                 if (sourceWidth &gt; sourceHeight) {
 198                     height = ((int) (width / ratio));
 199                 } else if (sourceHeight &gt; sourceWidth) {
 200                     width = ((int) (height * ratio));
 201                 }
 202             }
 203             // no intrinsic size --&gt; use default size
 204             int textureWidth = iconBitmapSize;
 205             int textureHeight = iconBitmapSize;
<abbr title=" 206             final Bitmap bitmap = Bitmap.createBitmap(textureWidth, textureHeight, Bitmap.Config.ARGB_8888);"> 206             final Bitmap bitmap = Bitmap.createBitmap(textureWidth, textureHeight, Bitmap.Config.ARGB_888🔵</abbr>
 207             final Canvas canvas = sCanvas;
 208             canvas.setBitmap(bitmap);
 209             final int left = (textureWidth - width) / 2;
 210             final int top = (textureHeight - height) / 2;
 211             // suppress dead code warning
 212             @SuppressWarnings(&quot;all&quot;)
 213             final boolean debug = false;
 214             if (debug) {
 215                 // draw a big box for the icon for debugging
 216                 canvas.drawColor(sColors[sColorIndex]);
 217                 if ((++sColorIndex) &gt;= Utilities.sColors.length) {
 218                     sColorIndex = 0;
 219                 }
 220                 Paint debugPaint = new Paint();
 221                 debugPaint.setColor(0xffcccc00);
 222                 canvas.drawRect(left, top, left + width, top + height, debugPaint);
 223             }
 224             sOldBounds.set(icon.getBounds());
 225             icon.setBounds(left, top, left + width, top + height);
 226             icon.draw(canvas);
 227             icon.setBounds(sOldBounds);
 228             canvas.setBitmap(null);
 229             return bitmap;
 230         }
 231     }
 232 
 233     /**
 234      * Given a coordinate relative to the descendant, find the coordinate in a parent view&#x27;s
 235      * coordinates.
 236      *
 237      * @param descendant The descendant to which the passed coordinate is relative.
 238      * @param root The root view to make the coordinates relative to.
 239      * @param coord The coordinate that we want mapped.
 240      * @param includeRootScroll Whether or not to account for the scroll of the descendant:
 241      *          sometimes this is relevant as in a child&#x27;s coordinates within the descendant.
 242      * @return The factor by which this descendant is scaled relative to this DragLayer. Caution
 243      *         this scale factor is assumed to be equal in X and Y, and so if at any point this
 244      *         assumption fails, we will need to return a pair of scale factors.
 245      */
 246     public static float getDescendantCoordRelativeToParent(View descendant, View root,
 247                                                            int[] coord, boolean includeRootScroll) {
 248         ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 249 
 250         float[] pt = {coord[0], coord[1]};
 251 
 252         View v = descendant;
 253         while(v != root &amp;&amp; v != null) {
 254             ancestorChain.add(v);
 255             v = (View) v.getParent();
 256         }
 257         ancestorChain.add(root);
 258 
 259         float scale = 1.0f;
 260         int count = ancestorChain.size();
 261         for (int i = 0; i &lt; count; i++) {
 262             View v0 = ancestorChain.get(i);
 263             // For TextViews, scroll has a meaning which relates to the text position
 264             // which is very strange... ignore the scroll.
 265             if (v0 != descendant || includeRootScroll) {
 266                 pt[0] -= v0.getScrollX();
 267                 pt[1] -= v0.getScrollY();
 268             }
 269 
 270             v0.getMatrix().mapPoints(pt);
 271             pt[0] += v0.getLeft();
 272             pt[1] += v0.getTop();
 273             scale *= v0.getScaleX();
 274         }
 275 
 276         coord[0] = (int) Math.round(pt[0]);
 277         coord[1] = (int) Math.round(pt[1]);
 278         return scale;
 279     }
 280 
 281     /**
 282      * Inverse of {@link #getDescendantCoordRelativeToSelf(View, int[])}.
 283      */
 284     public static float mapCoordInSelfToDescendent(View descendant, View root,
 285                                                    int[] coord) {
 286         ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 287 
 288         float[] pt = {coord[0], coord[1]};
 289 
 290         View v = descendant;
 291         while(v != root) {
 292             ancestorChain.add(v);
 293             v = (View) v.getParent();
 294         }
 295         ancestorChain.add(root);
 296 
 297         float scale = 1.0f;
 298         Matrix inverse = new Matrix();
 299         int count = ancestorChain.size();
 300         for (int i = count - 1; i &gt;= 0; i--) {
 301             View ancestor = ancestorChain.get(i);
 302             View next = i &gt; 0 ? ancestorChain.get(i-1) : null;
 303 
 304             pt[0] += ancestor.getScrollX();
 305             pt[1] += ancestor.getScrollY();
 306 
 307             if (next != null) {
 308                 pt[0] -= next.getLeft();
 309                 pt[1] -= next.getTop();
 310                 next.getMatrix().invert(inverse);
 311                 inverse.mapPoints(pt);
 312                 scale *= next.getScaleX();
 313             }
 314         }
 315 
 316         coord[0] = (int) Math.round(pt[0]);
 317         coord[1] = (int) Math.round(pt[1]);
 318         return scale;
 319     }
 320 
 321     /**
 322      * Utility method to determine whether the given point, in local coordinates,
 323      * is inside the view, where the area of the view is expanded by the slop factor.
 324      * This method is called while processing touch-move events to determine if the event
 325      * is still within the view.
 326      */
 327     public static boolean pointInView(View v, float localX, float localY, float slop) {
 328         return localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; (v.getWidth() + slop) &amp;&amp;
 329                 localY &lt; (v.getHeight() + slop);
 330     }
 331 
 332     public static void scaleRect(Rect r, float scale) {
 333         if (scale != 1.0f) {
 334             r.left = (int) (r.left * scale + 0.5f);
 335             r.top = (int) (r.top * scale + 0.5f);
 336             r.right = (int) (r.right * scale + 0.5f);
 337             r.bottom = (int) (r.bottom * scale + 0.5f);
 338         }
 339     }
 340 
 341     public static int[] getCenterDeltaInScreenSpace(View v0, View v1, int[] delta) {
 342         v0.getLocationInWindow(sLoc0);
 343         v1.getLocationInWindow(sLoc1);
 344 
 345         sLoc0[0] += (v0.getMeasuredWidth() * v0.getScaleX()) / 2;
 346         sLoc0[1] += (v0.getMeasuredHeight() * v0.getScaleY()) / 2;
 347         sLoc1[0] += (v1.getMeasuredWidth() * v1.getScaleX()) / 2;
 348         sLoc1[1] += (v1.getMeasuredHeight() * v1.getScaleY()) / 2;
 349 
 350         if (delta == null) {
 351             delta = new int[2];
 352         }
 353 
 354         delta[0] = sLoc1[0] - sLoc0[0];
 355         delta[1] = sLoc1[1] - sLoc0[1];
 356 
 357         return delta;
 358     }
 359 
 360     public static void scaleRectAboutCenter(Rect r, float scale) {
 361         int cx = r.centerX();
 362         int cy = r.centerY();
 363         r.offset(-cx, -cy);
 364         Utilities.scaleRect(r, scale);
 365         r.offset(cx, cy);
 366     }
 367 
 368     public static void startActivityForResultSafely(
 369             Activity activity, Intent intent, int requestCode) {
 370         try {
 371             activity.startActivityForResult(intent, requestCode);
 372         } catch (ActivityNotFoundException e) {
 373             Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 374         } catch (SecurityException e) {
 375             Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 376             Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +
 377                     &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +
 378                     &quot;or use the exported attribute for this activity.&quot;, e);
 379         }
 380     }
 381 
 382     static boolean isSystemApp(Context context, Intent intent) {
 383         PackageManager pm = context.getPackageManager();
 384         ComponentName cn = intent.getComponent();
 385         String packageName = null;
 386         if (cn == null) {
 387             ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
 388             if ((info != null) &amp;&amp; (info.activityInfo != null)) {
 389                 packageName = info.activityInfo.packageName;
 390             }
 391         } else {
 392             packageName = cn.getPackageName();
 393         }
 394         if (packageName != null) {
 395             try {
 396                 PackageInfo info = pm.getPackageInfo(packageName, 0);
 397                 return (info != null) &amp;&amp; (info.applicationInfo != null) &amp;&amp;
 398                         ((info.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0);
 399             } catch (NameNotFoundException e) {
 400                 return false;
 401             }
 402         } else {
 403             return false;
 404         }
 405     }
 406 
 407     /**
 408      * This picks a dominant color, looking for high-saturation, high-value, repeated hues.
 409      * @param bitmap The bitmap to scan
 410      * @param samples The approximate max number of samples to use.
 411      */
 412     static int findDominantColorByHue(Bitmap bitmap, int samples) {
 413         final int height = bitmap.getHeight();
 414         final int width = bitmap.getWidth();
 415         int sampleStride = (int) Math.sqrt((height * width) / samples);
 416         if (sampleStride &lt; 1) {
 417             sampleStride = 1;
 418         }
 419 
 420         // This is an out-param, for getting the hsv values for an rgb
 421         float[] hsv = new float[3];
 422 
 423         // First get the best hue, by creating a histogram over 360 hue buckets,
 424         // where each pixel contributes a score weighted by saturation, value, and alpha.
 425         float[] hueScoreHistogram = new float[360];
 426         float highScore = -1;
 427         int bestHue = -1;
 428 
 429         for (int y = 0; y &lt; height; y += sampleStride) {
 430             for (int x = 0; x &lt; width; x += sampleStride) {
 431                 int argb = bitmap.getPixel(x, y);
 432                 int alpha = 0xFF &amp; (argb &gt;&gt; 24);
 433                 if (alpha &lt; 0x80) {
 434                     // Drop mostly-transparent pixels.
 435                     continue;
 436                 }
 437                 // Remove the alpha channel.
 438                 int rgb = argb | 0xFF000000;
 439                 Color.colorToHSV(rgb, hsv);
 440                 // Bucket colors by the 360 integer hues.
 441                 int hue = (int) hsv[0];
 442                 if (hue &lt; 0 || hue &gt;= hueScoreHistogram.length) {
 443                     // Defensively avoid array bounds violations.
 444                     continue;
 445                 }
 446                 float score = hsv[1] * hsv[2];
 447                 hueScoreHistogram[hue] += score;
 448                 if (hueScoreHistogram[hue] &gt; highScore) {
 449                     highScore = hueScoreHistogram[hue];
 450                     bestHue = hue;
 451                 }
 452             }
 453         }
 454 
 455         SparseArray&lt;Float&gt; rgbScores = new SparseArray&lt;Float&gt;();
 456         int bestColor = 0xff000000;
 457         highScore = -1;
 458         // Go back over the RGB colors that match the winning hue,
 459         // creating a histogram of weighted s*v scores, for up to 100*100 [s,v] buckets.
 460         // The highest-scoring RGB color wins.
 461         for (int y = 0; y &lt; height; y += sampleStride) {
 462             for (int x = 0; x &lt; width; x += sampleStride) {
 463                 int rgb = bitmap.getPixel(x, y) | 0xff000000;
 464                 Color.colorToHSV(rgb, hsv);
 465                 int hue = (int) hsv[0];
 466                 if (hue == bestHue) {
 467                     float s = hsv[1];
 468                     float v = hsv[2];
 469                     int bucket = (int) (s * 100) + (int) (v * 10000);
 470                     // Score by cumulative saturation * value.
 471                     float score = s * v;
 472                     Float oldTotal = rgbScores.get(bucket);
 473                     float newTotal = oldTotal == null ? score : oldTotal + score;
 474                     rgbScores.put(bucket, newTotal);
 475                     if (newTotal &gt; highScore) {
 476                         highScore = newTotal;
 477                         // All the colors in the winning bucket are very similar. Last in wins.
 478                         bestColor = rgb;
 479                     }
 480                 }
 481             }
 482         }
 483         return bestColor;
 484     }
 485 
 486     /*
 487      * Finds a system apk which had a broadcast receiver listening to a particular action.
 488      * @param action intent action used to find the apk
 489      * @return a pair of apk package name and the resources.
 490      */
 491     static Pair&lt;String, Resources&gt; findSystemApk(String action, PackageManager pm) {
 492         final Intent intent = new Intent(action);
 493         for (ResolveInfo info : pm.queryBroadcastReceivers(intent, 0)) {
 494             if (info.activityInfo != null &amp;&amp;
 495                     (info.activityInfo.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 496                 final String packageName = info.activityInfo.packageName;
 497                 try {
 498                     final Resources res = pm.getResourcesForApplication(packageName);
 499                     return Pair.create(packageName, res);
 500                 } catch (NameNotFoundException e) {
 501                     Log.w(TAG, &quot;Failed to find resources for &quot; + packageName);
 502                 }
 503             }
 504         }
 505         return null;
 506     }
 507 
 508     @TargetApi(Build.VERSION_CODES.KITKAT)
 509     public static boolean isViewAttachedToWindow(View v) {
 510         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
 511             return v.isAttachedToWindow();
 512         } else {
 513             // A proxy call which returns null, if the view is not attached to the window.
 514             return v.getKeyDispatcherState() != null;
 515         }
 516     }
 517 
 518     /**
 519      * Returns a widget with category {@link AppWidgetProviderInfo#WIDGET_CATEGORY_SEARCHBOX}
 520      * provided by the same package which is set to be global search activity.
 521      * If widgetCategory is not supported, or no such widget is found, returns the first widget
 522      * provided by the package.
 523      */
 524     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 525     public static AppWidgetProviderInfo getSearchWidgetProvider(Context context) {
 526         SearchManager searchManager =
 527                 (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
 528         ComponentName searchComponent = searchManager.getGlobalSearchActivity();
 529         if (searchComponent == null) return null;
 530         String providerPkg = searchComponent.getPackageName();
 531 
 532         AppWidgetProviderInfo defaultWidgetForSearchPackage = null;
 533 
 534         AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
 535         for (AppWidgetProviderInfo info : appWidgetManager.getInstalledProviders()) {
 536             if (info.provider.getPackageName().equals(providerPkg)) {
 537                 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {
 538                     if ((info.widgetCategory &amp; AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX) != 0) {
 539                         return info;
 540                     } else if (defaultWidgetForSearchPackage == null) {
 541                         defaultWidgetForSearchPackage = info;
 542                     }
 543                 } else {
 544                     return info;
 545                 }
 546             }
 547         }
 548         return defaultWidgetForSearchPackage;
 549     }
 550 
 551     /**
 552      * Compresses the bitmap to a byte array for serialization.
 553      */
 554     public static byte[] flattenBitmap(Bitmap bitmap) {
 555         // Try go guesstimate how much space the icon will take when serialized
 556         // to avoid unnecessary allocations/copies during the write.
 557         int size = bitmap.getWidth() * bitmap.getHeight() * 4;
 558         ByteArrayOutputStream out = new ByteArrayOutputStream(size);
 559         try {
 560             bitmap.compress(Bitmap.CompressFormat.PNG, 100, out);
 561             out.flush();
 562             out.close();
 563             return out.toByteArray();
 564         } catch (IOException e) {
 565             Log.w(TAG, &quot;Could not write bitmap&quot;);
 566             return null;
 567         }
 568     }
 569 
 570     /**
 571      * Find the first vacant cell, if there is one.
 572      *
 573      * @param vacant Holds the x and y coordinate of the vacant cell
 574      * @param spanX Horizontal cell span.
 575      * @param spanY Vertical cell span.
 576      *
 577      * @return true if a vacant cell was found
 578      */
 579     public static boolean findVacantCell(int[] vacant, int spanX, int spanY,
 580             int xCount, int yCount, boolean[][] occupied) {
 581 
 582         for (int y = 0; (y + spanY) &lt;= yCount; y++) {
 583             for (int x = 0; (x + spanX) &lt;= xCount; x++) {
 584                 boolean available = !occupied[x][y];
 585                 out:            for (int i = x; i &lt; x + spanX; i++) {
 586                     for (int j = y; j &lt; y + spanY; j++) {
 587                         available = available &amp;&amp; !occupied[i][j];
 588                         if (!available) break out;
 589                     }
 590                 }
 591 
 592                 if (available) {
 593                     vacant[0] = x;
 594                     vacant[1] = y;
 595                     return true;
 596                 }
 597             }
 598         }
 599 
 600         return false;
 601     }
 602 
 603     /**
 604      * Trims the string, removing all whitespace at the beginning and end of the string.
 605      * Non-breaking whitespaces are also removed.
 606      */
 607     public static String trim(CharSequence s) {
 608         if (s == null) {
 609             return null;
 610         }
 611 
 612         // Just strip any sequence of whitespace or java space characters from the beginning and end
 613         Matcher m = sTrimPattern.matcher(s);
 614         return m.replaceAll(&quot;$1&quot;);
 615     }
 616 
 617     /**
 618      * Calculates the height of a given string at a specific text size.
 619      */
 620     public static float calculateTextHeight(float textSizePx) {
 621         Paint p = new Paint();
 622         p.setTextSize(textSizePx);
 623         Paint.FontMetrics fm = p.getFontMetrics();
 624         return -fm.top + fm.bottom;
 625     }
 626 
 627     /**
 628      * Convenience println with multiple args.
 629      */
 630     public static void println(String key, Object... args) {
 631         StringBuilder b = new StringBuilder();
 632         b.append(key);
 633         b.append(&quot;: &quot;);
 634         boolean isFirstArgument = true;
 635         for (Object arg : args) {
 636             if (isFirstArgument) {
 637                 isFirstArgument = false;
 638             } else {
 639                 b.append(&quot;, &quot;);
 640             }
 641             b.append(arg);
 642         }
 643         System.out.println(b.toString());
 644     }
 645 
 646     @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 647     public static boolean isRtl(Resources res) {
 648         return (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &amp;&amp;
 649                 (res.getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL);
 650     }
 651 
 652     public static void assertWorkerThread() {
 653         if (LauncherAppState.isDogfoodBuild() &amp;&amp;
 654                 (LauncherModel.sWorkerThread.getThreadId() != Process.myTid())) {
 655             throw new IllegalStateException();
 656         }
 657     }
 658 
 659     /**
 660      * Returns true if the intent is a valid launch intent for a launcher activity of an app.
 661      * This is used to identify shortcuts which are different from the ones exposed by the
 662      * applications&#x27; manifest file.
 663      *
 664      * @param launchIntent
 665      * 		The intent that will be launched when the shortcut is clicked.
 666      */
 667     public static boolean isLauncherAppTarget(Intent launchIntent) {
<abbr title=" 668         if (((((((launchIntent != null) &amp;&amp; Intent.ACTION_MAIN.equals(launchIntent.getAction())) &amp;&amp; (launchIntent.getComponent() != null)) &amp;&amp; (launchIntent.getCategories() != null)) &amp;&amp; (launchIntent.getCategories().size() == 1)) &amp;&amp; launchIntent.hasCategory(Intent.CATEGORY_LAUNCHER)) &amp;&amp; TextUtils.isEmpty(launchIntent.getDataString())) {"> 668         if (((((((launchIntent != null) &amp;&amp; Intent.ACTION_MAIN.equals(launchIntent.getAction())) &amp;&amp; (launc🔵</abbr>
 669             // An app target can either have no extra or have ItemInfo.EXTRA_PROFILE.
 670             Bundle extras = launchIntent.getExtras();
 671             if (extras == null) {
 672                 return true;
 673             } else {
 674                 Set&lt;String&gt; keys = extras.keySet();
 675                 return (keys.size() == 1) &amp;&amp; keys.contains(ItemInfo.EXTRA_PROFILE);
 676             }
 677         }
 678         return false;
 679     }
 680 
 681     public static float dpiFromPx(int size, DisplayMetrics metrics) {
 682         float densityRatio = ((float) (metrics.densityDpi)) / DisplayMetrics.DENSITY_DEFAULT;
 683         return size / densityRatio;
 684     }
 685 
 686     public static int pxFromDp(float size, DisplayMetrics metrics) {
<abbr title=" 687         return ((int) (Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, size, metrics))));"> 687         return ((int) (Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, size, metrics)))🔵</abbr>
 688     }
 689 
 690     public static int pxFromSp(float size, DisplayMetrics metrics) {
<abbr title=" 691         return ((int) (Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, size, metrics))));"> 691         return ((int) (Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, size, metrics))))🔵</abbr>
 692     }
 693 
 694     public static String createDbSelectionQuery(String columnName, Iterable&lt;?&gt; values) {
 695         return String.format(Locale.ENGLISH, &quot;%s IN (%s)&quot;, columnName, TextUtils.join(&quot;, &quot;, values));
 696     }
 697 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.annotation.TargetApi;
  20  import android.app.Activity;
  21  import android.app.SearchManager;
  22  import android.appwidget.AppWidgetManager;
  23  import android.appwidget.AppWidgetProviderInfo;
  24  import android.content.ActivityNotFoundException;
  25  import android.content.ComponentName;
  26  import android.content.Context;
  27  import android.content.Intent;

  28  import android.content.pm.ApplicationInfo;
  29  import android.content.pm.PackageInfo;
  30  import android.content.pm.PackageManager;
  31  import android.content.pm.PackageManager.NameNotFoundException;
  32  import android.content.pm.ResolveInfo;
  33  import android.content.res.Resources;

  34  import android.graphics.Bitmap;

  35  import android.graphics.Canvas;
  36  import android.graphics.Color;
  37  import android.graphics.Matrix;
  38  import android.graphics.Paint;
  39  import android.graphics.PaintFlagsDrawFilter;
  40  import android.graphics.Rect;
  41  import android.graphics.drawable.BitmapDrawable;
  42  import android.graphics.drawable.Drawable;
  43  import android.graphics.drawable.PaintDrawable;
  44  import android.os.Build;




  45  import android.util.Log;
  46  import android.util.Pair;
  47  import android.util.SparseArray;

  48  import android.view.View;
  49  import android.widget.Toast;
  50  


  51  import java.util.ArrayList;




  52  
  53  /**
  54   * Various utilities shared amongst the Launcher&#x27;s classes.
  55   */
  56  public final class Utilities {

  57      private static final String TAG = &quot;Launcher.Utilities&quot;;
  58  
  59      private static int sIconWidth = -1;
  60      private static int sIconHeight = -1;
  61  
  62      private static final Rect sOldBounds = new Rect();
  63      private static final Canvas sCanvas = new Canvas();



  64  
  65      static {
  66          sCanvas.setDrawFilter(new PaintFlagsDrawFilter(Paint.DITHER_FLAG,
  67                  Paint.FILTER_BITMAP_FLAG));
  68      }
  69      static int sColors[] = { 0xffff0000, 0xff00ff00, 0xff0000ff };
  70      static int sColorIndex = 0;
  71  
  72      static int[] sLoc0 = new int[2];
  73      static int[] sLoc1 = new int[2];


  74  
  75      // To turn on these properties, type
  76      // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
  77      static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;
  78      public static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);
  79  
  80      /**
  81       * Returns a FastBitmapDrawable with the icon, accurately sized.
  82       */
  83      public static FastBitmapDrawable createIconDrawable(Bitmap icon) {
  84          FastBitmapDrawable d = new FastBitmapDrawable(icon);
  85          d.setFilterBitmap(true);
  86          resizeIconDrawable(d);
  87          return d;
  88      }
  89  
  90      /**
  91       * Resizes an icon drawable to the correct icon size.
  92       */
  93      static void resizeIconDrawable(Drawable icon) {
  94          icon.setBounds(0, 0, sIconWidth, sIconHeight);
  95      }




  96  
  97      public static boolean isPropertyEnabled(String propertyName) {
  98          return Log.isLoggable(propertyName, Log.VERBOSE);
  99      }
 100  
 101      public static boolean isRotationEnabled(Context c) {
 102          boolean enableRotation = sForceEnableRotation ||
 103                  c.getResources().getBoolean(R.bool.allow_rotation);
 104          return enableRotation;










 105      }
 106  
 107      /**
 108       * Indicates if the device is running LMP or higher.
 109       */
 110      public static boolean isLmpOrAbove() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 111 -        return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.L;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 112 +        return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP;</span>



















 113      }
 114  
 115      /**
 116       * Returns a bitmap suitable for the all apps view. If the package or the resource do not
 117       * exist, it returns null.
 118       */
 119      static Bitmap createIconBitmap(String packageName, String resourceName, IconCache cache,

 120              Context context) {
 121          PackageManager packageManager = context.getPackageManager();
 122          // the resource
 123          try {
 124              Resources resources = packageManager.getResourcesForApplication(packageName);
 125              if (resources != null) {
 126                  final int id = resources.getIdentifier(resourceName, null, null);
 127                  return createIconBitmap(
 128                          resources.getDrawableForDensity(id, cache.getFullResIconDpi()), context);


 129              }
 130          } catch (Exception e) {
 131              // Icon not found.
 132          }
 133          return null;
 134      }
 135  




 136      /**
 137       * Returns a bitmap which is of the appropriate size to be displayed as an icon
 138       */
 139      static Bitmap createIconBitmap(Bitmap icon, Context context) {
 140          synchronized (sCanvas) { // we share the statics :-(
 141              if (sIconWidth == -1) {
 142                  initStatics(context);
 143              }
 144          }
 145          if (sIconWidth == icon.getWidth() &amp;&amp; sIconHeight == icon.getHeight()) {



 146              return icon;
 147          }
 148          return createIconBitmap(new BitmapDrawable(context.getResources(), icon), context);
 149      }
 150  
 151      /**
 152       * Returns a bitmap suitable for the all apps view.
 153       */
 154      public static Bitmap createIconBitmap(Drawable icon, Context context) {
 155          synchronized (sCanvas) { // we share the statics :-(
 156              if (sIconWidth == -1) {
 157                  initStatics(context);
 158              }
 159  
 160              int width = sIconWidth;
 161              int height = sIconHeight;





 162  
 163              if (icon instanceof PaintDrawable) {
 164                  PaintDrawable painter = (PaintDrawable) icon;
 165                  painter.setIntrinsicWidth(width);
 166                  painter.setIntrinsicHeight(height);
 167              } else if (icon instanceof BitmapDrawable) {
 168                  // Ensure the bitmap has a density.
 169                  BitmapDrawable bitmapDrawable = (BitmapDrawable) icon;
 170                  Bitmap bitmap = bitmapDrawable.getBitmap();
 171                  if (bitmap.getDensity() == Bitmap.DENSITY_NONE) {
 172                      bitmapDrawable.setTargetDensity(context.getResources().getDisplayMetrics());
 173                  }
 174              }
 175              int sourceWidth = icon.getIntrinsicWidth();
 176              int sourceHeight = icon.getIntrinsicHeight();
 177              if (sourceWidth &gt; 0 &amp;&amp; sourceHeight &gt; 0) {
 178                  // Scale the icon proportionally to the icon dimensions
 179                  final float ratio = (float) sourceWidth / sourceHeight;
 180                  if (sourceWidth &gt; sourceHeight) {
 181                      height = (int) (width / ratio);
 182                  } else if (sourceHeight &gt; sourceWidth) {
 183                      width = (int) (height * ratio);
 184                  }
 185              }
 186  
 187              // no intrinsic size --&gt; use default size
 188              int textureWidth = sIconWidth;
 189              int textureHeight = sIconHeight;


 190  
 191              final Bitmap bitmap = Bitmap.createBitmap(textureWidth, textureHeight,
 192                      Bitmap.Config.ARGB_8888);
 193              final Canvas canvas = sCanvas;
 194              canvas.setBitmap(bitmap);
 195  
 196              final int left = (textureWidth-width) / 2;
 197              final int top = (textureHeight-height) / 2;
 198  
 199              @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
 200              final boolean debug = false;
 201              if (debug) {
 202                  // draw a big box for the icon for debugging
 203                  canvas.drawColor(sColors[sColorIndex]);
 204                  if (++sColorIndex &gt;= sColors.length) sColorIndex = 0;
 205                  Paint debugPaint = new Paint();
 206                  debugPaint.setColor(0xffcccc00);
 207                  canvas.drawRect(left, top, left+width, top+height, debugPaint);
 208              }
 209  
 210              sOldBounds.set(icon.getBounds());
 211              icon.setBounds(left, top, left+width, top+height);
 212              icon.draw(canvas);
 213              icon.setBounds(sOldBounds);
 214              canvas.setBitmap(null);
 215  
 216              return bitmap;
 217          }
 218      }
 219  
 220      /**
 221       * Given a coordinate relative to the descendant, find the coordinate in a parent view&#x27;s
 222       * coordinates.
 223       *
 224       * @param descendant The descendant to which the passed coordinate is relative.
 225       * @param root The root view to make the coordinates relative to.
 226       * @param coord The coordinate that we want mapped.
 227       * @param includeRootScroll Whether or not to account for the scroll of the descendant:
 228       *          sometimes this is relevant as in a child&#x27;s coordinates within the descendant.
 229       * @return The factor by which this descendant is scaled relative to this DragLayer. Caution
 230       *         this scale factor is assumed to be equal in X and Y, and so if at any point this
 231       *         assumption fails, we will need to return a pair of scale factors.
 232       */
 233      public static float getDescendantCoordRelativeToParent(View descendant, View root,
 234                                                             int[] coord, boolean includeRootScroll) {
 235          ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 236  
 237          float[] pt = {coord[0], coord[1]};
 238  
 239          View v = descendant;
 240          while(v != root &amp;&amp; v != null) {
 241              ancestorChain.add(v);
 242              v = (View) v.getParent();
 243          }
 244          ancestorChain.add(root);
 245  
 246          float scale = 1.0f;
 247          int count = ancestorChain.size();
 248          for (int i = 0; i &lt; count; i++) {
 249              View v0 = ancestorChain.get(i);
 250              // For TextViews, scroll has a meaning which relates to the text position
 251              // which is very strange... ignore the scroll.
 252              if (v0 != descendant || includeRootScroll) {
 253                  pt[0] -= v0.getScrollX();
 254                  pt[1] -= v0.getScrollY();
 255              }
 256  
 257              v0.getMatrix().mapPoints(pt);
 258              pt[0] += v0.getLeft();
 259              pt[1] += v0.getTop();
 260              scale *= v0.getScaleX();
 261          }
 262  
 263          coord[0] = (int) Math.round(pt[0]);
 264          coord[1] = (int) Math.round(pt[1]);
 265          return scale;
 266      }
 267  
 268      /**
 269       * Inverse of {@link #getDescendantCoordRelativeToSelf(View, int[])}.
 270       */
 271      public static float mapCoordInSelfToDescendent(View descendant, View root,
 272                                                     int[] coord) {
 273          ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 274  
 275          float[] pt = {coord[0], coord[1]};
 276  
 277          View v = descendant;
 278          while(v != root) {
 279              ancestorChain.add(v);
 280              v = (View) v.getParent();
 281          }
 282          ancestorChain.add(root);
 283  
 284          float scale = 1.0f;
 285          Matrix inverse = new Matrix();
 286          int count = ancestorChain.size();
 287          for (int i = count - 1; i &gt;= 0; i--) {
 288              View ancestor = ancestorChain.get(i);
 289              View next = i &gt; 0 ? ancestorChain.get(i-1) : null;
 290  
 291              pt[0] += ancestor.getScrollX();
 292              pt[1] += ancestor.getScrollY();
 293  
 294              if (next != null) {
 295                  pt[0] -= next.getLeft();
 296                  pt[1] -= next.getTop();
 297                  next.getMatrix().invert(inverse);
 298                  inverse.mapPoints(pt);
 299                  scale *= next.getScaleX();
 300              }
 301          }
 302  
 303          coord[0] = (int) Math.round(pt[0]);
 304          coord[1] = (int) Math.round(pt[1]);
 305          return scale;
 306      }
 307  
 308      /**
 309       * Utility method to determine whether the given point, in local coordinates,
 310       * is inside the view, where the area of the view is expanded by the slop factor.
 311       * This method is called while processing touch-move events to determine if the event
 312       * is still within the view.
 313       */
 314      public static boolean pointInView(View v, float localX, float localY, float slop) {
 315          return localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; (v.getWidth() + slop) &amp;&amp;
 316                  localY &lt; (v.getHeight() + slop);
 317      }
 318  
 319      private static void initStatics(Context context) {
 320          final Resources resources = context.getResources();
 321          sIconWidth = sIconHeight = (int) resources.getDimension(R.dimen.app_icon_size);
 322      }
 323  
 324      public static void setIconSize(int widthPx) {
 325          sIconWidth = sIconHeight = widthPx;
 326      }
 327  
 328      public static void scaleRect(Rect r, float scale) {
 329          if (scale != 1.0f) {
 330              r.left = (int) (r.left * scale + 0.5f);
 331              r.top = (int) (r.top * scale + 0.5f);
 332              r.right = (int) (r.right * scale + 0.5f);
 333              r.bottom = (int) (r.bottom * scale + 0.5f);
 334          }
 335      }
 336  
 337      public static int[] getCenterDeltaInScreenSpace(View v0, View v1, int[] delta) {
 338          v0.getLocationInWindow(sLoc0);
 339          v1.getLocationInWindow(sLoc1);
 340  
 341          sLoc0[0] += (v0.getMeasuredWidth() * v0.getScaleX()) / 2;
 342          sLoc0[1] += (v0.getMeasuredHeight() * v0.getScaleY()) / 2;
 343          sLoc1[0] += (v1.getMeasuredWidth() * v1.getScaleX()) / 2;
 344          sLoc1[1] += (v1.getMeasuredHeight() * v1.getScaleY()) / 2;
 345  
 346          if (delta == null) {
 347              delta = new int[2];
 348          }
 349  
 350          delta[0] = sLoc1[0] - sLoc0[0];
 351          delta[1] = sLoc1[1] - sLoc0[1];
 352  
 353          return delta;
 354      }
 355  
 356      public static void scaleRectAboutCenter(Rect r, float scale) {
 357          int cx = r.centerX();
 358          int cy = r.centerY();
 359          r.offset(-cx, -cy);
 360          Utilities.scaleRect(r, scale);
 361          r.offset(cx, cy);
 362      }
 363  
 364      public static void startActivityForResultSafely(
 365              Activity activity, Intent intent, int requestCode) {
 366          try {
 367              activity.startActivityForResult(intent, requestCode);
 368          } catch (ActivityNotFoundException e) {
 369              Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 370          } catch (SecurityException e) {
 371              Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 372              Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +
 373                      &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +
 374                      &quot;or use the exported attribute for this activity.&quot;, e);
 375          }
 376      }
 377  
 378      static boolean isSystemApp(Context context, Intent intent) {
 379          PackageManager pm = context.getPackageManager();
 380          ComponentName cn = intent.getComponent();
 381          String packageName = null;
 382          if (cn == null) {
 383              ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
 384              if ((info != null) &amp;&amp; (info.activityInfo != null)) {
 385                  packageName = info.activityInfo.packageName;
 386              }
 387          } else {
 388              packageName = cn.getPackageName();
 389          }
 390          if (packageName != null) {
 391              try {
 392                  PackageInfo info = pm.getPackageInfo(packageName, 0);
 393                  return (info != null) &amp;&amp; (info.applicationInfo != null) &amp;&amp;
 394                          ((info.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0);
 395              } catch (NameNotFoundException e) {
 396                  return false;
 397              }
 398          } else {
 399              return false;
 400          }
 401      }
 402  
 403      /**
 404       * This picks a dominant color, looking for high-saturation, high-value, repeated hues.
 405       * @param bitmap The bitmap to scan
 406       * @param samples The approximate max number of samples to use.
 407       */
 408      static int findDominantColorByHue(Bitmap bitmap, int samples) {
 409          final int height = bitmap.getHeight();
 410          final int width = bitmap.getWidth();
 411          int sampleStride = (int) Math.sqrt((height * width) / samples);
 412          if (sampleStride &lt; 1) {
 413              sampleStride = 1;
 414          }
 415  
 416          // This is an out-param, for getting the hsv values for an rgb
 417          float[] hsv = new float[3];
 418  
 419          // First get the best hue, by creating a histogram over 360 hue buckets,
 420          // where each pixel contributes a score weighted by saturation, value, and alpha.
 421          float[] hueScoreHistogram = new float[360];
 422          float highScore = -1;
 423          int bestHue = -1;
 424  
 425          for (int y = 0; y &lt; height; y += sampleStride) {
 426              for (int x = 0; x &lt; width; x += sampleStride) {
 427                  int argb = bitmap.getPixel(x, y);
 428                  int alpha = 0xFF &amp; (argb &gt;&gt; 24);
 429                  if (alpha &lt; 0x80) {
 430                      // Drop mostly-transparent pixels.
 431                      continue;
 432                  }
 433                  // Remove the alpha channel.
 434                  int rgb = argb | 0xFF000000;
 435                  Color.colorToHSV(rgb, hsv);
 436                  // Bucket colors by the 360 integer hues.
 437                  int hue = (int) hsv[0];
 438                  if (hue &lt; 0 || hue &gt;= hueScoreHistogram.length) {
 439                      // Defensively avoid array bounds violations.
 440                      continue;
 441                  }
 442                  float score = hsv[1] * hsv[2];
 443                  hueScoreHistogram[hue] += score;
 444                  if (hueScoreHistogram[hue] &gt; highScore) {
 445                      highScore = hueScoreHistogram[hue];
 446                      bestHue = hue;
 447                  }
 448              }
 449          }
 450  
 451          SparseArray&lt;Float&gt; rgbScores = new SparseArray&lt;Float&gt;();
 452          int bestColor = 0xff000000;
 453          highScore = -1;
 454          // Go back over the RGB colors that match the winning hue,
 455          // creating a histogram of weighted s*v scores, for up to 100*100 [s,v] buckets.
 456          // The highest-scoring RGB color wins.
 457          for (int y = 0; y &lt; height; y += sampleStride) {
 458              for (int x = 0; x &lt; width; x += sampleStride) {
 459                  int rgb = bitmap.getPixel(x, y) | 0xff000000;
 460                  Color.colorToHSV(rgb, hsv);
 461                  int hue = (int) hsv[0];
 462                  if (hue == bestHue) {
 463                      float s = hsv[1];
 464                      float v = hsv[2];
 465                      int bucket = (int) (s * 100) + (int) (v * 10000);
 466                      // Score by cumulative saturation * value.
 467                      float score = s * v;
 468                      Float oldTotal = rgbScores.get(bucket);
 469                      float newTotal = oldTotal == null ? score : oldTotal + score;
 470                      rgbScores.put(bucket, newTotal);
 471                      if (newTotal &gt; highScore) {
 472                          highScore = newTotal;
 473                          // All the colors in the winning bucket are very similar. Last in wins.
 474                          bestColor = rgb;
 475                      }
 476                  }
 477              }
 478          }
 479          return bestColor;
 480      }
 481  
 482      /*
 483       * Finds a system apk which had a broadcast receiver listening to a particular action.
 484       * @param action intent action used to find the apk
 485       * @return a pair of apk package name and the resources.
 486       */
 487      static Pair&lt;String, Resources&gt; findSystemApk(String action, PackageManager pm) {
 488          final Intent intent = new Intent(action);
 489          for (ResolveInfo info : pm.queryBroadcastReceivers(intent, 0)) {
 490              if (info.activityInfo != null &amp;&amp;
 491                      (info.activityInfo.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 492                  final String packageName = info.activityInfo.packageName;
 493                  try {
 494                      final Resources res = pm.getResourcesForApplication(packageName);
 495                      return Pair.create(packageName, res);
 496                  } catch (NameNotFoundException e) {
 497                      Log.w(TAG, &quot;Failed to find resources for &quot; + packageName);
 498                  }
 499              }
 500          }
 501          return null;
 502      }
 503  
 504      @TargetApi(Build.VERSION_CODES.KITKAT)
 505      public static boolean isViewAttachedToWindow(View v) {
 506          if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
 507              return v.isAttachedToWindow();
 508          } else {
 509              // A proxy call which returns null, if the view is not attached to the window.
 510              return v.getKeyDispatcherState() != null;
 511          }
 512      }
 513  
 514      /**
 515       * Returns a widget with category {@link AppWidgetProviderInfo#WIDGET_CATEGORY_SEARCHBOX}
 516       * provided by the same package which is set to be global search activity.
 517       * If widgetCategory is not supported, or no such widget is found, returns the first widget
 518       * provided by the package.
 519       */
 520      @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 521      public static AppWidgetProviderInfo getSearchWidgetProvider(Context context) {
 522          SearchManager searchManager =
 523                  (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
 524          ComponentName searchComponent = searchManager.getGlobalSearchActivity();
 525          if (searchComponent == null) return null;
 526          String providerPkg = searchComponent.getPackageName();
 527  
 528          AppWidgetProviderInfo defaultWidgetForSearchPackage = null;
 529  
 530          AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
 531          for (AppWidgetProviderInfo info : appWidgetManager.getInstalledProviders()) {
 532              if (info.provider.getPackageName().equals(providerPkg)) {
 533                  if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {
 534                      if ((info.widgetCategory &amp; AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX) != 0) {
 535                          return info;
 536                      } else if (defaultWidgetForSearchPackage == null) {
 537                          defaultWidgetForSearchPackage = info;
 538                      }
 539                  } else {
 540                      return info;
 541                  }
 542              }
 543          }
 544          return defaultWidgetForSearchPackage;
 545      }
























































































































































 546  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.annotation.TargetApi;
  20  import android.app.Activity;
  21  import android.app.SearchManager;
  22  import android.appwidget.AppWidgetManager;
  23  import android.appwidget.AppWidgetProviderInfo;
  24  import android.content.ActivityNotFoundException;
  25  import android.content.ComponentName;
  26  import android.content.Context;
  27  import android.content.Intent;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import android.content.SharedPreferences;</span>
  29  import android.content.pm.ApplicationInfo;
  30  import android.content.pm.PackageInfo;
  31  import android.content.pm.PackageManager;
  32  import android.content.pm.PackageManager.NameNotFoundException;
  33  import android.content.pm.ResolveInfo;
  34  import android.content.res.Resources;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import android.database.Cursor;</span>
  36  import android.graphics.Bitmap;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  37 +import android.graphics.BitmapFactory;</span>
  38  import android.graphics.Canvas;
  39  import android.graphics.Color;
  40  import android.graphics.Matrix;
  41  import android.graphics.Paint;
  42  import android.graphics.PaintFlagsDrawFilter;
  43  import android.graphics.Rect;
  44  import android.graphics.drawable.BitmapDrawable;
  45  import android.graphics.drawable.Drawable;
  46  import android.graphics.drawable.PaintDrawable;
  47  import android.os.Build;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  48 +import android.os.Bundle;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  49 +import android.os.Process;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  50 +import android.text.TextUtils;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  51 +import android.util.DisplayMetrics;</span>
  52  import android.util.Log;
  53  import android.util.Pair;
  54  import android.util.SparseArray;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  55 +import android.util.TypedValue;</span>
  56  import android.view.View;
  57  import android.widget.Toast;
  58  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +import java.io.ByteArrayOutputStream;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +import java.io.IOException;</span>
  61  import java.util.ArrayList;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +import java.util.Locale;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +import java.util.Set;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +import java.util.regex.Matcher;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  65 +import java.util.regex.Pattern;</span>
  66  
  67  /**
  68   * Various utilities shared amongst the Launcher&#x27;s classes.
  69   */
  70  public final class Utilities {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  71 +</span>
  72      private static final String TAG = &quot;Launcher.Utilities&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  73 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  74 -    private static int sIconWidth = -1;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  75 -    private static int sIconHeight = -1;</span>
  76  
  77      private static final Rect sOldBounds = new Rect();
  78      private static final Canvas sCanvas = new Canvas();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  79 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  80 +    private static final Pattern sTrimPattern =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  81 +            Pattern.compile(&quot;^[\\s|\\p{javaSpaceChar}]*(.*)[\\s|\\p{javaSpaceChar}]*$&quot;);</span>
  82  
  83      static {
  84          sCanvas.setDrawFilter(new PaintFlagsDrawFilter(Paint.DITHER_FLAG,
  85                  Paint.FILTER_BITMAP_FLAG));
  86      }
  87      static int sColors[] = { 0xffff0000, 0xff00ff00, 0xff0000ff };
  88      static int sColorIndex = 0;
  89  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  90 -    static int[] sLoc0 = new int[2];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  91 -    static int[] sLoc1 = new int[2];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  92 +    private static final int[] sLoc0 = new int[2];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +    private static final int[] sLoc1 = new int[2];</span>
  94  
  95      // To turn on these properties, type
  96      // adb shell setprop log.tag.PROPERTY_NAME [VERBOSE | SUPPRESS]
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  97 -    static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -    public static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  99 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 101 -     * Returns a FastBitmapDrawable with the icon, accurately sized.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 103 -    public static FastBitmapDrawable createIconDrawable(Bitmap icon) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 104 -        FastBitmapDrawable d = new FastBitmapDrawable(icon);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 105 -        d.setFilterBitmap(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 106 -        resizeIconDrawable(d);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 107 -        return d;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 108 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 109 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 110 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 111 -     * Resizes an icon drawable to the correct icon size.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 112 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 113 -    static void resizeIconDrawable(Drawable icon) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 114 -        icon.setBounds(0, 0, sIconWidth, sIconHeight);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 115 -    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 116 +    private static final String FORCE_ENABLE_ROTATION_PROPERTY = &quot;launcher_force_rotate&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +    private static boolean sForceEnableRotation = isPropertyEnabled(FORCE_ENABLE_ROTATION_PROPERTY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +    public static final String ALLOW_ROTATION_PREFERENCE_KEY = &quot;pref_allowRotation&quot;;</span>
 120  
 121      public static boolean isPropertyEnabled(String propertyName) {
 122          return Log.isLoggable(propertyName, Log.VERBOSE);
 123      }
 124  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 125 -    public static boolean isRotationEnabled(Context c) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 126 -        boolean enableRotation = sForceEnableRotation ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -                c.getResources().getBoolean(R.bool.allow_rotation);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 128 -        return enableRotation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 129 +    public static boolean isAllowRotationPrefEnabled(Context context, boolean multiProcess) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 130 +        SharedPreferences sharedPrefs = context.getSharedPreferences(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +                LauncherAppState.getSharedPreferencesKey(), Context.MODE_PRIVATE | (multiProcess ?</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +                        Context.MODE_MULTI_PROCESS : 0));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +        boolean allowRotationPref = sharedPrefs.getBoolean(ALLOW_ROTATION_PREFERENCE_KEY, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 134 +        return sForceEnableRotation || allowRotationPref;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 135 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 136 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 137 +    public static boolean isRotationAllowedForDevice(Context context) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +        return sForceEnableRotation || context.getResources().getBoolean(R.bool.allow_rotation);</span>
 139      }
 140  
 141      /**
 142       * Indicates if the device is running LMP or higher.
 143       */
 144      public static boolean isLmpOrAbove() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 145 -        return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.L;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 146 +        return Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +    public static boolean isLmpMR1OrAbove() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +        // TODO(adamcohen): update to Build.VERSION_CODES.LOLLIPOP_MR1 once building against 22;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +        return Build.VERSION.SDK_INT &gt;= 22;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +    public static boolean isLmpMR1() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 155 +        // TODO(adamcohen): update to Build.VERSION_CODES.LOLLIPOP_MR1 once building against 22;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 156 +        return Build.VERSION.SDK_INT == 22;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 157 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 158 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +    public static Bitmap createIconBitmap(Cursor c, int iconIndex, Context context) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +        byte[] data = c.getBlob(iconIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +            return createIconBitmap(BitmapFactory.decodeByteArray(data, 0, data.length), context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +        } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +            return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +        }</span>
 166      }
 167  
 168      /**
 169       * Returns a bitmap suitable for the all apps view. If the package or the resource do not
 170       * exist, it returns null.
 171       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 172 -    static Bitmap createIconBitmap(String packageName, String resourceName, IconCache cache,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 173 +    public static Bitmap createIconBitmap(String packageName, String resourceName,</span>
 174              Context context) {
 175          PackageManager packageManager = context.getPackageManager();
 176          // the resource
 177          try {
 178              Resources resources = packageManager.getResourcesForApplication(packageName);
 179              if (resources != null) {
 180                  final int id = resources.getIdentifier(resourceName, null, null);
 181                  return createIconBitmap(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 182 -                        resources.getDrawableForDensity(id, cache.getFullResIconDpi()), context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +                        resources.getDrawableForDensity(id, LauncherAppState.getInstance()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +                                .getInvariantDeviceProfile().fillResIconDpi), context);</span>
 185              }
 186          } catch (Exception e) {
 187              // Icon not found.
 188          }
 189          return null;
 190      }
 191  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +    private static int getIconBitmapSize() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +        return LauncherAppState.getInstance().getInvariantDeviceProfile().iconBitmapSize;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 194 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 195 +</span>
 196      /**
 197       * Returns a bitmap which is of the appropriate size to be displayed as an icon
 198       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 199 -    static Bitmap createIconBitmap(Bitmap icon, Context context) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -        synchronized (sCanvas) { // we share the statics :-(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 201 -            if (sIconWidth == -1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 202 -                initStatics(context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 203 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 204 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 205 -        if (sIconWidth == icon.getWidth() &amp;&amp; sIconHeight == icon.getHeight()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 206 +    public static Bitmap createIconBitmap(Bitmap icon, Context context) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +        final int iconBitmapSize = getIconBitmapSize();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +        if (iconBitmapSize == icon.getWidth() &amp;&amp; iconBitmapSize == icon.getHeight()) {</span>
 209              return icon;
 210          }
 211          return createIconBitmap(new BitmapDrawable(context.getResources(), icon), context);
 212      }
 213  
 214      /**
 215       * Returns a bitmap suitable for the all apps view.
 216       */
 217      public static Bitmap createIconBitmap(Drawable icon, Context context) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 218 -        synchronized (sCanvas) { // we share the statics :-(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 219 -            if (sIconWidth == -1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 220 -                initStatics(context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 221 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 222 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 223 -            int width = sIconWidth;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 224 -            int height = sIconHeight;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +        synchronized (sCanvas) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +            final int iconBitmapSize = getIconBitmapSize();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +            int width = iconBitmapSize;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +            int height = iconBitmapSize;</span>
 230  
 231              if (icon instanceof PaintDrawable) {
 232                  PaintDrawable painter = (PaintDrawable) icon;
 233                  painter.setIntrinsicWidth(width);
 234                  painter.setIntrinsicHeight(height);
 235              } else if (icon instanceof BitmapDrawable) {
 236                  // Ensure the bitmap has a density.
 237                  BitmapDrawable bitmapDrawable = (BitmapDrawable) icon;
 238                  Bitmap bitmap = bitmapDrawable.getBitmap();
 239                  if (bitmap.getDensity() == Bitmap.DENSITY_NONE) {
 240                      bitmapDrawable.setTargetDensity(context.getResources().getDisplayMetrics());
 241                  }
 242              }
 243              int sourceWidth = icon.getIntrinsicWidth();
 244              int sourceHeight = icon.getIntrinsicHeight();
 245              if (sourceWidth &gt; 0 &amp;&amp; sourceHeight &gt; 0) {
 246                  // Scale the icon proportionally to the icon dimensions
 247                  final float ratio = (float) sourceWidth / sourceHeight;
 248                  if (sourceWidth &gt; sourceHeight) {
 249                      height = (int) (width / ratio);
 250                  } else if (sourceHeight &gt; sourceWidth) {
 251                      width = (int) (height * ratio);
 252                  }
 253              }
 254  
 255              // no intrinsic size --&gt; use default size
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 256 -            int textureWidth = sIconWidth;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 257 -            int textureHeight = sIconHeight;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +            int textureWidth = iconBitmapSize;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +            int textureHeight = iconBitmapSize;</span>
 260  
 261              final Bitmap bitmap = Bitmap.createBitmap(textureWidth, textureHeight,
 262                      Bitmap.Config.ARGB_8888);
 263              final Canvas canvas = sCanvas;
 264              canvas.setBitmap(bitmap);
 265  
 266              final int left = (textureWidth-width) / 2;
 267              final int top = (textureHeight-height) / 2;
 268  
 269              @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
 270              final boolean debug = false;
 271              if (debug) {
 272                  // draw a big box for the icon for debugging
 273                  canvas.drawColor(sColors[sColorIndex]);
 274                  if (++sColorIndex &gt;= sColors.length) sColorIndex = 0;
 275                  Paint debugPaint = new Paint();
 276                  debugPaint.setColor(0xffcccc00);
 277                  canvas.drawRect(left, top, left+width, top+height, debugPaint);
 278              }
 279  
 280              sOldBounds.set(icon.getBounds());
 281              icon.setBounds(left, top, left+width, top+height);
 282              icon.draw(canvas);
 283              icon.setBounds(sOldBounds);
 284              canvas.setBitmap(null);
 285  
 286              return bitmap;
 287          }
 288      }
 289  
 290      /**
 291       * Given a coordinate relative to the descendant, find the coordinate in a parent view&#x27;s
 292       * coordinates.
 293       *
 294       * @param descendant The descendant to which the passed coordinate is relative.
 295       * @param root The root view to make the coordinates relative to.
 296       * @param coord The coordinate that we want mapped.
 297       * @param includeRootScroll Whether or not to account for the scroll of the descendant:
 298       *          sometimes this is relevant as in a child&#x27;s coordinates within the descendant.
 299       * @return The factor by which this descendant is scaled relative to this DragLayer. Caution
 300       *         this scale factor is assumed to be equal in X and Y, and so if at any point this
 301       *         assumption fails, we will need to return a pair of scale factors.
 302       */
 303      public static float getDescendantCoordRelativeToParent(View descendant, View root,
 304                                                             int[] coord, boolean includeRootScroll) {
 305          ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 306  
 307          float[] pt = {coord[0], coord[1]};
 308  
 309          View v = descendant;
 310          while(v != root &amp;&amp; v != null) {
 311              ancestorChain.add(v);
 312              v = (View) v.getParent();
 313          }
 314          ancestorChain.add(root);
 315  
 316          float scale = 1.0f;
 317          int count = ancestorChain.size();
 318          for (int i = 0; i &lt; count; i++) {
 319              View v0 = ancestorChain.get(i);
 320              // For TextViews, scroll has a meaning which relates to the text position
 321              // which is very strange... ignore the scroll.
 322              if (v0 != descendant || includeRootScroll) {
 323                  pt[0] -= v0.getScrollX();
 324                  pt[1] -= v0.getScrollY();
 325              }
 326  
 327              v0.getMatrix().mapPoints(pt);
 328              pt[0] += v0.getLeft();
 329              pt[1] += v0.getTop();
 330              scale *= v0.getScaleX();
 331          }
 332  
 333          coord[0] = (int) Math.round(pt[0]);
 334          coord[1] = (int) Math.round(pt[1]);
 335          return scale;
 336      }
 337  
 338      /**
 339       * Inverse of {@link #getDescendantCoordRelativeToSelf(View, int[])}.
 340       */
 341      public static float mapCoordInSelfToDescendent(View descendant, View root,
 342                                                     int[] coord) {
 343          ArrayList&lt;View&gt; ancestorChain = new ArrayList&lt;View&gt;();
 344  
 345          float[] pt = {coord[0], coord[1]};
 346  
 347          View v = descendant;
 348          while(v != root) {
 349              ancestorChain.add(v);
 350              v = (View) v.getParent();
 351          }
 352          ancestorChain.add(root);
 353  
 354          float scale = 1.0f;
 355          Matrix inverse = new Matrix();
 356          int count = ancestorChain.size();
 357          for (int i = count - 1; i &gt;= 0; i--) {
 358              View ancestor = ancestorChain.get(i);
 359              View next = i &gt; 0 ? ancestorChain.get(i-1) : null;
 360  
 361              pt[0] += ancestor.getScrollX();
 362              pt[1] += ancestor.getScrollY();
 363  
 364              if (next != null) {
 365                  pt[0] -= next.getLeft();
 366                  pt[1] -= next.getTop();
 367                  next.getMatrix().invert(inverse);
 368                  inverse.mapPoints(pt);
 369                  scale *= next.getScaleX();
 370              }
 371          }
 372  
 373          coord[0] = (int) Math.round(pt[0]);
 374          coord[1] = (int) Math.round(pt[1]);
 375          return scale;
 376      }
 377  
 378      /**
 379       * Utility method to determine whether the given point, in local coordinates,
 380       * is inside the view, where the area of the view is expanded by the slop factor.
 381       * This method is called while processing touch-move events to determine if the event
 382       * is still within the view.
 383       */
 384      public static boolean pointInView(View v, float localX, float localY, float slop) {
 385          return localX &gt;= -slop &amp;&amp; localY &gt;= -slop &amp;&amp; localX &lt; (v.getWidth() + slop) &amp;&amp;
 386                  localY &lt; (v.getHeight() + slop);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 387 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 388 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 389 -    private static void initStatics(Context context) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 390 -        final Resources resources = context.getResources();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 391 -        sIconWidth = sIconHeight = (int) resources.getDimension(R.dimen.app_icon_size);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 392 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 393 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 394 -    public static void setIconSize(int widthPx) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 395 -        sIconWidth = sIconHeight = widthPx;</span>
 396      }
 397  
 398      public static void scaleRect(Rect r, float scale) {
 399          if (scale != 1.0f) {
 400              r.left = (int) (r.left * scale + 0.5f);
 401              r.top = (int) (r.top * scale + 0.5f);
 402              r.right = (int) (r.right * scale + 0.5f);
 403              r.bottom = (int) (r.bottom * scale + 0.5f);
 404          }
 405      }
 406  
 407      public static int[] getCenterDeltaInScreenSpace(View v0, View v1, int[] delta) {
 408          v0.getLocationInWindow(sLoc0);
 409          v1.getLocationInWindow(sLoc1);
 410  
 411          sLoc0[0] += (v0.getMeasuredWidth() * v0.getScaleX()) / 2;
 412          sLoc0[1] += (v0.getMeasuredHeight() * v0.getScaleY()) / 2;
 413          sLoc1[0] += (v1.getMeasuredWidth() * v1.getScaleX()) / 2;
 414          sLoc1[1] += (v1.getMeasuredHeight() * v1.getScaleY()) / 2;
 415  
 416          if (delta == null) {
 417              delta = new int[2];
 418          }
 419  
 420          delta[0] = sLoc1[0] - sLoc0[0];
 421          delta[1] = sLoc1[1] - sLoc0[1];
 422  
 423          return delta;
 424      }
 425  
 426      public static void scaleRectAboutCenter(Rect r, float scale) {
 427          int cx = r.centerX();
 428          int cy = r.centerY();
 429          r.offset(-cx, -cy);
 430          Utilities.scaleRect(r, scale);
 431          r.offset(cx, cy);
 432      }
 433  
 434      public static void startActivityForResultSafely(
 435              Activity activity, Intent intent, int requestCode) {
 436          try {
 437              activity.startActivityForResult(intent, requestCode);
 438          } catch (ActivityNotFoundException e) {
 439              Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 440          } catch (SecurityException e) {
 441              Toast.makeText(activity, R.string.activity_not_found, Toast.LENGTH_SHORT).show();
 442              Log.e(TAG, &quot;Launcher does not have the permission to launch &quot; + intent +
 443                      &quot;. Make sure to create a MAIN intent-filter for the corresponding activity &quot; +
 444                      &quot;or use the exported attribute for this activity.&quot;, e);
 445          }
 446      }
 447  
 448      static boolean isSystemApp(Context context, Intent intent) {
 449          PackageManager pm = context.getPackageManager();
 450          ComponentName cn = intent.getComponent();
 451          String packageName = null;
 452          if (cn == null) {
 453              ResolveInfo info = pm.resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY);
 454              if ((info != null) &amp;&amp; (info.activityInfo != null)) {
 455                  packageName = info.activityInfo.packageName;
 456              }
 457          } else {
 458              packageName = cn.getPackageName();
 459          }
 460          if (packageName != null) {
 461              try {
 462                  PackageInfo info = pm.getPackageInfo(packageName, 0);
 463                  return (info != null) &amp;&amp; (info.applicationInfo != null) &amp;&amp;
 464                          ((info.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0);
 465              } catch (NameNotFoundException e) {
 466                  return false;
 467              }
 468          } else {
 469              return false;
 470          }
 471      }
 472  
 473      /**
 474       * This picks a dominant color, looking for high-saturation, high-value, repeated hues.
 475       * @param bitmap The bitmap to scan
 476       * @param samples The approximate max number of samples to use.
 477       */
 478      static int findDominantColorByHue(Bitmap bitmap, int samples) {
 479          final int height = bitmap.getHeight();
 480          final int width = bitmap.getWidth();
 481          int sampleStride = (int) Math.sqrt((height * width) / samples);
 482          if (sampleStride &lt; 1) {
 483              sampleStride = 1;
 484          }
 485  
 486          // This is an out-param, for getting the hsv values for an rgb
 487          float[] hsv = new float[3];
 488  
 489          // First get the best hue, by creating a histogram over 360 hue buckets,
 490          // where each pixel contributes a score weighted by saturation, value, and alpha.
 491          float[] hueScoreHistogram = new float[360];
 492          float highScore = -1;
 493          int bestHue = -1;
 494  
 495          for (int y = 0; y &lt; height; y += sampleStride) {
 496              for (int x = 0; x &lt; width; x += sampleStride) {
 497                  int argb = bitmap.getPixel(x, y);
 498                  int alpha = 0xFF &amp; (argb &gt;&gt; 24);
 499                  if (alpha &lt; 0x80) {
 500                      // Drop mostly-transparent pixels.
 501                      continue;
 502                  }
 503                  // Remove the alpha channel.
 504                  int rgb = argb | 0xFF000000;
 505                  Color.colorToHSV(rgb, hsv);
 506                  // Bucket colors by the 360 integer hues.
 507                  int hue = (int) hsv[0];
 508                  if (hue &lt; 0 || hue &gt;= hueScoreHistogram.length) {
 509                      // Defensively avoid array bounds violations.
 510                      continue;
 511                  }
 512                  float score = hsv[1] * hsv[2];
 513                  hueScoreHistogram[hue] += score;
 514                  if (hueScoreHistogram[hue] &gt; highScore) {
 515                      highScore = hueScoreHistogram[hue];
 516                      bestHue = hue;
 517                  }
 518              }
 519          }
 520  
 521          SparseArray&lt;Float&gt; rgbScores = new SparseArray&lt;Float&gt;();
 522          int bestColor = 0xff000000;
 523          highScore = -1;
 524          // Go back over the RGB colors that match the winning hue,
 525          // creating a histogram of weighted s*v scores, for up to 100*100 [s,v] buckets.
 526          // The highest-scoring RGB color wins.
 527          for (int y = 0; y &lt; height; y += sampleStride) {
 528              for (int x = 0; x &lt; width; x += sampleStride) {
 529                  int rgb = bitmap.getPixel(x, y) | 0xff000000;
 530                  Color.colorToHSV(rgb, hsv);
 531                  int hue = (int) hsv[0];
 532                  if (hue == bestHue) {
 533                      float s = hsv[1];
 534                      float v = hsv[2];
 535                      int bucket = (int) (s * 100) + (int) (v * 10000);
 536                      // Score by cumulative saturation * value.
 537                      float score = s * v;
 538                      Float oldTotal = rgbScores.get(bucket);
 539                      float newTotal = oldTotal == null ? score : oldTotal + score;
 540                      rgbScores.put(bucket, newTotal);
 541                      if (newTotal &gt; highScore) {
 542                          highScore = newTotal;
 543                          // All the colors in the winning bucket are very similar. Last in wins.
 544                          bestColor = rgb;
 545                      }
 546                  }
 547              }
 548          }
 549          return bestColor;
 550      }
 551  
 552      /*
 553       * Finds a system apk which had a broadcast receiver listening to a particular action.
 554       * @param action intent action used to find the apk
 555       * @return a pair of apk package name and the resources.
 556       */
 557      static Pair&lt;String, Resources&gt; findSystemApk(String action, PackageManager pm) {
 558          final Intent intent = new Intent(action);
 559          for (ResolveInfo info : pm.queryBroadcastReceivers(intent, 0)) {
 560              if (info.activityInfo != null &amp;&amp;
 561                      (info.activityInfo.applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) != 0) {
 562                  final String packageName = info.activityInfo.packageName;
 563                  try {
 564                      final Resources res = pm.getResourcesForApplication(packageName);
 565                      return Pair.create(packageName, res);
 566                  } catch (NameNotFoundException e) {
 567                      Log.w(TAG, &quot;Failed to find resources for &quot; + packageName);
 568                  }
 569              }
 570          }
 571          return null;
 572      }
 573  
 574      @TargetApi(Build.VERSION_CODES.KITKAT)
 575      public static boolean isViewAttachedToWindow(View v) {
 576          if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) {
 577              return v.isAttachedToWindow();
 578          } else {
 579              // A proxy call which returns null, if the view is not attached to the window.
 580              return v.getKeyDispatcherState() != null;
 581          }
 582      }
 583  
 584      /**
 585       * Returns a widget with category {@link AppWidgetProviderInfo#WIDGET_CATEGORY_SEARCHBOX}
 586       * provided by the same package which is set to be global search activity.
 587       * If widgetCategory is not supported, or no such widget is found, returns the first widget
 588       * provided by the package.
 589       */
 590      @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)
 591      public static AppWidgetProviderInfo getSearchWidgetProvider(Context context) {
 592          SearchManager searchManager =
 593                  (SearchManager) context.getSystemService(Context.SEARCH_SERVICE);
 594          ComponentName searchComponent = searchManager.getGlobalSearchActivity();
 595          if (searchComponent == null) return null;
 596          String providerPkg = searchComponent.getPackageName();
 597  
 598          AppWidgetProviderInfo defaultWidgetForSearchPackage = null;
 599  
 600          AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(context);
 601          for (AppWidgetProviderInfo info : appWidgetManager.getInstalledProviders()) {
 602              if (info.provider.getPackageName().equals(providerPkg)) {
 603                  if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) {
 604                      if ((info.widgetCategory &amp; AppWidgetProviderInfo.WIDGET_CATEGORY_SEARCHBOX) != 0) {
 605                          return info;
 606                      } else if (defaultWidgetForSearchPackage == null) {
 607                          defaultWidgetForSearchPackage = info;
 608                      }
 609                  } else {
 610                      return info;
 611                  }
 612              }
 613          }
 614          return defaultWidgetForSearchPackage;
 615      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 616 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 617 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 618 +     * Compresses the bitmap to a byte array for serialization.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 619 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 620 +    public static byte[] flattenBitmap(Bitmap bitmap) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 621 +        // Try go guesstimate how much space the icon will take when serialized</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 622 +        // to avoid unnecessary allocations/copies during the write.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 623 +        int size = bitmap.getWidth() * bitmap.getHeight() * 4;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 624 +        ByteArrayOutputStream out = new ByteArrayOutputStream(size);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 625 +        try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 626 +            bitmap.compress(Bitmap.CompressFormat.PNG, 100, out);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 627 +            out.flush();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 628 +            out.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 629 +            return out.toByteArray();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 630 +        } catch (IOException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 631 +            Log.w(TAG, &quot;Could not write bitmap&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 632 +            return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 633 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 634 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 635 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 636 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 637 +     * Find the first vacant cell, if there is one.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 638 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 639 +     * @param vacant Holds the x and y coordinate of the vacant cell</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 640 +     * @param spanX Horizontal cell span.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 641 +     * @param spanY Vertical cell span.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 642 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 643 +     * @return true if a vacant cell was found</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 644 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 645 +    public static boolean findVacantCell(int[] vacant, int spanX, int spanY,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 646 +            int xCount, int yCount, boolean[][] occupied) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 647 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 648 +        for (int y = 0; (y + spanY) &lt;= yCount; y++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 649 +            for (int x = 0; (x + spanX) &lt;= xCount; x++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 650 +                boolean available = !occupied[x][y];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 651 +                out:            for (int i = x; i &lt; x + spanX; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 652 +                    for (int j = y; j &lt; y + spanY; j++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 653 +                        available = available &amp;&amp; !occupied[i][j];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 654 +                        if (!available) break out;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 655 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 656 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 657 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 658 +                if (available) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 659 +                    vacant[0] = x;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 660 +                    vacant[1] = y;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 661 +                    return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 662 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 663 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 664 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 665 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 666 +        return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 667 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 668 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 669 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 670 +     * Trims the string, removing all whitespace at the beginning and end of the string.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 671 +     * Non-breaking whitespaces are also removed.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 672 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 673 +    public static String trim(CharSequence s) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 674 +        if (s == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 675 +            return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 676 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 677 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 678 +        // Just strip any sequence of whitespace or java space characters from the beginning and end</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 679 +        Matcher m = sTrimPattern.matcher(s);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 680 +        return m.replaceAll(&quot;$1&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 681 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 682 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 683 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 684 +     * Calculates the height of a given string at a specific text size.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 685 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 686 +    public static float calculateTextHeight(float textSizePx) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 687 +        Paint p = new Paint();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 688 +        p.setTextSize(textSizePx);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 689 +        Paint.FontMetrics fm = p.getFontMetrics();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 690 +        return -fm.top + fm.bottom;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 691 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 692 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 693 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 694 +     * Convenience println with multiple args.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 695 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 696 +    public static void println(String key, Object... args) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 697 +        StringBuilder b = new StringBuilder();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 698 +        b.append(key);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 699 +        b.append(&quot;: &quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 700 +        boolean isFirstArgument = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 701 +        for (Object arg : args) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 702 +            if (isFirstArgument) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 703 +                isFirstArgument = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 704 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 705 +                b.append(&quot;, &quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 706 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 707 +            b.append(arg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 708 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 709 +        System.out.println(b.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 710 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 711 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 712 +    @TargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 713 +    public static boolean isRtl(Resources res) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 714 +        return (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.JELLY_BEAN_MR1) &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 715 +                (res.getConfiguration().getLayoutDirection() == View.LAYOUT_DIRECTION_RTL);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 716 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 717 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 718 +    public static void assertWorkerThread() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 719 +        if (LauncherAppState.isDogfoodBuild() &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 720 +                (LauncherModel.sWorkerThread.getThreadId() != Process.myTid())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 721 +            throw new IllegalStateException();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 722 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 723 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 724 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 725 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 726 +     * Returns true if the intent is a valid launch intent for a launcher activity of an app.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 727 +     * This is used to identify shortcuts which are different from the ones exposed by the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 728 +     * applications&#x27; manifest file.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 729 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 730 +     * @param launchIntent The intent that will be launched when the shortcut is clicked.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 731 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 732 +    public static boolean isLauncherAppTarget(Intent launchIntent) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 733 +        if (launchIntent != null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 734 +                &amp;&amp; Intent.ACTION_MAIN.equals(launchIntent.getAction())</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 735 +                &amp;&amp; launchIntent.getComponent() != null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 736 +                &amp;&amp; launchIntent.getCategories() != null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 737 +                &amp;&amp; launchIntent.getCategories().size() == 1</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 738 +                &amp;&amp; launchIntent.hasCategory(Intent.CATEGORY_LAUNCHER)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 739 +                &amp;&amp; TextUtils.isEmpty(launchIntent.getDataString())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 740 +            // An app target can either have no extra or have ItemInfo.EXTRA_PROFILE.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 741 +            Bundle extras = launchIntent.getExtras();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 742 +            if (extras == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 743 +                return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 744 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 745 +                Set&lt;String&gt; keys = extras.keySet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 746 +                return keys.size() == 1 &amp;&amp; keys.contains(ItemInfo.EXTRA_PROFILE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 747 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 748 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 749 +        return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 750 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 751 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 752 +    public static float dpiFromPx(int size, DisplayMetrics metrics){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 753 +        float densityRatio = (float) metrics.densityDpi / DisplayMetrics.DENSITY_DEFAULT;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 754 +        return (size / densityRatio);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 755 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 756 +    public static int pxFromDp(float size, DisplayMetrics metrics) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 757 +        return (int) Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 758 +                size, metrics));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 759 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 760 +    public static int pxFromSp(float size, DisplayMetrics metrics) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 761 +        return (int) Math.round(TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 762 +                size, metrics));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 763 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 764 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 765 +    public static String createDbSelectionQuery(String columnName, Iterable&lt;?&gt; values) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 766 +        return String.format(Locale.ENGLISH, &quot;%s IN (%s)&quot;, columnName, TextUtils.join(&quot;, &quot;, values));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 767 +    }</span>
 768  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            