<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>417</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    417
                    <a href="416.html">prev</a>
                    <a href="418.html">next</a>
                    <a href="417_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_f389ba111b6d691ecd5b0f2b8c9c050a03e595ad_core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;f389ba111b6d691ecd5b0f2b8c9c050a03e595ad:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;f389ba111b6d691ecd5b0f2b8c9c050a03e595ad^1:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;f389ba111b6d691ecd5b0f2b8c9c050a03e595ad^2:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;7c3f0a268d1fad776168ebb3b721653f7043ca97:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import org.apache.flink.api.common.typeinfo.TypeInformation;
  24 import org.apache.flink.api.java.tuple.Tuple2;
  25 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  26 import org.apache.flink.streaming.api.datastream.DataStream;
  27 import org.apache.flink.table.api.StreamQueryConfig;
  28 import org.apache.flink.table.api.Table;
  29 import org.apache.flink.table.api.TableSchema;
  30 import org.apache.flink.table.api.java.StreamTableEnvironment;
  31 import org.apache.flink.table.runtime.CRowKeySelector;
  32 import org.apache.flink.table.runtime.types.CRow;
  33 import org.apache.flink.table.runtime.types.CRowTypeInfo;
  34 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  35 import org.apache.flink.types.Row;
  36 
  37 import com.dtstack.flink.sql.enums.ECacheType;
  38 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  39 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  40 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  41 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  42 import com.dtstack.flink.sql.util.ClassUtil;
  43 import com.dtstack.flink.sql.util.ParseUtils;
  44 import com.dtstack.flink.sql.util.TableUtils;
  45 import com.google.common.base.Preconditions;
  46 import com.google.common.collect.*;
  47 import org.apache.calcite.sql.SqlAsOperator;
  48 import org.apache.calcite.sql.SqlBasicCall;
  49 import org.apache.calcite.sql.SqlDataTypeSpec;
  50 import org.apache.calcite.sql.SqlIdentifier;
  51 import org.apache.calcite.sql.SqlInsert;
  52 import org.apache.calcite.sql.SqlJoin;
  53 import org.apache.calcite.sql.SqlKind;
  54 import org.apache.calcite.sql.SqlLiteral;
  55 import org.apache.calcite.sql.SqlNode;
  56 import org.apache.calcite.sql.SqlNodeList;
  57 import org.apache.calcite.sql.SqlOperator;
  58 import org.apache.calcite.sql.SqlOrderBy;
  59 import org.apache.calcite.sql.SqlSelect;
  60 import org.apache.calcite.sql.SqlWithItem;
  61 import org.apache.calcite.sql.fun.SqlCase;
  62 import org.apache.calcite.sql.parser.SqlParseException;
  63 import org.apache.calcite.sql.parser.SqlParserPos;
  64 import org.apache.commons.collections.CollectionUtils;
  65 import org.apache.commons.lang3.StringUtils;
  66 import org.slf4j.Logger;
  67 import org.slf4j.LoggerFactory;
  68 
  69 import java.sql.Timestamp;
  70 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  71 import java.util.Arrays;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  72 import java.util.Collection;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  73 import java.util.LinkedList;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  74 import java.util.List;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  75 import java.util.Map;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  76 import java.util.Queue;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  77 import java.util.Set;</span>
  78 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  79 import org.slf4j.LoggerFactory;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  80 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  81 import java.sql.Timestamp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  82 import java.util.Collection;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  83 import java.util.LinkedList;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  84 import java.util.List;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  85 import java.util.Map;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  86 import java.util.Queue;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  87 import java.util.Set;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  88 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  89 import static org.apache.calcite.sql.SqlKind.*;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  90 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  91 /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  92  * Reason:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  93  * Date: 2018/7/24</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  94  * Company: www.dtstack.com</span>
  95 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  96 import java.util.*;</span>
  97 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  98 
  99 import static org.apache.calcite.sql.SqlKind.*;
 100 
 101 /**
 102  * Reason:
 103  * Date: 2018/7/24
 104  * Company: www.dtstack.com
 105  * @author xuchao
 106  */
 107 
 108 public class SideSqlExec {
 109 
 110     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
 111 
 112     private String localSqlPluginPath = null;
 113 
 114     private String tmpFields = null;
 115 
 116     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
 117 
 118     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
 119 
 120     public void exec(String sql,
 121                      Map&lt;String, SideTableInfo&gt; sideTableMap,
 122                      StreamTableEnvironment tableEnv,
 123                      Map&lt;String, Table&gt; tableCache,
 124                      StreamQueryConfig queryConfig,
 125                      CreateTmpTableParser.SqlParserResult createView) throws Exception {
 126         if(localSqlPluginPath == null){
 127             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 128         }
 129 
 130         localTableCache.putAll(tableCache);
 131         try {
 132             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 133         } catch (Exception e) {
 134             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 135         }
 136 
 137         if(createView != null){
 138             LOG.warn(&quot;create view info\n&quot;);
 139             LOG.warn(createView.getExecSql());
 140             LOG.warn(&quot;-----------------&quot;);
 141         }
 142 
 143         SideSQLParser sideSQLParser = new SideSQLParser();
 144         sideSQLParser.setLocalTableCache(localTableCache);
 145         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 146         Object pollObj = null;
 147 
 148         while((pollObj = exeQueue.poll()) != null){
 149 
 150             if(pollObj instanceof SqlNode){
 151                 SqlNode pollSqlNode = (SqlNode) pollObj;
 152 
 153 
 154                 if(pollSqlNode.getKind() == INSERT){
 155                     System.out.println(&quot;----------real exec sql-----------&quot; );
 156                     System.out.println(pollSqlNode.toString());
 157                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 158                     if(LOG.isInfoEnabled()){
 159                         LOG.info(&quot;exec sql: &quot; + pollSqlNode.toString());
 160                     }
 161 
 162                 }else if(pollSqlNode.getKind() == AS){
 163                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 164 
 165                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 166                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 167                     String TableAlias = sqlWithItem.name.toString();
 168                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 169                     tableEnv.registerTable(TableAlias, table);
 170 
 171                 } else if (pollSqlNode.getKind() == SELECT){
<abbr title=" 172                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 172                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 173                     Table table = tableEnv.sqlQuery(pollObj.toString());
 174 
 175                     if (createView.getFieldsInfoStr() == null){
 176                         tableEnv.registerTable(createView.getTableName(), table);
 177                     } else {
 178                         if (checkFieldsInfo(createView, table)){
 179                             table = table.as(tmpFields);
 180                             tableEnv.registerTable(createView.getTableName(), table);
 181                         } else {
 182                             throw new RuntimeException(&quot;Fields mismatch&quot;);
 183                         }
 184                     }
 185 
 186                     localTableCache.put(createView.getTableName(), table);
 187                 }
 188 
 189             }else if (pollObj instanceof JoinInfo){
 190                 System.out.println(&quot;----------exec join info----------&quot;);
 191                 System.out.println(pollObj.toString());
 192                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 193             }
 194         }
 195 
 196     }
 197 
 198 
 199     /**
 200      * 解析出as查询的表和字段的关系
 201      * @param asSqlNode
 202      * @param tableCache
 203      * @return
 204      */
 205     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 206         SqlNode info = asSqlNode.getOperands()[0];
 207         SqlNode alias = asSqlNode.getOperands()[1];
 208 
 209         SqlKind infoKind = info.getKind();
 210         if(infoKind != SELECT){
 211             return null;
 212         }
 213 
 214         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 215 
 216         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 217         for (FieldInfo fieldInfo : extractFieldList) {
 218             String tableName = fieldInfo.getTable();
 219             String fieldName = fieldInfo.getFieldName();
 220             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 221             mappingTable.put(tableName, fieldName, mappingFieldName);
 222         }
 223 
 224         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 225         replaceInfo.setMappingTable(mappingTable);
 226         replaceInfo.setTargetTableName(alias.toString());
 227         replaceInfo.setTargetTableAlias(alias.toString());
 228         return replaceInfo;
 229     }
 230 
 231 
 232     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 233         SqlKind sqlKind = sqlNode.getKind();
 234         if(sqlKind != AS){
 235             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 236         }
 237 
 238         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 239         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 240 
 241         AliasInfo aliasInfo = new AliasInfo();
 242         aliasInfo.setName(info.toString());
 243         aliasInfo.setAlias(alias.toString());
 244 
 245         return aliasInfo;
 246     }
 247 
 248     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,
 249                                            HashBasedTable&lt;String, String, String&gt; mappingTable) {
 250         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 251         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 252         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 253             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 254             String tableName = fieldInfo.getTable();
 255             String fieldName = fieldInfo.getFieldName();
 256 
 257             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 258             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 258             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 259 
 260             sideOutTypes[i] = fieldInfo.getTypeInformation();
 261             sideOutNames[i] = mappingFieldName;
 262         }
 263         return new RowTypeInfo(sideOutTypes, sideOutNames);
 264     }
 265 
 266 
 267 
 268     /**
 269      *  对时间类型进行类型转换
 270      * @param leftTypeInfo
 271      * @return
 272      */
 273     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 274         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 275         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 276         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 277             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 278         }
 279         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 280         return rowTypeInfo;
 281     }
 282 
 283     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 284         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 285             return TypeInformation.of(Timestamp.class);
 286         }
 287         return typeInformation;
 288     }
 289 
 290 
 291 
 292 
 293 
 294 
 295     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 296         this.localSqlPluginPath = localSqlPluginPath;
 297     }
 298 
<abbr title=" 299     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 299     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 300         Table table = localTableCache.get(tableAlias);
 301         if(table == null){
 302             table = localTableCache.get(tableName);
 303         }
 304 
 305         if(table == null){
 306             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 307         }
 308 
 309         return table;
 310     }
 311 
 312 
 313     /**
<abbr title=" 314      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 314      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 315      *
 316      * @return
 317      */
<abbr title=" 318     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, SideTableInfo sideTableInfo) {"> 318     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, SideTableInfo sideTa🔵</abbr>
 319         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 320         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 321             return true;
 322         }
 323         return false;
 324     }
 325 
 326     private List&lt;String&gt; convertPrimaryAlias(SideTableInfo sideTableInfo) {
 327         List&lt;String&gt; res = Lists.newArrayList();
 328         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 329             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 330         });
 331         return res;
 332     }
 333 
<abbr title=" 334     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, SideTableInfo sideTableInfo){"> 334     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, SideTableInfo 🔵</abbr>
 335         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 336         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 337         List&lt;String&gt; conditionFields = Lists.newArrayList();
 338         for(SqlNode sqlNode : sqlNodeList){
 339             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 340                 throw new RuntimeException(&quot;not compare operator.&quot;);
 341             }
 342 
 343             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 344             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 345 
 346             String leftTableName = left.getComponent(0).getSimple();
 347             String rightTableName = right.getComponent(0).getSimple();
 348 
 349             String tableCol = &quot;&quot;;
 350             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 351                 tableCol = left.getComponent(1).getSimple();
 352             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 353                 tableCol = right.getComponent(1).getSimple();
 354             }else{
<abbr title=" 355                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 355                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 356             }
 357             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 358             conditionFields.add(tableCol);
 359         }
 360 
 361         return conditionFields;
 362     }
 363 
 364     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 365                                      SqlNode pollSqlNode,
 366                                      Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 367 
 368         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 369         if (localTableCache.containsKey(aliasInfo.getName())) {
 370             return;
 371         }
 372 
 373         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 374         tableEnv.registerTable(aliasInfo.getAlias(), table);
 375         localTableCache.put(aliasInfo.getAlias(), table);
 376 
 377         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 378 
 379         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 380         if(fieldReplaceInfo == null){
 381            return;
 382         }
 383 
 384         //as 的源表
 385         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 386         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 387         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 388 
 389     }
 390 
 391     private void joinFun(Object pollObj,
 392                          Map&lt;String, Table&gt; localTableCache,
 393                          Map&lt;String, SideTableInfo&gt; sideTableMap,
 394                          StreamTableEnvironment tableEnv) throws Exception{
 395         JoinInfo joinInfo = (JoinInfo) pollObj;
 396 
 397         JoinScope joinScope = new JoinScope();
 398         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 399         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 400         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 401 
<abbr title=" 402         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 402         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title=" 403         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 403         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema(🔵</abbr>
 404         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 405 
 406         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 407         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 408         rightScopeChild.setTableName(joinInfo.getRightTableName());
 409         SideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 410         if(sideTableInfo == null){
 411             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 412         }
 413 
 414         if(sideTableInfo == null){
 415             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 416         }
 417 
 418 //        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){
 419 //            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
 420 //        }
 421 
 422         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 423 
 424         joinScope.addScope(leftScopeChild);
 425         joinScope.addScope(rightScopeChild);
 426 
 427         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();
 428 
 429         //获取两个表的所有字段
<abbr title=" 430         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 430         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 431         //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 432         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 432         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo🔵</abbr>
 433 
 434         String leftTableAlias = joinInfo.getLeftTableAlias();
 435         Table targetTable = localTableCache.get(leftTableAlias);
 436         if(targetTable == null){
 437             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 438         }
 439 
<abbr title=" 440         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 440         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema(🔵</abbr>
 441 
<abbr title=" 442         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)"> 442         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.c🔵</abbr>
 443                 .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {
 444                     return new CRow(tp2.f1, tp2.f0);
 445                 }).returns(CRow.class);
 446 
 447 
 448         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 449         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 450             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 450             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 451             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 452             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 453             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 453             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, tar🔵</abbr>
 454         }
 455 
 456         DataStream&lt;CRow&gt; dsOut = null;
 457         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 458             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 458             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 459         }else{
<abbr title=" 460             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 460             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 461         }
 462 
 463         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 464 
 465         CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 466         dsOut.getTransformation().setOutputType(cRowTypeInfo);
 467 
 468         String targetTableName = joinInfo.getNewTableName();
 469         String targetTableAlias = joinInfo.getNewTableAlias();
 470 
 471         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 472         replaceInfo.setMappingTable(mappingTable);
 473         replaceInfo.setTargetTableName(targetTableName);
 474         replaceInfo.setTargetTableAlias(targetTableAlias);
 475 
 476         if (!tableEnv.isRegistered(joinInfo.getNewTableName())){
 477             Table joinTable = tableEnv.fromDataStream(dsOut);
 478             tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 479             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 480         }
 481     }
 482 
 483     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 484         String[] fieldNames = schema.getFieldNames();
 485         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 486 
<abbr title=" 487         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 487         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 488         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 488         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 489         return new RowTypeInfo(projectedTypes, projectedNames);
 490     }
 491 
 492 
 493     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 494         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 495         String fieldsInfo = result.getFieldsInfoStr();
 496         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 497         for (int i = 0; i &lt; fields.length; i++) {
 498             String[] filed = fields[i].split(&quot;\\s&quot;);
 499             if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){
 500                 return false;
 501             } else {
 502                 String[] filedNameArr = new String[filed.length - 1];
 503                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 504                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 505                 fieldNames.add(fieldName);
 506                 String fieldType = filed[filed.length - 1 ].trim();
 507                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 508                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 509                 if (fieldClass == tableField){
 510                     continue;
 511                 } else {
 512                     return false;
 513                 }
 514             }
 515         }
 516         tmpFields = String.join(&quot;,&quot;, fieldNames);
 517         return true;
 518     }
 519 
 520 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import com.dtstack.flink.sql.enums.ECacheType;
  24 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  25 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  26 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  27 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  28 import com.dtstack.flink.sql.util.ClassUtil;
  29 import com.dtstack.flink.sql.util.ParseUtils;
  30 import com.dtstack.flink.sql.util.TableUtils;
  31 import com.google.common.base.Preconditions;
  32 import com.google.common.collect.*;
  33 import org.apache.calcite.sql.SqlAsOperator;
  34 import org.apache.calcite.sql.SqlBasicCall;
  35 import org.apache.calcite.sql.SqlDataTypeSpec;
  36 import org.apache.calcite.sql.SqlIdentifier;
  37 import org.apache.calcite.sql.SqlInsert;
  38 import org.apache.calcite.sql.SqlJoin;
  39 import org.apache.calcite.sql.SqlKind;
  40 import org.apache.calcite.sql.SqlLiteral;
  41 import org.apache.calcite.sql.SqlNode;
  42 import org.apache.calcite.sql.SqlNodeList;
  43 import org.apache.calcite.sql.SqlOperator;
  44 import org.apache.calcite.sql.SqlOrderBy;
  45 import org.apache.calcite.sql.SqlSelect;
  46 import org.apache.calcite.sql.SqlWithItem;
  47 import org.apache.calcite.sql.fun.SqlCase;
  48 import org.apache.calcite.sql.parser.SqlParseException;
  49 import org.apache.calcite.sql.parser.SqlParserPos;
  50 import org.apache.commons.collections.CollectionUtils;
  51 import org.apache.commons.lang3.StringUtils;
  52 
  53 import org.apache.flink.api.common.typeinfo.TypeInformation;
  54 import org.apache.flink.api.java.tuple.Tuple2;
  55 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  56 import org.apache.flink.streaming.api.datastream.DataStream;
  57 import org.apache.flink.table.api.StreamQueryConfig;
  58 import org.apache.flink.table.api.Table;
  59 import org.apache.flink.table.api.TableSchema;
  60 import org.apache.flink.table.api.java.StreamTableEnvironment;
  61 import org.apache.flink.table.runtime.CRowKeySelector;
  62 import org.apache.flink.table.runtime.types.CRow;
  63 import org.apache.flink.table.runtime.types.CRowTypeInfo;
  64 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  65 import org.apache.flink.types.Row;
  66 import org.slf4j.Logger;
  67 import org.slf4j.LoggerFactory;
  68 
  69 import java.sql.Timestamp;
  70 import java.util.Arrays;
  71 import java.util.*;
  72 
  73 import static org.apache.calcite.sql.SqlKind.*;
  74 
  75 /**
  76  * Reason:
  77  * Date: 2018/7/24
  78  * Company: www.dtstack.com
  79  * @author xuchao
  80  */
  81 
  82 public class SideSqlExec {
  83 
  84     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  85 
  86     private String localSqlPluginPath = null;
  87 
  88     private String tmpFields = null;
  89 
  90     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  91 
  92     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  93 
  94     public void exec(String sql,
  95                      Map&lt;String, SideTableInfo&gt; sideTableMap,
  96                      StreamTableEnvironment tableEnv,
  97                      Map&lt;String, Table&gt; tableCache,
  98                      StreamQueryConfig queryConfig,
  99                      CreateTmpTableParser.SqlParserResult createView) throws Exception {
 100         if(localSqlPluginPath == null){
 101             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 102         }
 103 
 104         localTableCache.putAll(tableCache);
 105         try {
 106             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 107         } catch (Exception e) {
 108             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 109         }
 110 
 111         if(createView != null){
 112             LOG.warn(&quot;create view info\n&quot;);
 113             LOG.warn(createView.getExecSql());
 114             LOG.warn(&quot;-----------------&quot;);
 115         }
 116 
 117         SideSQLParser sideSQLParser = new SideSQLParser();
 118         sideSQLParser.setLocalTableCache(localTableCache);
 119         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 120         Object pollObj = null;
 121 
 122         while((pollObj = exeQueue.poll()) != null){
 123 
 124             if(pollObj instanceof SqlNode){
 125                 SqlNode pollSqlNode = (SqlNode) pollObj;
 126 
 127 
 128                 if(pollSqlNode.getKind() == INSERT){
 129                     System.out.println(&quot;----------real exec sql-----------&quot; );
 130                     System.out.println(pollSqlNode.toString());
 131                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 132                     if(LOG.isInfoEnabled()){
 133                         LOG.info(&quot;exec sql: &quot; + pollSqlNode.toString());
 134                     }
 135 
 136                 }else if(pollSqlNode.getKind() == AS){
 137                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 138 
 139                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 140                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 141                     String TableAlias = sqlWithItem.name.toString();
 142                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 143                     tableEnv.registerTable(TableAlias, table);
 144 
 145                 } else if (pollSqlNode.getKind() == SELECT){
<abbr title=" 146                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 146                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 147                     Table table = tableEnv.sqlQuery(pollObj.toString());
 148 
 149                     if (createView.getFieldsInfoStr() == null){
 150                         tableEnv.registerTable(createView.getTableName(), table);
 151                     } else {
 152                         if (checkFieldsInfo(createView, table)){
 153                             table = table.as(tmpFields);
 154                             tableEnv.registerTable(createView.getTableName(), table);
 155                         } else {
 156                             throw new RuntimeException(&quot;Fields mismatch&quot;);
 157                         }
 158                     }
 159 
 160                     localTableCache.put(createView.getTableName(), table);
 161                 }
 162 
 163             }else if (pollObj instanceof JoinInfo){
 164                 System.out.println(&quot;----------exec join info----------&quot;);
 165                 System.out.println(pollObj.toString());
 166                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 167             }
 168         }
 169 
 170     }
 171 
 172 
 173     /**
 174      * 解析出as查询的表和字段的关系
 175      * @param asSqlNode
 176      * @param tableCache
 177      * @return
 178      */
 179     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 180         SqlNode info = asSqlNode.getOperands()[0];
 181         SqlNode alias = asSqlNode.getOperands()[1];
 182 
 183         SqlKind infoKind = info.getKind();
 184         if(infoKind != SELECT){
 185             return null;
 186         }
 187 
 188         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 189 
 190         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 191         for (FieldInfo fieldInfo : extractFieldList) {
 192             String tableName = fieldInfo.getTable();
 193             String fieldName = fieldInfo.getFieldName();
 194             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 195             mappingTable.put(tableName, fieldName, mappingFieldName);
 196         }
 197 
 198         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 199         replaceInfo.setMappingTable(mappingTable);
 200         replaceInfo.setTargetTableName(alias.toString());
 201         replaceInfo.setTargetTableAlias(alias.toString());
 202         return replaceInfo;
 203     }
 204 
 205 
 206     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 207         SqlKind sqlKind = sqlNode.getKind();
 208         if(sqlKind != AS){
 209             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 210         }
 211 
 212         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 213         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 214 
 215         AliasInfo aliasInfo = new AliasInfo();
 216         aliasInfo.setName(info.toString());
 217         aliasInfo.setAlias(alias.toString());
 218 
 219         return aliasInfo;
 220     }
 221 
 222     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,
 223                                            HashBasedTable&lt;String, String, String&gt; mappingTable) {
 224         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 225         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 226         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 227             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 228             String tableName = fieldInfo.getTable();
 229             String fieldName = fieldInfo.getFieldName();
 230 
 231             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 232             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 232             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 233 
 234             sideOutTypes[i] = fieldInfo.getTypeInformation();
 235             sideOutNames[i] = mappingFieldName;
 236         }
 237         return new RowTypeInfo(sideOutTypes, sideOutNames);
 238     }
 239 
 240 
 241 
 242     /**
 243      *  对时间类型进行类型转换
 244      * @param leftTypeInfo
 245      * @return
 246      */
 247     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 248         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 249         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 250         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 251             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 252         }
 253         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 254         return rowTypeInfo;
 255     }
 256 
 257     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 258         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 259             return TypeInformation.of(Timestamp.class);
 260         }
 261         return typeInformation;
 262     }
 263 
 264 
 265 
 266 
 267 
 268 
 269     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 270         this.localSqlPluginPath = localSqlPluginPath;
 271     }
 272 
<abbr title=" 273     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 273     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 274         Table table = localTableCache.get(tableAlias);
 275         if(table == null){
 276             table = localTableCache.get(tableName);
 277         }
 278 
 279         if(table == null){
 280             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 281         }
 282 
 283         return table;
 284     }
 285 
 286 
 287     /**
<abbr title=" 288      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 288      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 289      *
 290      * @return
 291      */
<abbr title=" 292     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, SideTableInfo sideTableInfo) {"> 292     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, SideTableInfo sideTa🔵</abbr>
 293         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 294         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 295             return true;
 296         }
 297         return false;
 298     }
 299 
 300     private List&lt;String&gt; convertPrimaryAlias(SideTableInfo sideTableInfo) {
 301         List&lt;String&gt; res = Lists.newArrayList();
 302         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 303             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 304         });
 305         return res;
 306     }
 307 
<abbr title=" 308     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, SideTableInfo sideTableInfo){"> 308     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, SideTableInfo 🔵</abbr>
 309         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 310         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 311         List&lt;String&gt; conditionFields = Lists.newArrayList();
 312         for(SqlNode sqlNode : sqlNodeList){
 313             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 314                 throw new RuntimeException(&quot;not compare operator.&quot;);
 315             }
 316 
 317             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 318             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 319 
 320             String leftTableName = left.getComponent(0).getSimple();
 321             String rightTableName = right.getComponent(0).getSimple();
 322 
 323             String tableCol = &quot;&quot;;
 324             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 325                 tableCol = left.getComponent(1).getSimple();
 326             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 327                 tableCol = right.getComponent(1).getSimple();
 328             }else{
<abbr title=" 329                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 329                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 330             }
 331             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 332             conditionFields.add(tableCol);
 333         }
 334 
 335         return conditionFields;
 336     }
 337 
 338     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 339                                      SqlNode pollSqlNode,
 340                                      Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 341 
 342         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 343         if (localTableCache.containsKey(aliasInfo.getName())) {
 344             return;
 345         }
 346 
 347         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 348         tableEnv.registerTable(aliasInfo.getAlias(), table);
 349         localTableCache.put(aliasInfo.getAlias(), table);
 350 
 351         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 352 
 353         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 354         if(fieldReplaceInfo == null){
 355            return;
 356         }
 357 
 358         //as 的源表
 359         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 360         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 361         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 362 
 363     }
 364 
 365     private void joinFun(Object pollObj,
 366                          Map&lt;String, Table&gt; localTableCache,
 367                          Map&lt;String, SideTableInfo&gt; sideTableMap,
 368                          StreamTableEnvironment tableEnv) throws Exception{
 369         JoinInfo joinInfo = (JoinInfo) pollObj;
 370 
 371         JoinScope joinScope = new JoinScope();
 372         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 373         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 374         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 375 
<abbr title=" 376         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 376         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title=" 377         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 377         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema(🔵</abbr>
 378         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 379 
 380         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 381         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 382         rightScopeChild.setTableName(joinInfo.getRightTableName());
 383         SideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 384         if(sideTableInfo == null){
 385             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 386         }
 387 
 388         if(sideTableInfo == null){
 389             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 390         }
 391 
 392 //        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){
 393 //            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
 394 //        }
 395 
 396         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 397 
 398         joinScope.addScope(leftScopeChild);
 399         joinScope.addScope(rightScopeChild);
 400 
 401         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();
 402 
 403         //获取两个表的所有字段
<abbr title=" 404         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 404         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 405         //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 406         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 406         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo🔵</abbr>
 407 
 408         String leftTableAlias = joinInfo.getLeftTableAlias();
 409         Table targetTable = localTableCache.get(leftTableAlias);
 410         if(targetTable == null){
 411             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 412         }
 413 
<abbr title=" 414         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 414         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema(🔵</abbr>
 415 
<abbr title=" 416         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)"> 416         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.c🔵</abbr>
 417                 .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {
 418                     return new CRow(tp2.f1, tp2.f0);
 419                 }).returns(CRow.class);
 420 
 421 
 422         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 423         if(sideTableInfo.isPartitionedJoin()){
<abbr title=" 424             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 424             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 425             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 426             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 427             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 427             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, tar🔵</abbr>
 428         }
 429 
 430         DataStream&lt;CRow&gt; dsOut = null;
 431         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 432             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 432             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 433         }else{
<abbr title=" 434             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 434             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 435         }
 436 
 437         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 438 
 439         CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 440         dsOut.getTransformation().setOutputType(cRowTypeInfo);
 441 
 442         String targetTableName = joinInfo.getNewTableName();
 443         String targetTableAlias = joinInfo.getNewTableAlias();
 444 
 445         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 446         replaceInfo.setMappingTable(mappingTable);
 447         replaceInfo.setTargetTableName(targetTableName);
 448         replaceInfo.setTargetTableAlias(targetTableAlias);
 449 
 450         if (!tableEnv.isRegistered(joinInfo.getNewTableName())){
 451             Table joinTable = tableEnv.fromDataStream(dsOut);
 452             tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 453             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 454         }
 455     }
 456 
 457     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 458         String[] fieldNames = schema.getFieldNames();
 459         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 460 
<abbr title=" 461         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 461         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 462         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 462         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 463         return new RowTypeInfo(projectedTypes, projectedNames);
 464     }
 465 
 466 
 467     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 468         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 469         String fieldsInfo = result.getFieldsInfoStr();
 470         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 471         for (int i = 0; i &lt; fields.length; i++) {
 472             String[] filed = fields[i].split(&quot;\\s&quot;);
 473             if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){
 474                 return false;
 475             } else {
 476                 String[] filedNameArr = new String[filed.length - 1];
 477                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 478                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 479                 fieldNames.add(fieldName);
 480                 String fieldType = filed[filed.length - 1 ].trim();
 481                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 482                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 483                 if (fieldClass == tableField){
 484                     continue;
 485                 } else {
 486                     return false;
 487                 }
 488             }
 489         }
 490         tmpFields = String.join(&quot;,&quot;, fieldNames);
 491         return true;
 492     }
 493 
 494 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheType;
  21 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  22 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  23 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  24 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  25 import com.dtstack.flink.sql.util.ClassUtil;
  26 import com.dtstack.flink.sql.util.ParseUtils;
  27 import com.dtstack.flink.sql.util.TableUtils;
  28 import com.google.common.base.Preconditions;
  29 import com.google.common.collect.*;
  30 import java.sql.Timestamp;
  31 import java.util.*;
  32 import java.util.Arrays;
  33 import org.apache.calcite.sql.SqlAsOperator;
  34 import org.apache.calcite.sql.SqlBasicCall;
  35 import org.apache.calcite.sql.SqlDataTypeSpec;
  36 import org.apache.calcite.sql.SqlIdentifier;
  37 import org.apache.calcite.sql.SqlInsert;
  38 import org.apache.calcite.sql.SqlJoin;
  39 import org.apache.calcite.sql.SqlKind;
  40 import org.apache.calcite.sql.SqlLiteral;
  41 import org.apache.calcite.sql.SqlNode;
  42 import org.apache.calcite.sql.SqlNodeList;
  43 import org.apache.calcite.sql.SqlOperator;
  44 import org.apache.calcite.sql.SqlOrderBy;
  45 import org.apache.calcite.sql.SqlSelect;
  46 import org.apache.calcite.sql.SqlWithItem;
  47 import org.apache.calcite.sql.fun.SqlCase;
  48 import org.apache.calcite.sql.parser.SqlParseException;
  49 import org.apache.calcite.sql.parser.SqlParserPos;
  50 import org.apache.commons.collections.CollectionUtils;
  51 import org.apache.commons.lang3.StringUtils;
  52 import org.apache.flink.api.common.typeinfo.TypeInformation;
  53 import org.apache.flink.api.java.tuple.Tuple2;
  54 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  55 import org.apache.flink.streaming.api.datastream.DataStream;
  56 import org.apache.flink.table.api.StreamQueryConfig;
  57 import org.apache.flink.table.api.Table;
  58 import org.apache.flink.table.api.TableSchema;
  59 import org.apache.flink.table.api.java.StreamTableEnvironment;
  60 import org.apache.flink.table.runtime.CRowKeySelector;
  61 import org.apache.flink.table.runtime.types.CRow;
  62 import org.apache.flink.table.runtime.types.CRowTypeInfo;
  63 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  64 import org.apache.flink.types.Row;
  65 import org.slf4j.Logger;
  66 import org.slf4j.LoggerFactory;
  67 import static org.apache.calcite.sql.SqlKind.*;
  68 
  69 
  70 /**
  71  * Reason:
  72  * Date: 2018/7/24
  73  * Company: www.dtstack.com
  74  * @author xuchao
  75  */
  76 public class SideSqlExec {
  77     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  78 
  79     private String localSqlPluginPath = null;
  80 
  81     private String tmpFields = null;
  82 
  83     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  84 
  85     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  86 
<abbr title="  87     public void exec(String sql, Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv, Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserResult createView) throws Exception {">  87     public void exec(String sql, Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv🔵</abbr>
  88         if (localSqlPluginPath == null) {
  89             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
  90         }
  91         localTableCache.putAll(tableCache);
  92         try {
  93             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
  94         } catch (java.lang.Exception e) {
  95             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
  96         }
  97         if (createView != null) {
  98             LOG.warn(&quot;create view info\n&quot;);
  99             LOG.warn(createView.getExecSql());
 100             LOG.warn(&quot;-----------------&quot;);
 101         }
 102         SideSQLParser sideSQLParser = new SideSQLParser();
 103         sideSQLParser.setLocalTableCache(localTableCache);
 104         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 105         Object pollObj = null;
 106         while ((pollObj = exeQueue.poll()) != null) {
 107             if (pollObj instanceof SqlNode) {
 108                 SqlNode pollSqlNode = ((SqlNode) (pollObj));
 109                 if (pollSqlNode.getKind() == INSERT) {
 110                     System.out.println(&quot;----------real exec sql-----------&quot;);
 111                     System.out.println(pollSqlNode.toString());
 112                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 113                     if (LOG.isInfoEnabled()) {
 114                         LOG.info(&quot;exec sql: &quot; + pollSqlNode.toString());
 115                     }
 116                 } else if (pollSqlNode.getKind() == AS) {
 117                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 118                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 119                     SqlWithItem sqlWithItem = ((SqlWithItem) (pollSqlNode));
 120                     String TableAlias = sqlWithItem.name.toString();
 121                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 122                     tableEnv.registerTable(TableAlias, table);
 123                 } else if (pollSqlNode.getKind() == SELECT) {
<abbr title=" 124                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 124                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 125                     Table table = tableEnv.sqlQuery(pollObj.toString());
 126                     if (createView.getFieldsInfoStr() == null) {
 127                         tableEnv.registerTable(createView.getTableName(), table);
 128                     } else if (checkFieldsInfo(createView, table)) {
 129                         table = table.as(tmpFields);
 130                         tableEnv.registerTable(createView.getTableName(), table);
 131                     } else {
 132                         throw new RuntimeException(&quot;Fields mismatch&quot;);
 133                     }
 134                     localTableCache.put(createView.getTableName(), table);
 135                 }
 136             } else if (pollObj instanceof JoinInfo) {
 137                 System.out.println(&quot;----------exec join info----------&quot;);
 138                 System.out.println(pollObj.toString());
 139                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 140             }
 141         }
 142     }
 143 
 144     /**
 145      * 解析出as查询的表和字段的关系
 146      * @param asSqlNode
 147      * @param tableCache
 148      * @return
 149      */
 150     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache) {
 151         SqlNode info = asSqlNode.getOperands()[0];
 152         SqlNode alias = asSqlNode.getOperands()[1];
 153         SqlKind infoKind = info.getKind();
 154         if (infoKind != SELECT) {
 155             return null;
 156         }
<abbr title=" 157         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField(((SqlSelect) (info)), tableCache);"> 157         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField(((SqlSelect) (info)), tableCache)🔵</abbr>
 158         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 159         for (FieldInfo fieldInfo : extractFieldList) {
 160             String tableName = fieldInfo.getTable();
 161             String fieldName = fieldInfo.getFieldName();
 162             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 163             mappingTable.put(tableName, fieldName, mappingFieldName);
 164         }
 165         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 166         replaceInfo.setMappingTable(mappingTable);
 167         replaceInfo.setTargetTableName(alias.toString());
 168         replaceInfo.setTargetTableAlias(alias.toString());
 169         return replaceInfo;
 170     }
 171 
 172     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 173         SqlKind sqlKind = sqlNode.getKind();
 174         if(sqlKind != AS){
 175             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 176         }
 177 
 178         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 179         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 180 
 181         AliasInfo aliasInfo = new AliasInfo();
 182         aliasInfo.setName(info.toString());
 183         aliasInfo.setAlias(alias.toString());
 184 
 185         return aliasInfo;
 186     }
 187 
<abbr title=" 188     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 188     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, Stri🔵</abbr>
 189         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 190         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 191         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 192             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 193             String tableName = fieldInfo.getTable();
 194             String fieldName = fieldInfo.getFieldName();
 195             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 196             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 196             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 197             sideOutTypes[i] = fieldInfo.getTypeInformation();
 198             sideOutNames[i] = mappingFieldName;
 199         }
 200         return new RowTypeInfo(sideOutTypes, sideOutNames);
 201     }
 202 
 203     /**
 204      *  对时间类型进行类型转换
 205      * @param leftTypeInfo
 206      * @return
 207      */
 208     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 209         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 210         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 211         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 212             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 213         }
 214         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 215         return rowTypeInfo;
 216     }
 217 
 218     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 219         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 220             return TypeInformation.of(Timestamp.class);
 221         }
 222         return typeInformation;
 223     }
 224 
 225     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 226         this.localSqlPluginPath = localSqlPluginPath;
 227     }
 228 
<abbr title=" 229     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName) {"> 229     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 230         Table table = localTableCache.get(tableAlias);
 231         if (table == null) {
 232             table = localTableCache.get(tableName);
 233         }
 234         if (table == null) {
 235             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 236         }
 237         return table;
 238     }
 239 
 240     /**
<abbr title=" 241      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 241      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 242      *
 243      * @return
 244      */
<abbr title=" 245     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, SideTableInfo sideTableInfo) {"> 245     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, SideTableInfo sideTa🔵</abbr>
 246         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 247         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 248             return true;
 249         }
 250         return false;
 251     }
 252 
 253     private List&lt;String&gt; convertPrimaryAlias(SideTableInfo sideTableInfo) {
 254         List&lt;String&gt; res = Lists.newArrayList();
 255         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 256             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 257         });
 258         return res;
 259     }
 260 
<abbr title=" 261     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, SideTableInfo sideTableInfo){"> 261     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, SideTableInfo 🔵</abbr>
 262         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 263         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 264         List&lt;String&gt; conditionFields = Lists.newArrayList();
 265         for(SqlNode sqlNode : sqlNodeList){
 266             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 267                 throw new RuntimeException(&quot;not compare operator.&quot;);
 268             }
 269 
 270             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 271             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 272 
 273             String leftTableName = left.getComponent(0).getSimple();
 274             String rightTableName = right.getComponent(0).getSimple();
 275 
 276             String tableCol = &quot;&quot;;
 277             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 278                 tableCol = left.getComponent(1).getSimple();
 279             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 280                 tableCol = right.getComponent(1).getSimple();
 281             }else{
<abbr title=" 282                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 282                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 283             }
 284             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 285             conditionFields.add(tableCol);
 286         }
 287 
 288         return conditionFields;
 289     }
 290 
<abbr title=" 291     protected void dealAsSourceTable(StreamTableEnvironment tableEnv, SqlNode pollSqlNode, Map&lt;String, Table&gt; tableCache) throws SqlParseException {"> 291     protected void dealAsSourceTable(StreamTableEnvironment tableEnv, SqlNode pollSqlNode, Map&lt;String, Ta🔵</abbr>
 292         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 293         if (localTableCache.containsKey(aliasInfo.getName())) {
 294             return;
 295         }
 296         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 297         tableEnv.registerTable(aliasInfo.getAlias(), table);
 298         localTableCache.put(aliasInfo.getAlias(), table);
 299         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 300         FieldReplaceInfo fieldReplaceInfo = parseAsQuery(((SqlBasicCall) (pollSqlNode)), tableCache);
 301         if (fieldReplaceInfo == null) {
 302             return;
 303         }
 304         // as 的源表
 305         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 306         SqlNode fromNode = ((SqlBasicCall) (pollSqlNode)).getOperands()[0];
 307         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 308     }
 309 
<abbr title=" 310     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache, Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv) throws Exception {"> 310     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache, Map&lt;String, SideTableInfo&gt; s🔵</abbr>
 311         JoinInfo joinInfo = ((JoinInfo) (pollObj));
 312         JoinScope joinScope = new JoinScope();
 313         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 314         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 315         leftScopeChild.setTableName(joinInfo.getLeftTableName());
<abbr title=" 316         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 316         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title=" 317         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 317         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema(🔵</abbr>
 318         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 319         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 320         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 321         rightScopeChild.setTableName(joinInfo.getRightTableName());
 322         SideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 323         if (sideTableInfo == null) {
 324             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 325         }
 326         if (sideTableInfo == null) {
 327             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 328         }
 329 //        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){
 330 //            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
 331 //        }
 332         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 333         joinScope.addScope(leftScopeChild);
 334         joinScope.addScope(rightScopeChild);
 335         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) (pollObj)).getTableFieldRef();
 336         // 获取两个表的所有字段
<abbr title=" 337         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 337         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 338         //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 339         sideJoinFieldInfo.removeIf(( tmpFieldInfo) -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 339         sideJoinFieldInfo.removeIf(( tmpFieldInfo) -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldI🔵</abbr>
 340         String leftTableAlias = joinInfo.getLeftTableAlias();
 341         Table targetTable = localTableCache.get(leftTableAlias);
 342         if (targetTable == null) {
 343             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 344         }
<abbr title=" 345         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 345         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema(🔵</abbr>
<abbr title=" 346         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class).map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {"> 346         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class).map((Tuple2&lt;Boole🔵</abbr>
 347             return new CRow(tp2.f1, tp2.f0);
 348         }).returns(CRow.class);
 349         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 350         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 351             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 351             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 352             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 353             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 354             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 354             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, tar🔵</abbr>
 355         }
 356         DataStream&lt;CRow&gt; dsOut = null;
 357         if (ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())) {
<abbr title=" 358             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 358             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 359         } else {
<abbr title=" 360             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 360             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 361         }
 362         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 363         CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 364         dsOut.getTransformation().setOutputType(cRowTypeInfo);
 365         String targetTableName = joinInfo.getNewTableName();
 366         String targetTableAlias = joinInfo.getNewTableAlias();
 367         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 368         replaceInfo.setMappingTable(mappingTable);
 369         replaceInfo.setTargetTableName(targetTableName);
 370         replaceInfo.setTargetTableAlias(targetTableAlias);
 371         if (!tableEnv.isRegistered(joinInfo.getNewTableName())) {
 372             Table joinTable = tableEnv.fromDataStream(dsOut);
 373             tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 374             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 375         }
 376     }
 377 
 378     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 379         String[] fieldNames = schema.getFieldNames();
 380         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 381 
<abbr title=" 382         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 382         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 383         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 383         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 384         return new RowTypeInfo(projectedTypes, projectedNames);
 385     }
 386 
 387     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 388         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 389         String fieldsInfo = result.getFieldsInfoStr();
 390         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 391         for (int i = 0; i &lt; fields.length; i++) {
 392             String[] filed = fields[i].split(&quot;\\s&quot;);
 393             if ((filed.length &lt; 2) || (fields.length != table.getSchema().getColumnNames().length)) {
 394                 return false;
 395             } else {
 396                 String[] filedNameArr = new String[filed.length - 1];
 397                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 398                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 399                 fieldNames.add(fieldName);
 400                 String fieldType = filed[filed.length - 1].trim();
 401                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 402                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 403                 if (fieldClass == tableField) {
 404                     continue;
 405                 } else {
 406                     return false;
 407                 }
 408             }
 409         }
 410         tmpFields = String.join(&quot;,&quot;, fieldNames);
 411         return true;
 412     }
 413 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  22 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import org.apache.flink.api.common.typeinfo.TypeInformation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import org.apache.flink.api.java.tuple.Tuple2;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +import org.apache.flink.streaming.api.datastream.DataStream;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import org.apache.flink.table.api.StreamQueryConfig;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import org.apache.flink.table.api.Table;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import org.apache.flink.table.api.TableSchema;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import org.apache.flink.table.api.java.StreamTableEnvironment;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 +import org.apache.flink.table.runtime.CRowKeySelector;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 +import org.apache.flink.table.runtime.types.CRowTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import org.apache.flink.types.Row;</span>
  36  
  37  import com.dtstack.flink.sql.enums.ECacheType;
  38  import com.dtstack.flink.sql.exec.FlinkSQLExec;
  39  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  40  import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  41  import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  42  import com.dtstack.flink.sql.util.ClassUtil;
  43  import com.dtstack.flink.sql.util.ParseUtils;
  44  import com.dtstack.flink.sql.util.TableUtils;
  45  import com.google.common.base.Preconditions;
  46  import com.google.common.collect.HashBasedTable;
  47  import com.google.common.collect.Lists;
  48  import com.google.common.collect.Maps;
  49  import com.google.common.collect.Sets;

  50  import org.apache.calcite.sql.SqlAsOperator;
  51  import org.apache.calcite.sql.SqlBasicCall;
  52  import org.apache.calcite.sql.SqlDataTypeSpec;
  53  import org.apache.calcite.sql.SqlIdentifier;
  54  import org.apache.calcite.sql.SqlInsert;
  55  import org.apache.calcite.sql.SqlJoin;
  56  import org.apache.calcite.sql.SqlKind;
  57  import org.apache.calcite.sql.SqlLiteral;
  58  import org.apache.calcite.sql.SqlNode;
  59  import org.apache.calcite.sql.SqlNodeList;
  60  import org.apache.calcite.sql.SqlOperator;
  61  import org.apache.calcite.sql.SqlOrderBy;
  62  import org.apache.calcite.sql.SqlSelect;
  63  import org.apache.calcite.sql.SqlWithItem;
  64  import org.apache.calcite.sql.fun.SqlCase;
  65  import org.apache.calcite.sql.parser.SqlParseException;
  66  import org.apache.calcite.sql.parser.SqlParserPos;
  67  import org.apache.commons.collections.CollectionUtils;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  68 -import org.apache.flink.api.common.typeinfo.TypeInformation;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  69 -import org.apache.flink.api.java.tuple.Tuple2;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  70 -import org.apache.flink.api.java.typeutils.RowTypeInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  71 -import org.apache.flink.streaming.api.datastream.DataStream;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  72 -import org.apache.flink.table.api.StreamQueryConfig;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  73 -import org.apache.flink.table.api.Table;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  74 -import org.apache.flink.table.api.java.StreamTableEnvironment;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  75 -import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  76 -import org.apache.flink.types.Row;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  77 +import org.apache.commons.lang3.StringUtils;</span>
  78  import org.slf4j.Logger;
  79  import org.slf4j.LoggerFactory;
  80  
  81  import java.sql.Timestamp;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  82 +import java.util.Arrays;</span>
  83  import java.util.Collection;
  84  import java.util.LinkedList;
  85  import java.util.List;
  86  import java.util.Map;
  87  import java.util.Queue;
  88  import java.util.Set;

  89  
  90  import static org.apache.calcite.sql.SqlKind.*;
  91  
  92  /**
  93   * Reason:
  94   * Date: 2018/7/24
  95   * Company: www.dtstack.com
  96   * @author xuchao
  97   */
  98  
  99  public class SideSqlExec {
 100  
 101      private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
 102  
 103      private String localSqlPluginPath = null;
 104  
 105      private String tmpFields = null;
 106  
 107      private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
 108  
 109      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
 110  
 111      public void exec(String sql, Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,
<abbr title=" 112                       Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserResult createView) throws Exception {"> 112                       Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserR🔵</abbr>






 113          if(localSqlPluginPath == null){
 114              throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 115          }
 116  
 117          localTableCache.putAll(tableCache);
 118          try {
 119              sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 120          } catch (Exception e) {
 121              LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 122          }
 123  
 124          if(createView != null){
 125              LOG.warn(&quot;create view info\n&quot;);
 126              LOG.warn(createView.getExecSql());
 127              LOG.warn(&quot;-----------------&quot;);
 128          }
 129  
 130          SideSQLParser sideSQLParser = new SideSQLParser();
 131          sideSQLParser.setLocalTableCache(localTableCache);
 132          Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 133          Object pollObj = null;
 134  
 135          //need clean
 136          boolean preIsSideJoin = false;
 137          List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 138  
 139          while((pollObj = exeQueue.poll()) != null){
 140  
 141              if(pollObj instanceof SqlNode){
 142                  SqlNode pollSqlNode = (SqlNode) pollObj;
 143  
 144                  if(preIsSideJoin){
 145                      preIsSideJoin = false;
 146                      List&lt;String&gt; fieldNames = null;
 147                      for(FieldReplaceInfo replaceInfo : replaceInfoList){
 148                          fieldNames = Lists.newArrayList();
 149                          replaceFieldName(pollSqlNode, replaceInfo);
 150                          addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());
 151                      }
 152                  }
 153  
 154                  if(pollSqlNode.getKind() == INSERT){
 155                      System.out.println(&quot;----------real exec sql-----------&quot; );
 156                      System.out.println(pollSqlNode.toString());
 157                      FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 158                      if(LOG.isInfoEnabled()){
 159                          LOG.info(&quot;exec sql: &quot; + pollSqlNode.toString());
 160                      }
 161  
 162                  }else if(pollSqlNode.getKind() == AS){
 163                      dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);

 164  
 165                  } else if (pollSqlNode.getKind() == WITH_ITEM) {
 166                      SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 167                      String TableAlias = sqlWithItem.name.toString();
 168                      Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 169                      tableEnv.registerTable(TableAlias, table);
 170  
 171                  } else if (pollSqlNode.getKind() == SELECT){
 172                      Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);
 173                      Table table = tableEnv.sqlQuery(pollObj.toString());
 174  
 175                      if (createView.getFieldsInfoStr() == null){
 176                          tableEnv.registerTable(createView.getTableName(), table);
 177                      } else {
 178                          if (checkFieldsInfo(createView, table)){
 179                              table = table.as(tmpFields);
 180                              tableEnv.registerTable(createView.getTableName(), table);
 181                          } else {
 182                              throw new RuntimeException(&quot;Fields mismatch&quot;);
 183                          }
 184                      }
 185  
 186                      localTableCache.put(createView.getTableName(), table);
 187                  }
 188  
 189              }else if (pollObj instanceof JoinInfo){
 190                  System.out.println(&quot;----------exec join info----------&quot;);
 191                  System.out.println(pollObj.toString());
 192                  preIsSideJoin = true;
 193                  joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);

 194              }
 195          }
 196  
 197      }
 198  
 199  
 200      /**
 201       * 解析出as查询的表和字段的关系
 202       * @param asSqlNode
 203       * @param tableCache
 204       * @return
 205       */
 206      private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 207          SqlNode info = asSqlNode.getOperands()[0];
 208          SqlNode alias = asSqlNode.getOperands()[1];
 209  
 210          SqlKind infoKind = info.getKind();
 211          if(infoKind != SELECT){
 212              return null;
 213          }
 214  
 215          List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 216  
 217          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 218          for (FieldInfo fieldInfo : extractFieldList) {
 219              String tableName = fieldInfo.getTable();
 220              String fieldName = fieldInfo.getFieldName();
 221              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 222              mappingTable.put(tableName, fieldName, mappingFieldName);
 223          }
 224  
 225          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 226          replaceInfo.setMappingTable(mappingTable);
 227          replaceInfo.setTargetTableName(alias.toString());
 228          replaceInfo.setTargetTableAlias(alias.toString());
 229          return replaceInfo;
 230      }
 231  
 232  
 233      /**
 234       * 添加字段别名
 235       * @param pollSqlNode
 236       * @param fieldList
 237       * @param mappingTable
 238       */
<abbr title=" 239      private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 239      private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, 🔵</abbr>
 240          SqlKind sqlKind = pollSqlNode.getKind();
 241          switch (sqlKind) {
 242              case INSERT:
 243                  SqlNode source = ((SqlInsert) pollSqlNode).getSource();
 244                  addAliasForFieldNode(source, fieldList, mappingTable);
 245                  break;
 246              case AS:
 247                  addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);
 248                  break;
 249              case SELECT:
 250                  SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();
 251                  selectList.getList().forEach(node -&gt; {
 252                      if (node.getKind() == IDENTIFIER) {
 253                          SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 254                          if (sqlIdentifier.names.size() == 1) {
 255                              return;
 256                          }
 257                          // save real field
 258                          String fieldName = sqlIdentifier.names.get(1);
<abbr title=" 259                          if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 259                          if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().contai🔵</abbr>
 260                              fieldList.add(fieldName);
 261                          }
 262  
 263                      }
 264                  });
 265                  for (int i = 0; i &lt; selectList.getList().size(); i++) {
 266                      SqlNode node = selectList.get(i);
 267                      if (node.getKind() == IDENTIFIER) {
 268                          SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 269                          if (sqlIdentifier.names.size() == 1) {
 270                              return;
 271                          }
 272                          String name = sqlIdentifier.names.get(1);
 273                          // avoid real field pv0 convert pv
<abbr title=" 274                          if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 274                          if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring🔵</abbr>
 275                              SqlOperator operator = new SqlAsOperator();
 276                              SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 277  
<abbr title=" 278                              SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 278                              SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() -🔵</abbr>
 279                              SqlNode[] sqlNodes = new SqlNode[2];
 280                              sqlNodes[0] = sqlIdentifier;
 281                              sqlNodes[1] = sqlIdentifierAlias;
 282                              SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 283  
 284                              selectList.set(i, sqlBasicCall);
 285                          }
 286                      }
 287                  }
 288                  break;
 289          }
 290      }
 291  
 292  
 293      public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 294          SqlKind sqlKind = sqlNode.getKind();
 295          if(sqlKind != AS){
 296              throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 297          }
 298  
 299          SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 300          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 301  
 302          AliasInfo aliasInfo = new AliasInfo();
 303          aliasInfo.setName(info.toString());
 304          aliasInfo.setAlias(alias.toString());
 305  
 306          return aliasInfo;
 307      }
 308  
<abbr title=" 309      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 309      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, Strin🔵</abbr>


 310          TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 311          String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 312          for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 313              FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 314              String tableName = fieldInfo.getTable();
 315              String fieldName = fieldInfo.getFieldName();
 316              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 317              mappingTable.put(tableName, fieldName, mappingFieldName);



 318  
 319              sideOutTypes[i] = fieldInfo.getTypeInformation();
 320              sideOutNames[i] = mappingFieldName;
 321          }
 322          return new RowTypeInfo(sideOutTypes, sideOutNames);
 323      }
 324  
 325  
 326  
 327      /**
 328       *  对时间类型进行类型转换
 329       * @param leftTypeInfo
 330       * @return
 331       */
 332      private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 333          TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 334          TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 335          for (int i = 0; i &lt; sideOutTypes.length; i++) {
 336              sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 337          }
 338          RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 339          return rowTypeInfo;
 340      }
 341  
 342      private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 343          if (typeInformation instanceof TimeIndicatorTypeInfo) {
 344              return TypeInformation.of(Timestamp.class);
 345          }
 346          return typeInformation;
 347      }
 348  
 349      //需要考虑更多的情况
 350      private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {
 351          SqlKind sqlKind = sqlNode.getKind();
 352          switch (sqlKind) {
 353              case INSERT:
 354                  SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();
 355                  replaceFieldName(sqlSource, replaceInfo);
 356                  break;
 357              case AS:
 358                  SqlNode asNode = ((SqlBasicCall) sqlNode).getOperands()[0];
 359                  replaceFieldName(asNode, replaceInfo);
 360                  break;
 361              case SELECT:
<abbr title=" 362                  SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName());"> 362                  SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName🔵</abbr>
 363                  if(sqlSelect == null){
 364                      return;
 365                  }
 366  
 367                  SqlNode sqlSource1 = sqlSelect.getFrom();
 368                  if(sqlSource1.getKind() == AS){
 369                      String tableName = ((SqlBasicCall)sqlSource1).getOperands()[0].toString();
 370                      if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){
 371                          SqlNodeList sqlSelectList = sqlSelect.getSelectList();
 372                          SqlNode whereNode = sqlSelect.getWhere();
 373                          SqlNodeList sqlGroup = sqlSelect.getGroup();
 374  
 375                          //TODO 暂时不处理having
 376                          SqlNode sqlHaving = sqlSelect.getHaving();
 377  
 378                          List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();
 379                          for( int i=0; i&lt;sqlSelectList.getList().size(); i++){
 380                              SqlNode selectNode = sqlSelectList.getList().get(i);
 381                              //特殊处理 isStar的标识
 382                              if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar()){
<abbr title=" 383                                  List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 383                                  List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo🔵</abbr>
 384                                  newSelectNodeList.addAll(replaceNodeList);
 385                                  continue;
 386                              }
 387  
 388                              SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);
 389                              if(replaceNode == null){
 390                                  continue;
 391                              }
 392  
 393                              //sqlSelectList.set(i, replaceNode);
 394                              newSelectNodeList.add(replaceNode);
 395                          }
 396  
<abbr title=" 397                          SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 397                          SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosi🔵</abbr>
 398                          sqlSelect.setSelectList(newSelectList);
 399  
 400                          //where
 401                          if(whereNode != null){
 402                              SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();
 403                              for(int i =0; i&lt;sqlNodeList.length; i++) {
 404                                  SqlNode whereSqlNode = sqlNodeList[i];
 405                                  SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);
 406                                  sqlNodeList[i] = replaceNode;
 407                              }
 408                          }
 409                          if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){
 410                              for( int i=0; i&lt;sqlGroup.getList().size(); i++){
 411                                  SqlNode selectNode = sqlGroup.getList().get(i);
 412                                  SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);
 413                                  sqlGroup.set(i, replaceNode);
 414                              }
 415                          }
 416                      }
 417                  }else{
 418                      //TODO
 419                      System.out.println(sqlNode);
 420                      throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);
 421                  }
 422  
 423                  break;
 424              case UNION:
 425                  SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];
 426                  SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];
 427                  replaceFieldName(unionLeft, replaceInfo);
 428                  replaceFieldName(unionRight, replaceInfo);
 429  
 430                  break;
 431              case ORDER_BY:
 432                  SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 433                  replaceFieldName(sqlOrderBy.query, replaceInfo);
 434                  SqlNodeList orderFiledList = sqlOrderBy.orderList;
 435                  for (int i=0 ;i&lt;orderFiledList.size();i++) {
<abbr title=" 436                      SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 436                      SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTabl🔵</abbr>
 437                      orderFiledList.set(i, replaceNode);
 438                  }
 439  
 440              default:
 441                  break;
 442          }
 443      }
 444  
 445      private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {
 446          if(orderNode.getKind() == IDENTIFIER){
 447              SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;
 448              if (sqlIdentifier.names.size() == 1) {
 449                  return orderNode;
 450              }
 451              return sqlIdentifier.setName(0, tableAlias);
 452          } else if (orderNode instanceof  SqlBasicCall) {
 453              SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;
 454              for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 455                  SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 456                  sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);
 457              }
 458              return sqlBasicCall;
 459          } else {
 460              return orderNode;
 461          }
 462      }
 463  
 464      private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){
 465          if(groupNode.getKind() == IDENTIFIER){
 466              SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;
 467              if(sqlIdentifier.names.size() == 1){
 468                  return sqlIdentifier;
 469              }
 470  
<abbr title=" 471              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 471              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr>
 472              if(mappingFieldName == null){
 473                  throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );
 474              }
 475  
 476              sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 477              return sqlIdentifier.setName(1, mappingFieldName);
 478          }else if(groupNode instanceof  SqlBasicCall){
 479              SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;
 480              for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 481                  SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 482                  SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 483                  sqlBasicCall.getOperands()[i] = replaceNode;
 484              }
 485  
 486              return sqlBasicCall;
 487          }else{
 488              return groupNode;
 489          }
 490      }
 491  
 492      public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {
 493  
 494          SqlKind sqlKind = sqlNode.getKind();
 495          switch (sqlKind){
 496              case SELECT:
 497                  SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();
 498                  if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){
 499                      if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){
 500                          return sqlNode;
 501                      }else{
 502                          return null;
 503                      }
 504                  }else{
 505                      return filterNodeWithTargetName(fromNode, targetTableName);
 506                  }
 507              case AS:
 508                  SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 509                  return filterNodeWithTargetName(childNode, targetTableName);
 510              case JOIN:
 511                  SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 512                  SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();
 513                  SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);
 514                  SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);
 515  
 516                  if(leftReturnNode != null) {
 517                      return leftReturnNode;
 518                  }else if(rightReturnNode != null){
 519                      return rightReturnNode;
 520                  }else{
 521                      return null;
 522                  }
 523          }
 524  
 525          return null;
 526      }



 527  
 528  
 529      public void setLocalSqlPluginPath(String localSqlPluginPath) {
 530          this.localSqlPluginPath = localSqlPluginPath;
 531      }
 532  
 533      private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){
 534          Table table = localTableCache.get(tableAlias);
 535          if(table == null){
 536              table = localTableCache.get(tableName);
 537          }
 538  
 539          if(table == null){
 540              throw new RuntimeException(&quot;not register table &quot; + tableName);

 541          }
 542  
 543          return table;
 544      }
 545  
 546      private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){
 547          SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 548          List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();
 549          if(sqlIdentifier.isStar()){//处理 [* or table.*]
 550              int identifierSize = sqlIdentifier.names.size();
 551              Collection&lt;String&gt; columns = null;
 552              if(identifierSize == 1){
 553                  columns = replaceInfo.getMappingTable().values();
 554              }else{
 555                  columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();
 556              }
 557  
 558              for(String colAlias : columns){
 559                  SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 560                  List&lt;String&gt; columnInfo = Lists.newArrayList();
 561                  columnInfo.add(replaceInfo.getTargetTableAlias());
 562                  columnInfo.add(colAlias);
 563                  SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);
 564                  sqlNodes.add(sqlIdentifierAlias);
 565              }
 566  
 567              return sqlNodes;
 568          }else{
 569              throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);
 570          }
 571      }
 572  
 573      private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {
 574          if (selectNode.getKind() == AS) {
 575              SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 576              SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);
 577              if (replaceNode != null) {
 578                  ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;
 579              }
 580  
 581              return selectNode;
 582          }else if(selectNode.getKind() == IDENTIFIER){
 583              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 584  
 585              if(sqlIdentifier.names.size() == 1){
 586                  return selectNode;
 587              }
 588  
 589              //Same level mappingTable
<abbr title=" 590              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 590              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr>
 591              if (mappingFieldName == null) {
 592                  throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );
 593              }
 594  
 595              sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 596              sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);
 597              return sqlIdentifier;
 598          }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义
 599              return selectNode;
 600          }else if(  AGGREGATE.contains(selectNode.getKind())
 601                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 602                  || COMPARISON.contains(selectNode.getKind())
 603                  || selectNode.getKind() == OTHER_FUNCTION
 604                  || selectNode.getKind() == DIVIDE
 605                  || selectNode.getKind() == CAST
 606                  || selectNode.getKind() == TRIM
 607                  || selectNode.getKind() == TIMES
 608                  || selectNode.getKind() == PLUS
 609                  || selectNode.getKind() == NOT_IN
 610                  || selectNode.getKind() == OR
 611                  || selectNode.getKind() == AND
 612                  || selectNode.getKind() == MINUS
 613                  || selectNode.getKind() == TUMBLE
 614                  || selectNode.getKind() == TUMBLE_START
 615                  || selectNode.getKind() == TUMBLE_END
 616                  || selectNode.getKind() == SESSION
 617                  || selectNode.getKind() == SESSION_START
 618                  || selectNode.getKind() == SESSION_END
 619                  || selectNode.getKind() == HOP
 620                  || selectNode.getKind() == HOP_START
 621                  || selectNode.getKind() == HOP_END
 622                  || selectNode.getKind() == BETWEEN
 623                  || selectNode.getKind() == IS_NULL
 624                  || selectNode.getKind() == IS_NOT_NULL
 625                  || selectNode.getKind() == CONTAINS
 626                  || selectNode.getKind() == TIMESTAMP_ADD
 627                  || selectNode.getKind() == TIMESTAMP_DIFF
 628                  || selectNode.getKind() == LIKE
 629  
 630                  ){
 631              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 632              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 633                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 634                  if(sqlNode instanceof SqlLiteral){
 635                      continue;
 636                  }
 637  
 638                  if(sqlNode instanceof SqlDataTypeSpec){
 639                      continue;
 640                  }
 641  
 642                  SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 643                  if(replaceNode == null){
 644                      continue;
 645                  }
 646  
 647                  sqlBasicCall.getOperands()[i] = replaceNode;
 648              }
 649  
 650              return selectNode;
 651          }else if(selectNode.getKind() == CASE){
 652              System.out.println(&quot;selectNode&quot;);
 653              SqlCase sqlCase = (SqlCase) selectNode;
 654              SqlNodeList whenOperands = sqlCase.getWhenOperands();
 655              SqlNodeList thenOperands = sqlCase.getThenOperands();
 656              SqlNode elseNode = sqlCase.getElseOperand();
 657  
 658              for(int i=0; i&lt;whenOperands.size(); i++){
 659                  SqlNode oneOperand = whenOperands.get(i);
 660                  SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 661                  if (replaceNode != null) {
 662                      whenOperands.set(i, replaceNode);
 663                  }
 664              }
 665  
 666              for(int i=0; i&lt;thenOperands.size(); i++){
 667                  SqlNode oneOperand = thenOperands.get(i);
 668                  SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 669                  if (replaceNode != null) {
 670                      thenOperands.set(i, replaceNode);
 671                  }
 672              }
 673  
 674              ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));
 675              return selectNode;
 676          }else if(selectNode.getKind() == OTHER){
 677              //不处理
 678              return selectNode;
 679          }else{
<abbr title=" 680              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 680              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNod🔵</abbr>
 681          }
 682      }
 683  
 684      /**
<abbr title=" 685       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 685       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension 🔵</abbr>
 686       *
 687       * @return
 688       */
<abbr title=" 689      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, SideTableInfo sideTableInfo) {"> 689      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, SideTableInfo sideTableInfo) 🔵</abbr>
 690          List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 691          if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 692              return true;
 693          }
 694          return false;
 695      }
 696  
 697      private List&lt;String&gt; convertPrimaryAlias(SideTableInfo sideTableInfo) {
 698          List&lt;String&gt; res = Lists.newArrayList();
 699          sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 700              res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 701          });
 702          return res;
 703      }
 704  
<abbr title=" 705      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, SideTableInfo sideTableInfo){"> 705      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, SideTableInfo sideTable🔵</abbr>
 706          List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 707          ParseUtils.parseAnd(conditionNode, sqlNodeList);
 708          List&lt;String&gt; conditionFields = Lists.newArrayList();
 709          for(SqlNode sqlNode : sqlNodeList){
 710              if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 711                  throw new RuntimeException(&quot;not compare operator.&quot;);
 712              }
 713  
 714              SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 715              SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 716  
 717              String leftTableName = left.getComponent(0).getSimple();
 718              String rightTableName = right.getComponent(0).getSimple();
 719  
 720              String tableCol = &quot;&quot;;
 721              if(leftTableName.equalsIgnoreCase(specifyTableName)){
 722                  tableCol = left.getComponent(1).getSimple();
 723              }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 724                  tableCol = right.getComponent(1).getSimple();
 725              }else{
<abbr title=" 726                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 726                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName🔵</abbr>
 727              }
 728              tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 729              conditionFields.add(tableCol);
 730          }
 731  
 732          return conditionFields;
 733      }
 734  
 735      protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 736                                       SqlNode pollSqlNode,
 737                                       Map&lt;String, Table&gt; tableCache,
 738                                       List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {

 739  
 740          AliasInfo aliasInfo = parseASNode(pollSqlNode);
 741          if (localTableCache.containsKey(aliasInfo.getName())) {
 742              return;
 743          }
 744  
 745          Table table = tableEnv.sqlQuery(aliasInfo.getName());
 746          tableEnv.registerTable(aliasInfo.getAlias(), table);
 747          localTableCache.put(aliasInfo.getAlias(), table);
 748  
 749          LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 750  
 751          FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 752          if(fieldReplaceInfo == null){
 753             return;
 754          }
 755  
 756          //as 的源表
 757          Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 758          SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 759          TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 760          for(FieldReplaceInfo tmp : replaceInfoList){
 761              if(fromTableNameSet.contains(tmp.getTargetTableName())
 762                      || fromTableNameSet.contains(tmp.getTargetTableAlias())){
 763                  fieldReplaceInfo.setPreNode(tmp);
 764                  break;
 765              }
 766          }
 767          replaceInfoList.add(fieldReplaceInfo);
 768      }
 769  
 770      private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,
 771                           Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,
 772                           List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{







 773          JoinInfo joinInfo = (JoinInfo) pollObj;
 774  
 775          JoinScope joinScope = new JoinScope();
 776          JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 777          leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 778          leftScopeChild.setTableName(joinInfo.getLeftTableName());
 779  
 780          SqlKind sqlKind = joinInfo.getLeftNode().getKind();
 781          if(sqlKind == AS){
 782              dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);
 783          }
 784  
<abbr title=" 785          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 785          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableNa🔵</abbr>
<abbr title=" 786          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 786          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColu🔵</abbr>
 787          leftScopeChild.setRowTypeInfo(leftTypeInfo);
 788  
 789          JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 790          rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 791          rightScopeChild.setTableName(joinInfo.getRightTableName());
 792          SideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 793          if(sideTableInfo == null){
 794              sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 795          }
 796  
 797          if(sideTableInfo == null){
 798              throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 799          }
 800  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 801 -        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 802 -            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 803 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 804 +//        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 805 +//            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 806 +//        }</span>
 807  
 808          rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 809  
 810          joinScope.addScope(leftScopeChild);
 811          joinScope.addScope(rightScopeChild);
 812  


 813          //获取两个表的所有字段
<abbr title=" 814          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 814          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, tr🔵</abbr>


 815  
 816          String leftTableAlias = joinInfo.getLeftTableAlias();
 817          Table targetTable = localTableCache.get(leftTableAlias);
 818          if(targetTable == null){
 819              targetTable = localTableCache.get(joinInfo.getLeftTableName());
 820          }
 821  
<abbr title=" 822          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 822          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColu🔵</abbr>
 823  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 824 -        DataStream adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 825 -                .filter((Tuple2&lt;Boolean, Row&gt; f0) -&gt; f0.f0)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 826 -                .map((Tuple2&lt;Boolean, Row&gt; f0) -&gt; f0.f1)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 827 -                .returns(Row.class);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 828 +        DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 829 +                .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 830 +                    return new CRow(tp2.f1, tp2.f0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 831 +                }).returns(CRow.class);</span>
 832  
 833  
 834          //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 835 -        if(sideTableInfo.isPartitionedJoin()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 836 -            RowTypeInfo leftTableOutType = buildLeftTableOutType(leftTypeInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 837 -            adaptStream.getTransformation().setOutputType(leftTableOutType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 838 +        if (sideTableInfo.isPartitionedJoin()) {</span>
<abbr title=" 839              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 839              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(🔵</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 840 -            String[] leftJoinColArr = leftJoinColList.toArray(new String[leftJoinColList.size()]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 841 -            adaptStream = adaptStream.keyBy(leftJoinColArr);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 842 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 843 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 844 -        DataStream dsOut;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 845 +            List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 846 +            int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 847 +            adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 847 +            adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 848 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 849 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 850 +        DataStream&lt;CRow&gt; dsOut = null;</span>
 851          if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 852              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 852              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr>
 853          }else{
<abbr title=" 854              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 854              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr>
 855          }
 856  
 857          // TODO  将嵌套表中的字段传递过去, 去除冗余的ROWtime
 858          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 859          RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 860  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 861 -        dsOut.getTransformation().setOutputType(sideOutTypeInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 862 +        CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 863 +        dsOut.getTransformation().setOutputType(cRowTypeInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 864 +</span>
 865          String targetTableName = joinInfo.getNewTableName();
 866          String targetTableAlias = joinInfo.getNewTableAlias();
 867  
 868          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 869          replaceInfo.setMappingTable(mappingTable);
 870          replaceInfo.setTargetTableName(targetTableName);
 871          replaceInfo.setTargetTableAlias(targetTableAlias);
 872  
 873          //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点
 874          for(FieldReplaceInfo tmp : replaceInfoList){
 875              if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())
 876              ||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){
 877                  replaceInfo.setPreNode(tmp);
 878                  break;
 879              }
 880          }
 881  
 882          replaceInfoList.add(replaceInfo);
 883  
 884          if (!tableEnv.isRegistered(joinInfo.getNewTableName())){
 885              Table joinTable = tableEnv.fromDataStream(dsOut);
 886              tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 887              localTableCache.put(joinInfo.getNewTableName(), joinTable);
 888          }
 889      }
 890  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 891 +    private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 892 +        String[] fieldNames = schema.getFieldNames();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 893 +        TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 894 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 895 +        String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 896 +        TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 896 +        TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformat🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 897 +        return new RowTypeInfo(projectedTypes, projectedNames);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 898 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 899 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 900 +</span>
 901      private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 902          List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 903          String fieldsInfo = result.getFieldsInfoStr();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 904 -        String[] fields = fieldsInfo.split(&quot;,&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 905 +        String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);</span>
 906          for (int i = 0; i &lt; fields.length; i++) {
 907              String[] filed = fields[i].split(&quot;\\s&quot;);
 908              if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){
 909                  return false;
 910              } else {
 911                  String[] filedNameArr = new String[filed.length - 1];
 912                  System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 913                  String fieldName = String.join(&quot; &quot;, filedNameArr);
 914                  fieldNames.add(fieldName);
 915                  String fieldType = filed[filed.length - 1 ].trim();
 916                  Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 917                  Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 918                  if (fieldClass == tableField){
 919                      continue;
 920                  } else {
 921                      return false;
 922                  }
 923              }
 924          }
 925          tmpFields = String.join(&quot;,&quot;, fieldNames);
 926          return true;
 927      }
 928  
 929  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;














  22  
  23  import com.dtstack.flink.sql.enums.ECacheType;
  24  import com.dtstack.flink.sql.exec.FlinkSQLExec;
  25  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  26  import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  27  import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  28  import com.dtstack.flink.sql.util.ClassUtil;
  29  import com.dtstack.flink.sql.util.ParseUtils;
  30  import com.dtstack.flink.sql.util.TableUtils;
  31  import com.google.common.base.Preconditions;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -import com.google.common.collect.HashBasedTable;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 -import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 -import com.google.common.collect.Maps;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 -import com.google.common.collect.Sets;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +import com.google.common.collect.*;</span>
  37  import org.apache.calcite.sql.SqlAsOperator;
  38  import org.apache.calcite.sql.SqlBasicCall;
  39  import org.apache.calcite.sql.SqlDataTypeSpec;
  40  import org.apache.calcite.sql.SqlIdentifier;
  41  import org.apache.calcite.sql.SqlInsert;
  42  import org.apache.calcite.sql.SqlJoin;
  43  import org.apache.calcite.sql.SqlKind;
  44  import org.apache.calcite.sql.SqlLiteral;
  45  import org.apache.calcite.sql.SqlNode;
  46  import org.apache.calcite.sql.SqlNodeList;
  47  import org.apache.calcite.sql.SqlOperator;
  48  import org.apache.calcite.sql.SqlOrderBy;
  49  import org.apache.calcite.sql.SqlSelect;
  50  import org.apache.calcite.sql.SqlWithItem;
  51  import org.apache.calcite.sql.fun.SqlCase;
  52  import org.apache.calcite.sql.parser.SqlParseException;
  53  import org.apache.calcite.sql.parser.SqlParserPos;
  54  import org.apache.commons.collections.CollectionUtils;
  55  import org.apache.flink.api.common.typeinfo.TypeInformation;
  56  import org.apache.flink.api.java.tuple.Tuple2;
  57  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  58  import org.apache.flink.streaming.api.datastream.DataStream;
  59  import org.apache.flink.table.api.StreamQueryConfig;
  60  import org.apache.flink.table.api.Table;
  61  import org.apache.flink.table.api.java.StreamTableEnvironment;
  62  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  63  import org.apache.flink.types.Row;

  64  import org.slf4j.Logger;
  65  import org.slf4j.LoggerFactory;
  66  
  67  import java.sql.Timestamp;

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  68 -import java.util.Collection;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  69 -import java.util.LinkedList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  70 -import java.util.List;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  71 -import java.util.Map;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  72 -import java.util.Queue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  73 -import java.util.Set;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  74 +import java.util.*;</span>
  75  
  76  import static org.apache.calcite.sql.SqlKind.*;
  77  
  78  /**
  79   * Reason:
  80   * Date: 2018/7/24
  81   * Company: www.dtstack.com
  82   * @author xuchao
  83   */
  84  
  85  public class SideSqlExec {
  86  
  87      private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  88  
  89      private String localSqlPluginPath = null;
  90  
  91      private String tmpFields = null;
  92  
  93      private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  94  
  95      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  96  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  97 -    public void exec(String sql, Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  98 -                     Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserResult createView) throws Exception {">  98 -                     Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserR🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  99 +    public void exec(String sql,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 100 +                     Map&lt;String, SideTableInfo&gt; sideTableMap,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 101 +                     StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 102 +                     Map&lt;String, Table&gt; tableCache,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 103 +                     StreamQueryConfig queryConfig,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +                     CreateTmpTableParser.SqlParserResult createView) throws Exception {</span>
 105          if(localSqlPluginPath == null){
 106              throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 107          }
 108  
 109          localTableCache.putAll(tableCache);
 110          try {
 111              sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 112          } catch (Exception e) {
 113              LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 114          }
 115  
 116          if(createView != null){
 117              LOG.warn(&quot;create view info\n&quot;);
 118              LOG.warn(createView.getExecSql());
 119              LOG.warn(&quot;-----------------&quot;);
 120          }
 121  
 122          SideSQLParser sideSQLParser = new SideSQLParser();
 123          sideSQLParser.setLocalTableCache(localTableCache);
 124          Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());
 125          Object pollObj = null;
 126  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -        //need clean</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 128 -        boolean preIsSideJoin = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 129 -        List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 130 -</span>
 131          while((pollObj = exeQueue.poll()) != null){
 132  
 133              if(pollObj instanceof SqlNode){
 134                  SqlNode pollSqlNode = (SqlNode) pollObj;
 135  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -                if(preIsSideJoin){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -                    preIsSideJoin = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 138 -                    List&lt;String&gt; fieldNames = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -                    for(FieldReplaceInfo replaceInfo : replaceInfoList){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -                        fieldNames = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -                        replaceFieldName(pollSqlNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -                        addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -                }</span>
 145  
 146                  if(pollSqlNode.getKind() == INSERT){
 147                      System.out.println(&quot;----------real exec sql-----------&quot; );
 148                      System.out.println(pollSqlNode.toString());
 149                      FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 150                      if(LOG.isInfoEnabled()){
 151                          LOG.info(&quot;exec sql: &quot; + pollSqlNode.toString());
 152                      }
 153  
 154                  }else if(pollSqlNode.getKind() == AS){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 155 -                    dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 156 +                    dealAsSourceTable(tableEnv, pollSqlNode, tableCache);</span>
 157  
 158                  } else if (pollSqlNode.getKind() == WITH_ITEM) {
 159                      SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 160                      String TableAlias = sqlWithItem.name.toString();
 161                      Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 162                      tableEnv.registerTable(TableAlias, table);
 163  
 164                  } else if (pollSqlNode.getKind() == SELECT){
 165                      Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);
 166                      Table table = tableEnv.sqlQuery(pollObj.toString());
 167  
 168                      if (createView.getFieldsInfoStr() == null){
 169                          tableEnv.registerTable(createView.getTableName(), table);
 170                      } else {
 171                          if (checkFieldsInfo(createView, table)){
 172                              table = table.as(tmpFields);
 173                              tableEnv.registerTable(createView.getTableName(), table);
 174                          } else {
 175                              throw new RuntimeException(&quot;Fields mismatch&quot;);
 176                          }
 177                      }
 178  
 179                      localTableCache.put(createView.getTableName(), table);
 180                  }
 181  
 182              }else if (pollObj instanceof JoinInfo){
 183                  System.out.println(&quot;----------exec join info----------&quot;);
 184                  System.out.println(pollObj.toString());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 185 -                preIsSideJoin = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 186 -                joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +                joinFun(pollObj, localTableCache, sideTableMap, tableEnv);</span>
 188              }
 189          }
 190  
 191      }
 192  
 193  
 194      /**
 195       * 解析出as查询的表和字段的关系
 196       * @param asSqlNode
 197       * @param tableCache
 198       * @return
 199       */
 200      private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 201          SqlNode info = asSqlNode.getOperands()[0];
 202          SqlNode alias = asSqlNode.getOperands()[1];
 203  
 204          SqlKind infoKind = info.getKind();
 205          if(infoKind != SELECT){
 206              return null;
 207          }
 208  
 209          List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 210  
 211          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 212          for (FieldInfo fieldInfo : extractFieldList) {
 213              String tableName = fieldInfo.getTable();
 214              String fieldName = fieldInfo.getFieldName();
 215              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 216              mappingTable.put(tableName, fieldName, mappingFieldName);
 217          }
 218  
 219          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 220          replaceInfo.setMappingTable(mappingTable);
 221          replaceInfo.setTargetTableName(alias.toString());
 222          replaceInfo.setTargetTableAlias(alias.toString());
 223          return replaceInfo;
 224      }
 225  
 226  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 227 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 228 -     * 添加字段别名</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 229 -     * @param pollSqlNode</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 230 -     * @param fieldList</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 231 -     * @param mappingTable</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 232 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 233 -    private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 233 -    private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, 🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 234 -        SqlKind sqlKind = pollSqlNode.getKind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 235 -        switch (sqlKind) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 236 -            case INSERT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 237 -                SqlNode source = ((SqlInsert) pollSqlNode).getSource();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 238 -                addAliasForFieldNode(source, fieldList, mappingTable);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 239 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 240 -            case AS:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 241 -                addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 242 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 243 -            case SELECT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 244 -                SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 245 -                selectList.getList().forEach(node -&gt; {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 246 -                    if (node.getKind() == IDENTIFIER) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 247 -                        SqlIdentifier sqlIdentifier = (SqlIdentifier) node;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 248 -                        if (sqlIdentifier.names.size() == 1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 249 -                            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 250 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 251 -                        // save real field</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 252 -                        String fieldName = sqlIdentifier.names.get(1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 253 -                        if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 253 -                        if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().contai🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 254 -                            fieldList.add(fieldName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 255 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 256 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 257 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 258 -                });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 259 -                for (int i = 0; i &lt; selectList.getList().size(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 260 -                    SqlNode node = selectList.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 261 -                    if (node.getKind() == IDENTIFIER) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 262 -                        SqlIdentifier sqlIdentifier = (SqlIdentifier) node;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 263 -                        if (sqlIdentifier.names.size() == 1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 264 -                            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 265 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 266 -                        String name = sqlIdentifier.names.get(1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 267 -                        // avoid real field pv0 convert pv</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 268 -                        if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 268 -                        if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 269 -                            SqlOperator operator = new SqlAsOperator();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 270 -                            SqlParserPos sqlParserPos = new SqlParserPos(0, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 271 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 272 -                            SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 272 -                            SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() -🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 273 -                            SqlNode[] sqlNodes = new SqlNode[2];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 274 -                            sqlNodes[0] = sqlIdentifier;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 275 -                            sqlNodes[1] = sqlIdentifierAlias;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 276 -                            SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 277 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 278 -                            selectList.set(i, sqlBasicCall);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 279 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 280 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 281 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 282 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 283 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 284 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 285 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 286 -</span>
 287      public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 288          SqlKind sqlKind = sqlNode.getKind();
 289          if(sqlKind != AS){
 290              throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 291          }
 292  
 293          SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 294          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 295  
 296          AliasInfo aliasInfo = new AliasInfo();
 297          aliasInfo.setName(info.toString());
 298          aliasInfo.setAlias(alias.toString());
 299  
 300          return aliasInfo;
 301      }
 302  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 303 -    public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 303 -    public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, Strin🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 304 +    public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 305 +                                           HashBasedTable&lt;String, String, String&gt; mappingTable) {</span>
 306          TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 307          String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 308          for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 309              FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 310              String tableName = fieldInfo.getTable();
 311              String fieldName = fieldInfo.getFieldName();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 312 -            String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 313 -            mappingTable.put(tableName, fieldName, mappingFieldName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 314 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +            String mappingFieldName = mappingTable.get(tableName, fieldName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 316 +            Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 316 +            Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;🔵</abbr></span>
 317  
 318              sideOutTypes[i] = fieldInfo.getTypeInformation();
 319              sideOutNames[i] = mappingFieldName;
 320          }
 321          return new RowTypeInfo(sideOutTypes, sideOutNames);
 322      }
 323  
 324  
 325  
 326      /**
 327       *  对时间类型进行类型转换
 328       * @param leftTypeInfo
 329       * @return
 330       */
 331      private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 332          TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 333          TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 334          for (int i = 0; i &lt; sideOutTypes.length; i++) {
 335              sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 336          }
 337          RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 338          return rowTypeInfo;
 339      }
 340  
 341      private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 342          if (typeInformation instanceof TimeIndicatorTypeInfo) {
 343              return TypeInformation.of(Timestamp.class);
 344          }
 345          return typeInformation;
 346      }
 347  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 348 -    //需要考虑更多的情况</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 349 -    private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 350 -        SqlKind sqlKind = sqlNode.getKind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 351 -        switch (sqlKind) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 352 -            case INSERT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 353 -                SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 354 -                replaceFieldName(sqlSource, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 355 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 356 -            case AS:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 357 -                SqlNode asNode = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 358 -                replaceFieldName(asNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 359 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 360 -            case SELECT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 361 -                SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName());"> 361 -                SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 362 -                if(sqlSelect == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 363 -                    return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 364 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 365 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 366 -                SqlNode sqlSource1 = sqlSelect.getFrom();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 367 -                if(sqlSource1.getKind() == AS){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 368 -                    String tableName = ((SqlBasicCall)sqlSource1).getOperands()[0].toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 369 -                    if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 370 -                        SqlNodeList sqlSelectList = sqlSelect.getSelectList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 371 -                        SqlNode whereNode = sqlSelect.getWhere();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 372 -                        SqlNodeList sqlGroup = sqlSelect.getGroup();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 373 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 374 -                        //TODO 暂时不处理having</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 375 -                        SqlNode sqlHaving = sqlSelect.getHaving();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 376 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 377 -                        List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 378 -                        for( int i=0; i&lt;sqlSelectList.getList().size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 379 -                            SqlNode selectNode = sqlSelectList.getList().get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 380 -                            //特殊处理 isStar的标识</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 381 -                            if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 382 -                                List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 382 -                                List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 383 -                                newSelectNodeList.addAll(replaceNodeList);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 384 -                                continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 385 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 386 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 387 -                            SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 388 -                            if(replaceNode == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 389 -                                continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 390 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 391 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 392 -                            //sqlSelectList.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 393 -                            newSelectNodeList.add(replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 394 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 395 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 396 -                        SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 396 -                        SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosi🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 397 -                        sqlSelect.setSelectList(newSelectList);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 398 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 399 -                        //where</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 400 -                        if(whereNode != null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 401 -                            SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 402 -                            for(int i =0; i&lt;sqlNodeList.length; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 403 -                                SqlNode whereSqlNode = sqlNodeList[i];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 404 -                                SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 405 -                                sqlNodeList[i] = replaceNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 406 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 407 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 408 -                        if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 409 -                            for( int i=0; i&lt;sqlGroup.getList().size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 410 -                                SqlNode selectNode = sqlGroup.getList().get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 411 -                                SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 412 -                                sqlGroup.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 413 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 414 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 415 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 416 -                }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 417 -                    //TODO</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 418 -                    System.out.println(sqlNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 419 -                    throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 420 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 421 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 422 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 423 -            case UNION:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 424 -                SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 425 -                SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 426 -                replaceFieldName(unionLeft, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 427 -                replaceFieldName(unionRight, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 428 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 429 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 430 -            case ORDER_BY:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 431 -                SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 432 -                replaceFieldName(sqlOrderBy.query, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 433 -                SqlNodeList orderFiledList = sqlOrderBy.orderList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 434 -                for (int i=0 ;i&lt;orderFiledList.size();i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 435 -                    SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 435 -                    SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTabl🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 436 -                    orderFiledList.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 437 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 438 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 439 -            default:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 440 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 441 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 442 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 443 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 444 -    private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 445 -        if(orderNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 446 -            SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 447 -            if (sqlIdentifier.names.size() == 1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 448 -                return orderNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 449 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 450 -            return sqlIdentifier.setName(0, tableAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 451 -        } else if (orderNode instanceof  SqlBasicCall) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 452 -            SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 453 -            for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 454 -                SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 455 -                sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 456 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 457 -            return sqlBasicCall;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 458 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 459 -            return orderNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 460 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 461 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 462 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 463 -    private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 464 -        if(groupNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 465 -            SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 466 -            if(sqlIdentifier.names.size() == 1){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 467 -                return sqlIdentifier;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 468 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 469 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 470 -            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 470 -            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 471 -            if(mappingFieldName == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 472 -                throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 473 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 474 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 475 -            sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 476 -            return sqlIdentifier.setName(1, mappingFieldName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 477 -        }else if(groupNode instanceof  SqlBasicCall){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 478 -            SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 479 -            for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 480 -                SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 481 -                SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 482 -                sqlBasicCall.getOperands()[i] = replaceNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 483 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 484 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 485 -            return sqlBasicCall;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 486 -        }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 487 -            return groupNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 488 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 489 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 490 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 491 -    public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 492 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 493 -        SqlKind sqlKind = sqlNode.getKind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 494 -        switch (sqlKind){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 495 -            case SELECT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 496 -                SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 497 -                if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 498 -                    if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 499 -                        return sqlNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 500 -                    }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 501 -                        return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 502 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 503 -                }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 504 -                    return filterNodeWithTargetName(fromNode, targetTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 505 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 506 -            case AS:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 507 -                SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 508 -                return filterNodeWithTargetName(childNode, targetTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 509 -            case JOIN:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 510 -                SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 511 -                SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 512 -                SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 513 -                SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 514 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 515 -                if(leftReturnNode != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 516 -                    return leftReturnNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 517 -                }else if(rightReturnNode != null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 518 -                    return rightReturnNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 519 -                }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 520 -                    return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 521 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 522 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 523 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 524 -        return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 525 -    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 526 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 527 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 528 +</span>
 529  
 530  
 531      public void setLocalSqlPluginPath(String localSqlPluginPath) {
 532          this.localSqlPluginPath = localSqlPluginPath;
 533      }
 534  
 535      private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){
 536          Table table = localTableCache.get(tableAlias);
 537          if(table == null){
 538              table = localTableCache.get(tableName);
 539          }
 540  
 541          if(table == null){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 542 -            throw new RuntimeException(&quot;not register table &quot; + tableName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 543 +            throw new RuntimeException(&quot;not register table &quot; + tableAlias);</span>
 544          }
 545  
 546          return table;
 547      }
 548  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 549 -    private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 550 -        SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 551 -        List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 552 -        if(sqlIdentifier.isStar()){//处理 [* or table.*]</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 553 -            int identifierSize = sqlIdentifier.names.size();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 554 -            Collection&lt;String&gt; columns = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 555 -            if(identifierSize == 1){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 556 -                columns = replaceInfo.getMappingTable().values();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 557 -            }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 558 -                columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 559 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 560 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 561 -            for(String colAlias : columns){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 562 -                SqlParserPos sqlParserPos = new SqlParserPos(0, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 563 -                List&lt;String&gt; columnInfo = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -                columnInfo.add(replaceInfo.getTargetTableAlias());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 565 -                columnInfo.add(colAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 566 -                SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 567 -                sqlNodes.add(sqlIdentifierAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 568 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 569 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 570 -            return sqlNodes;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 571 -        }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 572 -            throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 573 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 574 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 575 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 576 -    private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 577 -        if (selectNode.getKind() == AS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 578 -            SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 579 -            SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 580 -            if (replaceNode != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 581 -                ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 582 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 583 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 584 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 585 -        }else if(selectNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 586 -            SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 587 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 588 -            if(sqlIdentifier.names.size() == 1){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 589 -                return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 590 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 591 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 592 -            //Same level mappingTable</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 593 -            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 593 -            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 594 -            if (mappingFieldName == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 595 -                throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 596 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 597 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 598 -            sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 599 -            sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 600 -            return sqlIdentifier;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 601 -        }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 602 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 603 -        }else if(  AGGREGATE.contains(selectNode.getKind())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 604 -                || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 605 -                || COMPARISON.contains(selectNode.getKind())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 606 -                || selectNode.getKind() == OTHER_FUNCTION</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 607 -                || selectNode.getKind() == DIVIDE</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 608 -                || selectNode.getKind() == CAST</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 609 -                || selectNode.getKind() == TRIM</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 610 -                || selectNode.getKind() == TIMES</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 611 -                || selectNode.getKind() == PLUS</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 612 -                || selectNode.getKind() == NOT_IN</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 613 -                || selectNode.getKind() == OR</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 614 -                || selectNode.getKind() == AND</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 615 -                || selectNode.getKind() == MINUS</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 616 -                || selectNode.getKind() == TUMBLE</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 617 -                || selectNode.getKind() == TUMBLE_START</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 618 -                || selectNode.getKind() == TUMBLE_END</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 619 -                || selectNode.getKind() == SESSION</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 620 -                || selectNode.getKind() == SESSION_START</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 621 -                || selectNode.getKind() == SESSION_END</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 622 -                || selectNode.getKind() == HOP</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 623 -                || selectNode.getKind() == HOP_START</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 624 -                || selectNode.getKind() == HOP_END</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 625 -                || selectNode.getKind() == BETWEEN</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 626 -                || selectNode.getKind() == IS_NULL</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 627 -                || selectNode.getKind() == IS_NOT_NULL</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 628 -                || selectNode.getKind() == CONTAINS</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 629 -                || selectNode.getKind() == TIMESTAMP_ADD</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 630 -                || selectNode.getKind() == TIMESTAMP_DIFF</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 631 -                || selectNode.getKind() == LIKE</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 632 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 633 -                ){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 634 -            SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 635 -            for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 636 -                SqlNode sqlNode = sqlBasicCall.getOperands()[i];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 637 -                if(sqlNode instanceof SqlLiteral){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 638 -                    continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 639 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 640 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 641 -                if(sqlNode instanceof SqlDataTypeSpec){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 642 -                    continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 643 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 644 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 645 -                SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 646 -                if(replaceNode == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 647 -                    continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 648 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 649 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 650 -                sqlBasicCall.getOperands()[i] = replaceNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 651 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 652 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 653 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 654 -        }else if(selectNode.getKind() == CASE){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 655 -            System.out.println(&quot;selectNode&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 656 -            SqlCase sqlCase = (SqlCase) selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 657 -            SqlNodeList whenOperands = sqlCase.getWhenOperands();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 658 -            SqlNodeList thenOperands = sqlCase.getThenOperands();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 659 -            SqlNode elseNode = sqlCase.getElseOperand();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 660 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 661 -            for(int i=0; i&lt;whenOperands.size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 662 -                SqlNode oneOperand = whenOperands.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 663 -                SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 664 -                if (replaceNode != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 665 -                    whenOperands.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 666 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 667 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 668 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 669 -            for(int i=0; i&lt;thenOperands.size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 670 -                SqlNode oneOperand = thenOperands.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 671 -                SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 672 -                if (replaceNode != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 673 -                    thenOperands.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 674 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 675 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 676 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 677 -            ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 678 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 679 -        }else if(selectNode.getKind() == OTHER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 680 -            //不处理</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 681 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 682 -        }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 683 -            throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 683 -            throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNod🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 684 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 685 -    }</span>
 686  
 687      /**
<abbr title=" 688       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 688       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension 🔵</abbr>
 689       *
 690       * @return
 691       */
<abbr title=" 692      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, SideTableInfo sideTableInfo) {"> 692      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, SideTableInfo sideTableInfo) 🔵</abbr>
 693          List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 694          if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 695              return true;
 696          }
 697          return false;
 698      }
 699  
 700      private List&lt;String&gt; convertPrimaryAlias(SideTableInfo sideTableInfo) {
 701          List&lt;String&gt; res = Lists.newArrayList();
 702          sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 703              res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 704          });
 705          return res;
 706      }
 707  
<abbr title=" 708      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, SideTableInfo sideTableInfo){"> 708      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, SideTableInfo sideTable🔵</abbr>
 709          List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 710          ParseUtils.parseAnd(conditionNode, sqlNodeList);
 711          List&lt;String&gt; conditionFields = Lists.newArrayList();
 712          for(SqlNode sqlNode : sqlNodeList){
 713              if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 714                  throw new RuntimeException(&quot;not compare operator.&quot;);
 715              }
 716  
 717              SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 718              SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 719  
 720              String leftTableName = left.getComponent(0).getSimple();
 721              String rightTableName = right.getComponent(0).getSimple();
 722  
 723              String tableCol = &quot;&quot;;
 724              if(leftTableName.equalsIgnoreCase(specifyTableName)){
 725                  tableCol = left.getComponent(1).getSimple();
 726              }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 727                  tableCol = right.getComponent(1).getSimple();
 728              }else{
<abbr title=" 729                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 729                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName🔵</abbr>
 730              }
 731              tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 732              conditionFields.add(tableCol);
 733          }
 734  
 735          return conditionFields;
 736      }
 737  
 738      protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 739                                       SqlNode pollSqlNode,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 740 -                                     Map&lt;String, Table&gt; tableCache,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 741 -                                     List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 742 +                                     Map&lt;String, Table&gt; tableCache) throws SqlParseException {</span>
 743  
 744          AliasInfo aliasInfo = parseASNode(pollSqlNode);
 745          if (localTableCache.containsKey(aliasInfo.getName())) {
 746              return;
 747          }
 748  
 749          Table table = tableEnv.sqlQuery(aliasInfo.getName());
 750          tableEnv.registerTable(aliasInfo.getAlias(), table);
 751          localTableCache.put(aliasInfo.getAlias(), table);
 752  
 753          LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 754  
 755          FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 756          if(fieldReplaceInfo == null){
 757             return;
 758          }
 759  
 760          //as 的源表
 761          Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 762          SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 763          TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 764 -        for(FieldReplaceInfo tmp : replaceInfoList){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 765 -            if(fromTableNameSet.contains(tmp.getTargetTableName())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 766 -                    || fromTableNameSet.contains(tmp.getTargetTableAlias())){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 767 -                fieldReplaceInfo.setPreNode(tmp);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 768 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 769 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 770 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 771 -        replaceInfoList.add(fieldReplaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 772 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 773 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 774 -    private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 775 -                         Map&lt;String, SideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 776 -                         List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 777 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 778 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 779 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 780 +    private void joinFun(Object pollObj,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 781 +                         Map&lt;String, Table&gt; localTableCache,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 782 +                         Map&lt;String, SideTableInfo&gt; sideTableMap,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 783 +                         StreamTableEnvironment tableEnv) throws Exception{</span>
 784          JoinInfo joinInfo = (JoinInfo) pollObj;
 785  
 786          JoinScope joinScope = new JoinScope();
 787          JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 788          leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 789          leftScopeChild.setTableName(joinInfo.getLeftTableName());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 790 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 791 -        SqlKind sqlKind = joinInfo.getLeftNode().getKind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 792 -        if(sqlKind == AS){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 793 -            dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 794 -        }</span>
 795  
<abbr title=" 796          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 796          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableNa🔵</abbr>
<abbr title=" 797          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 797          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColu🔵</abbr>
 798          leftScopeChild.setRowTypeInfo(leftTypeInfo);
 799  
 800          JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 801          rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 802          rightScopeChild.setTableName(joinInfo.getRightTableName());
 803          SideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 804          if(sideTableInfo == null){
 805              sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 806          }
 807  
 808          if(sideTableInfo == null){
 809              throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 810          }
 811  
 812          if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){
 813              throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
 814          }



 815  
 816          rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 817  
 818          joinScope.addScope(leftScopeChild);
 819          joinScope.addScope(rightScopeChild);
 820  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 821 +        HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 822 +</span>
 823          //获取两个表的所有字段
<abbr title=" 824          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 824          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, tr🔵</abbr>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 825 +        //通过join的查询字段信息过滤出需要的字段信息</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 826 +        sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 826 +        sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getField🔵</abbr></span>
 827  
 828          String leftTableAlias = joinInfo.getLeftTableAlias();
 829          Table targetTable = localTableCache.get(leftTableAlias);
 830          if(targetTable == null){
 831              targetTable = localTableCache.get(joinInfo.getLeftTableName());
 832          }
 833  
<abbr title=" 834          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 834          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColu🔵</abbr>
 835  
 836          DataStream adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)
 837                  .filter((Tuple2&lt;Boolean, Row&gt; f0) -&gt; f0.f0)
 838                  .map((Tuple2&lt;Boolean, Row&gt; f0) -&gt; f0.f1)
 839                  .returns(Row.class);




 840  
 841  
 842          //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 843          if(sideTableInfo.isPartitionedJoin()){
 844              RowTypeInfo leftTableOutType = buildLeftTableOutType(leftTypeInfo);
 845              adaptStream.getTransformation().setOutputType(leftTableOutType);

<abbr title=" 846              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 846              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(🔵</abbr>
 847              String[] leftJoinColArr = leftJoinColList.toArray(new String[leftJoinColList.size()]);
 848              adaptStream = adaptStream.keyBy(leftJoinColArr);
 849          }
 850  
 851          DataStream dsOut;






 852          if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 853              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 853              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr>
 854          }else{
<abbr title=" 855              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 855              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr>
 856          }
 857  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 858 -        // TODO  将嵌套表中的字段传递过去, 去除冗余的ROWtime</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 859 -        HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();</span>
 860          RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 861  
 862          dsOut.getTransformation().setOutputType(sideOutTypeInfo);



 863          String targetTableName = joinInfo.getNewTableName();
 864          String targetTableAlias = joinInfo.getNewTableAlias();
 865  
 866          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 867          replaceInfo.setMappingTable(mappingTable);
 868          replaceInfo.setTargetTableName(targetTableName);
 869          replaceInfo.setTargetTableAlias(targetTableAlias);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 870 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 871 -        //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 872 -        for(FieldReplaceInfo tmp : replaceInfoList){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 873 -            if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 874 -            ||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 875 -                replaceInfo.setPreNode(tmp);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 876 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 877 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 878 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 879 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 880 -        replaceInfoList.add(replaceInfo);</span>
 881  
 882          if (!tableEnv.isRegistered(joinInfo.getNewTableName())){
 883              Table joinTable = tableEnv.fromDataStream(dsOut);
 884              tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);
 885              localTableCache.put(joinInfo.getNewTableName(), joinTable);
 886          }
 887      }
 888  










 889      private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 890          List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 891          String fieldsInfo = result.getFieldsInfoStr();
 892          String[] fields = fieldsInfo.split(&quot;,&quot;);

 893          for (int i = 0; i &lt; fields.length; i++) {
 894              String[] filed = fields[i].split(&quot;\\s&quot;);
 895              if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){
 896                  return false;
 897              } else {
 898                  String[] filedNameArr = new String[filed.length - 1];
 899                  System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 900                  String fieldName = String.join(&quot; &quot;, filedNameArr);
 901                  fieldNames.add(fieldName);
 902                  String fieldType = filed[filed.length - 1 ].trim();
 903                  Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 904                  Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 905                  if (fieldClass == tableField){
 906                      continue;
 907                  } else {
 908                      return false;
 909                  }
 910              }
 911          }
 912          tmpFields = String.join(&quot;,&quot;, fieldNames);
 913          return true;
 914      }
 915  
 916  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            