<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>538</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    538
                    <a href="537.html">prev</a>
                    <a href="539.html">next</a>
                    <a href="538_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_b43aec0679d705647015fd4416ad6dc326ea7890_core/src/main/java/com/dtstack/flink/sql/side/JoinNodeDealer.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;b43aec0679d705647015fd4416ad6dc326ea7890:core/src/main/java/com/dtstack/flink/sql/side/JoinNodeDealer.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;b43aec0679d705647015fd4416ad6dc326ea7890^1:core/src/main/java/com/dtstack/flink/sql/side/JoinNodeDealer.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;b43aec0679d705647015fd4416ad6dc326ea7890^2:core/src/main/java/com/dtstack/flink/sql/side/JoinNodeDealer.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;6159bb9bb9904f950c489b50fb7dcbe399c3d327:core/src/main/java/com/dtstack/flink/sql/side/JoinNodeDealer.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [j], [s]], subset: [[bs], [j]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.side;
  21 
  22 import com.dtstack.flink.sql.parser.FlinkPlanner;
  23 import com.dtstack.flink.sql.util.ParseUtils;
  24 import com.dtstack.flink.sql.util.TableUtils;
  25 import com.esotericsoftware.minlog.Log;
  26 import com.google.common.base.Preconditions;
  27 import com.google.common.collect.*;
  28 import org.apache.calcite.sql.JoinType;
  29 import org.apache.calcite.sql.SqlAsOperator;
  30 import org.apache.calcite.sql.SqlBasicCall;
  31 import org.apache.calcite.sql.SqlBinaryOperator;
  32 import org.apache.calcite.sql.SqlDataTypeSpec;
  33 import org.apache.calcite.sql.SqlIdentifier;
  34 import org.apache.calcite.sql.SqlJoin;
  35 import org.apache.calcite.sql.SqlKind;
  36 import org.apache.calcite.sql.SqlLiteral;
  37 import org.apache.calcite.sql.SqlNode;
  38 import org.apache.calcite.sql.SqlNodeList;
  39 import org.apache.calcite.sql.SqlOperator;
  40 import org.apache.calcite.sql.fun.SqlCase;
  41 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
  42 import org.apache.calcite.sql.parser.SqlParserPos;
  43 import org.apache.commons.collections.CollectionUtils;
  44 import org.apache.commons.lang3.StringUtils;
  45 import org.apache.flink.api.java.tuple.Tuple2;
  46 import org.apache.flink.table.calcite.FlinkPlannerImpl;
  47 
  48 import java.util.List;
  49 import java.util.Map;
  50 import java.util.Queue;
  51 import java.util.Set;
  52 
  53 import static org.apache.calcite.sql.SqlKind.*;
  54 
  55 /**
  56  * 处理join 节点
  57  * 1:如果包含维表节点替换为临时查询
  58  * Date: 2020/2/27
  59  * Company: www.dtstack.com
  60  * @author xuchao
  61  */
  62 
  63 public class JoinNodeDealer {
  64 
  65     //用来构建临时的中间查询
  66     private static final String SELECT_TEMP_SQL = &quot;select %s from %s %s&quot;;
  67 
  68     private SideSQLParser sideSQLParser;
  69 
  70     public JoinNodeDealer(SideSQLParser sideSQLParser){
  71         this.sideSQLParser = sideSQLParser;
  72     }
  73 
  74     /**
  75      * 解析 join 操作
  76      * @param joinNode
  77      * @param sideTableSet 标明哪些表名是维表
  78      * @param queueInfo sql执行队列
  79      * @param parentWhere join 关联的最上层的where 节点
  80      * @param parentSelectList join 关联的最上层的select 节点
  81      * @param joinFieldSet
  82      * @param tableRef 存储构建临时表查询后源表和新表之间的关联关系
  83      * @return
  84      */
  85     public JoinInfo dealJoinNode(SqlJoin joinNode,
  86                                  Set&lt;String&gt; sideTableSet,
  87                                  Queue&lt;Object&gt; queueInfo,
  88                                  SqlNode parentWhere,
  89                                  SqlNodeList parentSelectList,
  90                                  SqlNodeList parentGroupByList,
  91                                  Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,
  92                                  Map&lt;String, String&gt; tableRef,
  93                                  Map&lt;String, String&gt; fieldRef) {
  94 
  95         SqlNode leftNode = joinNode.getLeft();
  96         SqlNode rightNode = joinNode.getRight();
  97         JoinType joinType = joinNode.getJoinType();
  98 
  99         String leftTbName = &quot;&quot;;
 100         String leftTbAlias = &quot;&quot;;
 101         String rightTableName = &quot;&quot;;
 102         String rightTableAlias = &quot;&quot;;
 103 
 104         //抽取join中的的条件
 105         extractJoinField(joinNode.getCondition(), joinFieldSet);
 106 
 107         if (leftNode.getKind() == JOIN) {
 108             //处理连续join
 109             dealNestJoin(joinNode, sideTableSet,
<abbr title=" 110                     queueInfo, parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRef);"> 110                     queueInfo, parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, 🔵</abbr>
 111             leftNode = joinNode.getLeft();
 112         }
 113 
 114         if (leftNode.getKind() == AS) {
<abbr title=" 115             AliasInfo aliasInfo = (AliasInfo) sideSQLParser.parseSql(leftNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 115             AliasInfo aliasInfo = (AliasInfo) sideSQLParser.parseSql(leftNode, sideTableSet, queueInfo, p🔵</abbr>
 116             leftTbName = aliasInfo.getName();
 117             leftTbAlias = aliasInfo.getAlias();
 118         } else if(leftNode.getKind() == IDENTIFIER){
 119             leftTbName = leftNode.toString();
 120             leftTbAlias = leftTbName;
 121         }
 122 
 123         boolean leftIsSide = checkIsSideTable(leftTbName, sideTableSet);
 124         Preconditions.checkState(!leftIsSide, &quot;side-table must be at the right of join operator&quot;);
 125 
<abbr title=" 126         Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 126         Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo🔵</abbr>
 127         rightTableName = rightTableNameAndAlias.f0;
 128         rightTableAlias = rightTableNameAndAlias.f1;
 129 
 130         boolean rightIsSide = checkIsSideTable(rightTableName, sideTableSet);
 131         if(rightIsSide &amp;&amp; joinType == JoinType.RIGHT){
<abbr title=" 132             throw new RuntimeException(&quot;side join not support join type of right[current support inner join and left join]&quot;);"> 132             throw new RuntimeException(&quot;side join not support join type of right[current support inner jo🔵</abbr>
 133         }
 134 
 135         JoinInfo tableInfo = new JoinInfo();
 136         tableInfo.setLeftTableName(leftTbName);
 137         tableInfo.setRightTableName(rightTableName);
 138 
 139         leftTbAlias = StringUtils.isEmpty(leftTbAlias) ? leftTbName : leftTbAlias;
 140         rightTableAlias = StringUtils.isEmpty(rightTableAlias) ? rightTableName : rightTableAlias;
 141 
 142         tableInfo.setLeftTableAlias(leftTbAlias);
 143         tableInfo.setRightTableAlias(rightTableAlias);
 144         tableInfo.setRightIsSideTable(rightIsSide);
 145         tableInfo.setLeftNode(leftNode);
 146         tableInfo.setRightNode(rightNode);
 147         tableInfo.setJoinType(joinType);
 148         tableInfo.setCondition(joinNode.getCondition());
 149         TableUtils.replaceJoinFieldRefTableName(joinNode.getCondition(), fieldRef);
 150 
 151         //extract 需要查询的字段信息
 152         if(rightIsSide){
<abbr title=" 153             extractJoinNeedSelectField(leftNode, rightNode, parentWhere, parentSelectList, parentGroupByList, tableRef, joinFieldSet, fieldRef, tableInfo);"> 153             extractJoinNeedSelectField(leftNode, rightNode, parentWhere, parentSelectList, parentGroupByL🔵</abbr>
 154         }
 155 
 156         if(tableInfo.getLeftNode().getKind() != AS){
 157             return tableInfo;
 158         }
 159 
 160         SqlKind asNodeFirstKind = ((SqlBasicCall)tableInfo.getLeftNode()).operands[0].getKind();
 161         if(asNodeFirstKind == SELECT){
 162             queueInfo.offer(tableInfo.getLeftNode());
 163             tableInfo.setLeftNode(((SqlBasicCall)tableInfo.getLeftNode()).operands[1]);
 164         }
 165 
 166         return tableInfo;
 167     }
 168 
 169     /**
 170      * 获取join 之后需要查询的字段信息
 171      */
 172     public void extractJoinNeedSelectField(SqlNode leftNode,
 173                                            SqlNode rightNode,
 174                                            SqlNode parentWhere,
 175                                            SqlNodeList parentSelectList,
 176                                            SqlNodeList parentGroupByList,
 177                                            Map&lt;String, String&gt; tableRef,
 178                                            Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,
 179                                            Map&lt;String, String&gt; fieldRef,
 180                                            JoinInfo tableInfo){
 181 
<abbr title=" 182         Set&lt;String&gt; extractSelectField = extractField(leftNode, parentWhere, parentSelectList, parentGroupByList, tableRef, joinFieldSet);"> 182         Set&lt;String&gt; extractSelectField = extractField(leftNode, parentWhere, parentSelectList, parentGrou🔵</abbr>
<abbr title=" 183         Set&lt;String&gt; rightExtractSelectField = extractField(rightNode, parentWhere, parentSelectList, parentGroupByList, tableRef, joinFieldSet);"> 183         Set&lt;String&gt; rightExtractSelectField = extractField(rightNode, parentWhere, parentSelectList, pare🔵</abbr>
 184 
 185         //重命名right 中和 left 重名的
 186         Map&lt;String, String&gt; leftTbSelectField = Maps.newHashMap();
 187         Map&lt;String, String&gt; rightTbSelectField = Maps.newHashMap();
 188         String newTableName = tableInfo.getNewTableAlias();
 189 
 190         for(String tmpField : extractSelectField){
 191             String[] tmpFieldSplit = StringUtils.split(tmpField, &#x27;.&#x27;);
 192             leftTbSelectField.put(tmpFieldSplit[1], tmpFieldSplit[1]);
 193             fieldRef.put(tmpField, TableUtils.buildTableField(newTableName, tmpFieldSplit[1]));
 194         }
 195 
 196         for(String tmpField : rightExtractSelectField){
 197             String[] tmpFieldSplit = StringUtils.split(tmpField, &#x27;.&#x27;);
 198             String originalFieldName = tmpFieldSplit[1];
 199             String targetFieldName = originalFieldName;
 200             if(leftTbSelectField.containsKey(originalFieldName)){
<abbr title=" 201                 targetFieldName = ParseUtils.dealDuplicateFieldName(leftTbSelectField, originalFieldName);"> 201                 targetFieldName = ParseUtils.dealDuplicateFieldName(leftTbSelectField, originalFieldName)🔵</abbr>
 202             }
 203 
 204             rightTbSelectField.put(originalFieldName, targetFieldName);
 205             fieldRef.put(tmpField, TableUtils.buildTableField(newTableName, targetFieldName));
 206         }
 207 
 208         tableInfo.setLeftSelectFieldInfo(leftTbSelectField);
 209         tableInfo.setRightSelectFieldInfo(rightTbSelectField);
 210     }
 211 
 212     /**
 213      * 指定的节点关联到的 select 中的字段和 where中的字段
 214      * @param sqlNode
 215      * @param parentWhere
 216      * @param parentSelectList
 217      * @param parentGroupByList
 218      * @param tableRef
 219      * @param joinFieldSet
 220      * @return
 221      */
 222     public Set&lt;String&gt; extractField(SqlNode sqlNode,
 223                                     SqlNode parentWhere,
 224                                     SqlNodeList parentSelectList,
 225                                     SqlNodeList parentGroupByList,
 226                                     Map&lt;String, String&gt; tableRef,
 227                                     Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet){
 228         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 229         TableUtils.getFromTableInfo(sqlNode, fromTableNameSet);
 230         Set&lt;String&gt; extractCondition = Sets.newHashSet();
 231 
 232         extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere, extractCondition);
<abbr title=" 233         Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tableRef);"> 233         Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tableRef🔵</abbr>
<abbr title=" 234         Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSet, tableRef);"> 234         Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableN🔵</abbr>
 235 
<abbr title=" 236         Set&lt;String&gt; extractGroupByField = extractFieldFromGroupByList(parentGroupByList, fromTableNameSet, tableRef);"> 236         Set&lt;String&gt; extractGroupByField = extractFieldFromGroupByList(parentGroupByList, fromTableNameSet🔵</abbr>
 237 
 238         extractSelectField.addAll(extractCondition);
 239         extractSelectField.addAll(fieldFromJoinCondition);
 240         extractSelectField.addAll(extractGroupByField);
 241 
 242         return extractSelectField;
 243     }
 244 
 245 
 246     /**
 247      * 处理多层join
 248      * 判断左节点是否需要创建临时查询
 249      * （1）右节点是维表
 250      * （2）左节点不是 as 节点
 251      */
 252     private JoinInfo dealNestJoin(SqlJoin joinNode,
 253                                   Set&lt;String&gt; sideTableSet,
 254                                   Queue&lt;Object&gt; queueInfo,
 255                                   SqlNode parentWhere,
 256                                   SqlNodeList parentSelectList,
 257                                   SqlNodeList parentGroupByList,
 258                                   Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,
 259                                   Map&lt;String, String&gt; tableRef,
 260                                   Map&lt;String, String&gt; fieldRef){
 261 
 262         SqlJoin leftJoinNode = (SqlJoin) joinNode.getLeft();
 263         SqlNode parentRightJoinNode = joinNode.getRight();
 264         SqlNode rightNode = leftJoinNode.getRight();
<abbr title=" 265         Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 265         Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo🔵</abbr>
<abbr title=" 266         Tuple2&lt;String, String&gt; parentRightJoinInfo = parseRightNode(parentRightJoinNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 266         Tuple2&lt;String, String&gt; parentRightJoinInfo = parseRightNode(parentRightJoinNode, sideTableSet, qu🔵</abbr>
 267         boolean parentRightIsSide = checkIsSideTable(parentRightJoinInfo.f0, sideTableSet);
 268 
<abbr title=" 269         JoinInfo joinInfo = dealJoinNode(leftJoinNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRef);"> 269         JoinInfo joinInfo = dealJoinNode(leftJoinNode, sideTableSet, queueInfo, parentWhere, parentSelect🔵</abbr>
 270 
 271         String rightTableName = rightTableNameAndAlias.f0;
 272         boolean rightIsSide = checkIsSideTable(rightTableName, sideTableSet);
 273         SqlBasicCall buildAs = TableUtils.buildAsNodeByJoinInfo(joinInfo, null, null);
 274 
 275         if(rightIsSide){
<abbr title=" 276             addSideInfoToExeQueue(queueInfo, joinInfo, joinNode, parentSelectList, parentGroupByList, parentWhere, tableRef);"> 276             addSideInfoToExeQueue(queueInfo, joinInfo, joinNode, parentSelectList, parentGroupByList, par🔵</abbr>
 277         }
 278 
 279         SqlNode newLeftNode = joinNode.getLeft();
 280 
 281         if(newLeftNode.getKind() != AS &amp;&amp; parentRightIsSide){
 282 
 283             String leftTbAlias = buildAs.getOperands()[1].toString();
 284             extractTemporaryQuery(newLeftNode, leftTbAlias, (SqlBasicCall) parentWhere,
 285                     parentSelectList, queueInfo, joinFieldSet, tableRef, fieldRef);
 286 
 287             //替换leftNode 为新的查询
 288             joinNode.setLeft(buildAs);
<abbr title=" 289             replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByList, parentWhere);"> 289             replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByLi🔵</abbr>
 290         }
 291 
 292         return joinInfo;
 293     }
 294 
 295     /**
 296      * 右边表是维表需要重新构建左表的临时查询
 297      * 并将joinInfo 添加到执行队列里面
 298      * @param queueInfo
 299      * @param joinInfo
 300      * @param joinNode
 301      * @param parentSelectList
 302      * @param parentGroupByList
 303      * @param parentWhere
 304      * @param tableRef
 305      */
 306     public void addSideInfoToExeQueue(Queue&lt;Object&gt; queueInfo,
 307                                       JoinInfo joinInfo,
 308                                       SqlJoin joinNode,
 309                                       SqlNodeList parentSelectList,
 310                                       SqlNodeList parentGroupByList,
 311                                       SqlNode parentWhere,
 312                                       Map&lt;String, String&gt; tableRef){
 313         //只处理维表
 314         if(!joinInfo.isRightIsSideTable()){
 315             return;
 316         }
 317 
 318         SqlBasicCall buildAs = TableUtils.buildAsNodeByJoinInfo(joinInfo, null, null);
 319         SqlNode leftJoinNode = joinNode.getLeft();
 320         queueInfo.offer(joinInfo);
 321         //替换左表为新的表名称
 322         joinNode.setLeft(buildAs);
 323 
<abbr title=" 324         replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByList, parentWhere);"> 324         replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByList, 🔵</abbr>
 325     }
 326 
 327     /**
 328      * 替换指定的查询和条件节点中的字段为新的字段
 329      * @param buildAs
 330      * @param leftJoinNode
 331      * @param tableRef
 332      * @param parentSelectList
 333      * @param parentGroupByList
 334      * @param parentWhere
 335      */
 336     public void replaceSelectAndWhereField(SqlBasicCall buildAs,
 337                    SqlNode leftJoinNode,
 338                    Map&lt;String, String&gt; tableRef,
 339                    SqlNodeList parentSelectList,
 340                    SqlNodeList parentGroupByList,
 341                    SqlNode parentWhere){
 342 
 343         String newLeftTableName = buildAs.getOperands()[1].toString();
 344         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 345         TableUtils.getFromTableInfo(leftJoinNode, fromTableNameSet);
 346 
 347         for(String tbTmp : fromTableNameSet){
 348             tableRef.put(tbTmp, newLeftTableName);
 349         }
 350 
 351         //替换select field 中的对应字段
 352         HashBiMap&lt;String, String&gt; fieldReplaceRef = HashBiMap.create();
 353         for(SqlNode sqlNode : parentSelectList.getList()){
 354             for(String tbTmp : fromTableNameSet) {
 355                 TableUtils.replaceSelectFieldTable(sqlNode, tbTmp, newLeftTableName, fieldReplaceRef);
 356             }
 357         }
 358 
 359         //TODO 应该根据上面的查询字段的关联关系来替换
 360         //替换where 中的条件相关
 361         for(String tbTmp : fromTableNameSet){
 362             TableUtils.replaceWhereCondition(parentWhere, tbTmp, newLeftTableName, fieldReplaceRef);
 363         }
 364 
 365         if(parentGroupByList != null){
 366             for(SqlNode sqlNode : parentGroupByList.getList()){
 367                 for(String tbTmp : fromTableNameSet) {
<abbr title=" 368                     TableUtils.replaceSelectFieldTable(sqlNode, tbTmp, newLeftTableName, fieldReplaceRef);"> 368                     TableUtils.replaceSelectFieldTable(sqlNode, tbTmp, newLeftTableName, fieldReplaceRef)🔵</abbr>
 369                 }
 370             }
 371         }
 372 
 373     }
 374 
 375     /**
 376      * 抽取出中间查询表
 377      * @param node
 378      * @param tableAlias
 379      * @param parentWhere
 380      * @param parentSelectList
 381      * @param queueInfo
 382      * @param joinFieldSet
 383      * @param tableRef
 384      * @return 源自段和新生成字段之间的映射关系
 385      */
 386     private void extractTemporaryQuery(SqlNode node, String tableAlias,
 387                                        SqlBasicCall parentWhere,
 388                                        SqlNodeList parentSelectList,
 389                                        Queue&lt;Object&gt; queueInfo,
 390                                        Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,
 391                                        Map&lt;String, String&gt; tableRef,
 392                                        Map&lt;String, String&gt; fieldRef){
 393         try{
 394             //父一级的where 条件中如果只和临时查询相关的条件都截取进来
 395             Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 396             List&lt;SqlBasicCall&gt; extractCondition = Lists.newArrayList();
 397 
 398             TableUtils.getFromTableInfo(node, fromTableNameSet);
 399             checkAndRemoveWhereCondition(fromTableNameSet, parentWhere, extractCondition);
 400 
 401             if(node.getKind() == JOIN){
 402                 checkAndReplaceJoinCondition(((SqlJoin)node).getCondition(), tableRef);
 403             }
 404 
<abbr title=" 405             Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tableRef);"> 405             Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tabl🔵</abbr>
<abbr title=" 406             Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSet, tableRef);"> 406             Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTa🔵</abbr>
 407             Set&lt;String&gt; newFields = buildSelectNode(extractSelectField, fieldFromJoinCondition);
 408             String extractSelectFieldStr = StringUtils.join(newFields, &#x27;,&#x27;);
 409 
 410             Map&lt;String, String&gt; oldRefNewField = buildTmpTableFieldRefOriField(newFields, tableAlias);
 411             fieldRef.putAll(oldRefNewField);
 412 
 413             String extractConditionStr = buildCondition(extractCondition);
 414 
 415             String tmpSelectSql = String.format(SELECT_TEMP_SQL,
 416                     extractSelectFieldStr,
 417                     node.toString(),
 418                     extractConditionStr);
 419 
 420             FlinkPlannerImpl flinkPlanner = FlinkPlanner.getFlinkPlanner();
 421             SqlNode sqlNode = flinkPlanner.parse(tmpSelectSql);
 422 
 423             SqlBasicCall sqlBasicCall = buildAsSqlNode(tableAlias, sqlNode);
 424             queueInfo.offer(sqlBasicCall);
 425 
 426 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 427             //替换select中的表结构</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 428             HashBiMap&lt;String, String&gt; fieldReplaceRef = HashBiMap.create();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 429             for(SqlNode tmpSelect : parentSelectList.getList()){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 430                 for(String tbTmp : fromTableNameSet) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 431                     TableUtils.replaceSelectFieldTable(tmpSelect, tbTmp, tableAlias, fieldReplaceRef);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 432                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 433             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 434 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 435             //替换where 中的条件相关</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 436             for(String tbTmp : fromTableNameSet){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 437                 TableUtils.replaceWhereCondition(parentWhere, tbTmp, tableAlias, fieldReplaceRef);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 438             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 439 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 440             for(String tbTmp : fromTableNameSet){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 441                 tableRef.put(tbTmp, tableAlias);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 442             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 443 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 444             System.out.println(&quot;-------build temporary query-----------&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 445             System.out.println(tmpSelectSql);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 446             System.out.println(&quot;---------------------------------------&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 447 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 448         }catch (Exception e){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 449             e.printStackTrace();</span>
 450 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 451             System.out.println(tmpSelectSql);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 452             System.out.println(&quot;---------------------------------------&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 453         }catch (Exception e){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 454             e.printStackTrace();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 455             throw new RuntimeException(e);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 456         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 457     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 458 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 459     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 460      * 抽取上层需用使用到的字段</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 461      * 由于where字段已经抽取到上一层了所以不用查询出来</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 462      * @param parentSelectList</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 463      * @param fromTableNameSet</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 464      * @return</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 465      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 466     private Set&lt;String&gt; extractSelectFields(SqlNodeList parentSelectList,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 467                                             Set&lt;String&gt; fromTableNameSet,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 468                                             Map&lt;String, String&gt; tableRef){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 469         Set&lt;String&gt; extractFieldList = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 470         for(SqlNode selectNode : parentSelectList.getList()){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 471             extractSelectField(selectNode, extractFieldList, fromTableNameSet, tableRef);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 472         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 473 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 474         return extractFieldList;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 475     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 476 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 477     private Set&lt;String&gt; extractSelectFieldFromJoinCondition(Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet, Set&lt;String&gt; fromTableNameSet){"> 477     private Set&lt;String&gt; extractSelectFieldFromJoinCondition(Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet, Set🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 478         Set&lt;String&gt; extractFieldList = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 479         for(Tuple2&lt;String, String&gt; field : joinFieldSet){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 480             if(fromTableNameSet.contains(field.f0)){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 481                 extractFieldList.add(field.f0 + &quot;.&quot; + field.f1);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 482             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 483         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 484 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 485         return extractFieldList;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 486     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 487 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 488     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 489      * 从join的条件中获取字段信息</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 490      * @param condition</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 491      * @param joinFieldSet</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 492      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 493     private void extractJoinField(SqlNode condition, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 494         SqlKind joinKind = condition.getKind();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 495         if( joinKind == AND || joinKind == EQUALS ){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 496             extractJoinField(((SqlBasicCall)condition).operands[0], joinFieldSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 497             extractJoinField(((SqlBasicCall)condition).operands[1], joinFieldSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 498         }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 499             Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 499             Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must b🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 500             Tuple2&lt;String, String&gt; tuple2 = Tuple2.of(((SqlIdentifier)condition).names.get(0), ((SqlIdentifier)condition).names.get(1));"> 500             Tuple2&lt;String, String&gt; tuple2 = Tuple2.of(((SqlIdentifier)condition).names.get(0), ((SqlIdent🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 501             joinFieldSet.add(tuple2);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 502         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 503     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 504 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 505 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 506     private void extractSelectField(SqlNode selectNode,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 507                                     Set&lt;String&gt; extractFieldSet,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 508                                     Set&lt;String&gt; fromTableNameSet,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 509                                     Map&lt;String, String&gt; tableRef){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 510         if (selectNode.getKind() == AS) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 511             SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 512             extractSelectField(leftNode, extractFieldSet, fromTableNameSet, tableRef);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 513 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 514         }else if(selectNode.getKind() == IDENTIFIER) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 515             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 516 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 517             if(sqlIdentifier.names.size() == 1){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 518                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 519             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 520 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 521             String tableName = sqlIdentifier.names.get(0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 522             //TODO</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 523             if(fromTableNameSet.contains(tableName)){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 524                 extractFieldSet.add(sqlIdentifier.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 525             } else if(fromTableNameSet.contains(tableRef.get(tableName))){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 526                 //TODO extractFieldSet.add(sqlIdentifier.setName(0, tableRef.get(tableName)).toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 527             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 528 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 529         }else if(  AGGREGATE.contains(selectNode.getKind())</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 530                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 531                 || COMPARISON.contains(selectNode.getKind())</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 532                 || selectNode.getKind() == OTHER_FUNCTION</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 533                 || selectNode.getKind() == DIVIDE</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 534                 || selectNode.getKind() == CAST</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 535                 || selectNode.getKind() == TRIM</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 536                 || selectNode.getKind() == TIMES</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 537                 || selectNode.getKind() == PLUS</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 538                 || selectNode.getKind() == NOT_IN</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 539                 || selectNode.getKind() == OR</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 540                 || selectNode.getKind() == AND</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 541                 || selectNode.getKind() == MINUS</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 542                 || selectNode.getKind() == TUMBLE</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 543                 || selectNode.getKind() == TUMBLE_START</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 544                 || selectNode.getKind() == TUMBLE_END</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 545                 || selectNode.getKind() == SESSION</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 546                 || selectNode.getKind() == SESSION_START</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 547                 || selectNode.getKind() == SESSION_END</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 548                 || selectNode.getKind() == HOP</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 549                 || selectNode.getKind() == HOP_START</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 550                 || selectNode.getKind() == HOP_END</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 551                 || selectNode.getKind() == BETWEEN</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 552                 || selectNode.getKind() == IS_NULL</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 553                 || selectNode.getKind() == IS_NOT_NULL</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 554                 || selectNode.getKind() == CONTAINS</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 555                 || selectNode.getKind() == TIMESTAMP_ADD</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 556                 || selectNode.getKind() == TIMESTAMP_DIFF</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 557                 || selectNode.getKind() == LIKE</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 558 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 559         ){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 560             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 561             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 562                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 563                 if(sqlNode instanceof SqlLiteral){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 564                     continue;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 565                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 566 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 567                 if(sqlNode instanceof SqlDataTypeSpec){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 568                     continue;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 569                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 570 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 571                 extractSelectField(sqlNode, extractFieldSet, fromTableNameSet, tableRef);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 572             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 573 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 574         }else if(selectNode.getKind() == CASE){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 575             System.out.println(&quot;selectNode&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 576             SqlCase sqlCase = (SqlCase) selectNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 577             SqlNodeList whenOperands = sqlCase.getWhenOperands();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 578             SqlNodeList thenOperands = sqlCase.getThenOperands();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 579             SqlNode elseNode = sqlCase.getElseOperand();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 580 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 581             for(int i=0; i&lt;whenOperands.size(); i++){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 582                 SqlNode oneOperand = whenOperands.get(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 583                 extractSelectField(oneOperand, extractFieldSet, fromTableNameSet, tableRef);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 584             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 585 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 586             for(int i=0; i&lt;thenOperands.size(); i++){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 587                 SqlNode oneOperand = thenOperands.get(i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 588                 extractSelectField(oneOperand, extractFieldSet, fromTableNameSet, tableRef);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 589             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 590 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 591             extractSelectField(elseNode, extractFieldSet, fromTableNameSet, tableRef);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 592         }else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 593             //do nothing</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 594         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 595     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 596 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 597 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 598     private Tuple2&lt;String, String&gt; parseRightNode(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo,"> 598     private Tuple2&lt;String, String&gt; parseRightNode(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 599                                                   SqlNode parentWhere, SqlNodeList selectList) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 600         Tuple2&lt;String, String&gt; tabName = new Tuple2&lt;&gt;(&quot;&quot;, &quot;&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 601         if(sqlNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 602             tabName.f0 = sqlNode.toString();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 603         }else{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 604             AliasInfo aliasInfo = (AliasInfo)sideSQLParser.parseSql(sqlNode, sideTableSet, queueInfo, parentWhere, selectList);"> 604             AliasInfo aliasInfo = (AliasInfo)sideSQLParser.parseSql(sqlNode, sideTableSet, queueInfo, par🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 605             tabName.f0 = aliasInfo.getName();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 606             tabName.f1 = aliasInfo.getAlias();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 607         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 608         return tabName;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 609     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 610 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 611     private Tuple2&lt;String, String&gt; parseLeftNode(SqlNode sqlNode){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 612         Tuple2&lt;String, String&gt; tabName = new Tuple2&lt;&gt;(&quot;&quot;, &quot;&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 613         if(sqlNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 614             tabName.f0 = sqlNode.toString();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 615             tabName.f1 = sqlNode.toString();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 616         }else if (sqlNode.getKind() == AS){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 617             SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 618             SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 619 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 620             tabName.f0 = info.toString();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 621             tabName.f1 = alias.toString();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 622         }else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 623             throw new RuntimeException(&quot;&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 624         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 625 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 626         return tabName;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 627     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 628 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 629     public String buildCondition(List&lt;SqlBasicCall&gt; conditionList){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 630         if(CollectionUtils.isEmpty(conditionList)){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 631             return &quot;&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 632         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 633 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 634         return &quot; where &quot; + StringUtils.join(conditionList, &quot; AND &quot;);</span>
 635 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 636             Log.info(&quot;-------build temporary query-----------\n{}&quot;, tmpSelectSql);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 637             Log.info(&quot;---------------------------------------&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 638         } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 639             Log.error(&quot;&quot;, e);</span>
 640 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 641             throw new RuntimeException(e);
 642         }
 643     }
 644 
 645     /**
 646      * 抽取上层需用使用到的字段
 647      * @param parentSelectList
 648      * @param fromTableNameSet
 649      * @return
 650      */
 651     private Set&lt;String&gt; extractSelectFields(SqlNodeList parentSelectList,
 652                                             Set&lt;String&gt; fromTableNameSet,
 653                                             Map&lt;String, String&gt; tableRef){
 654         Set&lt;String&gt; extractFieldList = Sets.newHashSet();
 655         for(SqlNode selectNode : parentSelectList.getList()){
 656             extractSelectField(selectNode, extractFieldList, fromTableNameSet, tableRef);
 657         }
 658 
 659         return extractFieldList;
 660     }
 661 
 662     private Set&lt;String&gt; extractSelectFieldFromJoinCondition(Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,
 663                                                             Set&lt;String&gt; fromTableNameSet,
 664                                                             Map&lt;String, String&gt; tableRef){
 665         Set&lt;String&gt; extractFieldList = Sets.newHashSet();
 666         for(Tuple2&lt;String, String&gt; field : joinFieldSet){
 667             if(fromTableNameSet.contains(field.f0)){
 668                 extractFieldList.add(field.f0 + &quot;.&quot; + field.f1);
 669             }
 670 
 671             if(tableRef.containsKey(field.f0)){
 672                 if(fromTableNameSet.contains(tableRef.get(field.f0))){
 673                     extractFieldList.add(tableRef.get(field.f0) + &quot;.&quot; + field.f1);
 674                 }
 675             }
 676         }
 677 
 678         return extractFieldList;
 679     }
 680 
 681     private Set&lt;String&gt; extractFieldFromGroupByList(SqlNodeList parentGroupByList,
 682                                                     Set&lt;String&gt; fromTableNameSet,
 683                                                     Map&lt;String, String&gt; tableRef){
 684 
 685         if(parentGroupByList == null){
 686             return Sets.newHashSet();
 687         }
 688 
 689         Set&lt;String&gt; extractFieldList = Sets.newHashSet();
 690         for(SqlNode selectNode : parentGroupByList.getList()){
 691             extractSelectField(selectNode, extractFieldList, fromTableNameSet, tableRef);
 692         }
 693 
 694         return extractFieldList;
 695     }
 696 
 697     /**
 698      * 从join的条件中获取字段信息
 699      * @param condition
 700      * @param joinFieldSet
 701      */
 702     private void extractJoinField(SqlNode condition, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet){
 703         if (null == condition || condition.getKind() == LITERAL) {
 704             return;
 705         }
 706 
 707         SqlKind joinKind = condition.getKind();
 708         if( joinKind == AND || joinKind == EQUALS ){
 709             extractJoinField(((SqlBasicCall)condition).operands[0], joinFieldSet);
 710             extractJoinField(((SqlBasicCall)condition).operands[1], joinFieldSet);
 711         }else{
<abbr title=" 712             Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 712             Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must b🔵</abbr>
<abbr title=" 713             Tuple2&lt;String, String&gt; tuple2 = Tuple2.of(((SqlIdentifier)condition).names.get(0), ((SqlIdentifier)condition).names.get(1));"> 713             Tuple2&lt;String, String&gt; tuple2 = Tuple2.of(((SqlIdentifier)condition).names.get(0), ((SqlIdent🔵</abbr>
 714             joinFieldSet.add(tuple2);
 715         }
 716     }
 717 
 718 
 719     private void extractSelectField(SqlNode selectNode,
 720                                     Set&lt;String&gt; extractFieldSet,
 721                                     Set&lt;String&gt; fromTableNameSet,
 722                                     Map&lt;String, String&gt; tableRef){
 723         if (selectNode.getKind() == AS) {
 724             SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 725             extractSelectField(leftNode, extractFieldSet, fromTableNameSet, tableRef);
 726 
 727         }else if(selectNode.getKind() == IDENTIFIER) {
 728             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 729 
 730             if(sqlIdentifier.names.size() == 1){
 731                 return;
 732             }
 733 
 734             String tableName = sqlIdentifier.names.get(0);
 735             //TODO
 736             if(fromTableNameSet.contains(tableName)){
 737                 extractFieldSet.add(sqlIdentifier.toString());
 738             } else if(fromTableNameSet.contains(tableRef.get(tableName))){
 739                 //TODO extractFieldSet.add(sqlIdentifier.setName(0, tableRef.get(tableName)).toString());
 740             }
 741 
 742         }else if(  AGGREGATE.contains(selectNode.getKind())
 743                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 744                 || COMPARISON.contains(selectNode.getKind())
 745                 || selectNode.getKind() == OTHER_FUNCTION
 746                 || selectNode.getKind() == DIVIDE
 747                 || selectNode.getKind() == CAST
 748                 || selectNode.getKind() == TRIM
 749                 || selectNode.getKind() == TIMES
 750                 || selectNode.getKind() == PLUS
 751                 || selectNode.getKind() == NOT_IN
 752                 || selectNode.getKind() == OR
 753                 || selectNode.getKind() == AND
 754                 || selectNode.getKind() == MINUS
 755                 || selectNode.getKind() == TUMBLE
 756                 || selectNode.getKind() == TUMBLE_START
 757                 || selectNode.getKind() == TUMBLE_END
 758                 || selectNode.getKind() == SESSION
 759                 || selectNode.getKind() == SESSION_START
 760                 || selectNode.getKind() == SESSION_END
 761                 || selectNode.getKind() == HOP
 762                 || selectNode.getKind() == HOP_START
 763                 || selectNode.getKind() == HOP_END
 764                 || selectNode.getKind() == BETWEEN
 765                 || selectNode.getKind() == IS_NULL
 766                 || selectNode.getKind() == IS_NOT_NULL
 767                 || selectNode.getKind() == CONTAINS
 768                 || selectNode.getKind() == TIMESTAMP_ADD
 769                 || selectNode.getKind() == TIMESTAMP_DIFF
 770                 || selectNode.getKind() == LIKE
 771 
 772         ){
 773             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 774             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 775                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 776                 if(sqlNode instanceof SqlLiteral){
 777                     continue;
 778                 }
 779 
 780                 if(sqlNode instanceof SqlDataTypeSpec){
 781                     continue;
 782                 }
 783 
 784                 extractSelectField(sqlNode, extractFieldSet, fromTableNameSet, tableRef);
 785             }
 786 
 787         }else if(selectNode.getKind() == CASE){
 788             SqlCase sqlCase = (SqlCase) selectNode;
 789             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 790             SqlNodeList thenOperands = sqlCase.getThenOperands();
 791             SqlNode elseNode = sqlCase.getElseOperand();
 792 
 793             for(int i=0; i&lt;whenOperands.size(); i++){
 794                 SqlNode oneOperand = whenOperands.get(i);
 795                 extractSelectField(oneOperand, extractFieldSet, fromTableNameSet, tableRef);
 796             }
 797 
 798             for(int i=0; i&lt;thenOperands.size(); i++){
 799                 SqlNode oneOperand = thenOperands.get(i);
 800                 extractSelectField(oneOperand, extractFieldSet, fromTableNameSet, tableRef);
 801             }
 802 
 803             extractSelectField(elseNode, extractFieldSet, fromTableNameSet, tableRef);
 804         }else {
 805             //do nothing
 806         }
 807     }
 808 
 809 
<abbr title=" 810     private Tuple2&lt;String, String&gt; parseRightNode(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo,"> 810     private Tuple2&lt;String, String&gt; parseRightNode(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object🔵</abbr>
<abbr title=" 811                                                   SqlNode parentWhere, SqlNodeList selectList, SqlNodeList parentGroupByList) {"> 811                                                   SqlNode parentWhere, SqlNodeList selectList, SqlNodeLis🔵</abbr>
 812         Tuple2&lt;String, String&gt; tabName = new Tuple2&lt;&gt;(&quot;&quot;, &quot;&quot;);
 813         if(sqlNode.getKind() == IDENTIFIER){
 814             tabName.f0 = sqlNode.toString();
 815         }else{
<abbr title=" 816             AliasInfo aliasInfo = (AliasInfo)sideSQLParser.parseSql(sqlNode, sideTableSet, queueInfo, parentWhere, selectList, parentGroupByList);"> 816             AliasInfo aliasInfo = (AliasInfo)sideSQLParser.parseSql(sqlNode, sideTableSet, queueInfo, par🔵</abbr>
 817             tabName.f0 = aliasInfo.getName();
 818             tabName.f1 = aliasInfo.getAlias();
 819         }
 820         return tabName;
 821     }
 822 
 823     private Tuple2&lt;String, String&gt; parseLeftNode(SqlNode sqlNode){
 824         Tuple2&lt;String, String&gt; tabName = new Tuple2&lt;&gt;(&quot;&quot;, &quot;&quot;);
 825         if(sqlNode.getKind() == IDENTIFIER){
 826             tabName.f0 = sqlNode.toString();
 827             tabName.f1 = sqlNode.toString();
 828         }else if (sqlNode.getKind() == AS){
 829             SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 830             SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 831 
 832             tabName.f0 = info.toString();
 833             tabName.f1 = alias.toString();
 834         }else {
 835             throw new RuntimeException(&quot;&quot;);
 836         }
 837 
 838         return tabName;
 839     }
 840 
 841     public String buildCondition(List&lt;SqlBasicCall&gt; conditionList){
 842         if(CollectionUtils.isEmpty(conditionList)){
 843             return &quot;&quot;;
 844         }
 845 
 846         return &quot; where &quot; + StringUtils.join(conditionList, &quot; AND &quot;);
 847     }
 848 
 849     /**
 850      * 构建抽取表的查询字段信息
 851      * 包括去除重复字段，名称相同的取别名
 852      * @param extractSelectField
 853      * @param joinFieldSet
 854      * @return
 855      */
 856     public Set&lt;String&gt; buildSelectNode(Set&lt;String&gt; extractSelectField, Set&lt;String&gt; joinFieldSet){
 857         if(CollectionUtils.isEmpty(extractSelectField)){
 858             throw new RuntimeException(&quot;no field is used&quot;);
 859         }
 860 
 861         Sets.SetView&lt;String&gt; view = Sets.union(extractSelectField, joinFieldSet);
 862         Set&lt;String&gt; newFieldSet = Sets.newHashSet();
 863         //为相同的列取别名
 864         HashBiMap&lt;String, String&gt; refFieldMap = HashBiMap.create();
 865         for(String field : view){
 866             String[] fieldInfo = StringUtils.split(field, &#x27;.&#x27;);
 867             String aliasName = fieldInfo[1];
 868             StringBuilder stringBuilder = new StringBuilder();
 869             stringBuilder.append(field);
 870             if(refFieldMap.inverse().get(aliasName) != null){
 871                 aliasName = ParseUtils.dealDuplicateFieldName(refFieldMap, aliasName);
 872                 stringBuilder.append(&quot; as &quot;)
 873                         .append(aliasName);
 874             }
 875 
 876             refFieldMap.put(field, aliasName);
 877 
 878             newFieldSet.add(stringBuilder.toString());
 879         }
 880 
 881         return newFieldSet;
 882     }
 883 
 884     private boolean checkIsSideTable(String tableName, Set&lt;String&gt; sideTableList){
 885         if(sideTableList.contains(tableName)){
 886             return true;
 887         }
 888         return false;
 889     }
 890 
 891     private SqlBasicCall buildAsSqlNode(String internalTableName, SqlNode newSource) {
 892         SqlOperator operator = new SqlAsOperator();
 893         SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 894         SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(internalTableName, null, sqlParserPos);
 895         SqlNode[] sqlNodes = new SqlNode[2];
 896         sqlNodes[0] = newSource;
 897         sqlNodes[1] = sqlIdentifierAlias;
 898         return new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 899     }
 900 
 901     /**
 902      * 获取where中和指定表有关联的字段
 903      * @param fromTableNameSet
 904      * @param parentWhere
 905      * @param extractCondition
 906      */
<abbr title=" 907     private void extractWhereCondition(Set&lt;String&gt; fromTableNameSet, SqlBasicCall parentWhere, Set&lt;String&gt; extractCondition){"> 907     private void extractWhereCondition(Set&lt;String&gt; fromTableNameSet, SqlBasicCall parentWhere, Set&lt;String🔵</abbr>
 908 
 909         if(parentWhere == null){
 910             return;
 911         }
 912 
 913         SqlKind kind = parentWhere.getKind();
 914         if(kind == AND){
<abbr title=" 915             extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[0], extractCondition);"> 915             extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[0], extractC🔵</abbr>
<abbr title=" 916             extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[1], extractCondition);"> 916             extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[1], extractC🔵</abbr>
 917         } else {
 918 
 919             Set&lt;String&gt; fieldInfos = Sets.newHashSet();
 920             TableUtils.getConditionRefTable(parentWhere, fieldInfos);
 921             fieldInfos.forEach(fieldInfo -&gt; {
 922                 String[] splitInfo = StringUtils.split(fieldInfo, &quot;.&quot;);
 923                 if(splitInfo.length == 2 &amp;&amp; fromTableNameSet.contains(splitInfo[0])){
 924                     extractCondition.add(fieldInfo);
 925                 }
 926             });
 927 
 928         }
 929 
 930 
 931     }
 932 
 933 
 934     /**
 935      * 检查关联的where 条件中的判断是否可以下移到新构建的子查询
 936      * @param fromTableNameSet
 937      * @param parentWhere
 938      * @param extractCondition
 939      * @return
 940      */
 941     private boolean checkAndRemoveWhereCondition(Set&lt;String&gt; fromTableNameSet,
 942                                                  SqlBasicCall parentWhere,
 943                                                  List&lt;SqlBasicCall&gt; extractCondition){
 944         if(parentWhere == null){
 945             return false;
 946         }
 947 
 948         SqlKind kind = parentWhere.getKind();
 949         if(kind == AND){
<abbr title=" 950             boolean removeLeft = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[0], extractCondition);"> 950             boolean removeLeft = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWher🔵</abbr>
<abbr title=" 951             boolean removeRight = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[1], extractCondition);"> 951             boolean removeRight = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhe🔵</abbr>
 952             //DO remove
 953             if(removeLeft){
 954                 extractCondition.add(removeWhereConditionNode(parentWhere, 0));
 955             }
 956 
 957             if(removeRight){
 958                 extractCondition.add(removeWhereConditionNode(parentWhere, 1));
 959             }
 960 
 961             return false;
 962         } else {
 963             //条件表达式，如果该条件关联的表都是指定的表则移除
 964             Set&lt;String&gt; fieldInfos = Sets.newHashSet();
 965             TableUtils.getConditionRefTable(parentWhere, fieldInfos);
 966             Set&lt;String&gt; conditionRefTableNameSet = Sets.newHashSet();
 967 
 968             fieldInfos.forEach(fieldInfo -&gt; {
 969                 String[] splitInfo = StringUtils.split(fieldInfo, &quot;.&quot;);
 970                 if(splitInfo.length == 2){
 971                     conditionRefTableNameSet.add(splitInfo[0]);
 972                 }
 973             });
 974 
 975 
 976             if(fromTableNameSet.containsAll(conditionRefTableNameSet)){
 977                 return true;
 978             }
 979 
 980             return false;
 981         }
 982     }
 983 
 984     /**
 985      * 抽取where 条件中指定的条件
 986      * @param parentWhere
 987      * @param index
 988      * @return
 989      */
 990     public SqlBasicCall removeWhereConditionNode(SqlBasicCall parentWhere, int index){
 991         SqlBasicCall oldCondition = (SqlBasicCall) parentWhere.getOperands()[index];
 992         parentWhere.setOperand(index, buildEmptyCondition());
 993         return oldCondition;
 994     }
 995 
 996     /**
 997      * 构建 1=1的 where 条件
 998      * @return
 999      */
1000     public SqlBasicCall buildEmptyCondition(){
1001         SqlBinaryOperator equalsOperators = SqlStdOperatorTable.EQUALS;
1002         SqlNode[] operands = new SqlNode[2];
1003         operands[0] = SqlLiteral.createExactNumeric(&quot;1&quot;, SqlParserPos.ZERO);
1004         operands[1] = SqlLiteral.createExactNumeric(&quot;1&quot;, SqlParserPos.ZERO);
1005 
1006         return new SqlBasicCall(equalsOperators, operands, SqlParserPos.ZERO);
1007     }
1008 
1009     /**
1010      * 替换join 条件中的表名称
1011      * @param node
1012      * @param tableMap 表名的关联关系
1013      */
1014     private SqlIdentifier checkAndReplaceJoinCondition(SqlNode node, Map&lt;String, String&gt; tableMap){
1015 
1016         SqlKind joinKind = node.getKind();
1017         if( joinKind == AND || joinKind == EQUALS ){
<abbr title="1018             SqlIdentifier leftNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[0], tableMap);">1018             SqlIdentifier leftNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[0], table🔵</abbr>
<abbr title="1019             SqlIdentifier rightNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[1], tableMap);">1019             SqlIdentifier rightNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[1], tabl🔵</abbr>
1020 
1021             if(leftNode != null){
1022                 ((SqlBasicCall)node).setOperand(0, leftNode);
1023             }
1024 
1025             if(rightNode != null){
1026                 ((SqlBasicCall)node).setOperand(1, leftNode);
1027             }
1028 
1029             return null;
1030         } else {
1031             //replace table
<abbr title="1032             Preconditions.checkState(((SqlIdentifier)node).names.size() == 2, &quot;join condition must be format table.field&quot;);">1032             Preconditions.checkState(((SqlIdentifier)node).names.size() == 2, &quot;join condition must be for🔵</abbr>
1033             String tbName = ((SqlIdentifier) node).names.get(0);
1034             if(tableMap.containsKey(tbName)){
1035                 tbName = tableMap.get(tbName);
1036                 return ((SqlIdentifier) node).setName(0, tbName);
1037             }
1038 
1039             return null;
1040         }
1041     }
1042 
1043     /**
1044      * 解析出临时中间表的属性列和源表之间的关系
1045      * @param fieldSet
1046      * @param newTableAliasName
1047      */
<abbr title="1048     public Map&lt;String, String&gt; buildTmpTableFieldRefOriField(Set&lt;String&gt; fieldSet, String newTableAliasName){">1048     public Map&lt;String, String&gt; buildTmpTableFieldRefOriField(Set&lt;String&gt; fieldSet, String newTableAliasNa🔵</abbr>
1049         Map&lt;String, String&gt; refInfo = Maps.newConcurrentMap();
1050         for(String field : fieldSet){
1051             String[] fields = StringUtils.splitByWholeSeparator(field, &quot;as&quot;);
1052             String oldKey = field;
1053             String[] oldFieldInfo = StringUtils.splitByWholeSeparator(fields[0], &quot;.&quot;);
1054             String oldFieldName = oldFieldInfo.length == 2 ? oldFieldInfo[1] : oldFieldInfo[0];
1055             String newKey = fields.length == 2 ? newTableAliasName + &quot;.&quot; + fields[1] :
1056                     newTableAliasName + &quot;.&quot; + oldFieldName;
1057             refInfo.put(oldKey, newKey);
1058         }
1059 
1060         return refInfo;
1061     }
1062 
1063 
1064 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.side;
  21 
  22 import com.dtstack.flink.sql.parser.FlinkPlanner;
  23 import com.dtstack.flink.sql.util.ParseUtils;
  24 import com.dtstack.flink.sql.util.TableUtils;
  25 import com.esotericsoftware.minlog.Log;
  26 import com.google.common.base.Preconditions;
  27 import com.google.common.collect.*;
  28 import org.apache.calcite.sql.JoinType;
  29 import org.apache.calcite.sql.SqlAsOperator;
  30 import org.apache.calcite.sql.SqlBasicCall;
  31 import org.apache.calcite.sql.SqlBinaryOperator;
  32 import org.apache.calcite.sql.SqlDataTypeSpec;
  33 import org.apache.calcite.sql.SqlIdentifier;
  34 import org.apache.calcite.sql.SqlJoin;
  35 import org.apache.calcite.sql.SqlKind;
  36 import org.apache.calcite.sql.SqlLiteral;
  37 import org.apache.calcite.sql.SqlNode;
  38 import org.apache.calcite.sql.SqlNodeList;
  39 import org.apache.calcite.sql.SqlOperator;
  40 import org.apache.calcite.sql.fun.SqlCase;
  41 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
  42 import org.apache.calcite.sql.parser.SqlParserPos;
  43 import org.apache.commons.collections.CollectionUtils;
  44 import org.apache.commons.lang3.StringUtils;
  45 import org.apache.flink.api.java.tuple.Tuple2;
  46 import org.apache.flink.table.calcite.FlinkPlannerImpl;
  47 
  48 import java.util.List;
  49 import java.util.Map;
  50 import java.util.Queue;
  51 import java.util.Set;
  52 
  53 import static org.apache.calcite.sql.SqlKind.*;
  54 
  55 /**
  56  * 处理join 节点
  57  * 1:如果包含维表节点替换为临时查询
  58  * Date: 2020/2/27
  59  * Company: www.dtstack.com
  60  * @author xuchao
  61  */
  62 
  63 public class JoinNodeDealer {
  64 
  65     //用来构建临时的中间查询
  66     private static final String SELECT_TEMP_SQL = &quot;select %s from %s %s&quot;;
  67 
  68     private SideSQLParser sideSQLParser;
  69 
  70     public JoinNodeDealer(SideSQLParser sideSQLParser){
  71         this.sideSQLParser = sideSQLParser;
  72     }
  73 
  74     /**
  75      * 解析 join 操作
  76      * @param joinNode
  77      * @param sideTableSet 标明哪些表名是维表
  78      * @param queueInfo sql执行队列
  79      * @param parentWhere join 关联的最上层的where 节点
  80      * @param parentSelectList join 关联的最上层的select 节点
  81      * @param joinFieldSet
  82      * @param tableRef 存储构建临时表查询后源表和新表之间的关联关系
  83      * @return
  84      */
  85     public JoinInfo dealJoinNode(SqlJoin joinNode,
  86                                  Set&lt;String&gt; sideTableSet,
  87                                  Queue&lt;Object&gt; queueInfo,
  88                                  SqlNode parentWhere,
  89                                  SqlNodeList parentSelectList,
  90                                  SqlNodeList parentGroupByList,
  91                                  Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,
  92                                  Map&lt;String, String&gt; tableRef,
  93                                  Map&lt;String, String&gt; fieldRef) {
  94 
  95         SqlNode leftNode = joinNode.getLeft();
  96         SqlNode rightNode = joinNode.getRight();
  97         JoinType joinType = joinNode.getJoinType();
  98 
  99         String leftTbName = &quot;&quot;;
 100         String leftTbAlias = &quot;&quot;;
 101         String rightTableName = &quot;&quot;;
 102         String rightTableAlias = &quot;&quot;;
 103 
 104         //抽取join中的的条件
 105         extractJoinField(joinNode.getCondition(), joinFieldSet);
 106 
 107         if (leftNode.getKind() == JOIN) {
 108             //处理连续join
 109             dealNestJoin(joinNode, sideTableSet,
<abbr title=" 110                     queueInfo, parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRef);"> 110                     queueInfo, parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, 🔵</abbr>
 111             leftNode = joinNode.getLeft();
 112         }
 113 
 114         if (leftNode.getKind() == AS) {
<abbr title=" 115             AliasInfo aliasInfo = (AliasInfo) sideSQLParser.parseSql(leftNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 115             AliasInfo aliasInfo = (AliasInfo) sideSQLParser.parseSql(leftNode, sideTableSet, queueInfo, p🔵</abbr>
 116             leftTbName = aliasInfo.getName();
 117             leftTbAlias = aliasInfo.getAlias();
 118         } else if(leftNode.getKind() == IDENTIFIER){
 119             leftTbName = leftNode.toString();
 120             leftTbAlias = leftTbName;
 121         }
 122 
 123         boolean leftIsSide = checkIsSideTable(leftTbName, sideTableSet);
 124         Preconditions.checkState(!leftIsSide, &quot;side-table must be at the right of join operator&quot;);
 125 
<abbr title=" 126         Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 126         Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo🔵</abbr>
 127         rightTableName = rightTableNameAndAlias.f0;
 128         rightTableAlias = rightTableNameAndAlias.f1;
 129 
 130         boolean rightIsSide = checkIsSideTable(rightTableName, sideTableSet);
 131         if(rightIsSide &amp;&amp; joinType == JoinType.RIGHT){
<abbr title=" 132             throw new RuntimeException(&quot;side join not support join type of right[current support inner join and left join]&quot;);"> 132             throw new RuntimeException(&quot;side join not support join type of right[current support inner jo🔵</abbr>
 133         }
 134 
 135         JoinInfo tableInfo = new JoinInfo();
 136         tableInfo.setLeftTableName(leftTbName);
 137         tableInfo.setRightTableName(rightTableName);
 138 
 139         leftTbAlias = StringUtils.isEmpty(leftTbAlias) ? leftTbName : leftTbAlias;
 140         rightTableAlias = StringUtils.isEmpty(rightTableAlias) ? rightTableName : rightTableAlias;
 141 
 142         tableInfo.setLeftTableAlias(leftTbAlias);
 143         tableInfo.setRightTableAlias(rightTableAlias);
 144         tableInfo.setRightIsSideTable(rightIsSide);
 145         tableInfo.setLeftNode(leftNode);
 146         tableInfo.setRightNode(rightNode);
 147         tableInfo.setJoinType(joinType);
 148         tableInfo.setCondition(joinNode.getCondition());
 149         TableUtils.replaceJoinFieldRefTableName(joinNode.getCondition(), fieldRef);
 150 
 151         //extract 需要查询的字段信息
 152         if(rightIsSide){
<abbr title=" 153             extractJoinNeedSelectField(leftNode, rightNode, parentWhere, parentSelectList, parentGroupByList, tableRef, joinFieldSet, fieldRef, tableInfo);"> 153             extractJoinNeedSelectField(leftNode, rightNode, parentWhere, parentSelectList, parentGroupByL🔵</abbr>
 154         }
 155 
 156         if(tableInfo.getLeftNode().getKind() != AS){
 157             return tableInfo;
 158         }
 159 
 160         SqlKind asNodeFirstKind = ((SqlBasicCall)tableInfo.getLeftNode()).operands[0].getKind();
 161         if(asNodeFirstKind == SELECT){
 162             queueInfo.offer(tableInfo.getLeftNode());
 163             tableInfo.setLeftNode(((SqlBasicCall)tableInfo.getLeftNode()).operands[1]);
 164         }
 165 
 166         return tableInfo;
 167     }
 168 
 169     /**
 170      * 获取join 之后需要查询的字段信息
 171      */
 172     public void extractJoinNeedSelectField(SqlNode leftNode,
 173                                            SqlNode rightNode,
 174                                            SqlNode parentWhere,
 175                                            SqlNodeList parentSelectList,
 176                                            SqlNodeList parentGroupByList,
 177                                            Map&lt;String, String&gt; tableRef,
 178                                            Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,
 179                                            Map&lt;String, String&gt; fieldRef,
 180                                            JoinInfo tableInfo){
 181 
<abbr title=" 182         Set&lt;String&gt; extractSelectField = extractField(leftNode, parentWhere, parentSelectList, parentGroupByList, tableRef, joinFieldSet);"> 182         Set&lt;String&gt; extractSelectField = extractField(leftNode, parentWhere, parentSelectList, parentGrou🔵</abbr>
<abbr title=" 183         Set&lt;String&gt; rightExtractSelectField = extractField(rightNode, parentWhere, parentSelectList, parentGroupByList, tableRef, joinFieldSet);"> 183         Set&lt;String&gt; rightExtractSelectField = extractField(rightNode, parentWhere, parentSelectList, pare🔵</abbr>
 184 
 185         //重命名right 中和 left 重名的
 186         Map&lt;String, String&gt; leftTbSelectField = Maps.newHashMap();
 187         Map&lt;String, String&gt; rightTbSelectField = Maps.newHashMap();
 188         String newTableName = tableInfo.getNewTableAlias();
 189 
 190         for(String tmpField : extractSelectField){
 191             String[] tmpFieldSplit = StringUtils.split(tmpField, &#x27;.&#x27;);
 192             leftTbSelectField.put(tmpFieldSplit[1], tmpFieldSplit[1]);
 193             fieldRef.put(tmpField, TableUtils.buildTableField(newTableName, tmpFieldSplit[1]));
 194         }
 195 
 196         for(String tmpField : rightExtractSelectField){
 197             String[] tmpFieldSplit = StringUtils.split(tmpField, &#x27;.&#x27;);
 198             String originalFieldName = tmpFieldSplit[1];
 199             String targetFieldName = originalFieldName;
 200             if(leftTbSelectField.containsKey(originalFieldName)){
<abbr title=" 201                 targetFieldName = ParseUtils.dealDuplicateFieldName(leftTbSelectField, originalFieldName);"> 201                 targetFieldName = ParseUtils.dealDuplicateFieldName(leftTbSelectField, originalFieldName)🔵</abbr>
 202             }
 203 
 204             rightTbSelectField.put(originalFieldName, targetFieldName);
 205             fieldRef.put(tmpField, TableUtils.buildTableField(newTableName, targetFieldName));
 206         }
 207 
 208         tableInfo.setLeftSelectFieldInfo(leftTbSelectField);
 209         tableInfo.setRightSelectFieldInfo(rightTbSelectField);
 210     }
 211 
 212     /**
 213      * 指定的节点关联到的 select 中的字段和 where中的字段
 214      * @param sqlNode
 215      * @param parentWhere
 216      * @param parentSelectList
 217      * @param parentGroupByList
 218      * @param tableRef
 219      * @param joinFieldSet
 220      * @return
 221      */
 222     public Set&lt;String&gt; extractField(SqlNode sqlNode,
 223                                     SqlNode parentWhere,
 224                                     SqlNodeList parentSelectList,
 225                                     SqlNodeList parentGroupByList,
 226                                     Map&lt;String, String&gt; tableRef,
 227                                     Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet){
 228         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 229         TableUtils.getFromTableInfo(sqlNode, fromTableNameSet);
 230         Set&lt;String&gt; extractCondition = Sets.newHashSet();
 231 
 232         extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere, extractCondition);
<abbr title=" 233         Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tableRef);"> 233         Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tableRef🔵</abbr>
<abbr title=" 234         Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSet, tableRef);"> 234         Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableN🔵</abbr>
 235 
<abbr title=" 236         Set&lt;String&gt; extractGroupByField = extractFieldFromGroupByList(parentGroupByList, fromTableNameSet, tableRef);"> 236         Set&lt;String&gt; extractGroupByField = extractFieldFromGroupByList(parentGroupByList, fromTableNameSet🔵</abbr>
 237 
 238         extractSelectField.addAll(extractCondition);
 239         extractSelectField.addAll(fieldFromJoinCondition);
 240         extractSelectField.addAll(extractGroupByField);
 241 
 242         return extractSelectField;
 243     }
 244 
 245 
 246     /**
 247      * 处理多层join
 248      * 判断左节点是否需要创建临时查询
 249      * （1）右节点是维表
 250      * （2）左节点不是 as 节点
 251      */
 252     private JoinInfo dealNestJoin(SqlJoin joinNode,
 253                                   Set&lt;String&gt; sideTableSet,
 254                                   Queue&lt;Object&gt; queueInfo,
 255                                   SqlNode parentWhere,
 256                                   SqlNodeList parentSelectList,
 257                                   SqlNodeList parentGroupByList,
 258                                   Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,
 259                                   Map&lt;String, String&gt; tableRef,
 260                                   Map&lt;String, String&gt; fieldRef){
 261 
 262         SqlJoin leftJoinNode = (SqlJoin) joinNode.getLeft();
 263         SqlNode parentRightJoinNode = joinNode.getRight();
 264         SqlNode rightNode = leftJoinNode.getRight();
<abbr title=" 265         Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 265         Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo🔵</abbr>
<abbr title=" 266         Tuple2&lt;String, String&gt; parentRightJoinInfo = parseRightNode(parentRightJoinNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 266         Tuple2&lt;String, String&gt; parentRightJoinInfo = parseRightNode(parentRightJoinNode, sideTableSet, qu🔵</abbr>
 267         boolean parentRightIsSide = checkIsSideTable(parentRightJoinInfo.f0, sideTableSet);
 268 
<abbr title=" 269         JoinInfo joinInfo = dealJoinNode(leftJoinNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRef);"> 269         JoinInfo joinInfo = dealJoinNode(leftJoinNode, sideTableSet, queueInfo, parentWhere, parentSelect🔵</abbr>
 270 
 271         String rightTableName = rightTableNameAndAlias.f0;
 272         boolean rightIsSide = checkIsSideTable(rightTableName, sideTableSet);
 273         SqlBasicCall buildAs = TableUtils.buildAsNodeByJoinInfo(joinInfo, null, null);
 274 
 275         if(rightIsSide){
<abbr title=" 276             addSideInfoToExeQueue(queueInfo, joinInfo, joinNode, parentSelectList, parentGroupByList, parentWhere, tableRef);"> 276             addSideInfoToExeQueue(queueInfo, joinInfo, joinNode, parentSelectList, parentGroupByList, par🔵</abbr>
 277         }
 278 
 279         SqlNode newLeftNode = joinNode.getLeft();
 280 
 281         if(newLeftNode.getKind() != AS &amp;&amp; parentRightIsSide){
 282 
 283             String leftTbAlias = buildAs.getOperands()[1].toString();
 284             extractTemporaryQuery(newLeftNode, leftTbAlias, (SqlBasicCall) parentWhere,
 285                     parentSelectList, queueInfo, joinFieldSet, tableRef, fieldRef);
 286 
 287             //替换leftNode 为新的查询
 288             joinNode.setLeft(buildAs);
<abbr title=" 289             replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByList, parentWhere);"> 289             replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByLi🔵</abbr>
 290         }
 291 
 292         return joinInfo;
 293     }
 294 
 295     /**
 296      * 右边表是维表需要重新构建左表的临时查询
 297      * 并将joinInfo 添加到执行队列里面
 298      * @param queueInfo
 299      * @param joinInfo
 300      * @param joinNode
 301      * @param parentSelectList
 302      * @param parentGroupByList
 303      * @param parentWhere
 304      * @param tableRef
 305      */
 306     public void addSideInfoToExeQueue(Queue&lt;Object&gt; queueInfo,
 307                                       JoinInfo joinInfo,
 308                                       SqlJoin joinNode,
 309                                       SqlNodeList parentSelectList,
 310                                       SqlNodeList parentGroupByList,
 311                                       SqlNode parentWhere,
 312                                       Map&lt;String, String&gt; tableRef){
 313         //只处理维表
 314         if(!joinInfo.isRightIsSideTable()){
 315             return;
 316         }
 317 
 318         SqlBasicCall buildAs = TableUtils.buildAsNodeByJoinInfo(joinInfo, null, null);
 319         SqlNode leftJoinNode = joinNode.getLeft();
 320         queueInfo.offer(joinInfo);
 321         //替换左表为新的表名称
 322         joinNode.setLeft(buildAs);
 323 
<abbr title=" 324         replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByList, parentWhere);"> 324         replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByList, 🔵</abbr>
 325     }
 326 
 327     /**
 328      * 替换指定的查询和条件节点中的字段为新的字段
 329      * @param buildAs
 330      * @param leftJoinNode
 331      * @param tableRef
 332      * @param parentSelectList
 333      * @param parentGroupByList
 334      * @param parentWhere
 335      */
 336     public void replaceSelectAndWhereField(SqlBasicCall buildAs,
 337                    SqlNode leftJoinNode,
 338                    Map&lt;String, String&gt; tableRef,
 339                    SqlNodeList parentSelectList,
 340                    SqlNodeList parentGroupByList,
 341                    SqlNode parentWhere){
 342 
 343         String newLeftTableName = buildAs.getOperands()[1].toString();
 344         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 345         TableUtils.getFromTableInfo(leftJoinNode, fromTableNameSet);
 346 
 347         for(String tbTmp : fromTableNameSet){
 348             tableRef.put(tbTmp, newLeftTableName);
 349         }
 350 
 351         //替换select field 中的对应字段
 352         HashBiMap&lt;String, String&gt; fieldReplaceRef = HashBiMap.create();
 353         for(SqlNode sqlNode : parentSelectList.getList()){
 354             for(String tbTmp : fromTableNameSet) {
 355                 TableUtils.replaceSelectFieldTable(sqlNode, tbTmp, newLeftTableName, fieldReplaceRef);
 356             }
 357         }
 358 
 359         //TODO 应该根据上面的查询字段的关联关系来替换
 360         //替换where 中的条件相关
 361         for(String tbTmp : fromTableNameSet){
 362             TableUtils.replaceWhereCondition(parentWhere, tbTmp, newLeftTableName, fieldReplaceRef);
 363         }
 364 
 365         if(parentGroupByList != null){
 366             for(SqlNode sqlNode : parentGroupByList.getList()){
 367                 for(String tbTmp : fromTableNameSet) {
<abbr title=" 368                     TableUtils.replaceSelectFieldTable(sqlNode, tbTmp, newLeftTableName, fieldReplaceRef);"> 368                     TableUtils.replaceSelectFieldTable(sqlNode, tbTmp, newLeftTableName, fieldReplaceRef)🔵</abbr>
 369                 }
 370             }
 371         }
 372 
 373     }
 374 
 375     /**
 376      * 抽取出中间查询表
 377      * @param node
 378      * @param tableAlias
 379      * @param parentWhere
 380      * @param parentSelectList
 381      * @param queueInfo
 382      * @param joinFieldSet
 383      * @param tableRef
 384      * @return 源自段和新生成字段之间的映射关系
 385      */
 386     private void extractTemporaryQuery(SqlNode node, String tableAlias,
 387                                        SqlBasicCall parentWhere,
 388                                        SqlNodeList parentSelectList,
 389                                        Queue&lt;Object&gt; queueInfo,
 390                                        Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,
 391                                        Map&lt;String, String&gt; tableRef,
 392                                        Map&lt;String, String&gt; fieldRef){
 393         try{
 394             //父一级的where 条件中如果只和临时查询相关的条件都截取进来
 395             Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 396             List&lt;SqlBasicCall&gt; extractCondition = Lists.newArrayList();
 397 
 398             TableUtils.getFromTableInfo(node, fromTableNameSet);
 399             checkAndRemoveWhereCondition(fromTableNameSet, parentWhere, extractCondition);
 400 
 401             if(node.getKind() == JOIN){
 402                 checkAndReplaceJoinCondition(((SqlJoin)node).getCondition(), tableRef);
 403             }
 404 
<abbr title=" 405             Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tableRef);"> 405             Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tabl🔵</abbr>
<abbr title=" 406             Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSet, tableRef);"> 406             Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTa🔵</abbr>
 407             Set&lt;String&gt; newFields = buildSelectNode(extractSelectField, fieldFromJoinCondition);
 408             String extractSelectFieldStr = StringUtils.join(newFields, &#x27;,&#x27;);
 409 
 410             Map&lt;String, String&gt; oldRefNewField = buildTmpTableFieldRefOriField(newFields, tableAlias);
 411             fieldRef.putAll(oldRefNewField);
 412 
 413             String extractConditionStr = buildCondition(extractCondition);
 414 
 415             String tmpSelectSql = String.format(SELECT_TEMP_SQL,
 416                     extractSelectFieldStr,
 417                     node.toString(),
 418                     extractConditionStr);
 419 
 420             FlinkPlannerImpl flinkPlanner = FlinkPlanner.getFlinkPlanner();
 421             SqlNode sqlNode = flinkPlanner.parse(tmpSelectSql);
 422 
 423             SqlBasicCall sqlBasicCall = buildAsSqlNode(tableAlias, sqlNode);
 424             queueInfo.offer(sqlBasicCall);
 425 
 426             //替换select中的表结构
 427             HashBiMap&lt;String, String&gt; fieldReplaceRef = HashBiMap.create();
 428             for(SqlNode tmpSelect : parentSelectList.getList()){
 429                 for(String tbTmp : fromTableNameSet) {
 430                     TableUtils.replaceSelectFieldTable(tmpSelect, tbTmp, tableAlias, fieldReplaceRef);
 431                 }
 432             }
 433 
 434             //替换where 中的条件相关
 435             for(String tbTmp : fromTableNameSet){
 436                 TableUtils.replaceWhereCondition(parentWhere, tbTmp, tableAlias, fieldReplaceRef);
 437             }
 438 
 439             for(String tbTmp : fromTableNameSet){
 440                 tableRef.put(tbTmp, tableAlias);
 441             }
 442 
 443             System.out.println(&quot;-------build temporary query-----------&quot;);
 444             System.out.println(tmpSelectSql);
 445             System.out.println(&quot;---------------------------------------&quot;);
 446 
 447         }catch (Exception e){
 448             e.printStackTrace();
 449             throw new RuntimeException(e);
 450         }
 451     }
 452 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
 453 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 454 private void extractTemporaryQuery(SqlNode node, String tableAlias, SqlBasicCall parentWhere,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 455                                        SqlNodeList parentSelectList, Queue&lt;Object&gt; queueInfo,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 456                                        Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 457                                        Map&lt;String, String&gt; tableRef){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 458         try{</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 459             //父一级的where 条件中如果只和临时查询相关的条件都截取进来</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 460             Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 461             List&lt;SqlBasicCall&gt; extractCondition = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 462 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 463             TableUtils.getFromTableInfo(node, fromTableNameSet);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 464             checkAndRemoveWhereCondition(fromTableNameSet, parentWhere, extractCondition);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 465 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 466             if(node.getKind() == JOIN){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 467                 checkAndReplaceJoinCondition(((SqlJoin)node).getCondition(), tableRef);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 468             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 469 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 470             Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tableRef);"> 470             Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tabl🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 471             Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSet);"> 471             Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTa🔵</abbr></span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 472             String extractSelectFieldStr = buildSelectNode(extractSelectField, fieldFromJoinCondition);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 473             String extractConditionStr = buildCondition(extractCondition);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 474 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 475             String tmpSelectSql = String.format(SELECT_TEMP_SQL,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 476                     extractSelectFieldStr,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 477                     node.toString(),</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 478                     extractConditionStr);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 479 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 480             SqlParser sqlParser = SqlParser.create(tmpSelectSql, CalciteConfig.MYSQL_LEX_CONFIG);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 481             SqlNode sqlNode = sqlParser.parseStmt();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 482             SqlBasicCall sqlBasicCall = buildAsSqlNode(tableAlias, sqlNode);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 483             queueInfo.offer(sqlBasicCall);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 484 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 485             System.out.println(&quot;-------build temporary query-----------&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 486             System.out.println(tmpSelectSql);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 487             System.out.println(&quot;---------------------------------------&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 488         }catch (Exception e){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 489             e.printStackTrace();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 490             throw new RuntimeException(e);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 491         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 492     }</span>
 493 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 494 private void extractTemporaryQuery(SqlNode node, String tableAlias, SqlBasicCall parentWhere,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 495                                        SqlNodeList parentSelectList, Queue&lt;Object&gt; queueInfo,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 496                                        Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 497                                        Map&lt;String, String&gt; tableRef){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 498         try{</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 499             //父一级的where 条件中如果只和临时查询相关的条件都截取进来</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 500             Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 501             List&lt;SqlBasicCall&gt; extractCondition = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 502 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 503             TableUtils.getFromTableInfo(node, fromTableNameSet);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 504             checkAndRemoveWhereCondition(fromTableNameSet, parentWhere, extractCondition);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 505 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 506             if(node.getKind() == JOIN){</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 507                 checkAndReplaceJoinCondition(((SqlJoin)node).getCondition(), tableRef);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 508             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 509 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 510             Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tableRef);"> 510             Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tabl🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 511             Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSet);"> 511             Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTa🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 512             String extractSelectFieldStr = buildSelectNode(extractSelectField, fieldFromJoinCondition);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 513             String extractConditionStr = buildCondition(extractCondition);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 514 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 515             String tmpSelectSql = String.format(SELECT_TEMP_SQL,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 516                     extractSelectFieldStr,</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 517                     node.toString(),</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 518                     extractConditionStr);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 519 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 520             SqlParser sqlParser = SqlParser.create(tmpSelectSql, CalciteConfig.MYSQL_LEX_CONFIG);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 521             SqlNode sqlNode = sqlParser.parseStmt();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 522             SqlBasicCall sqlBasicCall = buildAsSqlNode(tableAlias, sqlNode);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 523             queueInfo.offer(sqlBasicCall);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 524 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 525             Log.info(&quot;-------build temporary query-----------\n{}&quot;, tmpSelectSql);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 526             Log.info(&quot;---------------------------------------&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 527         } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 528             Log.error(&quot;&quot;, e);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 529             throw new RuntimeException(e);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 530         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 531     }</span>
 532 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 533 
 534 
 535     /**
 536      * 抽取上层需用使用到的字段
 537      * @param parentSelectList
 538      * @param fromTableNameSet
 539      * @return
 540      */
 541     private Set&lt;String&gt; extractSelectFields(SqlNodeList parentSelectList,
 542                                             Set&lt;String&gt; fromTableNameSet,
 543                                             Map&lt;String, String&gt; tableRef){
 544         Set&lt;String&gt; extractFieldList = Sets.newHashSet();
 545         for(SqlNode selectNode : parentSelectList.getList()){
 546             extractSelectField(selectNode, extractFieldList, fromTableNameSet, tableRef);
 547         }
 548 
 549         return extractFieldList;
 550     }
 551 
 552     private Set&lt;String&gt; extractSelectFieldFromJoinCondition(Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,
 553                                                             Set&lt;String&gt; fromTableNameSet,
 554                                                             Map&lt;String, String&gt; tableRef){
 555         Set&lt;String&gt; extractFieldList = Sets.newHashSet();
 556         for(Tuple2&lt;String, String&gt; field : joinFieldSet){
 557             if(fromTableNameSet.contains(field.f0)){
 558                 extractFieldList.add(field.f0 + &quot;.&quot; + field.f1);
 559             }
 560 
 561             if(tableRef.containsKey(field.f0)){
 562                 if(fromTableNameSet.contains(tableRef.get(field.f0))){
 563                     extractFieldList.add(tableRef.get(field.f0) + &quot;.&quot; + field.f1);
 564                 }
 565             }
 566         }
 567 
 568         return extractFieldList;
 569     }
 570 
 571     private Set&lt;String&gt; extractFieldFromGroupByList(SqlNodeList parentGroupByList,
 572                                                     Set&lt;String&gt; fromTableNameSet,
 573                                                     Map&lt;String, String&gt; tableRef){
 574 
 575         if(parentGroupByList == null){
 576             return Sets.newHashSet();
 577         }
 578 
 579         Set&lt;String&gt; extractFieldList = Sets.newHashSet();
 580         for(SqlNode selectNode : parentGroupByList.getList()){
 581             extractSelectField(selectNode, extractFieldList, fromTableNameSet, tableRef);
 582         }
 583 
 584         return extractFieldList;
 585     }
 586 
 587     /**
 588      * 从join的条件中获取字段信息
 589      * @param condition
 590      * @param joinFieldSet
 591      */
 592     private void extractJoinField(SqlNode condition, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet){
 593         if (null == condition || condition.getKind() == LITERAL) {
 594             return;
 595         }
 596 
 597         SqlKind joinKind = condition.getKind();
 598         if( joinKind == AND || joinKind == EQUALS ){
 599             extractJoinField(((SqlBasicCall)condition).operands[0], joinFieldSet);
 600             extractJoinField(((SqlBasicCall)condition).operands[1], joinFieldSet);
 601         }else{
<abbr title=" 602             Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 602             Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must b🔵</abbr>
<abbr title=" 603             Tuple2&lt;String, String&gt; tuple2 = Tuple2.of(((SqlIdentifier)condition).names.get(0), ((SqlIdentifier)condition).names.get(1));"> 603             Tuple2&lt;String, String&gt; tuple2 = Tuple2.of(((SqlIdentifier)condition).names.get(0), ((SqlIdent🔵</abbr>
 604             joinFieldSet.add(tuple2);
 605         }
 606     }
 607 
 608 
 609     private void extractSelectField(SqlNode selectNode,
 610                                     Set&lt;String&gt; extractFieldSet,
 611                                     Set&lt;String&gt; fromTableNameSet,
 612                                     Map&lt;String, String&gt; tableRef){
 613         if (selectNode.getKind() == AS) {
 614             SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 615             extractSelectField(leftNode, extractFieldSet, fromTableNameSet, tableRef);
 616 
 617         }else if(selectNode.getKind() == IDENTIFIER) {
 618             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 619 
 620             if(sqlIdentifier.names.size() == 1){
 621                 return;
 622             }
 623 
 624             String tableName = sqlIdentifier.names.get(0);
 625             //TODO
 626             if(fromTableNameSet.contains(tableName)){
 627                 extractFieldSet.add(sqlIdentifier.toString());
 628             } else if(fromTableNameSet.contains(tableRef.get(tableName))){
 629                 //TODO extractFieldSet.add(sqlIdentifier.setName(0, tableRef.get(tableName)).toString());
 630             }
 631 
 632         }else if(  AGGREGATE.contains(selectNode.getKind())
 633                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 634                 || COMPARISON.contains(selectNode.getKind())
 635                 || selectNode.getKind() == OTHER_FUNCTION
 636                 || selectNode.getKind() == DIVIDE
 637                 || selectNode.getKind() == CAST
 638                 || selectNode.getKind() == TRIM
 639                 || selectNode.getKind() == TIMES
 640                 || selectNode.getKind() == PLUS
 641                 || selectNode.getKind() == NOT_IN
 642                 || selectNode.getKind() == OR
 643                 || selectNode.getKind() == AND
 644                 || selectNode.getKind() == MINUS
 645                 || selectNode.getKind() == TUMBLE
 646                 || selectNode.getKind() == TUMBLE_START
 647                 || selectNode.getKind() == TUMBLE_END
 648                 || selectNode.getKind() == SESSION
 649                 || selectNode.getKind() == SESSION_START
 650                 || selectNode.getKind() == SESSION_END
 651                 || selectNode.getKind() == HOP
 652                 || selectNode.getKind() == HOP_START
 653                 || selectNode.getKind() == HOP_END
 654                 || selectNode.getKind() == BETWEEN
 655                 || selectNode.getKind() == IS_NULL
 656                 || selectNode.getKind() == IS_NOT_NULL
 657                 || selectNode.getKind() == CONTAINS
 658                 || selectNode.getKind() == TIMESTAMP_ADD
 659                 || selectNode.getKind() == TIMESTAMP_DIFF
 660                 || selectNode.getKind() == LIKE
 661 
 662         ){
 663             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 664             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 665                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 666                 if(sqlNode instanceof SqlLiteral){
 667                     continue;
 668                 }
 669 
 670                 if(sqlNode instanceof SqlDataTypeSpec){
 671                     continue;
 672                 }
 673 
 674                 extractSelectField(sqlNode, extractFieldSet, fromTableNameSet, tableRef);
 675             }
 676 
 677         }else if(selectNode.getKind() == CASE){
 678             SqlCase sqlCase = (SqlCase) selectNode;
 679             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 680             SqlNodeList thenOperands = sqlCase.getThenOperands();
 681             SqlNode elseNode = sqlCase.getElseOperand();
 682 
 683             for(int i=0; i&lt;whenOperands.size(); i++){
 684                 SqlNode oneOperand = whenOperands.get(i);
 685                 extractSelectField(oneOperand, extractFieldSet, fromTableNameSet, tableRef);
 686             }
 687 
 688             for(int i=0; i&lt;thenOperands.size(); i++){
 689                 SqlNode oneOperand = thenOperands.get(i);
 690                 extractSelectField(oneOperand, extractFieldSet, fromTableNameSet, tableRef);
 691             }
 692 
 693             extractSelectField(elseNode, extractFieldSet, fromTableNameSet, tableRef);
 694         }else {
 695             //do nothing
 696         }
 697     }
 698 
 699 
<abbr title=" 700     private Tuple2&lt;String, String&gt; parseRightNode(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo,"> 700     private Tuple2&lt;String, String&gt; parseRightNode(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object🔵</abbr>
<abbr title=" 701                                                   SqlNode parentWhere, SqlNodeList selectList, SqlNodeList parentGroupByList) {"> 701                                                   SqlNode parentWhere, SqlNodeList selectList, SqlNodeLis🔵</abbr>
 702         Tuple2&lt;String, String&gt; tabName = new Tuple2&lt;&gt;(&quot;&quot;, &quot;&quot;);
 703         if(sqlNode.getKind() == IDENTIFIER){
 704             tabName.f0 = sqlNode.toString();
 705         }else{
<abbr title=" 706             AliasInfo aliasInfo = (AliasInfo)sideSQLParser.parseSql(sqlNode, sideTableSet, queueInfo, parentWhere, selectList, parentGroupByList);"> 706             AliasInfo aliasInfo = (AliasInfo)sideSQLParser.parseSql(sqlNode, sideTableSet, queueInfo, par🔵</abbr>
 707             tabName.f0 = aliasInfo.getName();
 708             tabName.f1 = aliasInfo.getAlias();
 709         }
 710         return tabName;
 711     }
 712 
 713     private Tuple2&lt;String, String&gt; parseLeftNode(SqlNode sqlNode){
 714         Tuple2&lt;String, String&gt; tabName = new Tuple2&lt;&gt;(&quot;&quot;, &quot;&quot;);
 715         if(sqlNode.getKind() == IDENTIFIER){
 716             tabName.f0 = sqlNode.toString();
 717             tabName.f1 = sqlNode.toString();
 718         }else if (sqlNode.getKind() == AS){
 719             SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 720             SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 721 
 722             tabName.f0 = info.toString();
 723             tabName.f1 = alias.toString();
 724         }else {
 725             throw new RuntimeException(&quot;&quot;);
 726         }
 727 
 728         return tabName;
 729     }
 730 
 731     public String buildCondition(List&lt;SqlBasicCall&gt; conditionList){
 732         if(CollectionUtils.isEmpty(conditionList)){
 733             return &quot;&quot;;
 734         }
 735 
 736         return &quot; where &quot; + StringUtils.join(conditionList, &quot; AND &quot;);
 737     }
 738 
 739     /**
 740      * 构建抽取表的查询字段信息
 741      * 包括去除重复字段，名称相同的取别名
 742      * @param extractSelectField
 743      * @param joinFieldSet
 744      * @return
 745      */
 746     public Set&lt;String&gt; buildSelectNode(Set&lt;String&gt; extractSelectField, Set&lt;String&gt; joinFieldSet){
 747         if(CollectionUtils.isEmpty(extractSelectField)){
 748             throw new RuntimeException(&quot;no field is used&quot;);
 749         }
 750 
 751         Sets.SetView&lt;String&gt; view = Sets.union(extractSelectField, joinFieldSet);
 752         Set&lt;String&gt; newFieldSet = Sets.newHashSet();
 753         //为相同的列取别名
 754         HashBiMap&lt;String, String&gt; refFieldMap = HashBiMap.create();
 755         for(String field : view){
 756             String[] fieldInfo = StringUtils.split(field, &#x27;.&#x27;);
 757             String aliasName = fieldInfo[1];
 758             StringBuilder stringBuilder = new StringBuilder();
 759             stringBuilder.append(field);
 760             if(refFieldMap.inverse().get(aliasName) != null){
 761                 aliasName = ParseUtils.dealDuplicateFieldName(refFieldMap, aliasName);
 762                 stringBuilder.append(&quot; as &quot;)
 763                         .append(aliasName);
 764             }
 765 
 766             refFieldMap.put(field, aliasName);
 767 
 768             newFieldSet.add(stringBuilder.toString());
 769         }
 770 
 771         return newFieldSet;
 772     }
 773 
 774     private boolean checkIsSideTable(String tableName, Set&lt;String&gt; sideTableList){
 775         if(sideTableList.contains(tableName)){
 776             return true;
 777         }
 778         return false;
 779     }
 780 
 781     private SqlBasicCall buildAsSqlNode(String internalTableName, SqlNode newSource) {
 782         SqlOperator operator = new SqlAsOperator();
 783         SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 784         SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(internalTableName, null, sqlParserPos);
 785         SqlNode[] sqlNodes = new SqlNode[2];
 786         sqlNodes[0] = newSource;
 787         sqlNodes[1] = sqlIdentifierAlias;
 788         return new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 789     }
 790 
 791     /**
 792      * 获取where中和指定表有关联的字段
 793      * @param fromTableNameSet
 794      * @param parentWhere
 795      * @param extractCondition
 796      */
<abbr title=" 797     private void extractWhereCondition(Set&lt;String&gt; fromTableNameSet, SqlBasicCall parentWhere, Set&lt;String&gt; extractCondition){"> 797     private void extractWhereCondition(Set&lt;String&gt; fromTableNameSet, SqlBasicCall parentWhere, Set&lt;String🔵</abbr>
 798 
 799         if(parentWhere == null){
 800             return;
 801         }
 802 
 803         SqlKind kind = parentWhere.getKind();
 804         if(kind == AND){
<abbr title=" 805             extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[0], extractCondition);"> 805             extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[0], extractC🔵</abbr>
<abbr title=" 806             extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[1], extractCondition);"> 806             extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[1], extractC🔵</abbr>
 807         } else {
 808 
 809             Set&lt;String&gt; fieldInfos = Sets.newHashSet();
 810             TableUtils.getConditionRefTable(parentWhere, fieldInfos);
 811             fieldInfos.forEach(fieldInfo -&gt; {
 812                 String[] splitInfo = StringUtils.split(fieldInfo, &quot;.&quot;);
 813                 if(splitInfo.length == 2 &amp;&amp; fromTableNameSet.contains(splitInfo[0])){
 814                     extractCondition.add(fieldInfo);
 815                 }
 816             });
 817 
 818         }
 819 
 820 
 821     }
 822 
 823 
 824     /**
 825      * 检查关联的where 条件中的判断是否可以下移到新构建的子查询
 826      * @param fromTableNameSet
 827      * @param parentWhere
 828      * @param extractCondition
 829      * @return
 830      */
 831     private boolean checkAndRemoveWhereCondition(Set&lt;String&gt; fromTableNameSet,
 832                                                  SqlBasicCall parentWhere,
 833                                                  List&lt;SqlBasicCall&gt; extractCondition){
 834         if(parentWhere == null){
 835             return false;
 836         }
 837 
 838         SqlKind kind = parentWhere.getKind();
 839         if(kind == AND){
<abbr title=" 840             boolean removeLeft = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[0], extractCondition);"> 840             boolean removeLeft = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWher🔵</abbr>
<abbr title=" 841             boolean removeRight = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[1], extractCondition);"> 841             boolean removeRight = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhe🔵</abbr>
 842             //DO remove
 843             if(removeLeft){
 844                 extractCondition.add(removeWhereConditionNode(parentWhere, 0));
 845             }
 846 
 847             if(removeRight){
 848                 extractCondition.add(removeWhereConditionNode(parentWhere, 1));
 849             }
 850 
 851             return false;
 852         } else {
 853             //条件表达式，如果该条件关联的表都是指定的表则移除
 854             Set&lt;String&gt; fieldInfos = Sets.newHashSet();
 855             TableUtils.getConditionRefTable(parentWhere, fieldInfos);
 856             Set&lt;String&gt; conditionRefTableNameSet = Sets.newHashSet();
 857 
 858             fieldInfos.forEach(fieldInfo -&gt; {
 859                 String[] splitInfo = StringUtils.split(fieldInfo, &quot;.&quot;);
 860                 if(splitInfo.length == 2){
 861                     conditionRefTableNameSet.add(splitInfo[0]);
 862                 }
 863             });
 864 
 865 
 866             if(fromTableNameSet.containsAll(conditionRefTableNameSet)){
 867                 return true;
 868             }
 869 
 870             return false;
 871         }
 872     }
 873 
 874     /**
 875      * 抽取where 条件中指定的条件
 876      * @param parentWhere
 877      * @param index
 878      * @return
 879      */
 880     public SqlBasicCall removeWhereConditionNode(SqlBasicCall parentWhere, int index){
 881         SqlBasicCall oldCondition = (SqlBasicCall) parentWhere.getOperands()[index];
 882         parentWhere.setOperand(index, buildEmptyCondition());
 883         return oldCondition;
 884     }
 885 
 886     /**
 887      * 构建 1=1的 where 条件
 888      * @return
 889      */
 890     public SqlBasicCall buildEmptyCondition(){
 891         SqlBinaryOperator equalsOperators = SqlStdOperatorTable.EQUALS;
 892         SqlNode[] operands = new SqlNode[2];
 893         operands[0] = SqlLiteral.createExactNumeric(&quot;1&quot;, SqlParserPos.ZERO);
 894         operands[1] = SqlLiteral.createExactNumeric(&quot;1&quot;, SqlParserPos.ZERO);
 895 
 896         return new SqlBasicCall(equalsOperators, operands, SqlParserPos.ZERO);
 897     }
 898 
 899     /**
 900      * 替换join 条件中的表名称
 901      * @param node
 902      * @param tableMap 表名的关联关系
 903      */
 904     private SqlIdentifier checkAndReplaceJoinCondition(SqlNode node, Map&lt;String, String&gt; tableMap){
 905 
 906         SqlKind joinKind = node.getKind();
 907         if( joinKind == AND || joinKind == EQUALS ){
<abbr title=" 908             SqlIdentifier leftNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[0], tableMap);"> 908             SqlIdentifier leftNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[0], table🔵</abbr>
<abbr title=" 909             SqlIdentifier rightNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[1], tableMap);"> 909             SqlIdentifier rightNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[1], tabl🔵</abbr>
 910 
 911             if(leftNode != null){
 912                 ((SqlBasicCall)node).setOperand(0, leftNode);
 913             }
 914 
 915             if(rightNode != null){
 916                 ((SqlBasicCall)node).setOperand(1, leftNode);
 917             }
 918 
 919             return null;
 920         } else {
 921             //replace table
<abbr title=" 922             Preconditions.checkState(((SqlIdentifier)node).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 922             Preconditions.checkState(((SqlIdentifier)node).names.size() == 2, &quot;join condition must be for🔵</abbr>
 923             String tbName = ((SqlIdentifier) node).names.get(0);
 924             if(tableMap.containsKey(tbName)){
 925                 tbName = tableMap.get(tbName);
 926                 return ((SqlIdentifier) node).setName(0, tbName);
 927             }
 928 
 929             return null;
 930         }
 931     }
 932 
 933     /**
 934      * 解析出临时中间表的属性列和源表之间的关系
 935      * @param fieldSet
 936      * @param newTableAliasName
 937      */
<abbr title=" 938     public Map&lt;String, String&gt; buildTmpTableFieldRefOriField(Set&lt;String&gt; fieldSet, String newTableAliasName){"> 938     public Map&lt;String, String&gt; buildTmpTableFieldRefOriField(Set&lt;String&gt; fieldSet, String newTableAliasNa🔵</abbr>
 939         Map&lt;String, String&gt; refInfo = Maps.newConcurrentMap();
 940         for(String field : fieldSet){
 941             String[] fields = StringUtils.splitByWholeSeparator(field, &quot;as&quot;);
 942             String oldKey = field;
 943             String[] oldFieldInfo = StringUtils.splitByWholeSeparator(fields[0], &quot;.&quot;);
 944             String oldFieldName = oldFieldInfo.length == 2 ? oldFieldInfo[1] : oldFieldInfo[0];
 945             String newKey = fields.length == 2 ? newTableAliasName + &quot;.&quot; + fields[1] :
 946                     newTableAliasName + &quot;.&quot; + oldFieldName;
 947             refInfo.put(oldKey, newKey);
 948         }
 949 
 950         return refInfo;
 951     }
 952 
 953 
 954 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side;
  19 
  20 import com.dtstack.flink.sql.parser.FlinkPlanner;
  21 import com.dtstack.flink.sql.util.ParseUtils;
  22 import com.dtstack.flink.sql.util.TableUtils;
  23 import com.esotericsoftware.minlog.Log;
  24 import com.google.common.base.Preconditions;
  25 import com.google.common.collect.*;
  26 import java.util.List;
  27 import java.util.Map;
  28 import java.util.Queue;
  29 import java.util.Set;
  30 import org.apache.calcite.sql.JoinType;
  31 import org.apache.calcite.sql.SqlAsOperator;
  32 import org.apache.calcite.sql.SqlBasicCall;
  33 import org.apache.calcite.sql.SqlBinaryOperator;
  34 import org.apache.calcite.sql.SqlDataTypeSpec;
  35 import org.apache.calcite.sql.SqlIdentifier;
  36 import org.apache.calcite.sql.SqlJoin;
  37 import org.apache.calcite.sql.SqlKind;
  38 import org.apache.calcite.sql.SqlLiteral;
  39 import org.apache.calcite.sql.SqlNode;
  40 import org.apache.calcite.sql.SqlNodeList;
  41 import org.apache.calcite.sql.SqlOperator;
  42 import org.apache.calcite.sql.fun.SqlCase;
  43 import org.apache.calcite.sql.fun.SqlStdOperatorTable;
  44 import org.apache.calcite.sql.parser.SqlParserPos;
  45 import org.apache.commons.collections.CollectionUtils;
  46 import org.apache.commons.lang3.StringUtils;
  47 import org.apache.flink.api.java.tuple.Tuple2;
  48 import org.apache.flink.table.calcite.FlinkPlannerImpl;
  49 import static org.apache.calcite.sql.SqlKind.*;
  50 
  51 
  52 /**
  53  * 处理join 节点
  54  * 1:如果包含维表节点替换为临时查询
  55  * Date: 2020/2/27
  56  * Company: www.dtstack.com
  57  * @author xuchao
  58  */
  59 public class JoinNodeDealer {
  60     //用来构建临时的中间查询
  61     //用来构建临时的中间查询
  62     private static final String SELECT_TEMP_SQL = &quot;select %s from %s %s&quot;;
  63 
  64     private SideSQLParser sideSQLParser;
  65 
  66     public JoinNodeDealer(SideSQLParser sideSQLParser) {
  67         this.sideSQLParser = sideSQLParser;
  68     }
  69 
  70     /**
  71      * 解析 join 操作
  72      * @param joinNode
  73      * @param sideTableSet 标明哪些表名是维表
  74      * @param queueInfo
  75      * @param parentWhere join 关联的最上层的where 节点
  76      * @param parentSelectList join 关联的最上层的select 节点
  77      * @param joinFieldSet
  78      * @param tableRef 存储构建临时表查询后源表和新表之间的关联关系
  79      * @return
  80      */
<abbr title="  81     public JoinInfo dealJoinNode(SqlJoin joinNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo, SqlNode parentWhere, SqlNodeList parentSelectList, SqlNodeList parentGroupByList, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet, Map&lt;String, String&gt; tableRef, Map&lt;String, String&gt; fieldRef) {">  81     public JoinInfo dealJoinNode(SqlJoin joinNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo, Sql🔵</abbr>
  82         SqlNode leftNode = joinNode.getLeft();
  83         SqlNode rightNode = joinNode.getRight();
  84         JoinType joinType = joinNode.getJoinType();
  85         String leftTbName = &quot;&quot;;
  86         String leftTbAlias = &quot;&quot;;
  87         String rightTableName = &quot;&quot;;
  88         String rightTableAlias = &quot;&quot;;
  89         //抽取join中的的条件
  90         extractJoinField(joinNode.getCondition(), joinFieldSet);
  91         if (leftNode.getKind() == JOIN) {
  92             //处理连续join
<abbr title="  93             dealNestJoin(joinNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRef);">  93             dealNestJoin(joinNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByL🔵</abbr>
  94             leftNode = joinNode.getLeft();
  95         }
  96         if (leftNode.getKind() == AS) {
<abbr title="  97             AliasInfo aliasInfo = ((AliasInfo) (sideSQLParser.parseSql(leftNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList)));">  97             AliasInfo aliasInfo = ((AliasInfo) (sideSQLParser.parseSql(leftNode, sideTableSet, queueInfo,🔵</abbr>
  98             leftTbName = aliasInfo.getName();
  99             leftTbAlias = aliasInfo.getAlias();
 100         } else if (leftNode.getKind() == IDENTIFIER) {
 101             leftTbName = leftNode.toString();
 102             leftTbAlias = leftTbName;
 103         }
 104         boolean leftIsSide = checkIsSideTable(leftTbName, sideTableSet);
 105         Preconditions.checkState(!leftIsSide, &quot;side-table must be at the right of join operator&quot;);
<abbr title=" 106         Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 106         Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo🔵</abbr>
 107         rightTableName = rightTableNameAndAlias.f0;
 108         rightTableAlias = rightTableNameAndAlias.f1;
 109         boolean rightIsSide = checkIsSideTable(rightTableName, sideTableSet);
 110         if (rightIsSide &amp;&amp; (joinType == JoinType.RIGHT)) {
<abbr title=" 111             throw new RuntimeException(&quot;side join not support join type of right[current support inner join and left join]&quot;);"> 111             throw new RuntimeException(&quot;side join not support join type of right[current support inner jo🔵</abbr>
 112         }
 113         JoinInfo tableInfo = new JoinInfo();
 114         tableInfo.setLeftTableName(leftTbName);
 115         tableInfo.setRightTableName(rightTableName);
 116         leftTbAlias = (StringUtils.isEmpty(leftTbAlias)) ? leftTbName : leftTbAlias;
 117         rightTableAlias = (StringUtils.isEmpty(rightTableAlias)) ? rightTableName : rightTableAlias;
 118         tableInfo.setLeftTableAlias(leftTbAlias);
 119         tableInfo.setRightTableAlias(rightTableAlias);
 120         tableInfo.setRightIsSideTable(rightIsSide);
 121         tableInfo.setLeftNode(leftNode);
 122         tableInfo.setRightNode(rightNode);
 123         tableInfo.setJoinType(joinType);
 124         tableInfo.setCondition(joinNode.getCondition());
 125         TableUtils.replaceJoinFieldRefTableName(joinNode.getCondition(), fieldRef);
 126         //extract 需要查询的字段信息
 127         if (rightIsSide) {
<abbr title=" 128             extractJoinNeedSelectField(leftNode, rightNode, parentWhere, parentSelectList, parentGroupByList, tableRef, joinFieldSet, fieldRef, tableInfo);"> 128             extractJoinNeedSelectField(leftNode, rightNode, parentWhere, parentSelectList, parentGroupByL🔵</abbr>
 129         }
 130         if (tableInfo.getLeftNode().getKind() != AS) {
 131             return tableInfo;
 132         }
 133         SqlKind asNodeFirstKind = ((SqlBasicCall) (tableInfo.getLeftNode())).operands[0].getKind();
 134         if (asNodeFirstKind == SELECT) {
 135             queueInfo.offer(tableInfo.getLeftNode());
 136             tableInfo.setLeftNode(((SqlBasicCall) (tableInfo.getLeftNode())).operands[1]);
 137         }
 138         return tableInfo;
 139     }
 140 
 141     /**
 142      * 获取join 之后需要查询的字段信息
 143      */
<abbr title=" 144     public void extractJoinNeedSelectField(SqlNode leftNode, SqlNode rightNode, SqlNode parentWhere, SqlNodeList parentSelectList, SqlNodeList parentGroupByList, Map&lt;String, String&gt; tableRef, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet, Map&lt;String, String&gt; fieldRef, JoinInfo tableInfo) {"> 144     public void extractJoinNeedSelectField(SqlNode leftNode, SqlNode rightNode, SqlNode parentWhere, SqlN🔵</abbr>
<abbr title=" 145         Set&lt;String&gt; extractSelectField = extractField(leftNode, parentWhere, parentSelectList, parentGroupByList, tableRef, joinFieldSet);"> 145         Set&lt;String&gt; extractSelectField = extractField(leftNode, parentWhere, parentSelectList, parentGrou🔵</abbr>
<abbr title=" 146         Set&lt;String&gt; rightExtractSelectField = extractField(rightNode, parentWhere, parentSelectList, parentGroupByList, tableRef, joinFieldSet);"> 146         Set&lt;String&gt; rightExtractSelectField = extractField(rightNode, parentWhere, parentSelectList, pare🔵</abbr>
 147         // 重命名right 中和 left 重名的
 148         Map&lt;String, String&gt; leftTbSelectField = Maps.newHashMap();
 149         Map&lt;String, String&gt; rightTbSelectField = Maps.newHashMap();
 150         String newTableName = tableInfo.getNewTableAlias();
 151         for (String tmpField : extractSelectField) {
 152             String[] tmpFieldSplit = StringUtils.split(tmpField, &#x27;.&#x27;);
 153             leftTbSelectField.put(tmpFieldSplit[1], tmpFieldSplit[1]);
 154             fieldRef.put(tmpField, TableUtils.buildTableField(newTableName, tmpFieldSplit[1]));
 155         }
 156         for (String tmpField : rightExtractSelectField) {
 157             String[] tmpFieldSplit = StringUtils.split(tmpField, &#x27;.&#x27;);
 158             String originalFieldName = tmpFieldSplit[1];
 159             String targetFieldName = originalFieldName;
 160             if (leftTbSelectField.containsKey(originalFieldName)) {
<abbr title=" 161                 targetFieldName = ParseUtils.dealDuplicateFieldName(leftTbSelectField, originalFieldName);"> 161                 targetFieldName = ParseUtils.dealDuplicateFieldName(leftTbSelectField, originalFieldName)🔵</abbr>
 162             }
 163             rightTbSelectField.put(originalFieldName, targetFieldName);
 164             fieldRef.put(tmpField, TableUtils.buildTableField(newTableName, targetFieldName));
 165         }
 166         tableInfo.setLeftSelectFieldInfo(leftTbSelectField);
 167         tableInfo.setRightSelectFieldInfo(rightTbSelectField);
 168     }
 169 
 170     /**
 171      * 指定的节点关联到的 select 中的字段和 where中的字段
 172      * @param sqlNode
 173      * @param parentWhere
 174      * @param parentSelectList
 175      * @param parentGroupByList
 176      * @param tableRef
 177      * @param joinFieldSet
 178      * @return
 179      */
<abbr title=" 180     public Set&lt;String&gt; extractField(SqlNode sqlNode, SqlNode parentWhere, SqlNodeList parentSelectList, SqlNodeList parentGroupByList, Map&lt;String, String&gt; tableRef, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet) {"> 180     public Set&lt;String&gt; extractField(SqlNode sqlNode, SqlNode parentWhere, SqlNodeList parentSelectList, S🔵</abbr>
 181         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 182         TableUtils.getFromTableInfo(sqlNode, fromTableNameSet);
 183         Set&lt;String&gt; extractCondition = Sets.newHashSet();
 184         extractWhereCondition(fromTableNameSet, ((SqlBasicCall) (parentWhere)), extractCondition);
<abbr title=" 185         Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tableRef);"> 185         Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tableRef🔵</abbr>
<abbr title=" 186         Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSet, tableRef);"> 186         Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableN🔵</abbr>
<abbr title=" 187         Set&lt;String&gt; extractGroupByField = extractFieldFromGroupByList(parentGroupByList, fromTableNameSet, tableRef);"> 187         Set&lt;String&gt; extractGroupByField = extractFieldFromGroupByList(parentGroupByList, fromTableNameSet🔵</abbr>
 188         extractSelectField.addAll(extractCondition);
 189         extractSelectField.addAll(fieldFromJoinCondition);
 190         extractSelectField.addAll(extractGroupByField);
 191         return extractSelectField;
 192     }
 193 
 194     /**
 195      * 处理多层join
 196      * 判断左节点是否需要创建临时查询
 197      * （1）右节点是维表
 198      * （2）左节点不是 as 节点
 199      */
<abbr title=" 200     private JoinInfo dealNestJoin(SqlJoin joinNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo, SqlNode parentWhere, SqlNodeList parentSelectList, SqlNodeList parentGroupByList, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet, Map&lt;String, String&gt; tableRef, Map&lt;String, String&gt; fieldRef) {"> 200     private JoinInfo dealNestJoin(SqlJoin joinNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo, Sq🔵</abbr>
 201         SqlJoin leftJoinNode = ((SqlJoin) (joinNode.getLeft()));
 202         SqlNode parentRightJoinNode = joinNode.getRight();
 203         SqlNode rightNode = leftJoinNode.getRight();
<abbr title=" 204         Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 204         Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo🔵</abbr>
<abbr title=" 205         Tuple2&lt;String, String&gt; parentRightJoinInfo = parseRightNode(parentRightJoinNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 205         Tuple2&lt;String, String&gt; parentRightJoinInfo = parseRightNode(parentRightJoinNode, sideTableSet, qu🔵</abbr>
 206         boolean parentRightIsSide = checkIsSideTable(parentRightJoinInfo.f0, sideTableSet);
<abbr title=" 207         JoinInfo joinInfo = dealJoinNode(leftJoinNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRef);"> 207         JoinInfo joinInfo = dealJoinNode(leftJoinNode, sideTableSet, queueInfo, parentWhere, parentSelect🔵</abbr>
 208         String rightTableName = rightTableNameAndAlias.f0;
 209         boolean rightIsSide = checkIsSideTable(rightTableName, sideTableSet);
 210         SqlBasicCall buildAs = TableUtils.buildAsNodeByJoinInfo(joinInfo, null, null);
 211         if (rightIsSide) {
<abbr title=" 212             addSideInfoToExeQueue(queueInfo, joinInfo, joinNode, parentSelectList, parentGroupByList, parentWhere, tableRef);"> 212             addSideInfoToExeQueue(queueInfo, joinInfo, joinNode, parentSelectList, parentGroupByList, par🔵</abbr>
 213         }
 214         SqlNode newLeftNode = joinNode.getLeft();
 215         if ((newLeftNode.getKind() != AS) &amp;&amp; parentRightIsSide) {
 216             String leftTbAlias = buildAs.getOperands()[1].toString();
<abbr title=" 217             extractTemporaryQuery(newLeftNode, leftTbAlias, ((SqlBasicCall) (parentWhere)), parentSelectList, queueInfo, joinFieldSet, tableRef, fieldRef);"> 217             extractTemporaryQuery(newLeftNode, leftTbAlias, ((SqlBasicCall) (parentWhere)), parentSelectL🔵</abbr>
 218             // 替换leftNode 为新的查询
 219             joinNode.setLeft(buildAs);
<abbr title=" 220             replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByList, parentWhere);"> 220             replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByLi🔵</abbr>
 221         }
 222         return joinInfo;
 223     }
 224 
 225     /**
 226      * 右边表是维表需要重新构建左表的临时查询
 227      * 并将joinInfo 添加到执行队列里面
 228      * @param queueInfo
 229      * @param joinInfo
 230      * @param joinNode
 231      * @param parentSelectList
 232      * @param parentGroupByList
 233      * @param parentWhere
 234      * @param tableRef
 235      */
<abbr title=" 236     public void addSideInfoToExeQueue(Queue&lt;Object&gt; queueInfo, JoinInfo joinInfo, SqlJoin joinNode, SqlNodeList parentSelectList, SqlNodeList parentGroupByList, SqlNode parentWhere, Map&lt;String, String&gt; tableRef) {"> 236     public void addSideInfoToExeQueue(Queue&lt;Object&gt; queueInfo, JoinInfo joinInfo, SqlJoin joinNode, SqlNo🔵</abbr>
 237         //只处理维表
 238         if (!joinInfo.isRightIsSideTable()) {
 239             return;
 240         }
 241         SqlBasicCall buildAs = TableUtils.buildAsNodeByJoinInfo(joinInfo, null, null);
 242         SqlNode leftJoinNode = joinNode.getLeft();
 243         queueInfo.offer(joinInfo);
 244         // 替换左表为新的表名称
 245         joinNode.setLeft(buildAs);
<abbr title=" 246         replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByList, parentWhere);"> 246         replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByList, 🔵</abbr>
 247     }
 248 
 249     /**
 250      * 替换指定的查询和条件节点中的字段为新的字段
 251      * @param buildAs
 252      * @param leftJoinNode
 253      * @param tableRef
 254      * @param parentSelectList
 255      * @param parentGroupByList
 256      * @param parentWhere
 257      */
<abbr title=" 258     public void replaceSelectAndWhereField(SqlBasicCall buildAs, SqlNode leftJoinNode, Map&lt;String, String&gt; tableRef, SqlNodeList parentSelectList, SqlNodeList parentGroupByList, SqlNode parentWhere) {"> 258     public void replaceSelectAndWhereField(SqlBasicCall buildAs, SqlNode leftJoinNode, Map&lt;String, String🔵</abbr>
 259         String newLeftTableName = buildAs.getOperands()[1].toString();
 260         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 261         TableUtils.getFromTableInfo(leftJoinNode, fromTableNameSet);
 262         for (String tbTmp : fromTableNameSet) {
 263             tableRef.put(tbTmp, newLeftTableName);
 264         }
 265         // 替换select field 中的对应字段
 266         HashBiMap&lt;String, String&gt; fieldReplaceRef = HashBiMap.create();
 267         for (SqlNode sqlNode : parentSelectList.getList()) {
 268             for (String tbTmp : fromTableNameSet) {
 269                 TableUtils.replaceSelectFieldTable(sqlNode, tbTmp, newLeftTableName, fieldReplaceRef);
 270             }
 271         }
 272         //TODO 应该根据上面的查询字段的关联关系来替换
 273         //替换where 中的条件相关
 274         for (String tbTmp : fromTableNameSet) {
 275             TableUtils.replaceWhereCondition(parentWhere, tbTmp, newLeftTableName, fieldReplaceRef);
 276         }
 277         if (parentGroupByList != null) {
 278             for (SqlNode sqlNode : parentGroupByList.getList()) {
 279                 for (String tbTmp : fromTableNameSet) {
<abbr title=" 280                     TableUtils.replaceSelectFieldTable(sqlNode, tbTmp, newLeftTableName, fieldReplaceRef);"> 280                     TableUtils.replaceSelectFieldTable(sqlNode, tbTmp, newLeftTableName, fieldReplaceRef)🔵</abbr>
 281                 }
 282             }
 283         }
 284     }
 285 
 286     /**
 287      * 抽取出中间查询表
 288      * @param node
 289      * @param tableAlias
 290      * @param parentWhere
 291      * @param parentSelectList
 292      * @param queueInfo
 293      * @param joinFieldSet
 294      * @param tableRef
 295      * @return 源自段和新生成字段之间的映射关系
 296      */
<abbr title=" 297     private void extractTemporaryQuery(SqlNode node, String tableAlias, SqlBasicCall parentWhere, SqlNodeList parentSelectList, Queue&lt;Object&gt; queueInfo, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet, Map&lt;String, String&gt; tableRef, Map&lt;String, String&gt; fieldRef) {"> 297     private void extractTemporaryQuery(SqlNode node, String tableAlias, SqlBasicCall parentWhere, SqlNode🔵</abbr>
 298         try {
 299             //父一级的where 条件中如果只和临时查询相关的条件都截取进来
 300             Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 301             List&lt;SqlBasicCall&gt; extractCondition = Lists.newArrayList();
 302 
 303             TableUtils.getFromTableInfo(node, fromTableNameSet);
 304             checkAndRemoveWhereCondition(fromTableNameSet, parentWhere, extractCondition);
 305 
 306             if(node.getKind() == JOIN){
 307                 checkAndReplaceJoinCondition(((SqlJoin)node).getCondition(), tableRef);
 308             }
 309 
<abbr title=" 310             Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tableRef);"> 310             Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tabl🔵</abbr>
<abbr title=" 311             Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSet, tableRef);"> 311             Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTa🔵</abbr>
 312             Set&lt;String&gt; newFields = buildSelectNode(extractSelectField, fieldFromJoinCondition);
 313             String extractSelectFieldStr = StringUtils.join(newFields, &#x27;,&#x27;);
 314 
 315             Map&lt;String, String&gt; oldRefNewField = buildTmpTableFieldRefOriField(newFields, tableAlias);
 316             fieldRef.putAll(oldRefNewField);
 317 
 318             String extractConditionStr = buildCondition(extractCondition);
 319 
 320             String tmpSelectSql = String.format(SELECT_TEMP_SQL,
 321                     extractSelectFieldStr,
 322                     node.toString(),
 323                     extractConditionStr);
 324 
 325             FlinkPlannerImpl flinkPlanner = FlinkPlanner.getFlinkPlanner();
 326             SqlNode sqlNode = flinkPlanner.parse(tmpSelectSql);
 327 
 328             SqlBasicCall sqlBasicCall = buildAsSqlNode(tableAlias, sqlNode);
 329             queueInfo.offer(sqlBasicCall);
 330 
 331 
 332 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 333             //替换select中的表结构</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 334             HashBiMap&lt;String, String&gt; fieldReplaceRef = HashBiMap.create();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 335             for(SqlNode tmpSelect : parentSelectList.getList()){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 336                 for(String tbTmp : fromTableNameSet) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 337                     TableUtils.replaceSelectFieldTable(tmpSelect, tbTmp, tableAlias, fieldReplaceRef);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 338                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 339             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 340 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 341             //替换where 中的条件相关</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 342             for(String tbTmp : fromTableNameSet){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 343                 TableUtils.replaceWhereCondition(parentWhere, tbTmp, tableAlias, fieldReplaceRef);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 344             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 345 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 346             for(String tbTmp : fromTableNameSet){</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 347                 tableRef.put(tbTmp, tableAlias);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 348             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 349 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 350             System.out.println(&quot;-------build temporary query-----------&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 351             System.out.println(tmpSelectSql);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 352             System.out.println(&quot;---------------------------------------&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 353 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 354 </span>
 355 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 356 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 356 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 357 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 358 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 359             Log.info(&quot;-------build temporary query-----------\n{}&quot;, tmpSelectSql);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 360             Log.info(&quot;---------------------------------------&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 361 </span>
 362 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 363         } catch (java.lang.Exception e) {
 364             Log.error(&quot;&quot;, e);
 365             throw new RuntimeException(e);
 366         }
 367     }
 368 
 369     /**
 370      * 抽取上层需用使用到的字段
 371      *
 372      * @param parentSelectList
 373      *
 374      * @param fromTableNameSet
 375      *
 376      * @return
 377      */
<abbr title=" 378     private Set&lt;String&gt; extractSelectFields(SqlNodeList parentSelectList, Set&lt;String&gt; fromTableNameSet, Map&lt;String, String&gt; tableRef) {"> 378     private Set&lt;String&gt; extractSelectFields(SqlNodeList parentSelectList, Set&lt;String&gt; fromTableNameSet, M🔵</abbr>
 379         Set&lt;String&gt; extractFieldList = Sets.newHashSet();
 380         for (SqlNode selectNode : parentSelectList.getList()) {
 381             extractSelectField(selectNode, extractFieldList, fromTableNameSet, tableRef);
 382         }
 383         return extractFieldList;
 384     }
 385 
<abbr title=" 386     private Set&lt;String&gt; extractSelectFieldFromJoinCondition(Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet, Set&lt;String&gt; fromTableNameSet, Map&lt;String, String&gt; tableRef) {"> 386     private Set&lt;String&gt; extractSelectFieldFromJoinCondition(Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet, Set🔵</abbr>
 387         Set&lt;String&gt; extractFieldList = Sets.newHashSet();
 388         for (Tuple2&lt;String, String&gt; field : joinFieldSet) {
 389             if (fromTableNameSet.contains(field.f0)) {
 390                 extractFieldList.add((field.f0 + &quot;.&quot;) + field.f1);
 391             }
 392             if (tableRef.containsKey(field.f0)) {
 393                 if (fromTableNameSet.contains(tableRef.get(field.f0))) {
 394                     extractFieldList.add((tableRef.get(field.f0) + &quot;.&quot;) + field.f1);
 395                 }
 396             }
 397         }
 398         return extractFieldList;
 399     }
 400 
 401     private Set&lt;String&gt; extractFieldFromGroupByList(SqlNodeList parentGroupByList,
 402                                                     Set&lt;String&gt; fromTableNameSet,
 403                                                     Map&lt;String, String&gt; tableRef){
 404 
 405         if(parentGroupByList == null){
 406             return Sets.newHashSet();
 407         }
 408 
 409         Set&lt;String&gt; extractFieldList = Sets.newHashSet();
 410         for(SqlNode selectNode : parentGroupByList.getList()){
 411             extractSelectField(selectNode, extractFieldList, fromTableNameSet, tableRef);
 412         }
 413 
 414         return extractFieldList;
 415     }
 416 
 417     /**
 418      * 从join的条件中获取字段信息
 419      * @param condition
 420      * @param joinFieldSet
 421      */
 422     private void extractJoinField(SqlNode condition, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet) {
 423         if ((null == condition) || (condition.getKind() == LITERAL)) {
 424             return;
 425         }
 426         SqlKind joinKind = condition.getKind();
 427         if ((joinKind == AND) || (joinKind == EQUALS)) {
 428             extractJoinField(((SqlBasicCall) (condition)).operands[0], joinFieldSet);
 429             extractJoinField(((SqlBasicCall) (condition)).operands[1], joinFieldSet);
 430         } else {
<abbr title=" 431             Preconditions.checkState(((SqlIdentifier) (condition)).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 431             Preconditions.checkState(((SqlIdentifier) (condition)).names.size() == 2, &quot;join condition mus🔵</abbr>
<abbr title=" 432             Tuple2&lt;String, String&gt; tuple2 = Tuple2.of(((SqlIdentifier) (condition)).names.get(0), ((SqlIdentifier) (condition)).names.get(1));"> 432             Tuple2&lt;String, String&gt; tuple2 = Tuple2.of(((SqlIdentifier) (condition)).names.get(0), ((SqlId🔵</abbr>
 433             joinFieldSet.add(tuple2);
 434         }
 435     }
 436 
<abbr title=" 437     private void extractSelectField(SqlNode selectNode, Set&lt;String&gt; extractFieldSet, Set&lt;String&gt; fromTableNameSet, Map&lt;String, String&gt; tableRef) {"> 437     private void extractSelectField(SqlNode selectNode, Set&lt;String&gt; extractFieldSet, Set&lt;String&gt; fromTabl🔵</abbr>
 438         if (selectNode.getKind() == AS) {
 439             SqlNode leftNode = ((SqlBasicCall) (selectNode)).getOperands()[0];
 440             extractSelectField(leftNode, extractFieldSet, fromTableNameSet, tableRef);
 441         } else if (selectNode.getKind() == IDENTIFIER) {
 442             SqlIdentifier sqlIdentifier = ((SqlIdentifier) (selectNode));
 443             if (sqlIdentifier.names.size() == 1) {
 444                 return;
 445             }
 446             String tableName = sqlIdentifier.names.get(0);
 447             // TODO
 448             if (fromTableNameSet.contains(tableName)) {
 449                 extractFieldSet.add(sqlIdentifier.toString());
 450             } else if (fromTableNameSet.contains(tableRef.get(tableName))) {
<abbr title=" 451                 // TODO extractFieldSet.add(sqlIdentifier.setName(0, tableRef.get(tableName)).toString());"> 451                 // TODO extractFieldSet.add(sqlIdentifier.setName(0, tableRef.get(tableName)).toString())🔵</abbr>
 452             }
<abbr title=" 453         } else if ((((((((((((((((((((((((((((AGGREGATE.contains(selectNode.getKind()) || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())) || COMPARISON.contains(selectNode.getKind())) || (selectNode.getKind() == OTHER_FUNCTION)) || (selectNode.getKind() == DIVIDE)) || (selectNode.getKind() == CAST)) || (selectNode.getKind() == TRIM)) || (selectNode.getKind() == TIMES)) || (selectNode.getKind() == PLUS)) || (selectNode.getKind() == NOT_IN)) || (selectNode.getKind() == OR)) || (selectNode.getKind() == AND)) || (selectNode.getKind() == MINUS)) || (selectNode.getKind() == TUMBLE)) || (selectNode.getKind() == TUMBLE_START)) || (selectNode.getKind() == TUMBLE_END)) || (selectNode.getKind() == SESSION)) || (selectNode.getKind() == SESSION_START)) || (selectNode.getKind() == SESSION_END)) || (selectNode.getKind() == HOP)) || (selectNode.getKind() == HOP_START)) || (selectNode.getKind() == HOP_END)) || (selectNode.getKind() == BETWEEN)) || (selectNode.getKind() == IS_NULL)) || (selectNode.getKind() == IS_NOT_NULL)) || (selectNode.getKind() == CONTAINS)) || (selectNode.getKind() == TIMESTAMP_ADD)) || (selectNode.getKind() == TIMESTAMP_DIFF)) || (selectNode.getKind() == LIKE)) {"> 453         } else if ((((((((((((((((((((((((((((AGGREGATE.contains(selectNode.getKind()) || AVG_AGG_FUNCTIO🔵</abbr>
 454             SqlBasicCall sqlBasicCall = ((SqlBasicCall) (selectNode));
 455             for (int i = 0; i &lt; sqlBasicCall.getOperands().length; i++) {
 456                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 457                 if (sqlNode instanceof SqlLiteral) {
 458                     continue;
 459                 }
 460                 if (sqlNode instanceof SqlDataTypeSpec) {
 461                     continue;
 462                 }
 463                 extractSelectField(sqlNode, extractFieldSet, fromTableNameSet, tableRef);
 464             }
 465         } else if (selectNode.getKind() == CASE) {
 466             SqlCase sqlCase = ((SqlCase) (selectNode));
 467             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 468             SqlNodeList thenOperands = sqlCase.getThenOperands();
 469             SqlNode elseNode = sqlCase.getElseOperand();
 470             for (int i = 0; i &lt; whenOperands.size(); i++) {
 471                 SqlNode oneOperand = whenOperands.get(i);
 472                 extractSelectField(oneOperand, extractFieldSet, fromTableNameSet, tableRef);
 473             }
 474             for (int i = 0; i &lt; thenOperands.size(); i++) {
 475                 SqlNode oneOperand = thenOperands.get(i);
 476                 extractSelectField(oneOperand, extractFieldSet, fromTableNameSet, tableRef);
 477             }
 478             extractSelectField(elseNode, extractFieldSet, fromTableNameSet, tableRef);
 479         } else {
 480             // do nothing
 481         }
 482     }
 483 
<abbr title=" 484     private Tuple2&lt;String, String&gt; parseRightNode(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo, SqlNode parentWhere, SqlNodeList selectList, SqlNodeList parentGroupByList) {"> 484     private Tuple2&lt;String, String&gt; parseRightNode(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object🔵</abbr>
 485         Tuple2&lt;String, String&gt; tabName = new Tuple2&lt;&gt;(&quot;&quot;, &quot;&quot;);
 486         if (sqlNode.getKind() == IDENTIFIER) {
 487             tabName.f0 = sqlNode.toString();
 488         } else {
<abbr title=" 489             AliasInfo aliasInfo = ((AliasInfo) (sideSQLParser.parseSql(sqlNode, sideTableSet, queueInfo, parentWhere, selectList, parentGroupByList)));"> 489             AliasInfo aliasInfo = ((AliasInfo) (sideSQLParser.parseSql(sqlNode, sideTableSet, queueInfo, 🔵</abbr>
 490             tabName.f0 = aliasInfo.getName();
 491             tabName.f1 = aliasInfo.getAlias();
 492         }
 493         return tabName;
 494     }
 495 
 496     private Tuple2&lt;String, String&gt; parseLeftNode(SqlNode sqlNode){
 497         Tuple2&lt;String, String&gt; tabName = new Tuple2&lt;&gt;(&quot;&quot;, &quot;&quot;);
 498         if(sqlNode.getKind() == IDENTIFIER){
 499             tabName.f0 = sqlNode.toString();
 500             tabName.f1 = sqlNode.toString();
 501         }else if (sqlNode.getKind() == AS){
 502             SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 503             SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 504 
 505             tabName.f0 = info.toString();
 506             tabName.f1 = alias.toString();
 507         }else {
 508             throw new RuntimeException(&quot;&quot;);
 509         }
 510 
 511         return tabName;
 512     }
 513 
 514     public String buildCondition(List&lt;SqlBasicCall&gt; conditionList){
 515         if(CollectionUtils.isEmpty(conditionList)){
 516             return &quot;&quot;;
 517         }
 518 
 519         return &quot; where &quot; + StringUtils.join(conditionList, &quot; AND &quot;);
 520     }
 521 
 522     /**
 523      * 构建抽取表的查询字段信息
 524      * 包括去除重复字段，名称相同的取别名
 525      * @param extractSelectField
 526      * @param joinFieldSet
 527      * @return
 528      */
 529     public Set&lt;String&gt; buildSelectNode(Set&lt;String&gt; extractSelectField, Set&lt;String&gt; joinFieldSet) {
 530         if (CollectionUtils.isEmpty(extractSelectField)) {
 531             throw new RuntimeException(&quot;no field is used&quot;);
 532         }
 533         Sets.SetView&lt;String&gt; view = Sets.union(extractSelectField, joinFieldSet);
 534         Set&lt;String&gt; newFieldSet = Sets.newHashSet();
 535         // 为相同的列取别名
 536         HashBiMap&lt;String, String&gt; refFieldMap = HashBiMap.create();
 537         for (String field : view) {
 538             String[] fieldInfo = StringUtils.split(field, &#x27;.&#x27;);
 539             String aliasName = fieldInfo[1];
 540             StringBuilder stringBuilder = new StringBuilder();
 541             stringBuilder.append(field);
 542             if (refFieldMap.inverse().get(aliasName) != null) {
 543                 aliasName = ParseUtils.dealDuplicateFieldName(refFieldMap, aliasName);
 544                 stringBuilder.append(&quot; as &quot;).append(aliasName);
 545             }
 546             refFieldMap.put(field, aliasName);
 547             newFieldSet.add(stringBuilder.toString());
 548         }
 549         return newFieldSet;
 550     }
 551 
 552     private boolean checkIsSideTable(String tableName, Set&lt;String&gt; sideTableList){
 553         if(sideTableList.contains(tableName)){
 554             return true;
 555         }
 556         return false;
 557     }
 558 
 559     private SqlBasicCall buildAsSqlNode(String internalTableName, SqlNode newSource) {
 560         SqlOperator operator = new SqlAsOperator();
 561         SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 562         SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(internalTableName, null, sqlParserPos);
 563         SqlNode[] sqlNodes = new SqlNode[2];
 564         sqlNodes[0] = newSource;
 565         sqlNodes[1] = sqlIdentifierAlias;
 566         return new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 567     }
 568 
 569     /**
 570      * 获取where中和指定表有关联的字段
 571      * @param fromTableNameSet
 572      * @param parentWhere
 573      * @param extractCondition
 574      */
<abbr title=" 575     private void extractWhereCondition(Set&lt;String&gt; fromTableNameSet, SqlBasicCall parentWhere, Set&lt;String&gt; extractCondition){"> 575     private void extractWhereCondition(Set&lt;String&gt; fromTableNameSet, SqlBasicCall parentWhere, Set&lt;String🔵</abbr>
 576 
 577         if(parentWhere == null){
 578             return;
 579         }
 580 
 581         SqlKind kind = parentWhere.getKind();
 582         if(kind == AND){
<abbr title=" 583             extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[0], extractCondition);"> 583             extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[0], extractC🔵</abbr>
<abbr title=" 584             extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[1], extractCondition);"> 584             extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[1], extractC🔵</abbr>
 585         } else {
 586 
 587             Set&lt;String&gt; fieldInfos = Sets.newHashSet();
 588             TableUtils.getConditionRefTable(parentWhere, fieldInfos);
 589             fieldInfos.forEach(fieldInfo -&gt; {
 590                 String[] splitInfo = StringUtils.split(fieldInfo, &quot;.&quot;);
 591                 if(splitInfo.length == 2 &amp;&amp; fromTableNameSet.contains(splitInfo[0])){
 592                     extractCondition.add(fieldInfo);
 593                 }
 594             });
 595 
 596         }
 597 
 598 
 599     }
 600 
 601     /**
 602      * 检查关联的where 条件中的判断是否可以下移到新构建的子查询
 603      * @param fromTableNameSet
 604      * @param parentWhere
 605      * @param extractCondition
 606      * @return
 607      */
<abbr title=" 608     private boolean checkAndRemoveWhereCondition(Set&lt;String&gt; fromTableNameSet, SqlBasicCall parentWhere, List&lt;SqlBasicCall&gt; extractCondition) {"> 608     private boolean checkAndRemoveWhereCondition(Set&lt;String&gt; fromTableNameSet, SqlBasicCall parentWhere, 🔵</abbr>
 609         if (parentWhere == null) {
 610             return false;
 611         }
 612         SqlKind kind = parentWhere.getKind();
 613         if (kind == AND) {
<abbr title=" 614             boolean removeLeft = checkAndRemoveWhereCondition(fromTableNameSet, ((SqlBasicCall) (parentWhere.getOperands()[0])), extractCondition);"> 614             boolean removeLeft = checkAndRemoveWhereCondition(fromTableNameSet, ((SqlBasicCall) (parentWh🔵</abbr>
<abbr title=" 615             boolean removeRight = checkAndRemoveWhereCondition(fromTableNameSet, ((SqlBasicCall) (parentWhere.getOperands()[1])), extractCondition);"> 615             boolean removeRight = checkAndRemoveWhereCondition(fromTableNameSet, ((SqlBasicCall) (parentW🔵</abbr>
 616             // DO remove
 617             if (removeLeft) {
 618                 extractCondition.add(removeWhereConditionNode(parentWhere, 0));
 619             }
 620             if (removeRight) {
 621                 extractCondition.add(removeWhereConditionNode(parentWhere, 1));
 622             }
 623             return false;
 624         } else {
 625             // 条件表达式，如果该条件关联的表都是指定的表则移除
 626             Set&lt;String&gt; fieldInfos = Sets.newHashSet();
 627             TableUtils.getConditionRefTable(parentWhere, fieldInfos);
 628             Set&lt;String&gt; conditionRefTableNameSet = Sets.newHashSet();
 629             fieldInfos.forEach(( fieldInfo) -&gt; {
 630                 String[] splitInfo = StringUtils.split(fieldInfo, &quot;.&quot;);
 631                 if (splitInfo.length == 2) {
 632                     conditionRefTableNameSet.add(splitInfo[0]);
 633                 }
 634             });
 635             if (fromTableNameSet.containsAll(conditionRefTableNameSet)) {
 636                 return true;
 637             }
 638             return false;
 639         }
 640     }
 641 
 642     /**
 643      * 抽取where 条件中指定的条件
 644      * @param parentWhere
 645      * @param index
 646      * @return
 647      */
 648     public SqlBasicCall removeWhereConditionNode(SqlBasicCall parentWhere, int index){
 649         SqlBasicCall oldCondition = (SqlBasicCall) parentWhere.getOperands()[index];
 650         parentWhere.setOperand(index, buildEmptyCondition());
 651         return oldCondition;
 652     }
 653 
 654     /**
 655      * 构建 1=1的 where 条件
 656      * @return
 657      */
 658     public SqlBasicCall buildEmptyCondition(){
 659         SqlBinaryOperator equalsOperators = SqlStdOperatorTable.EQUALS;
 660         SqlNode[] operands = new SqlNode[2];
 661         operands[0] = SqlLiteral.createExactNumeric(&quot;1&quot;, SqlParserPos.ZERO);
 662         operands[1] = SqlLiteral.createExactNumeric(&quot;1&quot;, SqlParserPos.ZERO);
 663 
 664         return new SqlBasicCall(equalsOperators, operands, SqlParserPos.ZERO);
 665     }
 666 
 667     /**
 668      * 替换join 条件中的表名称
 669      * @param node
 670      * @param tableMap 表名的关联关系
 671      */
 672     private SqlIdentifier checkAndReplaceJoinCondition(SqlNode node, Map&lt;String, String&gt; tableMap){
 673 
 674         SqlKind joinKind = node.getKind();
 675         if( joinKind == AND || joinKind == EQUALS ){
<abbr title=" 676             SqlIdentifier leftNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[0], tableMap);"> 676             SqlIdentifier leftNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[0], table🔵</abbr>
<abbr title=" 677             SqlIdentifier rightNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[1], tableMap);"> 677             SqlIdentifier rightNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[1], tabl🔵</abbr>
 678 
 679             if(leftNode != null){
 680                 ((SqlBasicCall)node).setOperand(0, leftNode);
 681             }
 682 
 683             if(rightNode != null){
 684                 ((SqlBasicCall)node).setOperand(1, leftNode);
 685             }
 686 
 687             return null;
 688         } else {
 689             //replace table
<abbr title=" 690             Preconditions.checkState(((SqlIdentifier)node).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 690             Preconditions.checkState(((SqlIdentifier)node).names.size() == 2, &quot;join condition must be for🔵</abbr>
 691             String tbName = ((SqlIdentifier) node).names.get(0);
 692             if(tableMap.containsKey(tbName)){
 693                 tbName = tableMap.get(tbName);
 694                 return ((SqlIdentifier) node).setName(0, tbName);
 695             }
 696 
 697             return null;
 698         }
 699     }
 700 
 701     /**
 702      * 解析出临时中间表的属性列和源表之间的关系
 703      * @param fieldSet
 704      * @param newTableAliasName
 705      */
<abbr title=" 706     public Map&lt;String, String&gt; buildTmpTableFieldRefOriField(Set&lt;String&gt; fieldSet, String newTableAliasName){"> 706     public Map&lt;String, String&gt; buildTmpTableFieldRefOriField(Set&lt;String&gt; fieldSet, String newTableAliasNa🔵</abbr>
 707         Map&lt;String, String&gt; refInfo = Maps.newConcurrentMap();
 708         for(String field : fieldSet){
 709             String[] fields = StringUtils.splitByWholeSeparator(field, &quot;as&quot;);
 710             String oldKey = field;
 711             String[] oldFieldInfo = StringUtils.splitByWholeSeparator(fields[0], &quot;.&quot;);
 712             String oldFieldName = oldFieldInfo.length == 2 ? oldFieldInfo[1] : oldFieldInfo[0];
 713             String newKey = fields.length == 2 ? newTableAliasName + &quot;.&quot; + fields[1] :
 714                     newTableAliasName + &quot;.&quot; + oldFieldName;
 715             refInfo.put(oldKey, newKey);
 716         }
 717 
 718         return refInfo;
 719     }
 720 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.side;
  21  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import com.dtstack.flink.sql.config.CalciteConfig;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import com.dtstack.flink.sql.parser.FlinkPlanner;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import com.dtstack.flink.sql.util.ParseUtils;</span>
  25  import com.dtstack.flink.sql.util.TableUtils;

  26  import com.google.common.base.Preconditions;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  27 -import com.google.common.collect.Lists;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  28 -import com.google.common.collect.Sets;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import com.google.common.collect.*;</span>
  30  import org.apache.calcite.sql.JoinType;
  31  import org.apache.calcite.sql.SqlAsOperator;
  32  import org.apache.calcite.sql.SqlBasicCall;
  33  import org.apache.calcite.sql.SqlBinaryOperator;
  34  import org.apache.calcite.sql.SqlDataTypeSpec;
  35  import org.apache.calcite.sql.SqlIdentifier;
  36  import org.apache.calcite.sql.SqlJoin;
  37  import org.apache.calcite.sql.SqlKind;
  38  import org.apache.calcite.sql.SqlLiteral;
  39  import org.apache.calcite.sql.SqlNode;
  40  import org.apache.calcite.sql.SqlNodeList;
  41  import org.apache.calcite.sql.SqlOperator;
  42  import org.apache.calcite.sql.fun.SqlCase;
  43  import org.apache.calcite.sql.fun.SqlStdOperatorTable;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  44 -import org.apache.calcite.sql.parser.SqlParser;</span>
  45  import org.apache.calcite.sql.parser.SqlParserPos;
  46  import org.apache.commons.collections.CollectionUtils;
  47  import org.apache.commons.lang3.StringUtils;
  48  import org.apache.flink.api.java.tuple.Tuple2;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  49 +import org.apache.flink.table.calcite.FlinkPlannerImpl;</span>
  50  
  51  import java.util.List;
  52  import java.util.Map;
  53  import java.util.Queue;
  54  import java.util.Set;
  55  
  56  import static org.apache.calcite.sql.SqlKind.*;
  57  
  58  /**
  59   * 处理join 节点
  60   * 1:如果包含维表节点替换为临时查询
  61   * Date: 2020/2/27
  62   * Company: www.dtstack.com
  63   * @author xuchao
  64   */
  65  
  66  public class JoinNodeDealer {
  67  
  68      //用来构建临时的中间查询
  69      private static final String SELECT_TEMP_SQL = &quot;select %s from %s %s&quot;;
  70  
  71      private SideSQLParser sideSQLParser;
  72  
  73      public JoinNodeDealer(SideSQLParser sideSQLParser){
  74          this.sideSQLParser = sideSQLParser;
  75      }
  76  
  77      /**
  78       * 解析 join 操作
  79       * @param joinNode
  80       * @param sideTableSet 标明哪些表名是维表
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  81 -     * @param queueInfo</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  82 +     * @param queueInfo sql执行队列</span>
  83       * @param parentWhere join 关联的最上层的where 节点
  84       * @param parentSelectList join 关联的最上层的select 节点
  85       * @param joinFieldSet
  86       * @param tableRef 存储构建临时表查询后源表和新表之间的关联关系
  87       * @return
  88       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  89 -    public JoinInfo dealJoinNode(SqlJoin joinNode, Set&lt;String&gt; sideTableSet,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  90 -                                 Queue&lt;Object&gt; queueInfo, SqlNode parentWhere,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  91 -                                 SqlNodeList parentSelectList, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  92 -                                 Map&lt;String, String&gt; tableRef) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +    public JoinInfo dealJoinNode(SqlJoin joinNode,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  94 +                                 Set&lt;String&gt; sideTableSet,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +                                 Queue&lt;Object&gt; queueInfo,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  96 +                                 SqlNode parentWhere,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  97 +                                 SqlNodeList parentSelectList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  98 +                                 SqlNodeList parentGroupByList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  99 +                                 Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 100 +                                 Map&lt;String, String&gt; tableRef,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 101 +                                 Map&lt;String, String&gt; fieldRef) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 102 +</span>
 103          SqlNode leftNode = joinNode.getLeft();
 104          SqlNode rightNode = joinNode.getRight();
 105          JoinType joinType = joinNode.getJoinType();
 106  
 107          String leftTbName = &quot;&quot;;
 108          String leftTbAlias = &quot;&quot;;
 109          String rightTableName = &quot;&quot;;
 110          String rightTableAlias = &quot;&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 111 -        boolean leftTbisTmp = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 112 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 113 -        //如果是连续join 判断是否已经处理过添加到执行队列</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 114 -        Boolean needBuildTemp = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 115 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 116 +        //抽取join中的的条件</span>
 117          extractJoinField(joinNode.getCondition(), joinFieldSet);
 118  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 119 -        if(leftNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 120 -            leftTbName = leftNode.toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 121 -        } else if (leftNode.getKind() == JOIN) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 122 +        if (leftNode.getKind() == JOIN) {</span>
 123              //处理连续join
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 124 -            Tuple2&lt;Boolean, JoinInfo&gt; nestJoinResult = dealNestJoin((SqlJoin) leftNode, sideTableSet,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 125 -                    queueInfo, parentWhere, parentSelectList, joinFieldSet, tableRef);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 126 -            needBuildTemp = nestJoinResult.f0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -            SqlBasicCall buildAs = TableUtils.buildAsNodeByJoinInfo(nestJoinResult.f1, null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 128 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 129 -            if(needBuildTemp){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 130 -                //记录表之间的关联关系</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 131 -                String newLeftTableName = buildAs.getOperands()[1].toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 132 -                Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -                TableUtils.getFromTableInfo(joinNode.getLeft(), fromTableNameSet);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -                for(String tbTmp : fromTableNameSet){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -                    tableRef.put(tbTmp, newLeftTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 137 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 138 -                //替换leftNode 为新的查询</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -                joinNode.setLeft(buildAs);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 140 -                leftNode = buildAs;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 141 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 142 -                //替换select field 中的对应字段</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -                for(SqlNode sqlNode : parentSelectList.getList()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -                    for(String tbTmp : fromTableNameSet) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 145 -                        TableUtils.replaceSelectFieldTable(sqlNode, tbTmp, newLeftTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 148 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 149 -                //替换where 中的条件相关</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 150 -                for(String tbTmp : fromTableNameSet){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 151 -                    TableUtils.replaceWhereCondition(parentWhere, tbTmp, newLeftTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 152 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 153 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 154 -                leftTbisTmp = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 155 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 156 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 157 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 158 -            leftTbName = buildAs.getOperands()[0].toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 159 -            leftTbAlias = buildAs.getOperands()[1].toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 160 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 161 -        } else if (leftNode.getKind() == AS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 162 -            AliasInfo aliasInfo = (AliasInfo) sideSQLParser.parseSql(leftNode, sideTableSet, queueInfo, parentWhere, parentSelectList);"> 162 -            AliasInfo aliasInfo = (AliasInfo) sideSQLParser.parseSql(leftNode, sideTableSet, queueInfo, parentWher🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +            dealNestJoin(joinNode, sideTableSet,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 164 +                    queueInfo, parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRef);"> 164 +                    queueInfo, parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRef)🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +            leftNode = joinNode.getLeft();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 167 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +        if (leftNode.getKind() == AS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 169 +            AliasInfo aliasInfo = (AliasInfo) sideSQLParser.parseSql(leftNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 169 +            AliasInfo aliasInfo = (AliasInfo) sideSQLParser.parseSql(leftNode, sideTableSet, queueInfo, parentWher🔵</abbr></span>
 170              leftTbName = aliasInfo.getName();
 171              leftTbAlias = aliasInfo.getAlias();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 172 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 173 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 174 -            throw new RuntimeException(String.format(&quot;---not deal node with type %s&quot;, leftNode.getKind().toString()));"> 174 -            throw new RuntimeException(String.format(&quot;---not deal node with type %s&quot;, leftNode.getKind().toString(🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +        } else if(leftNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 176 +            leftTbName = leftNode.toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 177 +            leftTbAlias = leftTbName;</span>
 178          }
 179  
 180          boolean leftIsSide = checkIsSideTable(leftTbName, sideTableSet);
 181          Preconditions.checkState(!leftIsSide, &quot;side-table must be at the right of join operator&quot;);
 182  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 183 -        Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentWhere, parentSelectList);"> 183 -        Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentW🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 184 +        Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 184 +        Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentW🔵</abbr></span>
 185          rightTableName = rightTableNameAndAlias.f0;
 186          rightTableAlias = rightTableNameAndAlias.f1;
 187  
 188          boolean rightIsSide = checkIsSideTable(rightTableName, sideTableSet);
 189          if(rightIsSide &amp;&amp; joinType == JoinType.RIGHT){
<abbr title=" 190              throw new RuntimeException(&quot;side join not support join type of right[current support inner join and left join]&quot;);"> 190              throw new RuntimeException(&quot;side join not support join type of right[current support inner join and le🔵</abbr>
 191          }
 192  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 193 -        if(leftNode.getKind() == JOIN &amp;&amp; rightIsSide){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 194 -            needBuildTemp = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 195 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 196 -</span>
 197          JoinInfo tableInfo = new JoinInfo();
 198          tableInfo.setLeftTableName(leftTbName);
 199          tableInfo.setRightTableName(rightTableName);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -        if (StringUtils.isEmpty(leftTbAlias)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 201 -            tableInfo.setLeftTableAlias(leftTbName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 202 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 203 -            tableInfo.setLeftTableAlias(leftTbAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 204 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 205 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 206 -        if (StringUtils.isEmpty(rightTableAlias)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 207 -            tableInfo.setRightTableAlias(rightTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 208 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 209 -            tableInfo.setRightTableAlias(rightTableAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 210 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 211 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 212 -        TableUtils.replaceJoinFieldRefTableName(joinNode.getCondition(), tableRef);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 213 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 214 -        tableInfo.setLeftIsTmpTable(leftTbisTmp);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 215 -        tableInfo.setLeftIsSideTable(leftIsSide);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +        leftTbAlias = StringUtils.isEmpty(leftTbAlias) ? leftTbName : leftTbAlias;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +        rightTableAlias = StringUtils.isEmpty(rightTableAlias) ? rightTableName : rightTableAlias;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +        tableInfo.setLeftTableAlias(leftTbAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +        tableInfo.setRightTableAlias(rightTableAlias);</span>
 222          tableInfo.setRightIsSideTable(rightIsSide);
 223          tableInfo.setLeftNode(leftNode);
 224          tableInfo.setRightNode(rightNode);
 225          tableInfo.setJoinType(joinType);
 226          tableInfo.setCondition(joinNode.getCondition());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 227 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 228 -        if(tableInfo.getLeftNode().getKind() != AS &amp;&amp; needBuildTemp){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 229 -            extractTemporaryQuery(tableInfo.getLeftNode(), tableInfo.getLeftTableAlias(), (SqlBasicCall) parentWhere,"> 229 -            extractTemporaryQuery(tableInfo.getLeftNode(), tableInfo.getLeftTableAlias(), (SqlBasicCall) parentWhe🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 230 -                    parentSelectList, queueInfo, joinFieldSet, tableRef);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 231 -        }else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 232 -            SqlKind asNodeFirstKind = ((SqlBasicCall)tableInfo.getLeftNode()).operands[0].getKind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 233 -            if(asNodeFirstKind == SELECT){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 234 -                queueInfo.offer(tableInfo.getLeftNode());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 235 -                tableInfo.setLeftNode(((SqlBasicCall)tableInfo.getLeftNode()).operands[1]);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 236 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 237 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +        TableUtils.replaceJoinFieldRefTableName(joinNode.getCondition(), fieldRef);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +        //extract 需要查询的字段信息</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +        if(rightIsSide){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 242 +            extractJoinNeedSelectField(leftNode, rightNode, parentWhere, parentSelectList, parentGroupByList, tableRef, joinFieldSet, fieldRef, tableInfo);"> 242 +            extractJoinNeedSelectField(leftNode, rightNode, parentWhere, parentSelectList, parentGroupByList, tabl🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 245 +        if(tableInfo.getLeftNode().getKind() != AS){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 246 +            return tableInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 247 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +        SqlKind asNodeFirstKind = ((SqlBasicCall)tableInfo.getLeftNode()).operands[0].getKind();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +        if(asNodeFirstKind == SELECT){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +            queueInfo.offer(tableInfo.getLeftNode());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +            tableInfo.setLeftNode(((SqlBasicCall)tableInfo.getLeftNode()).operands[1]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +</span>
 255          return tableInfo;
 256      }
 257  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 258 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 259 -    //处理多层join</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 260 -    private Tuple2&lt;Boolean, JoinInfo&gt; dealNestJoin(SqlJoin joinNode, Set&lt;String&gt; sideTableSet,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 261 -                                                   Queue&lt;Object&gt; queueInfo, SqlNode parentWhere,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 262 -                                                   SqlNodeList selectList, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,"> 262 -                                                   SqlNodeList selectList, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSe🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 263 -                                                   Map&lt;String, String&gt; tableRef){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 264 -        SqlNode rightNode = joinNode.getRight();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 265 -        Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentWhere, selectList);"> 265 -        Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentW🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 266 -        JoinInfo joinInfo = dealJoinNode(joinNode, sideTableSet, queueInfo, parentWhere, selectList, joinFieldSet, tableRef);"> 266 -        JoinInfo joinInfo = dealJoinNode(joinNode, sideTableSet, queueInfo, parentWhere, selectList, joinFieldSet,🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 267 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 268 +     * 获取join 之后需要查询的字段信息</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 269 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 270 +    public void extractJoinNeedSelectField(SqlNode leftNode,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +                                           SqlNode rightNode,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 272 +                                           SqlNode parentWhere,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 273 +                                           SqlNodeList parentSelectList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 274 +                                           SqlNodeList parentGroupByList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 275 +                                           Map&lt;String, String&gt; tableRef,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 276 +                                           Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 277 +                                           Map&lt;String, String&gt; fieldRef,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 278 +                                           JoinInfo tableInfo){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 279 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 280 +        Set&lt;String&gt; extractSelectField = extractField(leftNode, parentWhere, parentSelectList, parentGroupByList, tableRef, joinFieldSet);"> 280 +        Set&lt;String&gt; extractSelectField = extractField(leftNode, parentWhere, parentSelectList, parentGroupByList, 🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 281 +        Set&lt;String&gt; rightExtractSelectField = extractField(rightNode, parentWhere, parentSelectList, parentGroupByList, tableRef, joinFieldSet);"> 281 +        Set&lt;String&gt; rightExtractSelectField = extractField(rightNode, parentWhere, parentSelectList, parentGroupBy🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 282 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 283 +        //重命名right 中和 left 重名的</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 284 +        Map&lt;String, String&gt; leftTbSelectField = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 285 +        Map&lt;String, String&gt; rightTbSelectField = Maps.newHashMap();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 286 +        String newTableName = tableInfo.getNewTableAlias();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 287 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 288 +        for(String tmpField : extractSelectField){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 289 +            String[] tmpFieldSplit = StringUtils.split(tmpField, &#x27;.&#x27;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +            leftTbSelectField.put(tmpFieldSplit[1], tmpFieldSplit[1]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 291 +            fieldRef.put(tmpField, TableUtils.buildTableField(newTableName, tmpFieldSplit[1]));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 292 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 293 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 294 +        for(String tmpField : rightExtractSelectField){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 295 +            String[] tmpFieldSplit = StringUtils.split(tmpField, &#x27;.&#x27;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 296 +            String originalFieldName = tmpFieldSplit[1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 297 +            String targetFieldName = originalFieldName;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 298 +            if(leftTbSelectField.containsKey(originalFieldName)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 299 +                targetFieldName = ParseUtils.dealDuplicateFieldName(leftTbSelectField, originalFieldName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 300 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 301 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 302 +            rightTbSelectField.put(originalFieldName, targetFieldName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 303 +            fieldRef.put(tmpField, TableUtils.buildTableField(newTableName, targetFieldName));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 304 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 305 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 306 +        tableInfo.setLeftSelectFieldInfo(leftTbSelectField);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 307 +        tableInfo.setRightSelectFieldInfo(rightTbSelectField);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 308 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 309 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 310 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 311 +     * 指定的节点关联到的 select 中的字段和 where中的字段</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +     * @param sqlNode</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 313 +     * @param parentWhere</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 314 +     * @param parentSelectList</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +     * @param parentGroupByList</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 316 +     * @param tableRef</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 317 +     * @param joinFieldSet</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 318 +     * @return</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 319 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 320 +    public Set&lt;String&gt; extractField(SqlNode sqlNode,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 321 +                                    SqlNode parentWhere,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 322 +                                    SqlNodeList parentSelectList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 323 +                                    SqlNodeList parentGroupByList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 324 +                                    Map&lt;String, String&gt; tableRef,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 325 +                                    Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 326 +        Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 327 +        TableUtils.getFromTableInfo(sqlNode, fromTableNameSet);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 328 +        Set&lt;String&gt; extractCondition = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 329 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 330 +        extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere, extractCondition);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 331 +        Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tableRef);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 332 +        Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSet, tableRef);"> 332 +        Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSet, t🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 333 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 334 +        Set&lt;String&gt; extractGroupByField = extractFieldFromGroupByList(parentGroupByList, fromTableNameSet, tableRef);"> 334 +        Set&lt;String&gt; extractGroupByField = extractFieldFromGroupByList(parentGroupByList, fromTableNameSet, tableRe🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 335 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 336 +        extractSelectField.addAll(extractCondition);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 337 +        extractSelectField.addAll(fieldFromJoinCondition);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 338 +        extractSelectField.addAll(extractGroupByField);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 339 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 340 +        return extractSelectField;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 341 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 342 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 343 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 344 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 345 +     * 处理多层join</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 346 +     * 判断左节点是否需要创建临时查询</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 347 +     * （1）右节点是维表</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 348 +     * （2）左节点不是 as 节点</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 349 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 350 +    private JoinInfo dealNestJoin(SqlJoin joinNode,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 351 +                                  Set&lt;String&gt; sideTableSet,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 352 +                                  Queue&lt;Object&gt; queueInfo,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 353 +                                  SqlNode parentWhere,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 354 +                                  SqlNodeList parentSelectList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 355 +                                  SqlNodeList parentGroupByList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 356 +                                  Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 357 +                                  Map&lt;String, String&gt; tableRef,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 358 +                                  Map&lt;String, String&gt; fieldRef){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 359 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 360 +        SqlJoin leftJoinNode = (SqlJoin) joinNode.getLeft();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 361 +        SqlNode parentRightJoinNode = joinNode.getRight();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 362 +        SqlNode rightNode = leftJoinNode.getRight();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 363 +        Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 363 +        Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentW🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 364 +        Tuple2&lt;String, String&gt; parentRightJoinInfo = parseRightNode(parentRightJoinNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList);"> 364 +        Tuple2&lt;String, String&gt; parentRightJoinInfo = parseRightNode(parentRightJoinNode, sideTableSet, queueInfo, 🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 365 +        boolean parentRightIsSide = checkIsSideTable(parentRightJoinInfo.f0, sideTableSet);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 366 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 367 +        JoinInfo joinInfo = dealJoinNode(leftJoinNode, sideTableSet, queueInfo, parentWhere, parentSelectList, parentGroupByList, joinFieldSet, tableRef, fieldRef);"> 367 +        JoinInfo joinInfo = dealJoinNode(leftJoinNode, sideTableSet, queueInfo, parentWhere, parentSelectList, par🔵</abbr></span>
 368  
 369          String rightTableName = rightTableNameAndAlias.f0;
 370          boolean rightIsSide = checkIsSideTable(rightTableName, sideTableSet);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 371 -        boolean needBuildTemp = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 372 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 373 -        if(!rightIsSide){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 374 -            //右表不是维表的情况</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 375 -        }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 376 -            //右边表是维表需要重新构建左表的临时查询</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 377 -            queueInfo.offer(joinInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 378 -            needBuildTemp = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 379 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 380 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 381 -        //return Tuple2.of(needBuildTemp, TableUtils.buildAsNodeByJoinInfo(joinInfo, null, null));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 382 -        return Tuple2.of(needBuildTemp, joinInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 383 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 384 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 385 -    private void extractTemporaryQuery(SqlNode node, String tableAlias, SqlBasicCall parentWhere,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 386 -                                       SqlNodeList parentSelectList, Queue&lt;Object&gt; queueInfo,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 387 +        SqlBasicCall buildAs = TableUtils.buildAsNodeByJoinInfo(joinInfo, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 388 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 389 +        if(rightIsSide){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 390 +            addSideInfoToExeQueue(queueInfo, joinInfo, joinNode, parentSelectList, parentGroupByList, parentWhere, tableRef);"> 390 +            addSideInfoToExeQueue(queueInfo, joinInfo, joinNode, parentSelectList, parentGroupByList, parentWhere,🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 391 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 392 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 393 +        SqlNode newLeftNode = joinNode.getLeft();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 394 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 395 +        if(newLeftNode.getKind() != AS &amp;&amp; parentRightIsSide){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 396 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 397 +            String leftTbAlias = buildAs.getOperands()[1].toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 398 +            extractTemporaryQuery(newLeftNode, leftTbAlias, (SqlBasicCall) parentWhere,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 399 +                    parentSelectList, queueInfo, joinFieldSet, tableRef, fieldRef);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 400 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 401 +            //替换leftNode 为新的查询</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 402 +            joinNode.setLeft(buildAs);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 403 +            replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByList, parentWhere);"> 403 +            replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByList, paren🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 404 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 405 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 406 +        return joinInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 407 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 408 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 409 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 410 +     * 右边表是维表需要重新构建左表的临时查询</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 411 +     * 并将joinInfo 添加到执行队列里面</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 412 +     * @param queueInfo</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 413 +     * @param joinInfo</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 414 +     * @param joinNode</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 415 +     * @param parentSelectList</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 416 +     * @param parentGroupByList</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 417 +     * @param parentWhere</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 418 +     * @param tableRef</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 419 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 420 +    public void addSideInfoToExeQueue(Queue&lt;Object&gt; queueInfo,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 421 +                                      JoinInfo joinInfo,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 422 +                                      SqlJoin joinNode,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 423 +                                      SqlNodeList parentSelectList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 424 +                                      SqlNodeList parentGroupByList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 425 +                                      SqlNode parentWhere,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 426 +                                      Map&lt;String, String&gt; tableRef){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 427 +        //只处理维表</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 428 +        if(!joinInfo.isRightIsSideTable()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 429 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 430 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 431 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 432 +        SqlBasicCall buildAs = TableUtils.buildAsNodeByJoinInfo(joinInfo, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 433 +        SqlNode leftJoinNode = joinNode.getLeft();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 434 +        queueInfo.offer(joinInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 435 +        //替换左表为新的表名称</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 436 +        joinNode.setLeft(buildAs);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 437 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 438 +        replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByList, parentWhere);"> 438 +        replaceSelectAndWhereField(buildAs, leftJoinNode, tableRef, parentSelectList, parentGroupByList, parentWhe🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 439 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 440 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 441 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 442 +     * 替换指定的查询和条件节点中的字段为新的字段</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 443 +     * @param buildAs</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 444 +     * @param leftJoinNode</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 445 +     * @param tableRef</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 446 +     * @param parentSelectList</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 447 +     * @param parentGroupByList</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 448 +     * @param parentWhere</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 449 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 450 +    public void replaceSelectAndWhereField(SqlBasicCall buildAs,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 451 +                   SqlNode leftJoinNode,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 452 +                   Map&lt;String, String&gt; tableRef,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 453 +                   SqlNodeList parentSelectList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 454 +                   SqlNodeList parentGroupByList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 455 +                   SqlNode parentWhere){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 456 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 457 +        String newLeftTableName = buildAs.getOperands()[1].toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 458 +        Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 459 +        TableUtils.getFromTableInfo(leftJoinNode, fromTableNameSet);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 460 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 461 +        for(String tbTmp : fromTableNameSet){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 462 +            tableRef.put(tbTmp, newLeftTableName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 463 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 464 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 465 +        //替换select field 中的对应字段</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 466 +        HashBiMap&lt;String, String&gt; fieldReplaceRef = HashBiMap.create();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 467 +        for(SqlNode sqlNode : parentSelectList.getList()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 468 +            for(String tbTmp : fromTableNameSet) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 469 +                TableUtils.replaceSelectFieldTable(sqlNode, tbTmp, newLeftTableName, fieldReplaceRef);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 470 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 471 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 472 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 473 +        //TODO 应该根据上面的查询字段的关联关系来替换</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 474 +        //替换where 中的条件相关</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 475 +        for(String tbTmp : fromTableNameSet){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 476 +            TableUtils.replaceWhereCondition(parentWhere, tbTmp, newLeftTableName, fieldReplaceRef);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 477 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 478 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 479 +        if(parentGroupByList != null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 480 +            for(SqlNode sqlNode : parentGroupByList.getList()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 481 +                for(String tbTmp : fromTableNameSet) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 482 +                    TableUtils.replaceSelectFieldTable(sqlNode, tbTmp, newLeftTableName, fieldReplaceRef);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 483 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 484 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 485 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 486 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 487 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 488 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 489 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 490 +     * 抽取出中间查询表</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 491 +     * @param node</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 492 +     * @param tableAlias</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 493 +     * @param parentWhere</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 494 +     * @param parentSelectList</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 495 +     * @param queueInfo</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 496 +     * @param joinFieldSet</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 497 +     * @param tableRef</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 498 +     * @return 源自段和新生成字段之间的映射关系</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 499 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 500 +    private void extractTemporaryQuery(SqlNode node, String tableAlias,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 501 +                                       SqlBasicCall parentWhere,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 502 +                                       SqlNodeList parentSelectList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 503 +                                       Queue&lt;Object&gt; queueInfo,</span>
 504                                         Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 505 -                                       Map&lt;String, String&gt; tableRef){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 506 +                                       Map&lt;String, String&gt; tableRef,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 507 +                                       Map&lt;String, String&gt; fieldRef){</span>
 508          try{
 509              //父一级的where 条件中如果只和临时查询相关的条件都截取进来
 510              Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 511              List&lt;SqlBasicCall&gt; extractCondition = Lists.newArrayList();
 512  
 513              TableUtils.getFromTableInfo(node, fromTableNameSet);
 514              checkAndRemoveWhereCondition(fromTableNameSet, parentWhere, extractCondition);
 515  
 516              if(node.getKind() == JOIN){
 517                  checkAndReplaceJoinCondition(((SqlJoin)node).getCondition(), tableRef);
 518              }
 519  
 520              Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tableRef);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 521 -            Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSet);"> 521 -            Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSe🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 522 -            String extractSelectFieldStr = buildSelectNode(extractSelectField, fieldFromJoinCondition);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 523 +            Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSet, tableRef);"> 523 +            Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSe🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 524 +            Set&lt;String&gt; newFields = buildSelectNode(extractSelectField, fieldFromJoinCondition);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 525 +            String extractSelectFieldStr = StringUtils.join(newFields, &#x27;,&#x27;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 526 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 527 +            Map&lt;String, String&gt; oldRefNewField = buildTmpTableFieldRefOriField(newFields, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 528 +            fieldRef.putAll(oldRefNewField);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 529 +</span>
 530              String extractConditionStr = buildCondition(extractCondition);
 531  
 532              String tmpSelectSql = String.format(SELECT_TEMP_SQL,
 533                      extractSelectFieldStr,
 534                      node.toString(),
 535                      extractConditionStr);
 536  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 537 -            SqlParser sqlParser = SqlParser.create(tmpSelectSql, CalciteConfig.MYSQL_LEX_CONFIG);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 538 -            SqlNode sqlNode = sqlParser.parseStmt();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 539 +            FlinkPlannerImpl flinkPlanner = FlinkPlanner.getFlinkPlanner();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 540 +            SqlNode sqlNode = flinkPlanner.parse(tmpSelectSql);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 541 +</span>
 542              SqlBasicCall sqlBasicCall = buildAsSqlNode(tableAlias, sqlNode);
 543              queueInfo.offer(sqlBasicCall);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 544 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 545 +            //替换select中的表结构</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 546 +            HashBiMap&lt;String, String&gt; fieldReplaceRef = HashBiMap.create();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 547 +            for(SqlNode tmpSelect : parentSelectList.getList()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 548 +                for(String tbTmp : fromTableNameSet) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 549 +                    TableUtils.replaceSelectFieldTable(tmpSelect, tbTmp, tableAlias, fieldReplaceRef);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 550 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 551 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 552 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 553 +            //替换where 中的条件相关</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 554 +            for(String tbTmp : fromTableNameSet){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 555 +                TableUtils.replaceWhereCondition(parentWhere, tbTmp, tableAlias, fieldReplaceRef);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 556 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 557 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 558 +            for(String tbTmp : fromTableNameSet){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 559 +                tableRef.put(tbTmp, tableAlias);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 560 +            }</span>
 561  
 562              System.out.println(&quot;-------build temporary query-----------&quot;);
 563              System.out.println(tmpSelectSql);
 564              System.out.println(&quot;---------------------------------------&quot;);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 565 +</span>
 566          }catch (Exception e){
 567              e.printStackTrace();




 568              throw new RuntimeException(e);
 569          }
 570      }
 571  
 572      /**
 573       * 抽取上层需用使用到的字段
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 574 -     * 由于where字段已经抽取到上一层了所以不用查询出来</span>
 575       * @param parentSelectList
 576       * @param fromTableNameSet
 577       * @return
 578       */
 579      private Set&lt;String&gt; extractSelectFields(SqlNodeList parentSelectList,
 580                                              Set&lt;String&gt; fromTableNameSet,
 581                                              Map&lt;String, String&gt; tableRef){
 582          Set&lt;String&gt; extractFieldList = Sets.newHashSet();
 583          for(SqlNode selectNode : parentSelectList.getList()){
 584              extractSelectField(selectNode, extractFieldList, fromTableNameSet, tableRef);
 585          }
 586  
 587          return extractFieldList;
 588      }
 589  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 590 -    private Set&lt;String&gt; extractSelectFieldFromJoinCondition(Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet, Set&lt;String&gt; fromTableNameSet){"> 590 -    private Set&lt;String&gt; extractSelectFieldFromJoinCondition(Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet, Set&lt;String&gt; 🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 591 +    private Set&lt;String&gt; extractSelectFieldFromJoinCondition(Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 592 +                                                            Set&lt;String&gt; fromTableNameSet,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 593 +                                                            Map&lt;String, String&gt; tableRef){</span>
 594          Set&lt;String&gt; extractFieldList = Sets.newHashSet();
 595          for(Tuple2&lt;String, String&gt; field : joinFieldSet){
 596              if(fromTableNameSet.contains(field.f0)){
 597                  extractFieldList.add(field.f0 + &quot;.&quot; + field.f1);
 598              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 599 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 600 +            if(tableRef.containsKey(field.f0)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 601 +                if(fromTableNameSet.contains(tableRef.get(field.f0))){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 602 +                    extractFieldList.add(tableRef.get(field.f0) + &quot;.&quot; + field.f1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 603 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 604 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 605 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 606 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 607 +        return extractFieldList;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 608 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 609 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 610 +    private Set&lt;String&gt; extractFieldFromGroupByList(SqlNodeList parentGroupByList,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 611 +                                                    Set&lt;String&gt; fromTableNameSet,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 612 +                                                    Map&lt;String, String&gt; tableRef){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 613 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 614 +        if(parentGroupByList == null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 615 +            return Sets.newHashSet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 616 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 617 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 618 +        Set&lt;String&gt; extractFieldList = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 619 +        for(SqlNode selectNode : parentGroupByList.getList()){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 620 +            extractSelectField(selectNode, extractFieldList, fromTableNameSet, tableRef);</span>
 621          }
 622  
 623          return extractFieldList;
 624      }
 625  
 626      /**
 627       * 从join的条件中获取字段信息
 628       * @param condition
 629       * @param joinFieldSet
 630       */
 631      private void extractJoinField(SqlNode condition, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet){
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 632 +        if (null == condition || condition.getKind() == LITERAL) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 633 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 634 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 635 +</span>
 636          SqlKind joinKind = condition.getKind();
 637          if( joinKind == AND || joinKind == EQUALS ){
 638              extractJoinField(((SqlBasicCall)condition).operands[0], joinFieldSet);
 639              extractJoinField(((SqlBasicCall)condition).operands[1], joinFieldSet);
 640          }else{
<abbr title=" 641              Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 641              Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must be format 🔵</abbr>
<abbr title=" 642              Tuple2&lt;String, String&gt; tuple2 = Tuple2.of(((SqlIdentifier)condition).names.get(0), ((SqlIdentifier)condition).names.get(1));"> 642              Tuple2&lt;String, String&gt; tuple2 = Tuple2.of(((SqlIdentifier)condition).names.get(0), ((SqlIdentifier)con🔵</abbr>
 643              joinFieldSet.add(tuple2);
 644          }
 645      }
 646  
 647  
 648      private void extractSelectField(SqlNode selectNode,
 649                                      Set&lt;String&gt; extractFieldSet,
 650                                      Set&lt;String&gt; fromTableNameSet,
 651                                      Map&lt;String, String&gt; tableRef){
 652          if (selectNode.getKind() == AS) {
 653              SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 654              extractSelectField(leftNode, extractFieldSet, fromTableNameSet, tableRef);
 655  
 656          }else if(selectNode.getKind() == IDENTIFIER) {
 657              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 658  
 659              if(sqlIdentifier.names.size() == 1){
 660                  return;
 661              }
 662  
 663              String tableName = sqlIdentifier.names.get(0);
 664              //TODO
 665              if(fromTableNameSet.contains(tableName)){
 666                  extractFieldSet.add(sqlIdentifier.toString());
 667              } else if(fromTableNameSet.contains(tableRef.get(tableName))){
 668                  //TODO extractFieldSet.add(sqlIdentifier.setName(0, tableRef.get(tableName)).toString());
 669              }
 670  
 671          }else if(  AGGREGATE.contains(selectNode.getKind())
 672                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 673                  || COMPARISON.contains(selectNode.getKind())
 674                  || selectNode.getKind() == OTHER_FUNCTION
 675                  || selectNode.getKind() == DIVIDE
 676                  || selectNode.getKind() == CAST
 677                  || selectNode.getKind() == TRIM
 678                  || selectNode.getKind() == TIMES
 679                  || selectNode.getKind() == PLUS
 680                  || selectNode.getKind() == NOT_IN
 681                  || selectNode.getKind() == OR
 682                  || selectNode.getKind() == AND
 683                  || selectNode.getKind() == MINUS
 684                  || selectNode.getKind() == TUMBLE
 685                  || selectNode.getKind() == TUMBLE_START
 686                  || selectNode.getKind() == TUMBLE_END
 687                  || selectNode.getKind() == SESSION
 688                  || selectNode.getKind() == SESSION_START
 689                  || selectNode.getKind() == SESSION_END
 690                  || selectNode.getKind() == HOP
 691                  || selectNode.getKind() == HOP_START
 692                  || selectNode.getKind() == HOP_END
 693                  || selectNode.getKind() == BETWEEN
 694                  || selectNode.getKind() == IS_NULL
 695                  || selectNode.getKind() == IS_NOT_NULL
 696                  || selectNode.getKind() == CONTAINS
 697                  || selectNode.getKind() == TIMESTAMP_ADD
 698                  || selectNode.getKind() == TIMESTAMP_DIFF
 699                  || selectNode.getKind() == LIKE
 700  
 701          ){
 702              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 703              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 704                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 705                  if(sqlNode instanceof SqlLiteral){
 706                      continue;
 707                  }
 708  
 709                  if(sqlNode instanceof SqlDataTypeSpec){
 710                      continue;
 711                  }
 712  
 713                  extractSelectField(sqlNode, extractFieldSet, fromTableNameSet, tableRef);
 714              }
 715  
 716          }else if(selectNode.getKind() == CASE){
 717              System.out.println(&quot;selectNode&quot;);
 718              SqlCase sqlCase = (SqlCase) selectNode;
 719              SqlNodeList whenOperands = sqlCase.getWhenOperands();
 720              SqlNodeList thenOperands = sqlCase.getThenOperands();
 721              SqlNode elseNode = sqlCase.getElseOperand();
 722  
 723              for(int i=0; i&lt;whenOperands.size(); i++){
 724                  SqlNode oneOperand = whenOperands.get(i);
 725                  extractSelectField(oneOperand, extractFieldSet, fromTableNameSet, tableRef);
 726              }
 727  
 728              for(int i=0; i&lt;thenOperands.size(); i++){
 729                  SqlNode oneOperand = thenOperands.get(i);
 730                  extractSelectField(oneOperand, extractFieldSet, fromTableNameSet, tableRef);
 731              }
 732  
 733              extractSelectField(elseNode, extractFieldSet, fromTableNameSet, tableRef);
 734          }else {
 735              //do nothing
 736          }
 737      }
 738  
 739  
<abbr title=" 740      private Tuple2&lt;String, String&gt; parseRightNode(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo,"> 740      private Tuple2&lt;String, String&gt; parseRightNode(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueIn🔵</abbr>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 741 -                                                  SqlNode parentWhere, SqlNodeList selectList) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 742 +                                                  SqlNode parentWhere, SqlNodeList selectList, SqlNodeList parentGroupByList) {"> 742 +                                                  SqlNode parentWhere, SqlNodeList selectList, SqlNodeList parentG🔵</abbr></span>
 743          Tuple2&lt;String, String&gt; tabName = new Tuple2&lt;&gt;(&quot;&quot;, &quot;&quot;);
 744          if(sqlNode.getKind() == IDENTIFIER){
 745              tabName.f0 = sqlNode.toString();
 746          }else{
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 747 -            AliasInfo aliasInfo = (AliasInfo)sideSQLParser.parseSql(sqlNode, sideTableSet, queueInfo, parentWhere, selectList);"> 747 -            AliasInfo aliasInfo = (AliasInfo)sideSQLParser.parseSql(sqlNode, sideTableSet, queueInfo, parentWhere,🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 748 +            AliasInfo aliasInfo = (AliasInfo)sideSQLParser.parseSql(sqlNode, sideTableSet, queueInfo, parentWhere, selectList, parentGroupByList);"> 748 +            AliasInfo aliasInfo = (AliasInfo)sideSQLParser.parseSql(sqlNode, sideTableSet, queueInfo, parentWhere,🔵</abbr></span>
 749              tabName.f0 = aliasInfo.getName();
 750              tabName.f1 = aliasInfo.getAlias();
 751          }
 752          return tabName;
 753      }
 754  
 755      private Tuple2&lt;String, String&gt; parseLeftNode(SqlNode sqlNode){
 756          Tuple2&lt;String, String&gt; tabName = new Tuple2&lt;&gt;(&quot;&quot;, &quot;&quot;);
 757          if(sqlNode.getKind() == IDENTIFIER){
 758              tabName.f0 = sqlNode.toString();
 759              tabName.f1 = sqlNode.toString();
 760          }else if (sqlNode.getKind() == AS){
 761              SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 762              SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 763  
 764              tabName.f0 = info.toString();
 765              tabName.f1 = alias.toString();
 766          }else {
 767              throw new RuntimeException(&quot;&quot;);
 768          }
 769  
 770          return tabName;
 771      }
 772  
 773      public String buildCondition(List&lt;SqlBasicCall&gt; conditionList){
 774          if(CollectionUtils.isEmpty(conditionList)){
 775              return &quot;&quot;;
 776          }
 777  
 778          return &quot; where &quot; + StringUtils.join(conditionList, &quot; AND &quot;);
 779      }
 780  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 781 -    public String buildSelectNode(Set&lt;String&gt; extractSelectField, Set&lt;String&gt; joinFieldSet){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 782 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 783 +     * 构建抽取表的查询字段信息</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 784 +     * 包括去除重复字段，名称相同的取别名</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 785 +     * @param extractSelectField</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 786 +     * @param joinFieldSet</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 787 +     * @return</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 788 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 789 +    public Set&lt;String&gt; buildSelectNode(Set&lt;String&gt; extractSelectField, Set&lt;String&gt; joinFieldSet){</span>
 790          if(CollectionUtils.isEmpty(extractSelectField)){
 791              throw new RuntimeException(&quot;no field is used&quot;);
 792          }
 793  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 794 -        Sets.SetView view = Sets.union(extractSelectField, joinFieldSet);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 795 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 796 -        return StringUtils.join(view, &quot;,&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 797 +        Sets.SetView&lt;String&gt; view = Sets.union(extractSelectField, joinFieldSet);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 798 +        Set&lt;String&gt; newFieldSet = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 799 +        //为相同的列取别名</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 800 +        HashBiMap&lt;String, String&gt; refFieldMap = HashBiMap.create();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 801 +        for(String field : view){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 802 +            String[] fieldInfo = StringUtils.split(field, &#x27;.&#x27;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 803 +            String aliasName = fieldInfo[1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 804 +            StringBuilder stringBuilder = new StringBuilder();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 805 +            stringBuilder.append(field);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 806 +            if(refFieldMap.inverse().get(aliasName) != null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 807 +                aliasName = ParseUtils.dealDuplicateFieldName(refFieldMap, aliasName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 808 +                stringBuilder.append(&quot; as &quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 809 +                        .append(aliasName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 810 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 811 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 812 +            refFieldMap.put(field, aliasName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 813 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 814 +            newFieldSet.add(stringBuilder.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 815 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 816 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 817 +        return newFieldSet;</span>
 818      }
 819  
 820      private boolean checkIsSideTable(String tableName, Set&lt;String&gt; sideTableList){
 821          if(sideTableList.contains(tableName)){
 822              return true;
 823          }
 824          return false;
 825      }
 826  
 827      private SqlBasicCall buildAsSqlNode(String internalTableName, SqlNode newSource) {
 828          SqlOperator operator = new SqlAsOperator();
 829          SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 830          SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(internalTableName, null, sqlParserPos);
 831          SqlNode[] sqlNodes = new SqlNode[2];
 832          sqlNodes[0] = newSource;
 833          sqlNodes[1] = sqlIdentifierAlias;
 834          return new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 835      }
 836  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 837 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 838 +     * 获取where中和指定表有关联的字段</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 839 +     * @param fromTableNameSet</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 840 +     * @param parentWhere</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 841 +     * @param extractCondition</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 842 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 843 +    private void extractWhereCondition(Set&lt;String&gt; fromTableNameSet, SqlBasicCall parentWhere, Set&lt;String&gt; extractCondition){"> 843 +    private void extractWhereCondition(Set&lt;String&gt; fromTableNameSet, SqlBasicCall parentWhere, Set&lt;String&gt; extract🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 844 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 845 +        if(parentWhere == null){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 846 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 847 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 848 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 849 +        SqlKind kind = parentWhere.getKind();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 850 +        if(kind == AND){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 851 +            extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[0], extractCondition);"> 851 +            extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[0], extractCondition)🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 852 +            extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[1], extractCondition);"> 852 +            extractWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[1], extractCondition)🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 853 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 854 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 855 +            Set&lt;String&gt; fieldInfos = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 856 +            TableUtils.getConditionRefTable(parentWhere, fieldInfos);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 857 +            fieldInfos.forEach(fieldInfo -&gt; {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 858 +                String[] splitInfo = StringUtils.split(fieldInfo, &quot;.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 859 +                if(splitInfo.length == 2 &amp;&amp; fromTableNameSet.contains(splitInfo[0])){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 860 +                    extractCondition.add(fieldInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 861 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 862 +            });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 863 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 864 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 865 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 866 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 867 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 868 +</span>
 869  
 870      /**
 871       * 检查关联的where 条件中的判断是否可以下移到新构建的子查询
 872       * @param fromTableNameSet
 873       * @param parentWhere
 874       * @param extractCondition
 875       * @return
 876       */
 877      private boolean checkAndRemoveWhereCondition(Set&lt;String&gt; fromTableNameSet,
 878                                                   SqlBasicCall parentWhere,
 879                                                   List&lt;SqlBasicCall&gt; extractCondition){
 880          if(parentWhere == null){
 881              return false;
 882          }
 883  
 884          SqlKind kind = parentWhere.getKind();
 885          if(kind == AND){
<abbr title=" 886              boolean removeLeft = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[0], extractCondition);"> 886              boolean removeLeft = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOper🔵</abbr>
<abbr title=" 887              boolean removeRight = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[1], extractCondition);"> 887              boolean removeRight = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOpe🔵</abbr>
 888              //DO remove
 889              if(removeLeft){
 890                  extractCondition.add(removeWhereConditionNode(parentWhere, 0));
 891              }
 892  
 893              if(removeRight){
 894                  extractCondition.add(removeWhereConditionNode(parentWhere, 1));
 895              }
 896  
 897              return false;
 898          } else {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 899 +            //条件表达式，如果该条件关联的表都是指定的表则移除</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 900 +            Set&lt;String&gt; fieldInfos = Sets.newHashSet();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 901 +            TableUtils.getConditionRefTable(parentWhere, fieldInfos);</span>
 902              Set&lt;String&gt; conditionRefTableNameSet = Sets.newHashSet();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 903 -            TableUtils.getConditionRefTable(parentWhere, conditionRefTableNameSet);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 904 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 905 +            fieldInfos.forEach(fieldInfo -&gt; {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 906 +                String[] splitInfo = StringUtils.split(fieldInfo, &quot;.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 907 +                if(splitInfo.length == 2){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 908 +                    conditionRefTableNameSet.add(splitInfo[0]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 909 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 910 +            });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 911 +</span>
 912  
 913              if(fromTableNameSet.containsAll(conditionRefTableNameSet)){
 914                  return true;
 915              }
 916  
 917              return false;
 918          }
 919      }
 920  
 921      /**
 922       * 抽取where 条件中指定的条件
 923       * @param parentWhere
 924       * @param index
 925       * @return
 926       */
 927      public SqlBasicCall removeWhereConditionNode(SqlBasicCall parentWhere, int index){
 928          SqlBasicCall oldCondition = (SqlBasicCall) parentWhere.getOperands()[index];
 929          parentWhere.setOperand(index, buildEmptyCondition());
 930          return oldCondition;
 931      }
 932  
 933      /**
 934       * 构建 1=1的 where 条件
 935       * @return
 936       */
 937      public SqlBasicCall buildEmptyCondition(){
 938          SqlBinaryOperator equalsOperators = SqlStdOperatorTable.EQUALS;
 939          SqlNode[] operands = new SqlNode[2];
 940          operands[0] = SqlLiteral.createExactNumeric(&quot;1&quot;, SqlParserPos.ZERO);
 941          operands[1] = SqlLiteral.createExactNumeric(&quot;1&quot;, SqlParserPos.ZERO);
 942  
 943          return new SqlBasicCall(equalsOperators, operands, SqlParserPos.ZERO);
 944      }
 945  
 946      /**
 947       * 替换join 条件中的表名称
 948       * @param node
 949       * @param tableMap 表名的关联关系
 950       */
 951      private SqlIdentifier checkAndReplaceJoinCondition(SqlNode node, Map&lt;String, String&gt; tableMap){
 952  
 953          SqlKind joinKind = node.getKind();
 954          if( joinKind == AND || joinKind == EQUALS ){
 955              SqlIdentifier leftNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[0], tableMap);
 956              SqlIdentifier rightNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[1], tableMap);
 957  
 958              if(leftNode != null){
 959                  ((SqlBasicCall)node).setOperand(0, leftNode);
 960              }
 961  
 962              if(rightNode != null){
 963                  ((SqlBasicCall)node).setOperand(1, leftNode);
 964              }
 965  
 966              return null;
 967          } else {
 968              //replace table
<abbr title=" 969              Preconditions.checkState(((SqlIdentifier)node).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 969              Preconditions.checkState(((SqlIdentifier)node).names.size() == 2, &quot;join condition must be format table🔵</abbr>
 970              String tbName = ((SqlIdentifier) node).names.get(0);
 971              if(tableMap.containsKey(tbName)){
 972                  tbName = tableMap.get(tbName);
 973                  return ((SqlIdentifier) node).setName(0, tbName);
 974              }
 975  
 976              return null;
 977          }
 978      }
 979  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 980 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 981 +     * 解析出临时中间表的属性列和源表之间的关系</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 982 +     * @param fieldSet</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 983 +     * @param newTableAliasName</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 984 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 985 +    public Map&lt;String, String&gt; buildTmpTableFieldRefOriField(Set&lt;String&gt; fieldSet, String newTableAliasName){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 986 +        Map&lt;String, String&gt; refInfo = Maps.newConcurrentMap();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 987 +        for(String field : fieldSet){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 988 +            String[] fields = StringUtils.splitByWholeSeparator(field, &quot;as&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 989 +            String oldKey = field;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 990 +            String[] oldFieldInfo = StringUtils.splitByWholeSeparator(fields[0], &quot;.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 991 +            String oldFieldName = oldFieldInfo.length == 2 ? oldFieldInfo[1] : oldFieldInfo[0];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 992 +            String newKey = fields.length == 2 ? newTableAliasName + &quot;.&quot; + fields[1] :</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 993 +                    newTableAliasName + &quot;.&quot; + oldFieldName;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 994 +            refInfo.put(oldKey, newKey);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 995 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 996 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 997 +        return refInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 998 +    }</span>
 999  
1000  
1001  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.side;
  21  
  22  import com.dtstack.flink.sql.config.CalciteConfig;


  23  import com.dtstack.flink.sql.util.TableUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import com.esotericsoftware.minlog.Log;</span>
  25  import com.google.common.base.Preconditions;
  26  import com.google.common.collect.Lists;
  27  import com.google.common.collect.Sets;

  28  import org.apache.calcite.sql.JoinType;
  29  import org.apache.calcite.sql.SqlAsOperator;
  30  import org.apache.calcite.sql.SqlBasicCall;
  31  import org.apache.calcite.sql.SqlBinaryOperator;
  32  import org.apache.calcite.sql.SqlDataTypeSpec;
  33  import org.apache.calcite.sql.SqlIdentifier;
  34  import org.apache.calcite.sql.SqlJoin;
  35  import org.apache.calcite.sql.SqlKind;
  36  import org.apache.calcite.sql.SqlLiteral;
  37  import org.apache.calcite.sql.SqlNode;
  38  import org.apache.calcite.sql.SqlNodeList;
  39  import org.apache.calcite.sql.SqlOperator;
  40  import org.apache.calcite.sql.fun.SqlCase;
  41  import org.apache.calcite.sql.fun.SqlStdOperatorTable;
  42  import org.apache.calcite.sql.parser.SqlParser;
  43  import org.apache.calcite.sql.parser.SqlParserPos;
  44  import org.apache.commons.collections.CollectionUtils;
  45  import org.apache.commons.lang3.StringUtils;
  46  import org.apache.flink.api.java.tuple.Tuple2;

  47  
  48  import java.util.List;
  49  import java.util.Map;
  50  import java.util.Queue;
  51  import java.util.Set;
  52  
  53  import static org.apache.calcite.sql.SqlKind.*;
  54  
  55  /**
  56   * 处理join 节点
  57   * 1:如果包含维表节点替换为临时查询
  58   * Date: 2020/2/27
  59   * Company: www.dtstack.com
  60   * @author xuchao
  61   */
  62  
  63  public class JoinNodeDealer {
  64  
  65      //用来构建临时的中间查询
  66      private static final String SELECT_TEMP_SQL = &quot;select %s from %s %s&quot;;
  67  
  68      private SideSQLParser sideSQLParser;
  69  
  70      public JoinNodeDealer(SideSQLParser sideSQLParser){
  71          this.sideSQLParser = sideSQLParser;
  72      }
  73  
  74      /**
  75       * 解析 join 操作
  76       * @param joinNode
  77       * @param sideTableSet 标明哪些表名是维表
  78       * @param queueInfo

  79       * @param parentWhere join 关联的最上层的where 节点
  80       * @param parentSelectList join 关联的最上层的select 节点
  81       * @param joinFieldSet
  82       * @param tableRef 存储构建临时表查询后源表和新表之间的关联关系
  83       * @return
  84       */
  85      public JoinInfo dealJoinNode(SqlJoin joinNode, Set&lt;String&gt; sideTableSet,
  86                                   Queue&lt;Object&gt; queueInfo, SqlNode parentWhere,
  87                                   SqlNodeList parentSelectList, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,
  88                                   Map&lt;String, String&gt; tableRef) {










  89          SqlNode leftNode = joinNode.getLeft();
  90          SqlNode rightNode = joinNode.getRight();
  91          JoinType joinType = joinNode.getJoinType();
  92  
  93          String leftTbName = &quot;&quot;;
  94          String leftTbAlias = &quot;&quot;;
  95          String rightTableName = &quot;&quot;;
  96          String rightTableAlias = &quot;&quot;;
  97          boolean leftTbisTmp = false;
  98  
  99          //如果是连续join 判断是否已经处理过添加到执行队列
 100          Boolean needBuildTemp = false;


 101          extractJoinField(joinNode.getCondition(), joinFieldSet);
 102  
 103          if(leftNode.getKind() == IDENTIFIER){
 104              leftTbName = leftNode.toString();
 105          } else if (leftNode.getKind() == JOIN) {

 106              //处理连续join
 107              Tuple2&lt;Boolean, JoinInfo&gt; nestJoinResult = dealNestJoin((SqlJoin) leftNode, sideTableSet,
 108                      queueInfo, parentWhere, parentSelectList, joinFieldSet, tableRef);
 109              needBuildTemp = nestJoinResult.f0;
 110              SqlBasicCall buildAs = TableUtils.buildAsNodeByJoinInfo(nestJoinResult.f1, null, null);
 111  
 112              if(needBuildTemp){
 113                  //记录表之间的关联关系
 114                  String newLeftTableName = buildAs.getOperands()[1].toString();
 115                  Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 116                  TableUtils.getFromTableInfo(joinNode.getLeft(), fromTableNameSet);
 117                  for(String tbTmp : fromTableNameSet){
 118                      tableRef.put(tbTmp, newLeftTableName);
 119                  }
 120  
 121                  //替换leftNode 为新的查询
 122                  joinNode.setLeft(buildAs);
 123                  leftNode = buildAs;
 124  
 125                  //替换select field 中的对应字段
 126                  for(SqlNode sqlNode : parentSelectList.getList()){
 127                      for(String tbTmp : fromTableNameSet) {
 128                          TableUtils.replaceSelectFieldTable(sqlNode, tbTmp, newLeftTableName);
 129                      }
 130                  }
 131  
 132                  //替换where 中的条件相关
 133                  for(String tbTmp : fromTableNameSet){
 134                      TableUtils.replaceWhereCondition(parentWhere, tbTmp, newLeftTableName);
 135                  }
 136  
 137                  leftTbisTmp = true;
 138  
 139              }
 140  
 141              leftTbName = buildAs.getOperands()[0].toString();
 142              leftTbAlias = buildAs.getOperands()[1].toString();
 143  
 144          } else if (leftNode.getKind() == AS) {
<abbr title=" 145              AliasInfo aliasInfo = (AliasInfo) sideSQLParser.parseSql(leftNode, sideTableSet, queueInfo, parentWhere, parentSelectList);"> 145              AliasInfo aliasInfo = (AliasInfo) sideSQLParser.parseSql(leftNode, sideTableSet, queueInfo, parentWher🔵</abbr>







 146              leftTbName = aliasInfo.getName();
 147              leftTbAlias = aliasInfo.getAlias();
 148  
 149          } else {
<abbr title=" 150              throw new RuntimeException(String.format(&quot;---not deal node with type %s&quot;, leftNode.getKind().toString()));"> 150              throw new RuntimeException(String.format(&quot;---not deal node with type %s&quot;, leftNode.getKind().toString(🔵</abbr>



 151          }
 152  
 153          boolean leftIsSide = checkIsSideTable(leftTbName, sideTableSet);
 154          Preconditions.checkState(!leftIsSide, &quot;side-table must be at the right of join operator&quot;);
 155  
<abbr title=" 156          Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentWhere, parentSelectList);"> 156          Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentW🔵</abbr>

 157          rightTableName = rightTableNameAndAlias.f0;
 158          rightTableAlias = rightTableNameAndAlias.f1;
 159  
 160          boolean rightIsSide = checkIsSideTable(rightTableName, sideTableSet);
 161          if(rightIsSide &amp;&amp; joinType == JoinType.RIGHT){
<abbr title=" 162              throw new RuntimeException(&quot;side join not support join type of right[current support inner join and left join]&quot;);"> 162              throw new RuntimeException(&quot;side join not support join type of right[current support inner join and le🔵</abbr>
 163          }
 164  
 165          if(leftNode.getKind() == JOIN &amp;&amp; rightIsSide){
 166              needBuildTemp = true;
 167          }
 168  
 169          JoinInfo tableInfo = new JoinInfo();
 170          tableInfo.setLeftTableName(leftTbName);
 171          tableInfo.setRightTableName(rightTableName);
 172          if (StringUtils.isEmpty(leftTbAlias)){
 173              tableInfo.setLeftTableAlias(leftTbName);
 174          } else {
 175              tableInfo.setLeftTableAlias(leftTbAlias);
 176          }
 177  
 178          if (StringUtils.isEmpty(rightTableAlias)){
 179              tableInfo.setRightTableAlias(rightTableName);
 180          } else {
 181              tableInfo.setRightTableAlias(rightTableAlias);
 182          }
 183  
 184          TableUtils.replaceJoinFieldRefTableName(joinNode.getCondition(), tableRef);
 185  
 186          tableInfo.setLeftIsTmpTable(leftTbisTmp);
 187          tableInfo.setLeftIsSideTable(leftIsSide);






 188          tableInfo.setRightIsSideTable(rightIsSide);
 189          tableInfo.setLeftNode(leftNode);
 190          tableInfo.setRightNode(rightNode);
 191          tableInfo.setJoinType(joinType);
 192          tableInfo.setCondition(joinNode.getCondition());
 193  
 194          if(tableInfo.getLeftNode().getKind() != AS &amp;&amp; needBuildTemp){
<abbr title=" 195              extractTemporaryQuery(tableInfo.getLeftNode(), tableInfo.getLeftTableAlias(), (SqlBasicCall) parentWhere,"> 195              extractTemporaryQuery(tableInfo.getLeftNode(), tableInfo.getLeftTableAlias(), (SqlBasicCall) parentWhe🔵</abbr>
 196                      parentSelectList, queueInfo, joinFieldSet, tableRef);
 197          }else {
 198              SqlKind asNodeFirstKind = ((SqlBasicCall)tableInfo.getLeftNode()).operands[0].getKind();
 199              if(asNodeFirstKind == SELECT){
 200                  queueInfo.offer(tableInfo.getLeftNode());
 201                  tableInfo.setLeftNode(((SqlBasicCall)tableInfo.getLeftNode()).operands[1]);
 202              }
 203          }

















 204          return tableInfo;
 205      }
 206  
 207  
 208      //处理多层join
 209      private Tuple2&lt;Boolean, JoinInfo&gt; dealNestJoin(SqlJoin joinNode, Set&lt;String&gt; sideTableSet,
 210                                                     Queue&lt;Object&gt; queueInfo, SqlNode parentWhere,
<abbr title=" 211                                                     SqlNodeList selectList, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,"> 211                                                     SqlNodeList selectList, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSe🔵</abbr>
 212                                                     Map&lt;String, String&gt; tableRef){
 213          SqlNode rightNode = joinNode.getRight();
<abbr title=" 214          Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentWhere, selectList);"> 214          Tuple2&lt;String, String&gt; rightTableNameAndAlias = parseRightNode(rightNode, sideTableSet, queueInfo, parentW🔵</abbr>
<abbr title=" 215          JoinInfo joinInfo = dealJoinNode(joinNode, sideTableSet, queueInfo, parentWhere, selectList, joinFieldSet, tableRef);"> 215          JoinInfo joinInfo = dealJoinNode(joinNode, sideTableSet, queueInfo, parentWhere, selectList, joinFieldSet,🔵</abbr>





































































































 216  
 217          String rightTableName = rightTableNameAndAlias.f0;
 218          boolean rightIsSide = checkIsSideTable(rightTableName, sideTableSet);
 219          boolean needBuildTemp = false;
 220  
 221          if(!rightIsSide){
 222              //右表不是维表的情况
 223          }else{
 224              //右边表是维表需要重新构建左表的临时查询
 225              queueInfo.offer(joinInfo);
 226              needBuildTemp = true;
 227          }
 228  
 229          //return Tuple2.of(needBuildTemp, TableUtils.buildAsNodeByJoinInfo(joinInfo, null, null));
 230          return Tuple2.of(needBuildTemp, joinInfo);
 231      }
 232  
 233      private void extractTemporaryQuery(SqlNode node, String tableAlias, SqlBasicCall parentWhere,
 234                                         SqlNodeList parentSelectList, Queue&lt;Object&gt; queueInfo,





















































































































 235                                         Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet,
 236                                         Map&lt;String, String&gt; tableRef){


 237          try{
 238              //父一级的where 条件中如果只和临时查询相关的条件都截取进来
 239              Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 240              List&lt;SqlBasicCall&gt; extractCondition = Lists.newArrayList();
 241  
 242              TableUtils.getFromTableInfo(node, fromTableNameSet);
 243              checkAndRemoveWhereCondition(fromTableNameSet, parentWhere, extractCondition);
 244  
 245              if(node.getKind() == JOIN){
 246                  checkAndReplaceJoinCondition(((SqlJoin)node).getCondition(), tableRef);
 247              }
 248  
 249              Set&lt;String&gt; extractSelectField = extractSelectFields(parentSelectList, fromTableNameSet, tableRef);
<abbr title=" 250              Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSet);"> 250              Set&lt;String&gt; fieldFromJoinCondition = extractSelectFieldFromJoinCondition(joinFieldSet, fromTableNameSe🔵</abbr>
 251              String extractSelectFieldStr = buildSelectNode(extractSelectField, fieldFromJoinCondition);







 252              String extractConditionStr = buildCondition(extractCondition);
 253  
 254              String tmpSelectSql = String.format(SELECT_TEMP_SQL,
 255                      extractSelectFieldStr,
 256                      node.toString(),
 257                      extractConditionStr);
 258  
 259              SqlParser sqlParser = SqlParser.create(tmpSelectSql, CalciteConfig.MYSQL_LEX_CONFIG);
 260              SqlNode sqlNode = sqlParser.parseStmt();



 261              SqlBasicCall sqlBasicCall = buildAsSqlNode(tableAlias, sqlNode);
 262              queueInfo.offer(sqlBasicCall);

















 263  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 264 -            System.out.println(&quot;-------build temporary query-----------&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 265 -            System.out.println(tmpSelectSql);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 266 -            System.out.println(&quot;---------------------------------------&quot;);</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 267 -        }catch (Exception e){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 268 -            e.printStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 269 +            Log.info(&quot;-------build temporary query-----------\n{}&quot;, tmpSelectSql);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 270 +            Log.info(&quot;---------------------------------------&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +        } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 272 +            Log.error(&quot;&quot;, e);</span>
 273              throw new RuntimeException(e);
 274          }
 275      }
 276  
 277      /**
 278       * 抽取上层需用使用到的字段
 279       * 由于where字段已经抽取到上一层了所以不用查询出来
 280       * @param parentSelectList
 281       * @param fromTableNameSet
 282       * @return
 283       */
 284      private Set&lt;String&gt; extractSelectFields(SqlNodeList parentSelectList,
 285                                              Set&lt;String&gt; fromTableNameSet,
 286                                              Map&lt;String, String&gt; tableRef){
 287          Set&lt;String&gt; extractFieldList = Sets.newHashSet();
 288          for(SqlNode selectNode : parentSelectList.getList()){
 289              extractSelectField(selectNode, extractFieldList, fromTableNameSet, tableRef);
 290          }
 291  
 292          return extractFieldList;
 293      }
 294  
<abbr title=" 295      private Set&lt;String&gt; extractSelectFieldFromJoinCondition(Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet, Set&lt;String&gt; fromTableNameSet){"> 295      private Set&lt;String&gt; extractSelectFieldFromJoinCondition(Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet, Set&lt;String&gt; 🔵</abbr>



 296          Set&lt;String&gt; extractFieldList = Sets.newHashSet();
 297          for(Tuple2&lt;String, String&gt; field : joinFieldSet){
 298              if(fromTableNameSet.contains(field.f0)){
 299                  extractFieldList.add(field.f0 + &quot;.&quot; + field.f1);
 300              }






















 301          }
 302  
 303          return extractFieldList;
 304      }
 305  
 306      /**
 307       * 从join的条件中获取字段信息
 308       * @param condition
 309       * @param joinFieldSet
 310       */
 311      private void extractJoinField(SqlNode condition, Set&lt;Tuple2&lt;String, String&gt;&gt; joinFieldSet){




 312          SqlKind joinKind = condition.getKind();
 313          if( joinKind == AND || joinKind == EQUALS ){
 314              extractJoinField(((SqlBasicCall)condition).operands[0], joinFieldSet);
 315              extractJoinField(((SqlBasicCall)condition).operands[1], joinFieldSet);
 316          }else{
<abbr title=" 317              Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 317              Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must be format 🔵</abbr>
<abbr title=" 318              Tuple2&lt;String, String&gt; tuple2 = Tuple2.of(((SqlIdentifier)condition).names.get(0), ((SqlIdentifier)condition).names.get(1));"> 318              Tuple2&lt;String, String&gt; tuple2 = Tuple2.of(((SqlIdentifier)condition).names.get(0), ((SqlIdentifier)con🔵</abbr>
 319              joinFieldSet.add(tuple2);
 320          }
 321      }
 322  
 323  
 324      private void extractSelectField(SqlNode selectNode,
 325                                      Set&lt;String&gt; extractFieldSet,
 326                                      Set&lt;String&gt; fromTableNameSet,
 327                                      Map&lt;String, String&gt; tableRef){
 328          if (selectNode.getKind() == AS) {
 329              SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 330              extractSelectField(leftNode, extractFieldSet, fromTableNameSet, tableRef);
 331  
 332          }else if(selectNode.getKind() == IDENTIFIER) {
 333              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 334  
 335              if(sqlIdentifier.names.size() == 1){
 336                  return;
 337              }
 338  
 339              String tableName = sqlIdentifier.names.get(0);
 340              //TODO
 341              if(fromTableNameSet.contains(tableName)){
 342                  extractFieldSet.add(sqlIdentifier.toString());
 343              } else if(fromTableNameSet.contains(tableRef.get(tableName))){
 344                  //TODO extractFieldSet.add(sqlIdentifier.setName(0, tableRef.get(tableName)).toString());
 345              }
 346  
 347          }else if(  AGGREGATE.contains(selectNode.getKind())
 348                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 349                  || COMPARISON.contains(selectNode.getKind())
 350                  || selectNode.getKind() == OTHER_FUNCTION
 351                  || selectNode.getKind() == DIVIDE
 352                  || selectNode.getKind() == CAST
 353                  || selectNode.getKind() == TRIM
 354                  || selectNode.getKind() == TIMES
 355                  || selectNode.getKind() == PLUS
 356                  || selectNode.getKind() == NOT_IN
 357                  || selectNode.getKind() == OR
 358                  || selectNode.getKind() == AND
 359                  || selectNode.getKind() == MINUS
 360                  || selectNode.getKind() == TUMBLE
 361                  || selectNode.getKind() == TUMBLE_START
 362                  || selectNode.getKind() == TUMBLE_END
 363                  || selectNode.getKind() == SESSION
 364                  || selectNode.getKind() == SESSION_START
 365                  || selectNode.getKind() == SESSION_END
 366                  || selectNode.getKind() == HOP
 367                  || selectNode.getKind() == HOP_START
 368                  || selectNode.getKind() == HOP_END
 369                  || selectNode.getKind() == BETWEEN
 370                  || selectNode.getKind() == IS_NULL
 371                  || selectNode.getKind() == IS_NOT_NULL
 372                  || selectNode.getKind() == CONTAINS
 373                  || selectNode.getKind() == TIMESTAMP_ADD
 374                  || selectNode.getKind() == TIMESTAMP_DIFF
 375                  || selectNode.getKind() == LIKE
 376  
 377          ){
 378              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 379              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 380                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 381                  if(sqlNode instanceof SqlLiteral){
 382                      continue;
 383                  }
 384  
 385                  if(sqlNode instanceof SqlDataTypeSpec){
 386                      continue;
 387                  }
 388  
 389                  extractSelectField(sqlNode, extractFieldSet, fromTableNameSet, tableRef);
 390              }
 391  
 392          }else if(selectNode.getKind() == CASE){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 393 -            System.out.println(&quot;selectNode&quot;);</span>
 394              SqlCase sqlCase = (SqlCase) selectNode;
 395              SqlNodeList whenOperands = sqlCase.getWhenOperands();
 396              SqlNodeList thenOperands = sqlCase.getThenOperands();
 397              SqlNode elseNode = sqlCase.getElseOperand();
 398  
 399              for(int i=0; i&lt;whenOperands.size(); i++){
 400                  SqlNode oneOperand = whenOperands.get(i);
 401                  extractSelectField(oneOperand, extractFieldSet, fromTableNameSet, tableRef);
 402              }
 403  
 404              for(int i=0; i&lt;thenOperands.size(); i++){
 405                  SqlNode oneOperand = thenOperands.get(i);
 406                  extractSelectField(oneOperand, extractFieldSet, fromTableNameSet, tableRef);
 407              }
 408  
 409              extractSelectField(elseNode, extractFieldSet, fromTableNameSet, tableRef);
 410          }else {
 411              //do nothing
 412          }
 413      }
 414  
 415  
<abbr title=" 416      private Tuple2&lt;String, String&gt; parseRightNode(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueInfo,"> 416      private Tuple2&lt;String, String&gt; parseRightNode(SqlNode sqlNode, Set&lt;String&gt; sideTableSet, Queue&lt;Object&gt; queueIn🔵</abbr>
 417                                                    SqlNode parentWhere, SqlNodeList selectList) {

 418          Tuple2&lt;String, String&gt; tabName = new Tuple2&lt;&gt;(&quot;&quot;, &quot;&quot;);
 419          if(sqlNode.getKind() == IDENTIFIER){
 420              tabName.f0 = sqlNode.toString();
 421          }else{
<abbr title=" 422              AliasInfo aliasInfo = (AliasInfo)sideSQLParser.parseSql(sqlNode, sideTableSet, queueInfo, parentWhere, selectList);"> 422              AliasInfo aliasInfo = (AliasInfo)sideSQLParser.parseSql(sqlNode, sideTableSet, queueInfo, parentWhere,🔵</abbr>

 423              tabName.f0 = aliasInfo.getName();
 424              tabName.f1 = aliasInfo.getAlias();
 425          }
 426          return tabName;
 427      }
 428  
 429      private Tuple2&lt;String, String&gt; parseLeftNode(SqlNode sqlNode){
 430          Tuple2&lt;String, String&gt; tabName = new Tuple2&lt;&gt;(&quot;&quot;, &quot;&quot;);
 431          if(sqlNode.getKind() == IDENTIFIER){
 432              tabName.f0 = sqlNode.toString();
 433              tabName.f1 = sqlNode.toString();
 434          }else if (sqlNode.getKind() == AS){
 435              SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 436              SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 437  
 438              tabName.f0 = info.toString();
 439              tabName.f1 = alias.toString();
 440          }else {
 441              throw new RuntimeException(&quot;&quot;);
 442          }
 443  
 444          return tabName;
 445      }
 446  
 447      public String buildCondition(List&lt;SqlBasicCall&gt; conditionList){
 448          if(CollectionUtils.isEmpty(conditionList)){
 449              return &quot;&quot;;
 450          }
 451  
 452          return &quot; where &quot; + StringUtils.join(conditionList, &quot; AND &quot;);
 453      }
 454  
 455      public String buildSelectNode(Set&lt;String&gt; extractSelectField, Set&lt;String&gt; joinFieldSet){








 456          if(CollectionUtils.isEmpty(extractSelectField)){
 457              throw new RuntimeException(&quot;no field is used&quot;);
 458          }
 459  
 460          Sets.SetView view = Sets.union(extractSelectField, joinFieldSet);
 461  
 462          return StringUtils.join(view, &quot;,&quot;);





















 463      }
 464  
 465      private boolean checkIsSideTable(String tableName, Set&lt;String&gt; sideTableList){
 466          if(sideTableList.contains(tableName)){
 467              return true;
 468          }
 469          return false;
 470      }
 471  
 472      private SqlBasicCall buildAsSqlNode(String internalTableName, SqlNode newSource) {
 473          SqlOperator operator = new SqlAsOperator();
 474          SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 475          SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(internalTableName, null, sqlParserPos);
 476          SqlNode[] sqlNodes = new SqlNode[2];
 477          sqlNodes[0] = newSource;
 478          sqlNodes[1] = sqlIdentifierAlias;
 479          return new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 480      }
 481  
































 482  
 483      /**
 484       * 检查关联的where 条件中的判断是否可以下移到新构建的子查询
 485       * @param fromTableNameSet
 486       * @param parentWhere
 487       * @param extractCondition
 488       * @return
 489       */
 490      private boolean checkAndRemoveWhereCondition(Set&lt;String&gt; fromTableNameSet,
 491                                                   SqlBasicCall parentWhere,
 492                                                   List&lt;SqlBasicCall&gt; extractCondition){
 493          if(parentWhere == null){
 494              return false;
 495          }
 496  
 497          SqlKind kind = parentWhere.getKind();
 498          if(kind == AND){
<abbr title=" 499              boolean removeLeft = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[0], extractCondition);"> 499              boolean removeLeft = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOper🔵</abbr>
<abbr title=" 500              boolean removeRight = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOperands()[1], extractCondition);"> 500              boolean removeRight = checkAndRemoveWhereCondition(fromTableNameSet, (SqlBasicCall) parentWhere.getOpe🔵</abbr>
 501              //DO remove
 502              if(removeLeft){
 503                  extractCondition.add(removeWhereConditionNode(parentWhere, 0));
 504              }
 505  
 506              if(removeRight){
 507                  extractCondition.add(removeWhereConditionNode(parentWhere, 1));
 508              }
 509  
 510              return false;
 511          } else {



 512              Set&lt;String&gt; conditionRefTableNameSet = Sets.newHashSet();
 513              TableUtils.getConditionRefTable(parentWhere, conditionRefTableNameSet);








 514  
 515              if(fromTableNameSet.containsAll(conditionRefTableNameSet)){
 516                  return true;
 517              }
 518  
 519              return false;
 520          }
 521      }
 522  
 523      /**
 524       * 抽取where 条件中指定的条件
 525       * @param parentWhere
 526       * @param index
 527       * @return
 528       */
 529      public SqlBasicCall removeWhereConditionNode(SqlBasicCall parentWhere, int index){
 530          SqlBasicCall oldCondition = (SqlBasicCall) parentWhere.getOperands()[index];
 531          parentWhere.setOperand(index, buildEmptyCondition());
 532          return oldCondition;
 533      }
 534  
 535      /**
 536       * 构建 1=1的 where 条件
 537       * @return
 538       */
 539      public SqlBasicCall buildEmptyCondition(){
 540          SqlBinaryOperator equalsOperators = SqlStdOperatorTable.EQUALS;
 541          SqlNode[] operands = new SqlNode[2];
 542          operands[0] = SqlLiteral.createExactNumeric(&quot;1&quot;, SqlParserPos.ZERO);
 543          operands[1] = SqlLiteral.createExactNumeric(&quot;1&quot;, SqlParserPos.ZERO);
 544  
 545          return new SqlBasicCall(equalsOperators, operands, SqlParserPos.ZERO);
 546      }
 547  
 548      /**
 549       * 替换join 条件中的表名称
 550       * @param node
 551       * @param tableMap 表名的关联关系
 552       */
 553      private SqlIdentifier checkAndReplaceJoinCondition(SqlNode node, Map&lt;String, String&gt; tableMap){
 554  
 555          SqlKind joinKind = node.getKind();
 556          if( joinKind == AND || joinKind == EQUALS ){
 557              SqlIdentifier leftNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[0], tableMap);
 558              SqlIdentifier rightNode = checkAndReplaceJoinCondition(((SqlBasicCall)node).operands[1], tableMap);
 559  
 560              if(leftNode != null){
 561                  ((SqlBasicCall)node).setOperand(0, leftNode);
 562              }
 563  
 564              if(rightNode != null){
 565                  ((SqlBasicCall)node).setOperand(1, leftNode);
 566              }
 567  
 568              return null;
 569          } else {
 570              //replace table
<abbr title=" 571              Preconditions.checkState(((SqlIdentifier)node).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 571              Preconditions.checkState(((SqlIdentifier)node).names.size() == 2, &quot;join condition must be format table🔵</abbr>
 572              String tbName = ((SqlIdentifier) node).names.get(0);
 573              if(tableMap.containsKey(tbName)){
 574                  tbName = tableMap.get(tbName);
 575                  return ((SqlIdentifier) node).setName(0, tbName);
 576              }
 577  
 578              return null;
 579          }
 580      }
 581  



















 582  
 583  
 584  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            