<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>377</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    377
                    <a href="376.html">prev</a>
                    <a href="378.html">next</a>
                    <a href="377_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_1f467e8db1be23610cdc95a5c5e140b78d7f2639_core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;1f467e8db1be23610cdc95a5c5e140b78d7f2639:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;1f467e8db1be23610cdc95a5c5e140b78d7f2639^1:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;1f467e8db1be23610cdc95a5c5e140b78d7f2639^2:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;fe59047deaebb385b0ac710d0a60ac6f9faed0a7:core/src/main/java/com/dtstack/flink/sql/side/SideSqlExec.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import org.apache.flink.api.common.typeinfo.TypeInformation;
  24 import org.apache.flink.api.java.tuple.Tuple2;
  25 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  26 import org.apache.flink.streaming.api.datastream.DataStream;
  27 import org.apache.flink.table.api.StreamQueryConfig;
  28 import org.apache.flink.table.api.Table;
  29 import org.apache.flink.table.api.TableSchema;
  30 import org.apache.flink.table.api.java.StreamTableEnvironment;
  31 import org.apache.flink.table.runtime.CRowKeySelector;
  32 import org.apache.flink.table.runtime.types.CRow;
  33 import org.apache.flink.table.runtime.types.CRowTypeInfo;
  34 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  35 import org.apache.flink.types.Row;
  36 
  37 import com.dtstack.flink.sql.enums.ECacheType;
  38 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  39 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  40 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  41 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  42 import com.dtstack.flink.sql.util.ClassUtil;
  43 import com.dtstack.flink.sql.util.ParseUtils;
  44 import com.dtstack.flink.sql.util.TableUtils;
  45 import com.google.common.base.Preconditions;
  46 import com.google.common.collect.HashBasedTable;
  47 import com.google.common.collect.Lists;
  48 import com.google.common.collect.Maps;
  49 import com.google.common.collect.Sets;
  50 import org.apache.calcite.sql.SqlBasicCall;
  51 import org.apache.calcite.sql.SqlIdentifier;
  52 import org.apache.calcite.sql.SqlKind;
  53 import org.apache.calcite.sql.SqlNode;
  54 import org.apache.calcite.sql.SqlSelect;
  55 import org.apache.calcite.sql.SqlWithItem;
  56 import org.apache.calcite.sql.parser.SqlParseException;
  57 import org.apache.commons.collections.CollectionUtils;
  58 import org.apache.commons.lang3.StringUtils;
  59 import org.slf4j.Logger;
  60 import org.slf4j.LoggerFactory;
  61 
  62 import java.sql.Timestamp;
  63 import java.util.Arrays;
  64 import java.util.LinkedList;
  65 import java.util.List;
  66 import java.util.Map;
  67 import java.util.Queue;
  68 import java.util.Set;
  69 
  70 import static org.apache.calcite.sql.SqlKind.*;
  71 
  72 /**
  73  * Reason:
  74  * Date: 2018/7/24
  75  * Company: www.dtstack.com
  76  * @author xuchao
  77  */
  78 
  79 public class SideSqlExec {
  80 
  81     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  82 
  83     private String localSqlPluginPath = null;
  84 
  85     private String tmpFields = null;
  86 
  87     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  88 
  89     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  90 
  91     public void exec(String sql,
  92                      Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
  93                      StreamTableEnvironment tableEnv,
  94                      Map&lt;String, Table&gt; tableCache,
  95                      StreamQueryConfig queryConfig,
  96                      CreateTmpTableParser.SqlParserResult createView,
  97                      String scope) throws Exception {
  98         if(localSqlPluginPath == null){
  99             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 100         }
 101 
 102         localTableCache.putAll(tableCache);
 103         try {
 104             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 105         } catch (Exception e) {
 106             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 107         }
 108 
 109         if(createView != null){
 110             LOG.warn(&quot;create view info\n&quot;);
 111             LOG.warn(createView.getExecSql());
 112             LOG.warn(&quot;-----------------&quot;);
 113         }
 114 
 115         SideSQLParser sideSQLParser = new SideSQLParser();
 116         sideSQLParser.setLocalTableCache(localTableCache);
 117 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 118         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 119         Object pollObj = null;</span>
 120 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 121             LOG.warn(createView.getExecSql());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 122             LOG.warn(&quot;-----------------&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 123         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 124 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 125         SideSQLParser sideSQLParser = new SideSQLParser();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 126         sideSQLParser.setLocalTableCache(localTableCache);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 127         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 128         Object pollObj = null;</span>
 129 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 130         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 131         Object pollObj;</span>
 132 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 133 
 134         while((pollObj = exeQueue.poll()) != null){
 135 
 136             if(pollObj instanceof SqlNode){
 137                 SqlNode pollSqlNode = (SqlNode) pollObj;
 138 
 139 
 140                 if(pollSqlNode.getKind() == INSERT){
 141                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 142                     if(LOG.isInfoEnabled()){
 143                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 144                     }
 145 
 146                 }else if(pollSqlNode.getKind() == AS){
 147                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 148 
 149                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 150                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 151                     String TableAlias = sqlWithItem.name.toString();
 152                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 153                     tableEnv.registerTable(TableAlias, table);
 154 
 155                 } else if (pollSqlNode.getKind() == SELECT){
<abbr title=" 156                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 156                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 157                     Table table = tableEnv.sqlQuery(pollObj.toString());
 158 
 159                     if (createView.getFieldsInfoStr() == null){
 160                         tableEnv.registerTable(createView.getTableName(), table);
 161                     } else {
 162                         if (checkFieldsInfo(createView, table)){
 163                             table = table.as(tmpFields);
 164                             tableEnv.registerTable(createView.getTableName(), table);
 165                         } else {
 166                             throw new RuntimeException(&quot;Fields mismatch&quot;);
 167                         }
 168                     }
 169 
 170                     localTableCache.put(createView.getTableName(), table);
 171                 }
 172 
 173             }else if (pollObj instanceof JoinInfo){
 174                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 175                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 176             }
 177         }
 178 
 179     }
 180 
 181 
 182     /**
 183      * 解析出as查询的表和字段的关系
 184      * @param asSqlNode
 185      * @param tableCache
 186      * @return
 187      */
 188     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 189         SqlNode info = asSqlNode.getOperands()[0];
 190         SqlNode alias = asSqlNode.getOperands()[1];
 191 
 192         SqlKind infoKind = info.getKind();
 193         if(infoKind != SELECT){
 194             return null;
 195         }
 196 
 197         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 198 
 199         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 200         for (FieldInfo fieldInfo : extractFieldList) {
 201             String tableName = fieldInfo.getTable();
 202             String fieldName = fieldInfo.getFieldName();
 203             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 204             mappingTable.put(tableName, fieldName, mappingFieldName);
 205         }
 206 
 207         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 208         replaceInfo.setMappingTable(mappingTable);
 209         replaceInfo.setTargetTableName(alias.toString());
 210         replaceInfo.setTargetTableAlias(alias.toString());
 211         return replaceInfo;
 212     }
 213 
 214 
 215     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 216         SqlKind sqlKind = sqlNode.getKind();
 217         if(sqlKind != AS){
 218             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 219         }
 220 
 221         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 222         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 223 
 224         AliasInfo aliasInfo = new AliasInfo();
 225         aliasInfo.setName(info.toString());
 226         aliasInfo.setAlias(alias.toString());
 227 
 228         return aliasInfo;
 229     }
 230 
 231     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,
 232                                            HashBasedTable&lt;String, String, String&gt; mappingTable) {
 233         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 234         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 235         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 236             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 237             String tableName = fieldInfo.getTable();
 238             String fieldName = fieldInfo.getFieldName();
 239 
 240             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 241             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 241             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 242 
 243             sideOutTypes[i] = fieldInfo.getTypeInformation();
 244             sideOutNames[i] = mappingFieldName;
 245         }
 246         return new RowTypeInfo(sideOutTypes, sideOutNames);
 247     }
 248 
 249 
 250 
 251     /**
 252      *  对时间类型进行类型转换
 253      * @param leftTypeInfo
 254      * @return
 255      */
 256     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 257         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 258         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 259         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 260             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 261         }
 262         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 263         return rowTypeInfo;
 264     }
 265 
 266     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 267         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 268             return TypeInformation.of(Timestamp.class);
 269         }
 270         return typeInformation;
 271     }
 272 
 273 
 274 
 275 
 276 
 277 
 278     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 279         this.localSqlPluginPath = localSqlPluginPath;
 280     }
 281 
<abbr title=" 282     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 282     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 283         Table table = localTableCache.get(tableAlias);
 284         if(table == null){
 285             table = localTableCache.get(tableName);
 286         }
 287 
 288         if(table == null){
 289             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 290         }
 291 
 292         return table;
 293     }
 294 
 295 
 296     /**
<abbr title=" 297      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 297      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 298      *
 299      * @return
 300      */
<abbr title=" 301     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 301     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 302         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 303         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 304             return true;
 305         }
 306         return false;
 307     }
 308 
 309     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 310         List&lt;String&gt; res = Lists.newArrayList();
 311         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 312             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 313         });
 314         return res;
 315     }
 316 
<abbr title=" 317     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 317     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 318         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 319         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 320         List&lt;String&gt; conditionFields = Lists.newArrayList();
 321         for(SqlNode sqlNode : sqlNodeList){
 322             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 323                 throw new RuntimeException(&quot;not compare operator.&quot;);
 324             }
 325 
 326             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 327             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 328 
 329             String leftTableName = left.getComponent(0).getSimple();
 330             String rightTableName = right.getComponent(0).getSimple();
 331 
 332             String tableCol = &quot;&quot;;
 333             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 334                 tableCol = left.getComponent(1).getSimple();
 335             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 336                 tableCol = right.getComponent(1).getSimple();
 337             }else{
<abbr title=" 338                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 338                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 339             }
 340             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 341             conditionFields.add(tableCol);
 342         }
 343 
 344         return conditionFields;
 345     }
 346 
 347     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 348                                      SqlNode pollSqlNode,
 349                                      Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 350 
 351         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 352         if (localTableCache.containsKey(aliasInfo.getName())) {
 353             return;
 354         }
 355 
 356         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 357         tableEnv.registerTable(aliasInfo.getAlias(), table);
 358         localTableCache.put(aliasInfo.getAlias(), table);
 359 
 360         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 361 
 362         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 363         if(fieldReplaceInfo == null){
 364            return;
 365         }
 366 
 367         //as 的源表
 368         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 369         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 370         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 371 
 372     }
 373 
 374     private void joinFun(Object pollObj,
 375                          Map&lt;String, Table&gt; localTableCache,
 376                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 377                          StreamTableEnvironment tableEnv) throws Exception{
 378         JoinInfo joinInfo = (JoinInfo) pollObj;
 379 
 380         JoinScope joinScope = new JoinScope();
 381         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 382         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 383         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 384 
<abbr title=" 385         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 385         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title=" 386         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 386         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema(🔵</abbr>
 387         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 388 
 389         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 390         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 391         rightScopeChild.setTableName(joinInfo.getRightTableName());
 392         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 393         if(sideTableInfo == null){
 394             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 395         }
 396 
 397         if(sideTableInfo == null){
 398             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 399         }
 400 
 401         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 402 
 403         joinScope.addScope(leftScopeChild);
 404         joinScope.addScope(rightScopeChild);
 405 
 406         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();
 407 
 408         //获取两个表的所有字段
<abbr title=" 409         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 409         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 410         //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 411         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 411         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo🔵</abbr>
 412 
 413         String leftTableAlias = joinInfo.getLeftTableAlias();
 414         Table targetTable = localTableCache.get(leftTableAlias);
 415         if(targetTable == null){
 416             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 417         }
 418 
<abbr title=" 419         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 419         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema(🔵</abbr>
 420 
<abbr title=" 421         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)"> 421         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.c🔵</abbr>
 422                 .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {
 423                     return new CRow(tp2.f1, tp2.f0);
 424                 }).returns(CRow.class);
 425 
 426 
 427         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 428         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 429             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 429             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 430             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 431             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 432             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 432             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, tar🔵</abbr>
 433         }
 434 
 435         DataStream&lt;CRow&gt; dsOut = null;
 436         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 437             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 437             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 438         }else{
<abbr title=" 439             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 439             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 440         }
 441 
 442         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 443 
 444         CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 445         dsOut.getTransformation().setOutputType(cRowTypeInfo);
 446 
 447         String targetTableName = joinInfo.getNewTableName();
 448         String targetTableAlias = joinInfo.getNewTableAlias();
 449 
 450         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 451         replaceInfo.setMappingTable(mappingTable);
 452         replaceInfo.setTargetTableName(targetTableName);
 453         replaceInfo.setTargetTableAlias(targetTableAlias);
 454 
 455         if (!tableEnv.isRegistered(targetTableName)){
 456             Table joinTable = tableEnv.fromDataStream(dsOut);
 457             tableEnv.registerTable(targetTableName, joinTable);
 458             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 459         }
 460     }
 461 
 462     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 463         String[] fieldNames = schema.getFieldNames();
 464         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 465 
<abbr title=" 466         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 466         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 467         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 467         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 468         return new RowTypeInfo(projectedTypes, projectedNames);
 469     }
 470 
 471 
 472     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 473         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 474         String fieldsInfo = result.getFieldsInfoStr();
 475         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 476         for (int i = 0; i &lt; fields.length; i++) {
 477             String[] filed = fields[i].split(&quot;\\s&quot;);
 478             if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){
 479                 return false;
 480             } else {
 481                 String[] filedNameArr = new String[filed.length - 1];
 482                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 483                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 484                 fieldNames.add(fieldName);
 485                 String fieldType = filed[filed.length - 1 ].trim();
 486                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 487                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 488                 if (fieldClass == tableField){
 489                     continue;
 490                 } else {
 491                     return false;
 492                 }
 493             }
 494         }
 495         tmpFields = String.join(&quot;,&quot;, fieldNames);
 496         return true;
 497     }
 498 
 499 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side;
  22 
  23 import org.apache.flink.api.common.typeinfo.TypeInformation;
  24 import org.apache.flink.api.java.tuple.Tuple2;
  25 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  26 import org.apache.flink.streaming.api.datastream.DataStream;
  27 import org.apache.flink.table.api.StreamQueryConfig;
  28 import org.apache.flink.table.api.Table;
  29 import org.apache.flink.table.api.TableSchema;
  30 import org.apache.flink.table.api.java.StreamTableEnvironment;
  31 import org.apache.flink.table.runtime.CRowKeySelector;
  32 import org.apache.flink.table.runtime.types.CRow;
  33 import org.apache.flink.table.runtime.types.CRowTypeInfo;
  34 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  35 import org.apache.flink.types.Row;
  36 
  37 import com.dtstack.flink.sql.enums.ECacheType;
  38 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  39 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  40 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  41 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  42 import com.dtstack.flink.sql.util.ClassUtil;
  43 import com.dtstack.flink.sql.util.ParseUtils;
  44 import com.dtstack.flink.sql.util.TableUtils;
  45 import com.google.common.base.Preconditions;
  46 import com.google.common.collect.HashBasedTable;
  47 import com.google.common.collect.Lists;
  48 import com.google.common.collect.Maps;
  49 import com.google.common.collect.Sets;
  50 import org.apache.calcite.sql.SqlBasicCall;
  51 import org.apache.calcite.sql.SqlIdentifier;
  52 import org.apache.calcite.sql.SqlKind;
  53 import org.apache.calcite.sql.SqlNode;
  54 import org.apache.calcite.sql.SqlSelect;
  55 import org.apache.calcite.sql.SqlWithItem;
  56 import org.apache.calcite.sql.parser.SqlParseException;
  57 import org.apache.commons.collections.CollectionUtils;
  58 import org.apache.commons.lang3.StringUtils;
  59 import org.slf4j.Logger;
  60 import org.slf4j.LoggerFactory;
  61 
  62 import java.sql.Timestamp;
  63 import java.util.Arrays;
  64 import java.util.LinkedList;
  65 import java.util.List;
  66 import java.util.Map;
  67 import java.util.Queue;
  68 import java.util.Set;
  69 
  70 import static org.apache.calcite.sql.SqlKind.*;
  71 
  72 /**
  73  * Reason:
  74  * Date: 2018/7/24
  75  * Company: www.dtstack.com
  76  * @author xuchao
  77  */
  78 
  79 public class SideSqlExec {
  80 
  81     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  82 
  83     private String localSqlPluginPath = null;
  84 
  85     private String tmpFields = null;
  86 
  87     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  88 
  89     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  90 
  91     public void exec(String sql,
  92                      Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
  93                      StreamTableEnvironment tableEnv,
  94                      Map&lt;String, Table&gt; tableCache,
  95                      StreamQueryConfig queryConfig,
  96                      CreateTmpTableParser.SqlParserResult createView,
  97                      String scope) throws Exception {
  98         if(localSqlPluginPath == null){
  99             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 100         }
 101 
 102         localTableCache.putAll(tableCache);
 103         try {
 104             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 105         } catch (Exception e) {
 106             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 107         }
 108 
 109         if(createView != null){
 110             LOG.warn(&quot;create view info\n&quot;);
 111             LOG.warn(createView.getExecSql());
 112             LOG.warn(&quot;-----------------&quot;);
 113         }
 114 
 115         SideSQLParser sideSQLParser = new SideSQLParser();
 116         sideSQLParser.setLocalTableCache(localTableCache);
 117 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 118         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 119         Object pollObj = null;</span>
 120 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 121         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 122         Object pollObj = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 123 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 124         //need clean</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 125         boolean preIsSideJoin = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 126         List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 127 </span>
 128 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 129         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 130         Object pollObj;</span>
 131 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 132 
 133         while((pollObj = exeQueue.poll()) != null){
 134 
 135             if(pollObj instanceof SqlNode){
 136                 SqlNode pollSqlNode = (SqlNode) pollObj;
 137 
 138 
 139                 if(pollSqlNode.getKind() == INSERT){
 140                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 141                     if(LOG.isInfoEnabled()){
 142                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 143                     }
 144 
 145                 }else if(pollSqlNode.getKind() == AS){
 146                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 147 
 148                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 149                     SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 150                     String TableAlias = sqlWithItem.name.toString();
 151                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 152                     tableEnv.registerTable(TableAlias, table);
 153 
 154                 } else if (pollSqlNode.getKind() == SELECT){
<abbr title=" 155                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 155                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 156                     Table table = tableEnv.sqlQuery(pollObj.toString());
 157 
 158                     if (createView.getFieldsInfoStr() == null){
 159                         tableEnv.registerTable(createView.getTableName(), table);
 160                     } else {
 161                         if (checkFieldsInfo(createView, table)){
 162                             table = table.as(tmpFields);
 163                             tableEnv.registerTable(createView.getTableName(), table);
 164                         } else {
 165                             throw new RuntimeException(&quot;Fields mismatch&quot;);
 166                         }
 167                     }
 168 
 169                     localTableCache.put(createView.getTableName(), table);
 170                 }
 171 
 172             }else if (pollObj instanceof JoinInfo){
 173                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 174                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 175             }
 176         }
 177 
 178     }
 179 
 180 
 181     /**
 182      * 解析出as查询的表和字段的关系
 183      * @param asSqlNode
 184      * @param tableCache
 185      * @return
 186      */
 187     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 188         SqlNode info = asSqlNode.getOperands()[0];
 189         SqlNode alias = asSqlNode.getOperands()[1];
 190 
 191         SqlKind infoKind = info.getKind();
 192         if(infoKind != SELECT){
 193             return null;
 194         }
 195 
 196         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 197 
 198         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 199         for (FieldInfo fieldInfo : extractFieldList) {
 200             String tableName = fieldInfo.getTable();
 201             String fieldName = fieldInfo.getFieldName();
 202             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 203             mappingTable.put(tableName, fieldName, mappingFieldName);
 204         }
 205 
 206         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 207         replaceInfo.setMappingTable(mappingTable);
 208         replaceInfo.setTargetTableName(alias.toString());
 209         replaceInfo.setTargetTableAlias(alias.toString());
 210         return replaceInfo;
 211     }
 212 
 213 
 214     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 215         SqlKind sqlKind = sqlNode.getKind();
 216         if(sqlKind != AS){
 217             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 218         }
 219 
 220         SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 221         SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 222 
 223         AliasInfo aliasInfo = new AliasInfo();
 224         aliasInfo.setName(info.toString());
 225         aliasInfo.setAlias(alias.toString());
 226 
 227         return aliasInfo;
 228     }
 229 
 230     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,
 231                                            HashBasedTable&lt;String, String, String&gt; mappingTable) {
 232         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 233         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 234         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 235             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 236             String tableName = fieldInfo.getTable();
 237             String fieldName = fieldInfo.getFieldName();
 238 
 239             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 240             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 240             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 241 
 242             sideOutTypes[i] = fieldInfo.getTypeInformation();
 243             sideOutNames[i] = mappingFieldName;
 244         }
 245         return new RowTypeInfo(sideOutTypes, sideOutNames);
 246     }
 247 
 248 
 249 
 250     /**
 251      *  对时间类型进行类型转换
 252      * @param leftTypeInfo
 253      * @return
 254      */
 255     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 256         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 257         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 258         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 259             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 260         }
 261         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 262         return rowTypeInfo;
 263     }
 264 
 265     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 266         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 267             return TypeInformation.of(Timestamp.class);
 268         }
 269         return typeInformation;
 270     }
 271 
 272 
 273 
 274 
 275 
 276 
 277     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 278         this.localSqlPluginPath = localSqlPluginPath;
 279     }
 280 
<abbr title=" 281     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){"> 281     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 282         Table table = localTableCache.get(tableAlias);
 283         if(table == null){
 284             table = localTableCache.get(tableName);
 285         }
 286 
 287         if(table == null){
 288             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 289         }
 290 
 291         return table;
 292     }
 293 
 294 
 295     /**
<abbr title=" 296      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 296      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 297      *
 298      * @return
 299      */
<abbr title=" 300     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 300     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 301         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 302         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 303             return true;
 304         }
 305         return false;
 306     }
 307 
 308     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 309         List&lt;String&gt; res = Lists.newArrayList();
 310         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 311             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 312         });
 313         return res;
 314     }
 315 
<abbr title=" 316     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 316     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 317         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 318         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 319         List&lt;String&gt; conditionFields = Lists.newArrayList();
 320         for(SqlNode sqlNode : sqlNodeList){
 321             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 322                 throw new RuntimeException(&quot;not compare operator.&quot;);
 323             }
 324 
 325             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 326             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 327 
 328             String leftTableName = left.getComponent(0).getSimple();
 329             String rightTableName = right.getComponent(0).getSimple();
 330 
 331             String tableCol = &quot;&quot;;
 332             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 333                 tableCol = left.getComponent(1).getSimple();
 334             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 335                 tableCol = right.getComponent(1).getSimple();
 336             }else{
<abbr title=" 337                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 337                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 338             }
 339             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 340             conditionFields.add(tableCol);
 341         }
 342 
 343         return conditionFields;
 344     }
 345 
 346     protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 347                                      SqlNode pollSqlNode,
 348                                      Map&lt;String, Table&gt; tableCache) throws SqlParseException {
 349 
 350         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 351         if (localTableCache.containsKey(aliasInfo.getName())) {
 352             return;
 353         }
 354 
 355         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 356         tableEnv.registerTable(aliasInfo.getAlias(), table);
 357         localTableCache.put(aliasInfo.getAlias(), table);
 358 
 359         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 360 
 361         FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 362         if(fieldReplaceInfo == null){
 363            return;
 364         }
 365 
 366         //as 的源表
 367         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 368         SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 369         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 370 
 371     }
 372 
 373     private void joinFun(Object pollObj,
 374                          Map&lt;String, Table&gt; localTableCache,
 375                          Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,
 376                          StreamTableEnvironment tableEnv) throws Exception{
 377         JoinInfo joinInfo = (JoinInfo) pollObj;
 378 
 379         JoinScope joinScope = new JoinScope();
 380         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 381         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 382         leftScopeChild.setTableName(joinInfo.getLeftTableName());
 383 
<abbr title=" 384         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 384         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title=" 385         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 385         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema(🔵</abbr>
 386         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 387 
 388         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 389         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 390         rightScopeChild.setTableName(joinInfo.getRightTableName());
 391         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 392         if(sideTableInfo == null){
 393             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 394         }
 395 
 396         if(sideTableInfo == null){
 397             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 398         }
 399 
 400         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 401 
 402         joinScope.addScope(leftScopeChild);
 403         joinScope.addScope(rightScopeChild);
 404 
 405         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();
 406 
 407         //获取两个表的所有字段
<abbr title=" 408         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 408         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 409         //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 410         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 410         sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo🔵</abbr>
 411 
 412         String leftTableAlias = joinInfo.getLeftTableAlias();
 413         Table targetTable = localTableCache.get(leftTableAlias);
 414         if(targetTable == null){
 415             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 416         }
 417 
<abbr title=" 418         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 418         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema(🔵</abbr>
 419 
<abbr title=" 420         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)"> 420         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.c🔵</abbr>
 421                 .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {
 422                     return new CRow(tp2.f1, tp2.f0);
 423                 }).returns(CRow.class);
 424 
 425 
 426         //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 427         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 428             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 428             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 429             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 430             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 431             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 431             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, tar🔵</abbr>
 432         }
 433 
 434         DataStream&lt;CRow&gt; dsOut = null;
 435         if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 436             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 436             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 437         }else{
<abbr title=" 438             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 438             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 439         }
 440 
 441         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 442 
 443         CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 444         dsOut.getTransformation().setOutputType(cRowTypeInfo);
 445 
 446         String targetTableName = joinInfo.getNewTableName();
 447         String targetTableAlias = joinInfo.getNewTableAlias();
 448 
 449         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 450         replaceInfo.setMappingTable(mappingTable);
 451         replaceInfo.setTargetTableName(targetTableName);
 452         replaceInfo.setTargetTableAlias(targetTableAlias);
 453 
 454         if (!tableEnv.isRegistered(targetTableName)){
 455             Table joinTable = tableEnv.fromDataStream(dsOut);
 456             tableEnv.registerTable(targetTableName, joinTable);
 457             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 458         }
 459     }
 460 
 461     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 462         String[] fieldNames = schema.getFieldNames();
 463         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 464 
<abbr title=" 465         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 465         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 466         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 466         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 467         return new RowTypeInfo(projectedTypes, projectedNames);
 468     }
 469 
 470 
 471     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 472         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 473         String fieldsInfo = result.getFieldsInfoStr();
 474         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 475         for (int i = 0; i &lt; fields.length; i++) {
 476             String[] filed = fields[i].split(&quot;\\s&quot;);
 477             if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){
 478                 return false;
 479             } else {
 480                 String[] filedNameArr = new String[filed.length - 1];
 481                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 482                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 483                 fieldNames.add(fieldName);
 484                 String fieldType = filed[filed.length - 1 ].trim();
 485                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 486                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 487                 if (fieldClass == tableField){
 488                     continue;
 489                 } else {
 490                     return false;
 491                 }
 492             }
 493         }
 494         tmpFields = String.join(&quot;,&quot;, fieldNames);
 495         return true;
 496     }
 497 
 498 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheType;
  21 import com.dtstack.flink.sql.exec.FlinkSQLExec;
  22 import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  23 import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  24 import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  25 import com.dtstack.flink.sql.util.ClassUtil;
  26 import com.dtstack.flink.sql.util.ParseUtils;
  27 import com.dtstack.flink.sql.util.TableUtils;
  28 import com.google.common.base.Preconditions;
  29 import com.google.common.collect.HashBasedTable;
  30 import com.google.common.collect.Lists;
  31 import com.google.common.collect.Maps;
  32 import com.google.common.collect.Sets;
  33 import java.sql.Timestamp;
  34 import java.util.Arrays;
  35 import java.util.LinkedList;
  36 import java.util.List;
  37 import java.util.Map;
  38 import java.util.Queue;
  39 import java.util.Set;
  40 import org.apache.calcite.sql.SqlBasicCall;
  41 import org.apache.calcite.sql.SqlIdentifier;
  42 import org.apache.calcite.sql.SqlKind;
  43 import org.apache.calcite.sql.SqlNode;
  44 import org.apache.calcite.sql.SqlSelect;
  45 import org.apache.calcite.sql.SqlWithItem;
  46 import org.apache.calcite.sql.parser.SqlParseException;
  47 import org.apache.commons.collections.CollectionUtils;
  48 import org.apache.commons.lang3.StringUtils;
  49 import org.apache.flink.api.common.typeinfo.TypeInformation;
  50 import org.apache.flink.api.java.tuple.Tuple2;
  51 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  52 import org.apache.flink.streaming.api.datastream.DataStream;
  53 import org.apache.flink.table.api.StreamQueryConfig;
  54 import org.apache.flink.table.api.Table;
  55 import org.apache.flink.table.api.TableSchema;
  56 import org.apache.flink.table.api.java.StreamTableEnvironment;
  57 import org.apache.flink.table.runtime.CRowKeySelector;
  58 import org.apache.flink.table.runtime.types.CRow;
  59 import org.apache.flink.table.runtime.types.CRowTypeInfo;
  60 import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  61 import org.apache.flink.types.Row;
  62 import org.slf4j.Logger;
  63 import org.slf4j.LoggerFactory;
  64 import static org.apache.calcite.sql.SqlKind.*;
  65 
  66 
  67 /**
  68  * Reason:
  69  * Date: 2018/7/24
  70  * Company: www.dtstack.com
  71  * @author xuchao
  72  */
  73 public class SideSqlExec {
  74     private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  75 
  76     private String localSqlPluginPath = null;
  77 
  78     private String tmpFields = null;
  79 
  80     private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  81 
  82     private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
  83 
<abbr title="  84     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv, Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserResult createView, String scope) throws Exception {">  84     public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment 🔵</abbr>
  85         if (localSqlPluginPath == null) {
  86             throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
  87         }
  88         localTableCache.putAll(tableCache);
  89         try {
  90             sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
  91         } catch (java.lang.Exception e) {
  92             LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
  93         }
  94         if (createView != null) {
  95             LOG.warn(&quot;create view info\n&quot;);
  96             LOG.warn(createView.getExecSql());
  97             LOG.warn(&quot;-----------------&quot;);
  98         }
  99         SideSQLParser sideSQLParser = new SideSQLParser();
 100         sideSQLParser.setLocalTableCache(localTableCache);
 101         Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);
 102         Object pollObj;
 103         while ((pollObj = exeQueue.poll()) != null) {
 104             if (pollObj instanceof SqlNode) {
 105                 SqlNode pollSqlNode = ((SqlNode) (pollObj));
 106                 if (pollSqlNode.getKind() == INSERT) {
 107                     FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 108                     if (LOG.isInfoEnabled()) {
 109                         LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 110                     }
 111                 } else if (pollSqlNode.getKind() == AS) {
 112                     dealAsSourceTable(tableEnv, pollSqlNode, tableCache);
 113                 } else if (pollSqlNode.getKind() == WITH_ITEM) {
 114                     SqlWithItem sqlWithItem = ((SqlWithItem) (pollSqlNode));
 115                     String TableAlias = sqlWithItem.name.toString();
 116                     Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 117                     tableEnv.registerTable(TableAlias, table);
 118                 } else if (pollSqlNode.getKind() == SELECT) {
<abbr title=" 119                     Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);"> 119                     Preconditions.checkState(createView != null, &quot;select sql must included by create view🔵</abbr>
 120                     Table table = tableEnv.sqlQuery(pollObj.toString());
 121                     if (createView.getFieldsInfoStr() == null) {
 122                         tableEnv.registerTable(createView.getTableName(), table);
 123                     } else if (checkFieldsInfo(createView, table)) {
 124                         table = table.as(tmpFields);
 125                         tableEnv.registerTable(createView.getTableName(), table);
 126                     } else {
 127                         throw new RuntimeException(&quot;Fields mismatch&quot;);
 128                     }
 129                     localTableCache.put(createView.getTableName(), table);
 130                 }
 131             } else if (pollObj instanceof JoinInfo) {
 132                 LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 133                 joinFun(pollObj, localTableCache, sideTableMap, tableEnv);
 134             }
 135         }
 136     }
 137 
 138     /**
 139      * 解析出as查询的表和字段的关系
 140      * @param asSqlNode
 141      * @param tableCache
 142      * @return
 143      */
 144     private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 145         SqlNode info = asSqlNode.getOperands()[0];
 146         SqlNode alias = asSqlNode.getOperands()[1];
 147 
 148         SqlKind infoKind = info.getKind();
 149         if(infoKind != SELECT){
 150             return null;
 151         }
 152 
 153         List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 154 
 155         HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 156         for (FieldInfo fieldInfo : extractFieldList) {
 157             String tableName = fieldInfo.getTable();
 158             String fieldName = fieldInfo.getFieldName();
 159             String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 160             mappingTable.put(tableName, fieldName, mappingFieldName);
 161         }
 162 
 163         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 164         replaceInfo.setMappingTable(mappingTable);
 165         replaceInfo.setTargetTableName(alias.toString());
 166         replaceInfo.setTargetTableAlias(alias.toString());
 167         return replaceInfo;
 168     }
 169 
 170     public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {
 171         SqlKind sqlKind = sqlNode.getKind();
 172         if (sqlKind != AS) {
 173             throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 174         }
 175         SqlNode info = ((SqlBasicCall) (sqlNode)).getOperands()[0];
 176         SqlNode alias = ((SqlBasicCall) (sqlNode)).getOperands()[1];
 177         AliasInfo aliasInfo = new AliasInfo();
 178         aliasInfo.setName(info.toString());
 179         aliasInfo.setAlias(alias.toString());
 180         return aliasInfo;
 181     }
 182 
<abbr title=" 183     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 183     public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, Stri🔵</abbr>
 184         TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 185         String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 186         for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 187             FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 188             String tableName = fieldInfo.getTable();
 189             String fieldName = fieldInfo.getFieldName();
 190             String mappingFieldName = mappingTable.get(tableName, fieldName);
<abbr title=" 191             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 191             Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be f🔵</abbr>
 192             sideOutTypes[i] = fieldInfo.getTypeInformation();
 193             sideOutNames[i] = mappingFieldName;
 194         }
 195         return new RowTypeInfo(sideOutTypes, sideOutNames);
 196     }
 197 
 198     /**
 199      *  对时间类型进行类型转换
 200      * @param leftTypeInfo
 201      * @return
 202      */
 203     private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 204         TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 205         TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 206         for (int i = 0; i &lt; sideOutTypes.length; i++) {
 207             sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 208         }
 209         RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 210         return rowTypeInfo;
 211     }
 212 
 213     private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 214         if (typeInformation instanceof TimeIndicatorTypeInfo) {
 215             return TypeInformation.of(Timestamp.class);
 216         }
 217         return typeInformation;
 218     }
 219 
 220     public void setLocalSqlPluginPath(String localSqlPluginPath) {
 221         this.localSqlPluginPath = localSqlPluginPath;
 222     }
 223 
<abbr title=" 224     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName) {"> 224     private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableNa🔵</abbr>
 225         Table table = localTableCache.get(tableAlias);
 226         if (table == null) {
 227             table = localTableCache.get(tableName);
 228         }
 229         if (table == null) {
 230             throw new RuntimeException(&quot;not register table &quot; + tableAlias);
 231         }
 232         return table;
 233     }
 234 
 235     /**
<abbr title=" 236      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 236      * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., d🔵</abbr>
 237      *
 238      * @return
 239      */
<abbr title=" 240     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 240     private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInf🔵</abbr>
 241         List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 242         if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 243             return true;
 244         }
 245         return false;
 246     }
 247 
 248     private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 249         List&lt;String&gt; res = Lists.newArrayList();
 250         sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 251             res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 252         });
 253         return res;
 254     }
 255 
<abbr title=" 256     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 256     public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTa🔵</abbr>
 257         List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 258         ParseUtils.parseAnd(conditionNode, sqlNodeList);
 259         List&lt;String&gt; conditionFields = Lists.newArrayList();
 260         for(SqlNode sqlNode : sqlNodeList){
 261             if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 262                 throw new RuntimeException(&quot;not compare operator.&quot;);
 263             }
 264 
 265             SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 266             SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 267 
 268             String leftTableName = left.getComponent(0).getSimple();
 269             String rightTableName = right.getComponent(0).getSimple();
 270 
 271             String tableCol = &quot;&quot;;
 272             if(leftTableName.equalsIgnoreCase(specifyTableName)){
 273                 tableCol = left.getComponent(1).getSimple();
 274             }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 275                 tableCol = right.getComponent(1).getSimple();
 276             }else{
<abbr title=" 277                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 277                 throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specify🔵</abbr>
 278             }
 279             tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 280             conditionFields.add(tableCol);
 281         }
 282 
 283         return conditionFields;
 284     }
 285 
<abbr title=" 286     protected void dealAsSourceTable(StreamTableEnvironment tableEnv, SqlNode pollSqlNode, Map&lt;String, Table&gt; tableCache) throws SqlParseException {"> 286     protected void dealAsSourceTable(StreamTableEnvironment tableEnv, SqlNode pollSqlNode, Map&lt;String, Ta🔵</abbr>
 287         AliasInfo aliasInfo = parseASNode(pollSqlNode);
 288         if (localTableCache.containsKey(aliasInfo.getName())) {
 289             return;
 290         }
 291         Table table = tableEnv.sqlQuery(aliasInfo.getName());
 292         tableEnv.registerTable(aliasInfo.getAlias(), table);
 293         localTableCache.put(aliasInfo.getAlias(), table);
 294         LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 295         FieldReplaceInfo fieldReplaceInfo = parseAsQuery(((SqlBasicCall) (pollSqlNode)), tableCache);
 296         if (fieldReplaceInfo == null) {
 297             return;
 298         }
 299         // as 的源表
 300         Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 301         SqlNode fromNode = ((SqlBasicCall) (pollSqlNode)).getOperands()[0];
 302         TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 303     }
 304 
<abbr title=" 305     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv) throws Exception {"> 305     private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache, Map&lt;String, AbstractSideTabl🔵</abbr>
 306         JoinInfo joinInfo = ((JoinInfo) (pollObj));
 307         JoinScope joinScope = new JoinScope();
 308         JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 309         leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 310         leftScopeChild.setTableName(joinInfo.getLeftTableName());
<abbr title=" 311         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 311         Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLe🔵</abbr>
<abbr title=" 312         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 312         RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema(🔵</abbr>
 313         leftScopeChild.setRowTypeInfo(leftTypeInfo);
 314         JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 315         rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 316         rightScopeChild.setTableName(joinInfo.getRightTableName());
 317         AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 318         if (sideTableInfo == null) {
 319             sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 320         }
 321         if (sideTableInfo == null) {
 322             throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 323         }
 324         rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 325         joinScope.addScope(leftScopeChild);
 326         joinScope.addScope(rightScopeChild);
 327         HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) (pollObj)).getTableFieldRef();
 328         // 获取两个表的所有字段
<abbr title=" 329         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 329         List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), join🔵</abbr>
 330         //通过join的查询字段信息过滤出需要的字段信息
<abbr title=" 331         sideJoinFieldInfo.removeIf(( tmpFieldInfo) -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 331         sideJoinFieldInfo.removeIf(( tmpFieldInfo) -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldI🔵</abbr>
 332         String leftTableAlias = joinInfo.getLeftTableAlias();
 333         Table targetTable = localTableCache.get(leftTableAlias);
 334         if (targetTable == null) {
 335             targetTable = localTableCache.get(joinInfo.getLeftTableName());
 336         }
<abbr title=" 337         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 337         RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema(🔵</abbr>
<abbr title=" 338         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class).map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {"> 338         DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, Row.class).map((Tuple2&lt;Boole🔵</abbr>
 339             return new CRow(tp2.f1, tp2.f0);
 340         }).returns(CRow.class);
 341         // join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 342         if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 343             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 343             List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTa🔵</abbr>
 344             List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 345             int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 346             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 346             adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, tar🔵</abbr>
 347         }
 348         DataStream&lt;CRow&gt; dsOut = null;
 349         if (ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())) {
<abbr title=" 350             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 350             dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), 🔵</abbr>
 351         } else {
<abbr title=" 352             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 352             dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSq🔵</abbr>
 353         }
 354         RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 355         CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 356         dsOut.getTransformation().setOutputType(cRowTypeInfo);
 357         String targetTableName = joinInfo.getNewTableName();
 358         String targetTableAlias = joinInfo.getNewTableAlias();
 359         FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 360         replaceInfo.setMappingTable(mappingTable);
 361         replaceInfo.setTargetTableName(targetTableName);
 362         replaceInfo.setTargetTableAlias(targetTableAlias);
 363         if (!tableEnv.isRegistered(targetTableName)) {
 364             Table joinTable = tableEnv.fromDataStream(dsOut);
 365             tableEnv.registerTable(targetTableName, joinTable);
 366             localTableCache.put(joinInfo.getNewTableName(), joinTable);
 367         }
 368     }
 369 
 370     private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 371         String[] fieldNames = schema.getFieldNames();
 372         TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 373 
<abbr title=" 374         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);"> 374         String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::ne🔵</abbr>
<abbr title=" 375         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 375         TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(Typ🔵</abbr>
 376         return new RowTypeInfo(projectedTypes, projectedNames);
 377     }
 378 
 379     private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 380         List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 381         String fieldsInfo = result.getFieldsInfoStr();
 382         String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 383         for (int i = 0; i &lt; fields.length; i++) {
 384             String[] filed = fields[i].split(&quot;\\s&quot;);
 385             if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){
 386                 return false;
 387             } else {
 388                 String[] filedNameArr = new String[filed.length - 1];
 389                 System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 390                 String fieldName = String.join(&quot; &quot;, filedNameArr);
 391                 fieldNames.add(fieldName);
 392                 String fieldType = filed[filed.length - 1 ].trim();
 393                 Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 394                 Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 395                 if (fieldClass == tableField){
 396                     continue;
 397                 } else {
 398                     return false;
 399                 }
 400             }
 401         }
 402         tmpFields = String.join(&quot;,&quot;, fieldNames);
 403         return true;
 404     }
 405 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
  23  import org.apache.flink.api.common.typeinfo.TypeInformation;
  24  import org.apache.flink.api.java.tuple.Tuple2;
  25  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  26  import org.apache.flink.streaming.api.datastream.DataStream;
  27  import org.apache.flink.table.api.StreamQueryConfig;
  28  import org.apache.flink.table.api.Table;
  29  import org.apache.flink.table.api.TableSchema;
  30  import org.apache.flink.table.api.java.StreamTableEnvironment;
  31  import org.apache.flink.table.runtime.CRowKeySelector;
  32  import org.apache.flink.table.runtime.types.CRow;
  33  import org.apache.flink.table.runtime.types.CRowTypeInfo;
  34  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  35  import org.apache.flink.types.Row;
  36  
  37  import com.dtstack.flink.sql.enums.ECacheType;
  38  import com.dtstack.flink.sql.exec.FlinkSQLExec;
  39  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  40  import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  41  import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  42  import com.dtstack.flink.sql.util.ClassUtil;
  43  import com.dtstack.flink.sql.util.ParseUtils;
  44  import com.dtstack.flink.sql.util.TableUtils;
  45  import com.google.common.base.Preconditions;
  46  import com.google.common.collect.HashBasedTable;
  47  import com.google.common.collect.Lists;
  48  import com.google.common.collect.Maps;
  49  import com.google.common.collect.Sets;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  50 -import org.apache.calcite.sql.SqlAsOperator;</span>
  51  import org.apache.calcite.sql.SqlBasicCall;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import org.apache.calcite.sql.SqlDataTypeSpec;</span>
  53  import org.apache.calcite.sql.SqlIdentifier;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  54 -import org.apache.calcite.sql.SqlInsert;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -import org.apache.calcite.sql.SqlJoin;</span>
  56  import org.apache.calcite.sql.SqlKind;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  57 -import org.apache.calcite.sql.SqlLiteral;</span>
  58  import org.apache.calcite.sql.SqlNode;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  59 -import org.apache.calcite.sql.SqlNodeList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  60 -import org.apache.calcite.sql.SqlOperator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  61 -import org.apache.calcite.sql.SqlOrderBy;</span>
  62  import org.apache.calcite.sql.SqlSelect;
  63  import org.apache.calcite.sql.SqlWithItem;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  64 -import org.apache.calcite.sql.fun.SqlCase;</span>
  65  import org.apache.calcite.sql.parser.SqlParseException;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  66 -import org.apache.calcite.sql.parser.SqlParserPos;</span>
  67  import org.apache.commons.collections.CollectionUtils;
  68  import org.apache.commons.lang3.StringUtils;
  69  import org.slf4j.Logger;
  70  import org.slf4j.LoggerFactory;
  71  
  72  import java.sql.Timestamp;
  73  import java.util.Arrays;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  74 -import java.util.Collection;</span>
  75  import java.util.LinkedList;
  76  import java.util.List;
  77  import java.util.Map;
  78  import java.util.Queue;
  79  import java.util.Set;
  80  
  81  import static org.apache.calcite.sql.SqlKind.*;
  82  
  83  /**
  84   * Reason:
  85   * Date: 2018/7/24
  86   * Company: www.dtstack.com
  87   * @author xuchao
  88   */
  89  
  90  public class SideSqlExec {
  91  
  92      private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  93  
  94      private String localSqlPluginPath = null;
  95  
  96      private String tmpFields = null;
  97  
  98      private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  99  
 100      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
 101  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -    public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 103 -                     Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserResult createView) throws Exception {"> 103 -                     Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserR🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +    public void exec(String sql,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 105 +                     Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 106 +                     StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 107 +                     Map&lt;String, Table&gt; tableCache,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 108 +                     StreamQueryConfig queryConfig,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +                     CreateTmpTableParser.SqlParserResult createView,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +                     String scope) throws Exception {</span>
 111          if(localSqlPluginPath == null){
 112              throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 113          }
 114  
 115          localTableCache.putAll(tableCache);
 116          try {
 117              sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 118          } catch (Exception e) {
 119              LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 120          }
 121  
 122          if(createView != null){
 123              LOG.warn(&quot;create view info\n&quot;);
 124              LOG.warn(createView.getExecSql());
 125              LOG.warn(&quot;-----------------&quot;);
 126          }
 127  
 128          SideSQLParser sideSQLParser = new SideSQLParser();
 129          sideSQLParser.setLocalTableCache(localTableCache);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 130 -        Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +        Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet(), scope);</span>
 132          Object pollObj = null;

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 134 -        //need clean</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 135 -        boolean preIsSideJoin = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 136 -        List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();</span>
 137  
 138          while((pollObj = exeQueue.poll()) != null){
 139  
 140              if(pollObj instanceof SqlNode){
 141                  SqlNode pollSqlNode = (SqlNode) pollObj;
 142  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 143 -                if(preIsSideJoin){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 144 -                    preIsSideJoin = false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 145 -                    List&lt;String&gt; fieldNames = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -                    for(FieldReplaceInfo replaceInfo : replaceInfoList){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -                        fieldNames = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 148 -                        replaceFieldName(pollSqlNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 149 -                        addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 150 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 151 -                }</span>
 152  
 153                  if(pollSqlNode.getKind() == INSERT){
 154                      FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 155                      if(LOG.isInfoEnabled()){
 156                          LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 157                      }
 158  
 159                  }else if(pollSqlNode.getKind() == AS){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 160 -                    dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +                    dealAsSourceTable(tableEnv, pollSqlNode, tableCache);</span>
 162  
 163                  } else if (pollSqlNode.getKind() == WITH_ITEM) {
 164                      SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 165                      String TableAlias = sqlWithItem.name.toString();
 166                      Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 167                      tableEnv.registerTable(TableAlias, table);
 168  
 169                  } else if (pollSqlNode.getKind() == SELECT){
 170                      Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);
 171                      Table table = tableEnv.sqlQuery(pollObj.toString());
 172  
 173                      if (createView.getFieldsInfoStr() == null){
 174                          tableEnv.registerTable(createView.getTableName(), table);
 175                      } else {
 176                          if (checkFieldsInfo(createView, table)){
 177                              table = table.as(tmpFields);
 178                              tableEnv.registerTable(createView.getTableName(), table);
 179                          } else {
 180                              throw new RuntimeException(&quot;Fields mismatch&quot;);
 181                          }
 182                      }
 183  
 184                      localTableCache.put(createView.getTableName(), table);
 185                  }
 186  
 187              }else if (pollObj instanceof JoinInfo){
 188                  LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 189 -                preIsSideJoin = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 190 -                joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +                joinFun(pollObj, localTableCache, sideTableMap, tableEnv);</span>
 192              }
 193          }
 194  
 195      }
 196  
 197  
 198      /**
 199       * 解析出as查询的表和字段的关系
 200       * @param asSqlNode
 201       * @param tableCache
 202       * @return
 203       */
 204      private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 205          SqlNode info = asSqlNode.getOperands()[0];
 206          SqlNode alias = asSqlNode.getOperands()[1];
 207  
 208          SqlKind infoKind = info.getKind();
 209          if(infoKind != SELECT){
 210              return null;
 211          }
 212  
 213          List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 214  
 215          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 216          for (FieldInfo fieldInfo : extractFieldList) {
 217              String tableName = fieldInfo.getTable();
 218              String fieldName = fieldInfo.getFieldName();
 219              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 220              mappingTable.put(tableName, fieldName, mappingFieldName);
 221          }
 222  
 223          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 224          replaceInfo.setMappingTable(mappingTable);
 225          replaceInfo.setTargetTableName(alias.toString());
 226          replaceInfo.setTargetTableAlias(alias.toString());
 227          return replaceInfo;
 228      }
 229  
 230  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 231 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 232 -     * 添加字段别名</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 233 -     * @param pollSqlNode</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 234 -     * @param fieldList</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 235 -     * @param mappingTable</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 236 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 237 -    private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 237 -    private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, 🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 238 -        SqlKind sqlKind = pollSqlNode.getKind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 239 -        switch (sqlKind) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 240 -            case INSERT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 241 -                SqlNode source = ((SqlInsert) pollSqlNode).getSource();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 242 -                addAliasForFieldNode(source, fieldList, mappingTable);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 243 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 244 -            case AS:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 245 -                addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 246 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 247 -            case SELECT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 248 -                SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 249 -                selectList.getList().forEach(node -&gt; {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 250 -                    if (node.getKind() == IDENTIFIER) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 251 -                        SqlIdentifier sqlIdentifier = (SqlIdentifier) node;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 252 -                        if (sqlIdentifier.names.size() == 1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 253 -                            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 254 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 255 -                        // save real field</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 256 -                        String fieldName = sqlIdentifier.names.get(1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 257 -                        if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 257 -                        if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().contai🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 258 -                            fieldList.add(fieldName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 259 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 260 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 261 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 262 -                });</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 263 -                for (int i = 0; i &lt; selectList.getList().size(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 264 -                    SqlNode node = selectList.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 265 -                    if (node.getKind() == IDENTIFIER) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 266 -                        SqlIdentifier sqlIdentifier = (SqlIdentifier) node;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 267 -                        if (sqlIdentifier.names.size() == 1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 268 -                            return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 269 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 270 -                        String name = sqlIdentifier.names.get(1);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 271 -                        // avoid real field pv0 convert pv</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 272 -                        if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 272 -                        if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 273 -                            SqlOperator operator = new SqlAsOperator();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 274 -                            SqlParserPos sqlParserPos = new SqlParserPos(0, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 275 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 276 -                            SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 276 -                            SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() -🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 277 -                            SqlNode[] sqlNodes = new SqlNode[2];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 278 -                            sqlNodes[0] = sqlIdentifier;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 279 -                            sqlNodes[1] = sqlIdentifierAlias;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 280 -                            SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 281 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 282 -                            selectList.set(i, sqlBasicCall);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 283 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 284 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 285 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 286 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 287 -            default:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 288 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 289 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 290 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 291 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 292 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 293 -    public AliasInfo parseAsNode(SqlNode sqlNode) throws SqlParseException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 294 +    public AliasInfo parseASNode(SqlNode sqlNode) throws SqlParseException {</span>
 295          SqlKind sqlKind = sqlNode.getKind();
 296          if(sqlKind != AS){
 297              throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 298          }
 299  
 300          SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 301          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 302  
 303          AliasInfo aliasInfo = new AliasInfo();
 304          aliasInfo.setName(info.toString());
 305          aliasInfo.setAlias(alias.toString());
 306  
 307          return aliasInfo;
 308      }
 309  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 310 -    public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 310 -    public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, Strin🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 311 +    public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +                                           HashBasedTable&lt;String, String, String&gt; mappingTable) {</span>
 313          TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 314          String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 315          for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 316              FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 317              String tableName = fieldInfo.getTable();
 318              String fieldName = fieldInfo.getFieldName();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 319 -            String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 320 -            mappingTable.put(tableName, fieldName, mappingFieldName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 321 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 322 +            String mappingFieldName = mappingTable.get(tableName, fieldName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 323 +            Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;);"> 323 +            Preconditions.checkNotNull(mappingFieldName, fieldInfo + &quot; not mapping any field! it may be frame bug&quot;🔵</abbr></span>
 324  
 325              sideOutTypes[i] = fieldInfo.getTypeInformation();
 326              sideOutNames[i] = mappingFieldName;
 327          }
 328          return new RowTypeInfo(sideOutTypes, sideOutNames);
 329      }
 330  
 331  
 332  
 333      /**
 334       *  对时间类型进行类型转换
 335       * @param leftTypeInfo
 336       * @return
 337       */
 338      private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 339          TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 340          TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 341          for (int i = 0; i &lt; sideOutTypes.length; i++) {
 342              sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 343          }
 344          RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 345          return rowTypeInfo;
 346      }
 347  
 348      private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 349          if (typeInformation instanceof TimeIndicatorTypeInfo) {
 350              return TypeInformation.of(Timestamp.class);
 351          }
 352          return typeInformation;
 353      }
 354  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 355 -    //需要考虑更多的情况</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 356 -    private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 357 -        SqlKind sqlKind = sqlNode.getKind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 358 -        switch (sqlKind) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 359 -            case INSERT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 360 -                SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 361 -                replaceFieldName(sqlSource, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 362 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 363 -            case AS:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 364 -                SqlNode asNode = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 365 -                replaceFieldName(asNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 366 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 367 -            case SELECT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 368 -                SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName());"> 368 -                SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 369 -                if(sqlSelect == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 370 -                    return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 371 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 372 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 373 -                SqlNode sqlSource1 = sqlSelect.getFrom();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 374 -                if(sqlSource1.getKind() == AS){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 375 -                    String tableName = ((SqlBasicCall)sqlSource1).getOperands()[0].toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 376 -                    if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 377 -                        SqlNodeList sqlSelectList = sqlSelect.getSelectList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 378 -                        SqlNode whereNode = sqlSelect.getWhere();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 379 -                        SqlNodeList sqlGroup = sqlSelect.getGroup();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 380 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 381 -                        //TODO 暂时不处理having</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 382 -                        SqlNode sqlHaving = sqlSelect.getHaving();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 383 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 384 -                        List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 385 -                        for( int i=0; i&lt;sqlSelectList.getList().size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 386 -                            SqlNode selectNode = sqlSelectList.getList().get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 387 -                            //特殊处理 isStar的标识</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 388 -                            if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar()){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 389 -                                List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 389 -                                List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 390 -                                newSelectNodeList.addAll(replaceNodeList);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 391 -                                continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 392 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 393 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 394 -                            SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 395 -                            if(replaceNode == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 396 -                                continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 397 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 398 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 399 -                            //sqlSelectList.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 400 -                            newSelectNodeList.add(replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 401 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 402 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 403 -                        SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 403 -                        SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosi🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 404 -                        sqlSelect.setSelectList(newSelectList);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 405 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 406 -                        //where</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 407 -                        if(whereNode != null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 408 -                            SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 409 -                            for(int i =0; i&lt;sqlNodeList.length; i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 410 -                                SqlNode whereSqlNode = sqlNodeList[i];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 411 -                                SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 412 -                                sqlNodeList[i] = replaceNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 413 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 414 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 415 -                        if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 416 -                            for( int i=0; i&lt;sqlGroup.getList().size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 417 -                                SqlNode selectNode = sqlGroup.getList().get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 418 -                                SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 419 -                                sqlGroup.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 420 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 421 -                        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 422 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 423 -                }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 424 -                    throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 425 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 426 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 427 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 428 -            case UNION:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 429 -                SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 430 -                SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 431 -                replaceFieldName(unionLeft, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 432 -                replaceFieldName(unionRight, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 433 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 434 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 435 -            case ORDER_BY:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 436 -                SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 437 -                replaceFieldName(sqlOrderBy.query, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 438 -                SqlNodeList orderFiledList = sqlOrderBy.orderList;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 439 -                for (int i=0 ;i&lt;orderFiledList.size();i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 440 -                    SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 440 -                    SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTabl🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 441 -                    orderFiledList.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 442 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 443 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 444 -            default:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 445 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 446 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 447 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 448 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 449 -    private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 450 -        if(orderNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 451 -            SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 452 -            if (sqlIdentifier.names.size() == 1) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 453 -                return orderNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 454 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 455 -            return sqlIdentifier.setName(0, tableAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 456 -        } else if (orderNode instanceof  SqlBasicCall) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 457 -            SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 458 -            for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 459 -                SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 460 -                sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 461 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 462 -            return sqlBasicCall;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 463 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 464 -            return orderNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 465 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 466 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 467 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 468 -    private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 469 -        if(groupNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 470 -            SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 471 -            if(sqlIdentifier.names.size() == 1){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 472 -                return sqlIdentifier;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 473 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 474 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 475 -            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 475 -            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 476 -            if(mappingFieldName == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 477 -                throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 478 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 479 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 480 -            sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 481 -            return sqlIdentifier.setName(1, mappingFieldName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 482 -        }else if(groupNode instanceof  SqlBasicCall){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 483 -            SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 484 -            for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 485 -                SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 486 -                SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 487 -                sqlBasicCall.getOperands()[i] = replaceNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 488 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 489 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 490 -            return sqlBasicCall;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 491 -        }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 492 -            return groupNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 493 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 494 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 495 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 496 -    public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 497 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 498 -        SqlKind sqlKind = sqlNode.getKind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 499 -        switch (sqlKind){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 500 -            case SELECT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 501 -                SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 502 -                if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 503 -                    if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 504 -                        return sqlNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 505 -                    }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 506 -                        return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 507 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 508 -                }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 509 -                    return filterNodeWithTargetName(fromNode, targetTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 510 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 511 -            case AS:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 512 -                SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 513 -                return filterNodeWithTargetName(childNode, targetTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 514 -            case JOIN:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 515 -                SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 516 -                SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 517 -                SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 518 -                SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 519 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 520 -                if(leftReturnNode != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 521 -                    return leftReturnNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 522 -                }else if(rightReturnNode != null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 523 -                    return rightReturnNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 524 -                }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 525 -                    return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 526 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 527 -            default:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 528 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 529 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 530 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 531 -        return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 532 -    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 533 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 534 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 535 +</span>
 536  
 537  
 538      public void setLocalSqlPluginPath(String localSqlPluginPath) {
 539          this.localSqlPluginPath = localSqlPluginPath;
 540      }
 541  
 542      private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){
 543          Table table = localTableCache.get(tableAlias);
 544          if(table == null){
 545              table = localTableCache.get(tableName);
 546          }
 547  
 548          if(table == null){
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 549 -            throw new RuntimeException(&quot;not register table &quot; + tableName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 550 +            throw new RuntimeException(&quot;not register table &quot; + tableAlias);</span>
 551          }
 552  
 553          return table;
 554      }
 555  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 556 -    private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 557 -        SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 558 -        List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 559 -        if(sqlIdentifier.isStar()){//处理 [* or table.*]</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 560 -            int identifierSize = sqlIdentifier.names.size();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 561 -            Collection&lt;String&gt; columns = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 562 -            if(identifierSize == 1){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 563 -                columns = replaceInfo.getMappingTable().values();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -            }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 565 -                columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 566 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 567 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 568 -            for(String colAlias : columns){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 569 -                SqlParserPos sqlParserPos = new SqlParserPos(0, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 570 -                List&lt;String&gt; columnInfo = Lists.newArrayList();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 571 -                columnInfo.add(replaceInfo.getTargetTableAlias());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 572 -                columnInfo.add(colAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 573 -                SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 574 -                sqlNodes.add(sqlIdentifierAlias);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 575 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 576 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 577 -            return sqlNodes;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 578 -        }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 579 -            throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 580 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 581 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 582 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 583 -    private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 584 -        if (selectNode.getKind() == AS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 585 -            SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 586 -            SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 587 -            if (replaceNode != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 588 -                ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 589 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 590 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 591 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 592 -        }else if(selectNode.getKind() == IDENTIFIER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 593 -            SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 594 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 595 -            if(sqlIdentifier.names.size() == 1){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 596 -                return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 597 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 598 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 599 -            //Same level mappingTable</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 600 -            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 600 -            String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 601 -            if (mappingFieldName == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 602 -                throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 603 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 604 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 605 -            sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 606 -            sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 607 -            return sqlIdentifier;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 608 -        }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 609 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 610 -        }else if(  AGGREGATE.contains(selectNode.getKind())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 611 -                || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 612 -                || COMPARISON.contains(selectNode.getKind())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 613 -                || selectNode.getKind() == OTHER_FUNCTION</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 614 -                || selectNode.getKind() == DIVIDE</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 615 -                || selectNode.getKind() == CAST</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 616 -                || selectNode.getKind() == TRIM</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 617 -                || selectNode.getKind() == TIMES</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 618 -                || selectNode.getKind() == PLUS</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 619 -                || selectNode.getKind() == NOT_IN</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 620 -                || selectNode.getKind() == OR</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 621 -                || selectNode.getKind() == AND</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 622 -                || selectNode.getKind() == MINUS</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 623 -                || selectNode.getKind() == TUMBLE</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 624 -                || selectNode.getKind() == TUMBLE_START</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 625 -                || selectNode.getKind() == TUMBLE_END</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 626 -                || selectNode.getKind() == SESSION</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 627 -                || selectNode.getKind() == SESSION_START</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 628 -                || selectNode.getKind() == SESSION_END</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 629 -                || selectNode.getKind() == HOP</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 630 -                || selectNode.getKind() == HOP_START</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 631 -                || selectNode.getKind() == HOP_END</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 632 -                || selectNode.getKind() == BETWEEN</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 633 -                || selectNode.getKind() == IS_NULL</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 634 -                || selectNode.getKind() == IS_NOT_NULL</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 635 -                || selectNode.getKind() == CONTAINS</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 636 -                || selectNode.getKind() == TIMESTAMP_ADD</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 637 -                || selectNode.getKind() == TIMESTAMP_DIFF</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 638 -                || selectNode.getKind() == LIKE</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 639 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 640 -                ){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 641 -            SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 642 -            for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 643 -                SqlNode sqlNode = sqlBasicCall.getOperands()[i];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 644 -                if(sqlNode instanceof SqlLiteral){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 645 -                    continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 646 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 647 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 648 -                if(sqlNode instanceof SqlDataTypeSpec){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 649 -                    continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 650 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 651 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 652 -                SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 653 -                if(replaceNode == null){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 654 -                    continue;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 655 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 656 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 657 -                sqlBasicCall.getOperands()[i] = replaceNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 658 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 659 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 660 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 661 -        }else if(selectNode.getKind() == CASE){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 662 -            SqlCase sqlCase = (SqlCase) selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 663 -            SqlNodeList whenOperands = sqlCase.getWhenOperands();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 664 -            SqlNodeList thenOperands = sqlCase.getThenOperands();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 665 -            SqlNode elseNode = sqlCase.getElseOperand();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 666 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 667 -            for(int i=0; i&lt;whenOperands.size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 668 -                SqlNode oneOperand = whenOperands.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 669 -                SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 670 -                if (replaceNode != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 671 -                    whenOperands.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 672 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 673 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 674 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 675 -            for(int i=0; i&lt;thenOperands.size(); i++){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 676 -                SqlNode oneOperand = thenOperands.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 677 -                SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 678 -                if (replaceNode != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 679 -                    thenOperands.set(i, replaceNode);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 680 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 681 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 682 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 683 -            ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 684 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 685 -        }else if(selectNode.getKind() == OTHER){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 686 -            //不处理</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 687 -            return selectNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 688 -        }else{</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 689 -            throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 689 -            throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNod🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 690 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 691 -    }</span>
 692  
 693      /**
<abbr title=" 694       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 694       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension 🔵</abbr>
 695       *
 696       * @return
 697       */
<abbr title=" 698      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 698      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTab🔵</abbr>
 699          List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 700          if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 701              return true;
 702          }
 703          return false;
 704      }
 705  
 706      private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 707          List&lt;String&gt; res = Lists.newArrayList();
 708          sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 709              res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 710          });
 711          return res;
 712      }
 713  
<abbr title=" 714      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 714      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo s🔵</abbr>
 715          List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 716          ParseUtils.parseAnd(conditionNode, sqlNodeList);
 717          List&lt;String&gt; conditionFields = Lists.newArrayList();
 718          for(SqlNode sqlNode : sqlNodeList){
 719              if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 720                  throw new RuntimeException(&quot;not compare operator.&quot;);
 721              }
 722  
 723              SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 724              SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 725  
 726              String leftTableName = left.getComponent(0).getSimple();
 727              String rightTableName = right.getComponent(0).getSimple();
 728  
 729              String tableCol = &quot;&quot;;
 730              if(leftTableName.equalsIgnoreCase(specifyTableName)){
 731                  tableCol = left.getComponent(1).getSimple();
 732              }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 733                  tableCol = right.getComponent(1).getSimple();
 734              }else{
<abbr title=" 735                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 735                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName🔵</abbr>
 736              }
 737              tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 738              conditionFields.add(tableCol);
 739          }
 740  
 741          return conditionFields;
 742      }
 743  
 744      protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 745                                       SqlNode pollSqlNode,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 746 -                                     Map&lt;String, Table&gt; tableCache,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 747 -                                     List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 748 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 749 -        AliasInfo aliasInfo = parseAsNode(pollSqlNode);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 750 +                                     Map&lt;String, Table&gt; tableCache) throws SqlParseException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 751 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 752 +        AliasInfo aliasInfo = parseASNode(pollSqlNode);</span>
 753          if (localTableCache.containsKey(aliasInfo.getName())) {
 754              return;
 755          }
 756  
 757          Table table = tableEnv.sqlQuery(aliasInfo.getName());
 758          tableEnv.registerTable(aliasInfo.getAlias(), table);
 759          localTableCache.put(aliasInfo.getAlias(), table);
 760  
 761          LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 762  
 763          FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 764          if(fieldReplaceInfo == null){
 765             return;
 766          }
 767  
 768          //as 的源表
 769          Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 770          SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 771          TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 772 -        for(FieldReplaceInfo tmp : replaceInfoList){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 773 -            if(fromTableNameSet.contains(tmp.getTargetTableName())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 774 -                    || fromTableNameSet.contains(tmp.getTargetTableAlias())){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 775 -                fieldReplaceInfo.setPreNode(tmp);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 776 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 777 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 778 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 779 -        replaceInfoList.add(fieldReplaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 780 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 781 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 782 -    private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 783 -                         Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 784 -                         List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 785 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 786 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 787 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 788 +    private void joinFun(Object pollObj,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 789 +                         Map&lt;String, Table&gt; localTableCache,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 790 +                         Map&lt;String, AbstractSideTableInfo&gt; sideTableMap,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 791 +                         StreamTableEnvironment tableEnv) throws Exception{</span>
 792          JoinInfo joinInfo = (JoinInfo) pollObj;
 793  
 794          JoinScope joinScope = new JoinScope();
 795          JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 796          leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 797          leftScopeChild.setTableName(joinInfo.getLeftTableName());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 798 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 799 -        SqlKind sqlKind = joinInfo.getLeftNode().getKind();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 800 -        if(sqlKind == AS){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 801 -            dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 802 -        }</span>
 803  
<abbr title=" 804          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 804          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableNa🔵</abbr>
<abbr title=" 805          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 805          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColu🔵</abbr>
 806          leftScopeChild.setRowTypeInfo(leftTypeInfo);
 807  
 808          JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 809          rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 810          rightScopeChild.setTableName(joinInfo.getRightTableName());
 811          AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 812          if(sideTableInfo == null){
 813              sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 814          }
 815  
 816          if(sideTableInfo == null){
 817              throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 818          }
 819  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 820 -//        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 821 -//            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 822 -//        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 823 -</span>
 824          rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 825  
 826          joinScope.addScope(leftScopeChild);
 827          joinScope.addScope(rightScopeChild);
 828  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 829 +        HashBasedTable&lt;String, String, String&gt; mappingTable = ((JoinInfo) pollObj).getTableFieldRef();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 830 +</span>
 831          //获取两个表的所有字段
<abbr title=" 832          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 832          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, tr🔵</abbr>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 833 +        //通过join的查询字段信息过滤出需要的字段信息</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 834 +        sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getFieldName()) == null);"> 834 +        sideJoinFieldInfo.removeIf(tmpFieldInfo -&gt; mappingTable.get(tmpFieldInfo.getTable(), tmpFieldInfo.getField🔵</abbr></span>
 835  
 836          String leftTableAlias = joinInfo.getLeftTableAlias();
 837          Table targetTable = localTableCache.get(leftTableAlias);
 838          if(targetTable == null){
 839              targetTable = localTableCache.get(joinInfo.getLeftTableName());
 840          }
 841  
<abbr title=" 842          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 842          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColu🔵</abbr>
 843  
 844          DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)
 845                  .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {
 846                      return new CRow(tp2.f1, tp2.f0);
 847                  }).returns(CRow.class);
 848  
 849  
 850          //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 851          if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 852              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 852              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(🔵</abbr>
 853              List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 854              int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 855              adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 855              adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.🔵</abbr>
 856          }
 857  
 858          DataStream&lt;CRow&gt; dsOut = null;
 859          if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 860              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 860              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr>
 861          }else{
<abbr title=" 862              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 862              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr>
 863          }
 864  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 865 -        // TODO  将嵌套表中的字段传递过去, 去除冗余的ROWtime</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 866 -        HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();</span>
 867          RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 868  
 869          CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 870          dsOut.getTransformation().setOutputType(cRowTypeInfo);
 871  
 872          String targetTableName = joinInfo.getNewTableName();
 873          String targetTableAlias = joinInfo.getNewTableAlias();
 874  
 875          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 876          replaceInfo.setMappingTable(mappingTable);
 877          replaceInfo.setTargetTableName(targetTableName);
 878          replaceInfo.setTargetTableAlias(targetTableAlias);
 879  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 880 -        //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 881 -        for(FieldReplaceInfo tmp : replaceInfoList){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 882 -            if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 883 -            ||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 884 -                replaceInfo.setPreNode(tmp);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 885 -                break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 886 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 887 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 888 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 889 -        replaceInfoList.add(replaceInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 890 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 891 -        if (!tableEnv.isRegistered(joinInfo.getNewTableName())){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 892 +        if (!tableEnv.isRegistered(targetTableName)){</span>
 893              Table joinTable = tableEnv.fromDataStream(dsOut);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 894 -            tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 895 +            tableEnv.registerTable(targetTableName, joinTable);</span>
 896              localTableCache.put(joinInfo.getNewTableName(), joinTable);
 897          }
 898      }
 899  
 900      private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 901          String[] fieldNames = schema.getFieldNames();
 902          TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 903  
 904          String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);
<abbr title=" 905          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 905          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformat🔵</abbr>
 906          return new RowTypeInfo(projectedTypes, projectedNames);
 907      }
 908  
 909  
 910      private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 911          List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 912          String fieldsInfo = result.getFieldsInfoStr();
 913          String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 914          for (int i = 0; i &lt; fields.length; i++) {
 915              String[] filed = fields[i].split(&quot;\\s&quot;);
 916              if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){
 917                  return false;
 918              } else {
 919                  String[] filedNameArr = new String[filed.length - 1];
 920                  System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 921                  String fieldName = String.join(&quot; &quot;, filedNameArr);
 922                  fieldNames.add(fieldName);
 923                  String fieldType = filed[filed.length - 1 ].trim();
 924                  Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 925                  Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 926                  if (fieldClass == tableField){
 927                      continue;
 928                  } else {
 929                      return false;
 930                  }
 931              }
 932          }
 933          tmpFields = String.join(&quot;,&quot;, fieldNames);
 934          return true;
 935      }
 936  
 937  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side;
  22  
  23  import org.apache.flink.api.common.typeinfo.TypeInformation;
  24  import org.apache.flink.api.java.tuple.Tuple2;
  25  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  26  import org.apache.flink.streaming.api.datastream.DataStream;
  27  import org.apache.flink.table.api.StreamQueryConfig;
  28  import org.apache.flink.table.api.Table;
  29  import org.apache.flink.table.api.TableSchema;
  30  import org.apache.flink.table.api.java.StreamTableEnvironment;
  31  import org.apache.flink.table.runtime.CRowKeySelector;
  32  import org.apache.flink.table.runtime.types.CRow;
  33  import org.apache.flink.table.runtime.types.CRowTypeInfo;
  34  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  35  import org.apache.flink.types.Row;
  36  
  37  import com.dtstack.flink.sql.enums.ECacheType;
  38  import com.dtstack.flink.sql.exec.FlinkSQLExec;
  39  import com.dtstack.flink.sql.parser.CreateTmpTableParser;
  40  import com.dtstack.flink.sql.side.operator.SideAsyncOperator;
  41  import com.dtstack.flink.sql.side.operator.SideWithAllCacheOperator;
  42  import com.dtstack.flink.sql.util.ClassUtil;
  43  import com.dtstack.flink.sql.util.ParseUtils;
  44  import com.dtstack.flink.sql.util.TableUtils;
  45  import com.google.common.base.Preconditions;
  46  import com.google.common.collect.HashBasedTable;
  47  import com.google.common.collect.Lists;
  48  import com.google.common.collect.Maps;
  49  import com.google.common.collect.Sets;
  50  import org.apache.calcite.sql.SqlAsOperator;
  51  import org.apache.calcite.sql.SqlBasicCall;
  52  import org.apache.calcite.sql.SqlDataTypeSpec;
  53  import org.apache.calcite.sql.SqlIdentifier;
  54  import org.apache.calcite.sql.SqlInsert;
  55  import org.apache.calcite.sql.SqlJoin;
  56  import org.apache.calcite.sql.SqlKind;
  57  import org.apache.calcite.sql.SqlLiteral;
  58  import org.apache.calcite.sql.SqlNode;
  59  import org.apache.calcite.sql.SqlNodeList;
  60  import org.apache.calcite.sql.SqlOperator;
  61  import org.apache.calcite.sql.SqlOrderBy;
  62  import org.apache.calcite.sql.SqlSelect;
  63  import org.apache.calcite.sql.SqlWithItem;
  64  import org.apache.calcite.sql.fun.SqlCase;
  65  import org.apache.calcite.sql.parser.SqlParseException;
  66  import org.apache.calcite.sql.parser.SqlParserPos;
  67  import org.apache.commons.collections.CollectionUtils;
  68  import org.apache.commons.lang3.StringUtils;
  69  import org.slf4j.Logger;
  70  import org.slf4j.LoggerFactory;
  71  
  72  import java.sql.Timestamp;
  73  import java.util.Arrays;
  74  import java.util.Collection;
  75  import java.util.LinkedList;
  76  import java.util.List;
  77  import java.util.Map;
  78  import java.util.Queue;
  79  import java.util.Set;
  80  
  81  import static org.apache.calcite.sql.SqlKind.*;
  82  
  83  /**
  84   * Reason:
  85   * Date: 2018/7/24
  86   * Company: www.dtstack.com
  87   * @author xuchao
  88   */
  89  
  90  public class SideSqlExec {
  91  
  92      private static final Logger LOG = LoggerFactory.getLogger(SideSqlExec.class);
  93  
  94      private String localSqlPluginPath = null;
  95  
  96      private String tmpFields = null;
  97  
  98      private SidePredicatesParser sidePredicatesParser = new SidePredicatesParser();
  99  
 100      private Map&lt;String, Table&gt; localTableCache = Maps.newHashMap();
 101  
 102      public void exec(String sql, Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,
<abbr title=" 103                       Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserResult createView) throws Exception {"> 103                       Map&lt;String, Table&gt; tableCache, StreamQueryConfig queryConfig, CreateTmpTableParser.SqlParserR🔵</abbr>







 104          if(localSqlPluginPath == null){
 105              throw new RuntimeException(&quot;need to set localSqlPluginPath&quot;);
 106          }
 107  
 108          localTableCache.putAll(tableCache);
 109          try {
 110              sidePredicatesParser.fillPredicatesForSideTable(sql, sideTableMap);
 111          } catch (Exception e) {
 112              LOG.error(&quot;fill predicates for sideTable fail &quot;, e);
 113          }
 114  
 115          if(createView != null){
 116              LOG.warn(&quot;create view info\n&quot;);
 117              LOG.warn(createView.getExecSql());
 118              LOG.warn(&quot;-----------------&quot;);
 119          }
 120  
 121          SideSQLParser sideSQLParser = new SideSQLParser();
 122          sideSQLParser.setLocalTableCache(localTableCache);
 123          Queue&lt;Object&gt; exeQueue = sideSQLParser.getExeQueue(sql, sideTableMap.keySet());

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 124 -        Object pollObj = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +        Object pollObj;</span>
 126  
 127          //need clean
 128          boolean preIsSideJoin = false;
 129          List&lt;FieldReplaceInfo&gt; replaceInfoList = Lists.newArrayList();
 130  
 131          while((pollObj = exeQueue.poll()) != null){
 132  
 133              if(pollObj instanceof SqlNode){
 134                  SqlNode pollSqlNode = (SqlNode) pollObj;
 135  
 136                  if(preIsSideJoin){
 137                      preIsSideJoin = false;
 138                      List&lt;String&gt; fieldNames = null;
 139                      for(FieldReplaceInfo replaceInfo : replaceInfoList){
 140                          fieldNames = Lists.newArrayList();
 141                          replaceFieldName(pollSqlNode, replaceInfo);
 142                          addAliasForFieldNode(pollSqlNode, fieldNames, replaceInfo.getMappingTable());
 143                      }
 144                  }
 145  
 146                  if(pollSqlNode.getKind() == INSERT){
 147                      FlinkSQLExec.sqlUpdate(tableEnv, pollSqlNode.toString(), queryConfig);
 148                      if(LOG.isInfoEnabled()){
 149                          LOG.info(&quot;----------real exec sql-----------\n{}&quot;, pollSqlNode.toString());
 150                      }
 151  
 152                  }else if(pollSqlNode.getKind() == AS){
 153                      dealAsSourceTable(tableEnv, pollSqlNode, tableCache, replaceInfoList);

 154  
 155                  } else if (pollSqlNode.getKind() == WITH_ITEM) {
 156                      SqlWithItem sqlWithItem = (SqlWithItem) pollSqlNode;
 157                      String TableAlias = sqlWithItem.name.toString();
 158                      Table table = tableEnv.sqlQuery(sqlWithItem.query.toString());
 159                      tableEnv.registerTable(TableAlias, table);
 160  
 161                  } else if (pollSqlNode.getKind() == SELECT){
 162                      Preconditions.checkState(createView != null, &quot;select sql must included by create view&quot;);
 163                      Table table = tableEnv.sqlQuery(pollObj.toString());
 164  
 165                      if (createView.getFieldsInfoStr() == null){
 166                          tableEnv.registerTable(createView.getTableName(), table);
 167                      } else {
 168                          if (checkFieldsInfo(createView, table)){
 169                              table = table.as(tmpFields);
 170                              tableEnv.registerTable(createView.getTableName(), table);
 171                          } else {
 172                              throw new RuntimeException(&quot;Fields mismatch&quot;);
 173                          }
 174                      }
 175  
 176                      localTableCache.put(createView.getTableName(), table);
 177                  }
 178  
 179              }else if (pollObj instanceof JoinInfo){
 180                  LOG.info(&quot;----------exec join info----------\n{}&quot;, pollObj.toString());
 181                  preIsSideJoin = true;
 182                  joinFun(pollObj, localTableCache, sideTableMap, tableEnv, replaceInfoList);

 183              }
 184          }
 185  
 186      }
 187  
 188  
 189      /**
 190       * 解析出as查询的表和字段的关系
 191       * @param asSqlNode
 192       * @param tableCache
 193       * @return
 194       */
 195      private FieldReplaceInfo parseAsQuery(SqlBasicCall asSqlNode, Map&lt;String, Table&gt; tableCache){
 196          SqlNode info = asSqlNode.getOperands()[0];
 197          SqlNode alias = asSqlNode.getOperands()[1];
 198  
 199          SqlKind infoKind = info.getKind();
 200          if(infoKind != SELECT){
 201              return null;
 202          }
 203  
 204          List&lt;FieldInfo&gt; extractFieldList = TableUtils.parserSelectField((SqlSelect) info, tableCache);
 205  
 206          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 207          for (FieldInfo fieldInfo : extractFieldList) {
 208              String tableName = fieldInfo.getTable();
 209              String fieldName = fieldInfo.getFieldName();
 210              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 211              mappingTable.put(tableName, fieldName, mappingFieldName);
 212          }
 213  
 214          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 215          replaceInfo.setMappingTable(mappingTable);
 216          replaceInfo.setTargetTableName(alias.toString());
 217          replaceInfo.setTargetTableAlias(alias.toString());
 218          return replaceInfo;
 219      }
 220  
 221  
 222      /**
 223       * 添加字段别名
 224       * @param pollSqlNode
 225       * @param fieldList
 226       * @param mappingTable
 227       */
<abbr title=" 228      private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 228      private void addAliasForFieldNode(SqlNode pollSqlNode, List&lt;String&gt; fieldList, HashBasedTable&lt;String, String, 🔵</abbr>
 229          SqlKind sqlKind = pollSqlNode.getKind();
 230          switch (sqlKind) {
 231              case INSERT:
 232                  SqlNode source = ((SqlInsert) pollSqlNode).getSource();
 233                  addAliasForFieldNode(source, fieldList, mappingTable);
 234                  break;
 235              case AS:
 236                  addAliasForFieldNode(((SqlBasicCall) pollSqlNode).getOperands()[0], fieldList, mappingTable);
 237                  break;
 238              case SELECT:
 239                  SqlNodeList selectList = ((SqlSelect) pollSqlNode).getSelectList();
 240                  selectList.getList().forEach(node -&gt; {
 241                      if (node.getKind() == IDENTIFIER) {
 242                          SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 243                          if (sqlIdentifier.names.size() == 1) {
 244                              return;
 245                          }
 246                          // save real field
 247                          String fieldName = sqlIdentifier.names.get(1);
<abbr title=" 248                          if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().containsKey(fieldName)) {"> 248                          if (!fieldName.endsWith(&quot;0&quot;) || fieldName.endsWith(&quot;0&quot;) &amp;&amp; mappingTable.columnMap().contai🔵</abbr>
 249                              fieldList.add(fieldName);
 250                          }
 251  
 252                      }
 253                  });
 254                  for (int i = 0; i &lt; selectList.getList().size(); i++) {
 255                      SqlNode node = selectList.get(i);
 256                      if (node.getKind() == IDENTIFIER) {
 257                          SqlIdentifier sqlIdentifier = (SqlIdentifier) node;
 258                          if (sqlIdentifier.names.size() == 1) {
 259                              return;
 260                          }
 261                          String name = sqlIdentifier.names.get(1);
 262                          // avoid real field pv0 convert pv
<abbr title=" 263                          if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring(0, name.length() - 1))) {"> 263                          if (name.endsWith(&quot;0&quot;) &amp;&amp;  !fieldList.contains(name) &amp;&amp; !fieldList.contains(name.substring🔵</abbr>
 264                              SqlOperator operator = new SqlAsOperator();
 265                              SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 266  
<abbr title=" 267                              SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() - 1), null, sqlParserPos);"> 267                              SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(name.substring(0, name.length() -🔵</abbr>
 268                              SqlNode[] sqlNodes = new SqlNode[2];
 269                              sqlNodes[0] = sqlIdentifier;
 270                              sqlNodes[1] = sqlIdentifierAlias;
 271                              SqlBasicCall sqlBasicCall = new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 272  
 273                              selectList.set(i, sqlBasicCall);
 274                          }
 275                      }
 276                  }
 277                  break;
 278              default:
 279                  break;
 280          }
 281      }
 282  
 283  
 284      public AliasInfo parseAsNode(SqlNode sqlNode) throws SqlParseException {

 285          SqlKind sqlKind = sqlNode.getKind();
 286          if(sqlKind != AS){
 287              throw new RuntimeException(sqlNode + &quot; is not &#x27;as&#x27; operator&quot;);
 288          }
 289  
 290          SqlNode info = ((SqlBasicCall)sqlNode).getOperands()[0];
 291          SqlNode alias = ((SqlBasicCall) sqlNode).getOperands()[1];
 292  
 293          AliasInfo aliasInfo = new AliasInfo();
 294          aliasInfo.setName(info.toString());
 295          aliasInfo.setAlias(alias.toString());
 296  
 297          return aliasInfo;
 298      }
 299  
<abbr title=" 300      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, String&gt; mappingTable) {"> 300      public RowTypeInfo buildOutRowTypeInfo(List&lt;FieldInfo&gt; sideJoinFieldInfo, HashBasedTable&lt;String, String, Strin🔵</abbr>


 301          TypeInformation[] sideOutTypes = new TypeInformation[sideJoinFieldInfo.size()];
 302          String[] sideOutNames = new String[sideJoinFieldInfo.size()];
 303          for (int i = 0; i &lt; sideJoinFieldInfo.size(); i++) {
 304              FieldInfo fieldInfo = sideJoinFieldInfo.get(i);
 305              String tableName = fieldInfo.getTable();
 306              String fieldName = fieldInfo.getFieldName();
 307              String mappingFieldName = ParseUtils.dealDuplicateFieldName(mappingTable, fieldName);
 308              mappingTable.put(tableName, fieldName, mappingFieldName);



 309  
 310              sideOutTypes[i] = fieldInfo.getTypeInformation();
 311              sideOutNames[i] = mappingFieldName;
 312          }
 313          return new RowTypeInfo(sideOutTypes, sideOutNames);
 314      }
 315  
 316  
 317  
 318      /**
 319       *  对时间类型进行类型转换
 320       * @param leftTypeInfo
 321       * @return
 322       */
 323      private RowTypeInfo buildLeftTableOutType(RowTypeInfo leftTypeInfo) {
 324          TypeInformation[] sideOutTypes = new TypeInformation[leftTypeInfo.getFieldNames().length];
 325          TypeInformation&lt;?&gt;[] fieldTypes = leftTypeInfo.getFieldTypes();
 326          for (int i = 0; i &lt; sideOutTypes.length; i++) {
 327              sideOutTypes[i] = convertTimeAttributeType(fieldTypes[i]);
 328          }
 329          RowTypeInfo rowTypeInfo = new RowTypeInfo(sideOutTypes, leftTypeInfo.getFieldNames());
 330          return rowTypeInfo;
 331      }
 332  
 333      private TypeInformation convertTimeAttributeType(TypeInformation typeInformation) {
 334          if (typeInformation instanceof TimeIndicatorTypeInfo) {
 335              return TypeInformation.of(Timestamp.class);
 336          }
 337          return typeInformation;
 338      }
 339  
 340      //需要考虑更多的情况
 341      private void replaceFieldName(SqlNode sqlNode, FieldReplaceInfo replaceInfo) {
 342          SqlKind sqlKind = sqlNode.getKind();
 343          switch (sqlKind) {
 344              case INSERT:
 345                  SqlNode sqlSource = ((SqlInsert) sqlNode).getSource();
 346                  replaceFieldName(sqlSource, replaceInfo);
 347                  break;
 348              case AS:
 349                  SqlNode asNode = ((SqlBasicCall) sqlNode).getOperands()[0];
 350                  replaceFieldName(asNode, replaceInfo);
 351                  break;
 352              case SELECT:
<abbr title=" 353                  SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName());"> 353                  SqlSelect sqlSelect = (SqlSelect) filterNodeWithTargetName(sqlNode, replaceInfo.getTargetTableName🔵</abbr>
 354                  if(sqlSelect == null){
 355                      return;
 356                  }
 357  
 358                  SqlNode sqlSource1 = sqlSelect.getFrom();
 359                  if(sqlSource1.getKind() == AS){
 360                      String tableName = ((SqlBasicCall)sqlSource1).getOperands()[0].toString();
 361                      if(tableName.equalsIgnoreCase(replaceInfo.getTargetTableName())){
 362                          SqlNodeList sqlSelectList = sqlSelect.getSelectList();
 363                          SqlNode whereNode = sqlSelect.getWhere();
 364                          SqlNodeList sqlGroup = sqlSelect.getGroup();
 365  
 366                          //TODO 暂时不处理having
 367                          SqlNode sqlHaving = sqlSelect.getHaving();
 368  
 369                          List&lt;SqlNode&gt; newSelectNodeList = Lists.newArrayList();
 370                          for( int i=0; i&lt;sqlSelectList.getList().size(); i++){
 371                              SqlNode selectNode = sqlSelectList.getList().get(i);
 372                              //特殊处理 isStar的标识
 373                              if(selectNode.getKind() == IDENTIFIER &amp;&amp; ((SqlIdentifier) selectNode).isStar()){
<abbr title=" 374                                  List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo);"> 374                                  List&lt;SqlNode&gt; replaceNodeList = replaceSelectStarFieldName(selectNode, replaceInfo🔵</abbr>
 375                                  newSelectNodeList.addAll(replaceNodeList);
 376                                  continue;
 377                              }
 378  
 379                              SqlNode replaceNode = replaceSelectFieldName(selectNode, replaceInfo);
 380                              if(replaceNode == null){
 381                                  continue;
 382                              }
 383  
 384                              //sqlSelectList.set(i, replaceNode);
 385                              newSelectNodeList.add(replaceNode);
 386                          }
 387  
<abbr title=" 388                          SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosition());"> 388                          SqlNodeList newSelectList = new SqlNodeList(newSelectNodeList, sqlSelectList.getParserPosi🔵</abbr>
 389                          sqlSelect.setSelectList(newSelectList);
 390  
 391                          //where
 392                          if(whereNode != null){
 393                              SqlNode[] sqlNodeList = ((SqlBasicCall)whereNode).getOperands();
 394                              for(int i =0; i&lt;sqlNodeList.length; i++) {
 395                                  SqlNode whereSqlNode = sqlNodeList[i];
 396                                  SqlNode replaceNode = replaceNodeInfo(whereSqlNode, replaceInfo);
 397                                  sqlNodeList[i] = replaceNode;
 398                              }
 399                          }
 400                          if(sqlGroup != null &amp;&amp; CollectionUtils.isNotEmpty(sqlGroup.getList())){
 401                              for( int i=0; i&lt;sqlGroup.getList().size(); i++){
 402                                  SqlNode selectNode = sqlGroup.getList().get(i);
 403                                  SqlNode replaceNode = replaceNodeInfo(selectNode, replaceInfo);
 404                                  sqlGroup.set(i, replaceNode);
 405                              }
 406                          }
 407                      }
 408                  }else{
 409                      throw new RuntimeException(&quot;---not deal type:&quot; + sqlNode);
 410                  }
 411  
 412                  break;
 413              case UNION:
 414                  SqlNode unionLeft = ((SqlBasicCall) sqlNode).getOperands()[0];
 415                  SqlNode unionRight = ((SqlBasicCall) sqlNode).getOperands()[1];
 416                  replaceFieldName(unionLeft, replaceInfo);
 417                  replaceFieldName(unionRight, replaceInfo);
 418  
 419                  break;
 420              case ORDER_BY:
 421                  SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 422                  replaceFieldName(sqlOrderBy.query, replaceInfo);
 423                  SqlNodeList orderFiledList = sqlOrderBy.orderList;
 424                  for (int i=0 ;i&lt;orderFiledList.size();i++) {
<abbr title=" 425                      SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTableAlias());"> 425                      SqlNode replaceNode = replaceOrderByTableName(orderFiledList.get(i), replaceInfo.getTargetTabl🔵</abbr>
 426                      orderFiledList.set(i, replaceNode);
 427                  }
 428  
 429              default:
 430                  break;
 431          }
 432      }
 433  
 434      private SqlNode replaceOrderByTableName(SqlNode orderNode, String tableAlias) {
 435          if(orderNode.getKind() == IDENTIFIER){
 436              SqlIdentifier sqlIdentifier = (SqlIdentifier) orderNode;
 437              if (sqlIdentifier.names.size() == 1) {
 438                  return orderNode;
 439              }
 440              return sqlIdentifier.setName(0, tableAlias);
 441          } else if (orderNode instanceof  SqlBasicCall) {
 442              SqlBasicCall sqlBasicCall = (SqlBasicCall) orderNode;
 443              for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 444                  SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 445                  sqlBasicCall.getOperands()[i] = replaceOrderByTableName(sqlNode , tableAlias);
 446              }
 447              return sqlBasicCall;
 448          } else {
 449              return orderNode;
 450          }
 451      }
 452  
 453      private SqlNode replaceNodeInfo(SqlNode groupNode, FieldReplaceInfo replaceInfo){
 454          if(groupNode.getKind() == IDENTIFIER){
 455              SqlIdentifier sqlIdentifier = (SqlIdentifier) groupNode;
 456              if(sqlIdentifier.names.size() == 1){
 457                  return sqlIdentifier;
 458              }
 459  
<abbr title=" 460              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 460              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr>
 461              if(mappingFieldName == null){
 462                  throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + sqlIdentifier.toString() );
 463              }
 464  
 465              sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 466              return sqlIdentifier.setName(1, mappingFieldName);
 467          }else if(groupNode instanceof  SqlBasicCall){
 468              SqlBasicCall sqlBasicCall = (SqlBasicCall) groupNode;
 469              for(int i=0; i&lt;sqlBasicCall.getOperandList().size(); i++){
 470                  SqlNode sqlNode = sqlBasicCall.getOperandList().get(i);
 471                  SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 472                  sqlBasicCall.getOperands()[i] = replaceNode;
 473              }
 474  
 475              return sqlBasicCall;
 476          }else{
 477              return groupNode;
 478          }
 479      }
 480  
 481      public SqlNode filterNodeWithTargetName(SqlNode sqlNode, String targetTableName) {
 482  
 483          SqlKind sqlKind = sqlNode.getKind();
 484          switch (sqlKind){
 485              case SELECT:
 486                  SqlNode fromNode = ((SqlSelect)sqlNode).getFrom();
 487                  if(fromNode.getKind() == AS &amp;&amp; ((SqlBasicCall)fromNode).getOperands()[0].getKind() == IDENTIFIER){
 488                      if(((SqlBasicCall)fromNode).getOperands()[0].toString().equalsIgnoreCase(targetTableName)){
 489                          return sqlNode;
 490                      }else{
 491                          return null;
 492                      }
 493                  }else{
 494                      return filterNodeWithTargetName(fromNode, targetTableName);
 495                  }
 496              case AS:
 497                  SqlNode childNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 498                  return filterNodeWithTargetName(childNode, targetTableName);
 499              case JOIN:
 500                  SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 501                  SqlNode rightNode =  ((SqlJoin)sqlNode).getRight();
 502                  SqlNode leftReturnNode = filterNodeWithTargetName(leftNode, targetTableName);
 503                  SqlNode rightReturnNode = filterNodeWithTargetName(rightNode, targetTableName);
 504  
 505                  if(leftReturnNode != null) {
 506                      return leftReturnNode;
 507                  }else if(rightReturnNode != null){
 508                      return rightReturnNode;
 509                  }else{
 510                      return null;
 511                  }
 512              default:
 513                  break;
 514          }
 515  
 516          return null;
 517      }



 518  
 519  
 520      public void setLocalSqlPluginPath(String localSqlPluginPath) {
 521          this.localSqlPluginPath = localSqlPluginPath;
 522      }
 523  
 524      private Table getTableFromCache(Map&lt;String, Table&gt; localTableCache, String tableAlias, String tableName){
 525          Table table = localTableCache.get(tableAlias);
 526          if(table == null){
 527              table = localTableCache.get(tableName);
 528          }
 529  
 530          if(table == null){
 531              throw new RuntimeException(&quot;not register table &quot; + tableName);

 532          }
 533  
 534          return table;
 535      }
 536  
 537      private List&lt;SqlNode&gt; replaceSelectStarFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo){
 538          SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 539          List&lt;SqlNode&gt; sqlNodes = Lists.newArrayList();
 540          if(sqlIdentifier.isStar()){//处理 [* or table.*]
 541              int identifierSize = sqlIdentifier.names.size();
 542              Collection&lt;String&gt; columns = null;
 543              if(identifierSize == 1){
 544                  columns = replaceInfo.getMappingTable().values();
 545              }else{
 546                  columns = replaceInfo.getMappingTable().row(sqlIdentifier.names.get(0)).values();
 547              }
 548  
 549              for(String colAlias : columns){
 550                  SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 551                  List&lt;String&gt; columnInfo = Lists.newArrayList();
 552                  columnInfo.add(replaceInfo.getTargetTableAlias());
 553                  columnInfo.add(colAlias);
 554                  SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(columnInfo, sqlParserPos);
 555                  sqlNodes.add(sqlIdentifierAlias);
 556              }
 557  
 558              return sqlNodes;
 559          }else{
 560              throw new RuntimeException(&quot;is not a star select field.&quot; + selectNode);
 561          }
 562      }
 563  
 564      private SqlNode replaceSelectFieldName(SqlNode selectNode, FieldReplaceInfo replaceInfo) {
 565          if (selectNode.getKind() == AS) {
 566              SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 567              SqlNode replaceNode = replaceSelectFieldName(leftNode, replaceInfo);
 568              if (replaceNode != null) {
 569                  ((SqlBasicCall) selectNode).getOperands()[0] = replaceNode;
 570              }
 571  
 572              return selectNode;
 573          }else if(selectNode.getKind() == IDENTIFIER){
 574              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 575  
 576              if(sqlIdentifier.names.size() == 1){
 577                  return selectNode;
 578              }
 579  
 580              //Same level mappingTable
<abbr title=" 581              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sqlIdentifier.getComponent(1).getSimple());"> 581              String mappingFieldName = replaceInfo.getTargetFieldName(sqlIdentifier.getComponent(0).getSimple(), sq🔵</abbr>
 582              if (mappingFieldName == null) {
 583                  throw new RuntimeException(&quot;can&#x27;t find mapping fieldName:&quot; + selectNode.toString() );
 584              }
 585  
 586              sqlIdentifier = sqlIdentifier.setName(0, replaceInfo.getTargetTableAlias());
 587              sqlIdentifier = sqlIdentifier.setName(1, mappingFieldName);
 588              return sqlIdentifier;
 589          }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//字面含义
 590              return selectNode;
 591          }else if(  AGGREGATE.contains(selectNode.getKind())
 592                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 593                  || COMPARISON.contains(selectNode.getKind())
 594                  || selectNode.getKind() == OTHER_FUNCTION
 595                  || selectNode.getKind() == DIVIDE
 596                  || selectNode.getKind() == CAST
 597                  || selectNode.getKind() == TRIM
 598                  || selectNode.getKind() == TIMES
 599                  || selectNode.getKind() == PLUS
 600                  || selectNode.getKind() == NOT_IN
 601                  || selectNode.getKind() == OR
 602                  || selectNode.getKind() == AND
 603                  || selectNode.getKind() == MINUS
 604                  || selectNode.getKind() == TUMBLE
 605                  || selectNode.getKind() == TUMBLE_START
 606                  || selectNode.getKind() == TUMBLE_END
 607                  || selectNode.getKind() == SESSION
 608                  || selectNode.getKind() == SESSION_START
 609                  || selectNode.getKind() == SESSION_END
 610                  || selectNode.getKind() == HOP
 611                  || selectNode.getKind() == HOP_START
 612                  || selectNode.getKind() == HOP_END
 613                  || selectNode.getKind() == BETWEEN
 614                  || selectNode.getKind() == IS_NULL
 615                  || selectNode.getKind() == IS_NOT_NULL
 616                  || selectNode.getKind() == CONTAINS
 617                  || selectNode.getKind() == TIMESTAMP_ADD
 618                  || selectNode.getKind() == TIMESTAMP_DIFF
 619                  || selectNode.getKind() == LIKE
 620  
 621                  ){
 622              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 623              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 624                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 625                  if(sqlNode instanceof SqlLiteral){
 626                      continue;
 627                  }
 628  
 629                  if(sqlNode instanceof SqlDataTypeSpec){
 630                      continue;
 631                  }
 632  
 633                  SqlNode replaceNode = replaceSelectFieldName(sqlNode, replaceInfo);
 634                  if(replaceNode == null){
 635                      continue;
 636                  }
 637  
 638                  sqlBasicCall.getOperands()[i] = replaceNode;
 639              }
 640  
 641              return selectNode;
 642          }else if(selectNode.getKind() == CASE){
 643              SqlCase sqlCase = (SqlCase) selectNode;
 644              SqlNodeList whenOperands = sqlCase.getWhenOperands();
 645              SqlNodeList thenOperands = sqlCase.getThenOperands();
 646              SqlNode elseNode = sqlCase.getElseOperand();
 647  
 648              for(int i=0; i&lt;whenOperands.size(); i++){
 649                  SqlNode oneOperand = whenOperands.get(i);
 650                  SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 651                  if (replaceNode != null) {
 652                      whenOperands.set(i, replaceNode);
 653                  }
 654              }
 655  
 656              for(int i=0; i&lt;thenOperands.size(); i++){
 657                  SqlNode oneOperand = thenOperands.get(i);
 658                  SqlNode replaceNode = replaceSelectFieldName(oneOperand, replaceInfo);
 659                  if (replaceNode != null) {
 660                      thenOperands.set(i, replaceNode);
 661                  }
 662              }
 663  
 664              ((SqlCase) selectNode).setOperand(3, replaceSelectFieldName(elseNode, replaceInfo));
 665              return selectNode;
 666          }else if(selectNode.getKind() == OTHER){
 667              //不处理
 668              return selectNode;
 669          }else{
<abbr title=" 670              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 670              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNod🔵</abbr>
 671          }
 672      }
 673  
 674      /**
<abbr title=" 675       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension table is the primary key definition"> 675       * Analyzing conditions are very join the dimension tables include all equivalent conditions (i.e., dimension 🔵</abbr>
 676       *
 677       * @return
 678       */
<abbr title=" 679      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTableInfo) {"> 679      private boolean checkJoinCondition(SqlNode conditionNode, String sideTableAlias, AbstractSideTableInfo sideTab🔵</abbr>
 680          List&lt;String&gt; conditionFields = getConditionFields(conditionNode, sideTableAlias, sideTableInfo);
 681          if(CollectionUtils.isEqualCollection(conditionFields, convertPrimaryAlias(sideTableInfo))){
 682              return true;
 683          }
 684          return false;
 685      }
 686  
 687      private List&lt;String&gt; convertPrimaryAlias(AbstractSideTableInfo sideTableInfo) {
 688          List&lt;String&gt; res = Lists.newArrayList();
 689          sideTableInfo.getPrimaryKeys().forEach(field -&gt; {
 690              res.add(sideTableInfo.getPhysicalFields().getOrDefault(field, field));
 691          });
 692          return res;
 693      }
 694  
<abbr title=" 695      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo sideTableInfo){"> 695      public List&lt;String&gt; getConditionFields(SqlNode conditionNode, String specifyTableName, AbstractSideTableInfo s🔵</abbr>
 696          List&lt;SqlNode&gt; sqlNodeList = Lists.newArrayList();
 697          ParseUtils.parseAnd(conditionNode, sqlNodeList);
 698          List&lt;String&gt; conditionFields = Lists.newArrayList();
 699          for(SqlNode sqlNode : sqlNodeList){
 700              if (!SqlKind.COMPARISON.contains(sqlNode.getKind())) {
 701                  throw new RuntimeException(&quot;not compare operator.&quot;);
 702              }
 703  
 704              SqlIdentifier left = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[0];
 705              SqlIdentifier right = (SqlIdentifier)((SqlBasicCall)sqlNode).getOperands()[1];
 706  
 707              String leftTableName = left.getComponent(0).getSimple();
 708              String rightTableName = right.getComponent(0).getSimple();
 709  
 710              String tableCol = &quot;&quot;;
 711              if(leftTableName.equalsIgnoreCase(specifyTableName)){
 712                  tableCol = left.getComponent(1).getSimple();
 713              }else if(rightTableName.equalsIgnoreCase(specifyTableName)){
 714                  tableCol = right.getComponent(1).getSimple();
 715              }else{
<abbr title=" 716                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName));"> 716                  throw new RuntimeException(String.format(&quot;side table:%s join condition is wrong&quot;, specifyTableName🔵</abbr>
 717              }
 718              tableCol = sideTableInfo.getPhysicalFields().getOrDefault(tableCol, tableCol);
 719              conditionFields.add(tableCol);
 720          }
 721  
 722          return conditionFields;
 723      }
 724  
 725      protected void dealAsSourceTable(StreamTableEnvironment tableEnv,
 726                                       SqlNode pollSqlNode,
 727                                       Map&lt;String, Table&gt; tableCache,
 728                                       List&lt;FieldReplaceInfo&gt; replaceInfoList) throws SqlParseException {
 729  
 730          AliasInfo aliasInfo = parseAsNode(pollSqlNode);



 731          if (localTableCache.containsKey(aliasInfo.getName())) {
 732              return;
 733          }
 734  
 735          Table table = tableEnv.sqlQuery(aliasInfo.getName());
 736          tableEnv.registerTable(aliasInfo.getAlias(), table);
 737          localTableCache.put(aliasInfo.getAlias(), table);
 738  
 739          LOG.info(&quot;Register Table {} by {}&quot;, aliasInfo.getAlias(), aliasInfo.getName());
 740  
 741          FieldReplaceInfo fieldReplaceInfo = parseAsQuery((SqlBasicCall) pollSqlNode, tableCache);
 742          if(fieldReplaceInfo == null){
 743             return;
 744          }
 745  
 746          //as 的源表
 747          Set&lt;String&gt; fromTableNameSet = Sets.newHashSet();
 748          SqlNode fromNode = ((SqlBasicCall)pollSqlNode).getOperands()[0];
 749          TableUtils.getFromTableInfo(fromNode, fromTableNameSet);
 750          for(FieldReplaceInfo tmp : replaceInfoList){
 751              if(fromTableNameSet.contains(tmp.getTargetTableName())
 752                      || fromTableNameSet.contains(tmp.getTargetTableAlias())){
 753                  fieldReplaceInfo.setPreNode(tmp);
 754                  break;
 755              }
 756          }
 757          replaceInfoList.add(fieldReplaceInfo);
 758      }
 759  
 760      private void joinFun(Object pollObj, Map&lt;String, Table&gt; localTableCache,
 761                           Map&lt;String, AbstractSideTableInfo&gt; sideTableMap, StreamTableEnvironment tableEnv,
 762                           List&lt;FieldReplaceInfo&gt; replaceInfoList) throws Exception{







 763          JoinInfo joinInfo = (JoinInfo) pollObj;
 764  
 765          JoinScope joinScope = new JoinScope();
 766          JoinScope.ScopeChild leftScopeChild = new JoinScope.ScopeChild();
 767          leftScopeChild.setAlias(joinInfo.getLeftTableAlias());
 768          leftScopeChild.setTableName(joinInfo.getLeftTableName());
 769  
 770          SqlKind sqlKind = joinInfo.getLeftNode().getKind();
 771          if(sqlKind == AS){
 772              dealAsSourceTable(tableEnv, joinInfo.getLeftNode(), localTableCache, replaceInfoList);
 773          }
 774  
<abbr title=" 775          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableName());"> 775          Table leftTable = getTableFromCache(localTableCache, joinInfo.getLeftTableAlias(), joinInfo.getLeftTableNa🔵</abbr>
<abbr title=" 776          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColumnNames());"> 776          RowTypeInfo leftTypeInfo = new RowTypeInfo(leftTable.getSchema().getTypes(), leftTable.getSchema().getColu🔵</abbr>
 777          leftScopeChild.setRowTypeInfo(leftTypeInfo);
 778  
 779          JoinScope.ScopeChild rightScopeChild = new JoinScope.ScopeChild();
 780          rightScopeChild.setAlias(joinInfo.getRightTableAlias());
 781          rightScopeChild.setTableName(joinInfo.getRightTableName());
 782          AbstractSideTableInfo sideTableInfo = sideTableMap.get(joinInfo.getRightTableName());
 783          if(sideTableInfo == null){
 784              sideTableInfo = sideTableMap.get(joinInfo.getRightTableAlias());
 785          }
 786  
 787          if(sideTableInfo == null){
 788              throw new RuntimeException(&quot;can&#x27;t not find side table:&quot; + joinInfo.getRightTableName());
 789          }
 790  
 791  //        if(!checkJoinCondition(joinInfo.getCondition(), joinInfo.getRightTableAlias(), sideTableInfo)){
 792  //            throw new RuntimeException(&quot;ON condition must contain all equal fields!!!&quot;);
 793  //        }
 794  
 795          rightScopeChild.setRowTypeInfo(sideTableInfo.getRowTypeInfo());
 796  
 797          joinScope.addScope(leftScopeChild);
 798          joinScope.addScope(rightScopeChild);
 799  


 800          //获取两个表的所有字段
<abbr title=" 801          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, true);"> 801          List&lt;FieldInfo&gt; sideJoinFieldInfo = ParserJoinField.getRowTypeInfo(joinInfo.getSelectNode(), joinScope, tr🔵</abbr>


 802  
 803          String leftTableAlias = joinInfo.getLeftTableAlias();
 804          Table targetTable = localTableCache.get(leftTableAlias);
 805          if(targetTable == null){
 806              targetTable = localTableCache.get(joinInfo.getLeftTableName());
 807          }
 808  
<abbr title=" 809          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColumnNames());"> 809          RowTypeInfo typeInfo = new RowTypeInfo(targetTable.getSchema().getTypes(), targetTable.getSchema().getColu🔵</abbr>
 810  
 811          DataStream&lt;CRow&gt; adaptStream = tableEnv.toRetractStream(targetTable, org.apache.flink.types.Row.class)
 812                  .map((Tuple2&lt;Boolean, Row&gt; tp2) -&gt; {
 813                      return new CRow(tp2.f1, tp2.f0);
 814                  }).returns(CRow.class);
 815  
 816  
 817          //join side table before keyby ===&gt; Reducing the size of each dimension table cache of async
 818          if (sideTableInfo.isPartitionedJoin()) {
<abbr title=" 819              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(), sideTableInfo);"> 819              List&lt;String&gt; leftJoinColList = getConditionFields(joinInfo.getCondition(), joinInfo.getLeftTableAlias(🔵</abbr>
 820              List&lt;String&gt; fieldNames = Arrays.asList(targetTable.getSchema().getFieldNames());
 821              int[] keyIndex = leftJoinColList.stream().mapToInt(fieldNames::indexOf).toArray();
<abbr title=" 822              adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.getSchema())));"> 822              adaptStream = adaptStream.keyBy(new CRowKeySelector(keyIndex, projectedTypeInfo(keyIndex, targetTable.🔵</abbr>
 823          }
 824  
 825          DataStream&lt;CRow&gt; dsOut = null;
 826          if(ECacheType.ALL.name().equalsIgnoreCase(sideTableInfo.getCacheType())){
<abbr title=" 827              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 827              dsOut = SideWithAllCacheOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlP🔵</abbr>
 828          }else{
<abbr title=" 829              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPath, typeInfo, joinInfo, sideJoinFieldInfo, sideTableInfo);"> 829              dsOut = SideAsyncOperator.getSideJoinDataStream(adaptStream, sideTableInfo.getType(), localSqlPluginPa🔵</abbr>
 830          }
 831  
 832          // TODO  将嵌套表中的字段传递过去, 去除冗余的ROWtime
 833          HashBasedTable&lt;String, String, String&gt; mappingTable = HashBasedTable.create();
 834          RowTypeInfo sideOutTypeInfo = buildOutRowTypeInfo(sideJoinFieldInfo, mappingTable);
 835  
 836          CRowTypeInfo cRowTypeInfo = new CRowTypeInfo(sideOutTypeInfo);
 837          dsOut.getTransformation().setOutputType(cRowTypeInfo);
 838  
 839          String targetTableName = joinInfo.getNewTableName();
 840          String targetTableAlias = joinInfo.getNewTableAlias();
 841  
 842          FieldReplaceInfo replaceInfo = new FieldReplaceInfo();
 843          replaceInfo.setMappingTable(mappingTable);
 844          replaceInfo.setTargetTableName(targetTableName);
 845          replaceInfo.setTargetTableAlias(targetTableAlias);
 846  
 847          //判断之前是不是被替换过,被替换过则设置之前的替换信息作为上一个节点
 848          for(FieldReplaceInfo tmp : replaceInfoList){
 849              if(tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableName())
 850              ||tmp.getTargetTableName().equalsIgnoreCase(joinInfo.getLeftTableAlias())){
 851                  replaceInfo.setPreNode(tmp);
 852                  break;
 853              }
 854          }
 855  
 856          replaceInfoList.add(replaceInfo);
 857  
 858          if (!tableEnv.isRegistered(joinInfo.getNewTableName())){

 859              Table joinTable = tableEnv.fromDataStream(dsOut);
 860              tableEnv.registerTable(joinInfo.getNewTableName(), joinTable);

 861              localTableCache.put(joinInfo.getNewTableName(), joinTable);
 862          }
 863      }
 864  
 865      private TypeInformation&lt;Row&gt; projectedTypeInfo(int[] fields, TableSchema schema) {
 866          String[] fieldNames = schema.getFieldNames();
 867          TypeInformation&lt;?&gt;[] fieldTypes = schema.getFieldTypes();
 868  
 869          String[] projectedNames = Arrays.stream(fields).mapToObj(i -&gt; fieldNames[i]).toArray(String[]::new);
<abbr title=" 870          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformation[]::new);"> 870          TypeInformation[] projectedTypes = Arrays.stream(fields).mapToObj(i -&gt; fieldTypes[i]).toArray(TypeInformat🔵</abbr>
 871          return new RowTypeInfo(projectedTypes, projectedNames);
 872      }
 873  
 874  
 875      private boolean checkFieldsInfo(CreateTmpTableParser.SqlParserResult result, Table table) {
 876          List&lt;String&gt; fieldNames = new LinkedList&lt;&gt;();
 877          String fieldsInfo = result.getFieldsInfoStr();
 878          String[] fields = StringUtils.split(fieldsInfo, &quot;,&quot;);
 879          for (int i = 0; i &lt; fields.length; i++) {
 880              String[] filed = fields[i].split(&quot;\\s&quot;);
 881              if (filed.length &lt; 2 || fields.length != table.getSchema().getColumnNames().length){
 882                  return false;
 883              } else {
 884                  String[] filedNameArr = new String[filed.length - 1];
 885                  System.arraycopy(filed, 0, filedNameArr, 0, filed.length - 1);
 886                  String fieldName = String.join(&quot; &quot;, filedNameArr);
 887                  fieldNames.add(fieldName);
 888                  String fieldType = filed[filed.length - 1 ].trim();
 889                  Class fieldClass = ClassUtil.stringConvertClass(fieldType);
 890                  Class tableField = table.getSchema().getFieldType(i).get().getTypeClass();
 891                  if (fieldClass == tableField){
 892                      continue;
 893                  } else {
 894                      return false;
 895                  }
 896              }
 897          }
 898          tmpFields = String.join(&quot;,&quot;, fieldNames);
 899          return true;
 900      }
 901  
 902  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            