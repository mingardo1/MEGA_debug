<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>427</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    427
                    <a href="426.html">prev</a>
                    <a href="428.html">next</a>
                    <a href="427_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_c82b9ccdf1393af88048eae80a098a6a0901d157_core/src/main/java/com/dtstack/flink/sql/util/TableUtils.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;c82b9ccdf1393af88048eae80a098a6a0901d157:core/src/main/java/com/dtstack/flink/sql/util/TableUtils.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;c82b9ccdf1393af88048eae80a098a6a0901d157^1:core/src/main/java/com/dtstack/flink/sql/util/TableUtils.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;c82b9ccdf1393af88048eae80a098a6a0901d157^2:core/src/main/java/com/dtstack/flink/sql/util/TableUtils.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;8cb6d5aea72f25034c7f3626ec6ef98783b1bee5:core/src/main/java/com/dtstack/flink/sql/util/TableUtils.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.util;
  21 
  22 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  23 import com.dtstack.flink.sql.side.FieldInfo;
  24 import com.dtstack.flink.sql.side.JoinInfo;
  25 import com.dtstack.flink.sql.side.PredicateInfo;
  26 import com.google.common.base.Preconditions;
  27 import com.google.common.base.Strings;
  28 import com.google.common.collect.HashBasedTable;
  29 import com.google.common.collect.HashBiMap;
  30 import com.google.common.collect.Lists;
  31 import org.apache.calcite.sql.SqlAsOperator;
  32 import org.apache.calcite.sql.SqlBasicCall;
  33 import org.apache.calcite.sql.SqlDataTypeSpec;
  34 import org.apache.calcite.sql.SqlIdentifier;
  35 import org.apache.calcite.sql.SqlJoin;
  36 import org.apache.calcite.sql.SqlKind;
  37 import org.apache.calcite.sql.SqlLiteral;
  38 import org.apache.calcite.sql.SqlNode;
  39 import org.apache.calcite.sql.SqlNodeList;
  40 import org.apache.calcite.sql.SqlOperator;
  41 import org.apache.calcite.sql.SqlSelect;
  42 import org.apache.calcite.sql.fun.SqlCase;
  43 import org.apache.calcite.sql.parser.SqlParserPos;
  44 import org.apache.commons.collections.CollectionUtils;
  45 import org.apache.commons.lang3.StringUtils;
  46 import org.apache.flink.table.api.Table;
  47 
  48 import java.util.List;
  49 import java.util.Map;
  50 import java.util.Queue;
  51 import java.util.Set;
  52 import java.util.regex.Matcher;
  53 import java.util.regex.Pattern;
  54 
  55 import static org.apache.calcite.sql.SqlKind.*;
  56 import static org.apache.calcite.sql.SqlKind.CASE;
  57 import static org.apache.calcite.sql.SqlKind.OTHER;
  58 
  59 /**
  60  * Ë°®ÁöÑËß£ÊûêÁõ∏ÂÖ≥
  61  * Date: 2020/2/17
  62  * Company: www.dtstack.com
  63  * @author xuchao
  64  */
  65 
  66 public class TableUtils {
  67 
  68     public static final char SPLIT = &#x27;_&#x27;;
  69     public static final Pattern stringPattern = Pattern.compile(&quot;\&quot;.*?\&quot;|\&#x27;.*?\&#x27;&quot;);
  70     /**
  71      * Ëé∑Âèñselect ÁöÑÂ≠óÊÆµ
  72      * @param sqlSelect
  73      */
<abbr title="  74     public static List&lt;FieldInfo&gt; parserSelectField(SqlSelect sqlSelect, Map&lt;String, Table&gt; localTableCache){">  74     public static List&lt;FieldInfo&gt; parserSelectField(SqlSelect sqlSelect, Map&lt;String, Table&gt; localTableCacüîµ</abbr>
  75         SqlNodeList sqlNodeList = sqlSelect.getSelectList();
  76         List&lt;FieldInfo&gt; fieldInfoList = Lists.newArrayList();
  77         String fromNode = sqlSelect.getFrom().toString();
  78 
  79         for (SqlNode fieldNode : sqlNodeList.getList()) {
  80             extractSelectFieldToFieldInfo(fieldNode,fromNode,fieldInfoList,localTableCache);
  81         }
  82 
  83         return fieldInfoList;
  84     }
  85 
  86     /**
  87      *  Ëß£Êûêselect Node ÊèêÂèñFieldInfo
  88      * @param fieldNode
  89      * @param fromNode
  90      * @param fieldInfoList
  91      * @param localTableCache
  92      */
<abbr title="  93     public static void extractSelectFieldToFieldInfo(SqlNode fieldNode, String fromNode, List&lt;FieldInfo&gt; fieldInfoList, Map&lt;String, Table&gt; localTableCache) {">  93     public static void extractSelectFieldToFieldInfo(SqlNode fieldNode, String fromNode, List&lt;FieldInfo&gt; üîµ</abbr>
  94         if (fieldNode.getKind() == IDENTIFIER) {
  95             SqlIdentifier identifier = (SqlIdentifier) fieldNode;
  96             if (!identifier.isStar()) {
<abbr title="  97                 String tableName = identifier.names.size() == 1 ? fromNode : identifier.getComponent(0).getSimple();">  97                 String tableName = identifier.names.size() == 1 ? fromNode : identifier.getComponent(0).güîµ</abbr>
<abbr title="  98                 String fieldName = identifier.names.size() == 1 ? identifier.getComponent(0).getSimple() : identifier.getComponent(1).getSimple();">  98                 String fieldName = identifier.names.size() == 1 ? identifier.getComponent(0).getSimple() üîµ</abbr>
  99                 FieldInfo fieldInfo = new FieldInfo();
 100                 fieldInfo.setTable(tableName);
 101                 fieldInfo.setFieldName(fieldName);
 102 
 103                 if (!fieldInfoList.contains(fieldInfo)) {
 104                     fieldInfoList.add(fieldInfo);
 105                 }
 106             } else {
 107                 //Â§ÑÁêÜ
 108                 int identifierSize = identifier.names.size();
 109                 switch (identifierSize) {
 110                     case 1:
 111                         throw new RuntimeException(&quot;not support to parse * without scope of table&quot;);
 112                     default:
 113                         SqlIdentifier tableIdentify = identifier.skipLast(1);
 114                         Table registerTable = localTableCache.get(tableIdentify.getSimple());
 115                         if (registerTable == null) {
<abbr title=" 116                             throw new RuntimeException(&quot;can&#x27;t find table alias &quot; + tableIdentify.getSimple());"> 116                             throw new RuntimeException(&quot;can&#x27;t find table alias &quot; + tableIdentify.getSimplüîµ</abbr>
 117                         }
 118 
 119                         String[] fieldNames = registerTable.getSchema().getFieldNames();
 120                         for (String fieldName : fieldNames) {
 121                             FieldInfo fieldInfo = new FieldInfo();
 122                             fieldInfo.setTable(tableIdentify.getSimple());
 123                             fieldInfo.setFieldName(fieldName);
 124                             fieldInfoList.add(fieldInfo);
 125                         }
 126                 }
 127             }
 128         } else if (AGGREGATE.contains(fieldNode.getKind())
 129                 || AVG_AGG_FUNCTIONS.contains(fieldNode.getKind())
 130                 || COMPARISON.contains(fieldNode.getKind())
 131                 || fieldNode.getKind() == OTHER_FUNCTION
 132                 || fieldNode.getKind() == DIVIDE
 133                 || fieldNode.getKind() == CAST
 134                 || fieldNode.getKind() == TRIM
 135                 || fieldNode.getKind() == TIMES
 136                 || fieldNode.getKind() == PLUS
 137                 || fieldNode.getKind() == NOT_IN
 138                 || fieldNode.getKind() == OR
 139                 || fieldNode.getKind() == AND
 140                 || fieldNode.getKind() == MINUS
 141                 || fieldNode.getKind() == TUMBLE
 142                 || fieldNode.getKind() == TUMBLE_START
 143                 || fieldNode.getKind() == TUMBLE_END
 144                 || fieldNode.getKind() == SESSION
 145                 || fieldNode.getKind() == SESSION_START
 146                 || fieldNode.getKind() == SESSION_END
 147                 || fieldNode.getKind() == HOP
 148                 || fieldNode.getKind() == HOP_START
 149                 || fieldNode.getKind() == HOP_END
 150                 || fieldNode.getKind() == BETWEEN
 151                 || fieldNode.getKind() == IS_NULL
 152                 || fieldNode.getKind() == IS_NOT_NULL
 153                 || fieldNode.getKind() == CONTAINS
 154                 || fieldNode.getKind() == TIMESTAMP_ADD
 155                 || fieldNode.getKind() == TIMESTAMP_DIFF
 156                 || fieldNode.getKind() == LIKE
 157                 || fieldNode.getKind() == COALESCE
 158                 ) {
 159             SqlBasicCall sqlBasicCall = (SqlBasicCall) fieldNode;
 160             for (int i = 0; i &lt; sqlBasicCall.getOperands().length; i++) {
 161                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 162                 if (sqlNode instanceof SqlLiteral) {
 163                     continue;
 164                 }
 165 
 166                 if (sqlNode instanceof SqlDataTypeSpec) {
 167                     continue;
 168                 }
 169                 extractSelectFieldToFieldInfo(sqlNode, fromNode, fieldInfoList, localTableCache);
 170             }
 171         } else if (fieldNode.getKind() == AS) {
 172             SqlNode leftNode = ((SqlBasicCall) fieldNode).getOperands()[0];
 173             extractSelectFieldToFieldInfo(leftNode, fromNode,fieldInfoList, localTableCache);
 174         } else if (fieldNode.getKind() == CASE) {
 175             SqlCase sqlCase = (SqlCase) fieldNode;
 176             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 177             SqlNodeList thenOperands = sqlCase.getThenOperands();
 178             SqlNode elseNode = sqlCase.getElseOperand();
 179 
 180             for (int i = 0; i &lt; whenOperands.size(); i++) {
 181                 SqlNode oneOperand = whenOperands.get(i);
 182                 extractSelectFieldToFieldInfo(oneOperand, fromNode, fieldInfoList, localTableCache);
 183             }
 184 
 185             for (int i = 0; i &lt; thenOperands.size(); i++) {
 186                 SqlNode oneOperand = thenOperands.get(i);
 187                 extractSelectFieldToFieldInfo(oneOperand, fromNode, fieldInfoList, localTableCache);
 188 
 189             }
 190 
 191             extractSelectFieldToFieldInfo(elseNode, fromNode, fieldInfoList, localTableCache);
 192         }
 193     }
 194 
<abbr title=" 195     public static SqlBasicCall buildAsNodeByJoinInfo(JoinInfo joinInfo, SqlNode sqlNode0, String tableAlias) {"> 195     public static SqlBasicCall buildAsNodeByJoinInfo(JoinInfo joinInfo, SqlNode sqlNode0, String tableAliüîµ</abbr>
 196         SqlOperator operator = new SqlAsOperator();
 197 
 198         SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 199         String newTableName = joinInfo.getNewTableName();
 200 
<abbr title=" 201         String newTableAlias = !StringUtils.isEmpty(tableAlias) ? tableAlias : joinInfo.getNewTableAlias();"> 201         String newTableAlias = !StringUtils.isEmpty(tableAlias) ? tableAlias : joinInfo.getNewTableAlias(üîµ</abbr>
 202 
 203         if (null == sqlNode0) {
 204             sqlNode0 = new SqlIdentifier(newTableName, null, sqlParserPos);
 205         }
 206 
 207         SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(newTableAlias, null, sqlParserPos);
 208         SqlNode[] sqlNodes = new SqlNode[2];
 209         sqlNodes[0] = sqlNode0;
 210         sqlNodes[1] = sqlIdentifierAlias;
 211         return new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 212     }
 213 
 214     /**
 215      *
 216      * @param joinInfo
 217      * @param sqlNode
 218      * @param queueInfo
 219      * @return   ‰∏§‰∏™ËæπÂÖ≥ËÅîÂêéÁöÑÊñ∞Ë°®Ë°®Âêç
 220      */
<abbr title=" 221     public static String dealSelectResultWithJoinInfo(JoinInfo joinInfo, SqlSelect sqlNode, Queue&lt;Object&gt; queueInfo) {"> 221     public static String dealSelectResultWithJoinInfo(JoinInfo joinInfo, SqlSelect sqlNode, Queue&lt;Object&gt;üîµ</abbr>
 222         //SideJoinInfo rename
 223         if (joinInfo.checkIsSide()) {
 224             joinInfo.setSelectFields(sqlNode.getSelectList());
 225             joinInfo.setSelectNode(sqlNode);
 226             if (joinInfo.isRightIsSideTable()) {
 227                 //Analyzing left is not a simple table
 228                 if (joinInfo.getLeftNode().getKind() == SELECT) {
 229                     queueInfo.offer(joinInfo.getLeftNode());
 230                 }
 231 
 232                 queueInfo.offer(joinInfo);
 233             } else {
 234                 //Determining right is not a simple table
 235                 if (joinInfo.getRightNode().getKind() == SELECT) {
 236                     queueInfo.offer(joinInfo.getLeftNode());
 237                 }
 238 
 239                 queueInfo.offer(joinInfo);
 240             }
 241             replaceFromNodeForJoin(joinInfo, sqlNode);
 242             return joinInfo.getNewTableName();
 243         }
 244         return &quot;&quot;;
 245     }
 246 
 247     public static void replaceFromNodeForJoin(JoinInfo joinInfo, SqlSelect sqlNode) {
 248         //Update from node
 249         SqlBasicCall sqlBasicCall = buildAsNodeByJoinInfo(joinInfo, null, null);
 250         String newAliasName = sqlBasicCall.operand(1).toString();
 251 
 252         //ÊõøÊç¢select ‰∏≠ÁöÑÂ±ûÊÄß‰∏∫Êñ∞ÁöÑË°®ÂêçÁß∞ÂíåÂ≠óÊÆµ
 253         HashBasedTable&lt;String, String, String&gt; fieldMapping = joinInfo.getTableFieldRef();
 254         Map&lt;String, String&gt; leftFieldMapping = fieldMapping.row(joinInfo.getLeftTableAlias());
 255         Map&lt;String, String&gt; rightFieldMapping = fieldMapping.row(joinInfo.getRightTableAlias());
 256 
 257        /* for(SqlNode oneSelectNode : sqlNode.getSelectList()){
<abbr title=" 258             replaceSelectFieldTable(oneSelectNode, joinInfo.getLeftTableAlias(), newAliasName, null ,leftFieldMapping);"> 258             replaceSelectFieldTable(oneSelectNode, joinInfo.getLeftTableAlias(), newAliasName, null ,leftüîµ</abbr>
<abbr title=" 259             replaceSelectFieldTable(oneSelectNode, joinInfo.getRightTableAlias(), newAliasName, null , rightFieldMapping);"> 259             replaceSelectFieldTable(oneSelectNode, joinInfo.getRightTableAlias(), newAliasName, null , riüîµ</abbr>
 260         }*/
 261 
 262         //where‰∏≠ÁöÑÊù°‰ª∂Â±ûÊÄß‰∏∫Êñ∞ÁöÑË°®ÂêçÁß∞ÂíåÂ≠óÊÆµ
<abbr title=" 263         FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getLeftTableAlias(), newAliasName, leftFieldMapping);"> 263         FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getLeftTableAlias(), newAliasName, leftFieldMüîµ</abbr>
<abbr title=" 264         FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getRightTableAlias(), newAliasName, rightFieldMapping);"> 264         FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getRightTableAlias(), newAliasName, rightFielüîµ</abbr>
 265         sqlNode.setFrom(sqlBasicCall);
 266     }
 267 
 268 
 269     /**
 270      * Ëé∑ÂèñËäÇÁÇπÂÖ≥ËÅîÁöÑÊü•ËØ¢Ë°®
 271      * @param fromTable
 272      * @param tableNameSet
 273      */
 274     public static void getFromTableInfo(SqlNode fromTable, Set&lt;String&gt; tableNameSet){
 275         SqlKind sqlKind = fromTable.getKind();
 276         switch (sqlKind){
 277             case AS:
 278                 SqlNode alias = ((SqlBasicCall) fromTable).getOperands()[1];
 279                 tableNameSet.add(alias.toString());
 280                 return;
 281             case JOIN:
 282                 getFromTableInfo(((SqlJoin)fromTable).getLeft(), tableNameSet);
 283                 getFromTableInfo(((SqlJoin)fromTable).getRight(), tableNameSet);
 284                 return;
 285             case IDENTIFIER:
 286                 tableNameSet.add(((SqlIdentifier)fromTable).getSimple());
 287                 return;
 288             case SELECT:
 289                 getFromTableInfo(((SqlSelect) fromTable).getFrom(), tableNameSet);
 290                 return;
 291             default:
 292                 throw new RuntimeException(&quot;not support sqlKind:&quot; + sqlKind);
 293         }
 294     }
 295 
 296     /**
 297      * ÊõøÊç¢select ‰∏≠ÁöÑÂ≠óÊÆµ‰ø°ÊÅØ
 298      * Â¶ÇÊûúmappingTable ÈùûÁ©∫Âàô‰ªéËØ•ÂèÇÊï∞Ëé∑ÂèñÂ≠óÊÆµÁöÑÊò†Â∞Ñ
 299      * Â¶ÇÊûúmappingTable ‰∏∫Á©∫ÂàôÊ†πÊçÆÊòØÂê¶Â≠òÂú®Êñ∞ÁîüÊàêÂ≠óÊÆµ
 300      * @param selectNode
 301      * @param oldTbName
 302      * @param newTbName
 303      * @param fieldReplaceRef
 304      */
 305     public static void replaceSelectFieldTable(SqlNode selectNode,
 306                                                String oldTbName,
 307                                                String newTbName,
 308                                                HashBiMap&lt;String, String&gt; fieldReplaceRef) {
 309         if (selectNode.getKind() == AS) {
 310             SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 311             replaceSelectFieldTable(leftNode, oldTbName, newTbName, fieldReplaceRef);
 312 
 313         }else if(selectNode.getKind() == IDENTIFIER){
 314             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 315 
 316             if(sqlIdentifier.names.size() == 1){
 317                 return ;
 318             }
 319 
 320             String fieldTableName = sqlIdentifier.names.get(0);
 321             if(oldTbName.equalsIgnoreCase(fieldTableName)){
 322                 replaceOneSelectField(sqlIdentifier, newTbName, oldTbName, fieldReplaceRef);
 323             }
 324 
 325         }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//Â≠óÈù¢Âê´‰πâ
 326             return;
 327         }else if(  AGGREGATE.contains(selectNode.getKind())
 328                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 329                 || COMPARISON.contains(selectNode.getKind())
 330                 || selectNode.getKind() == OTHER_FUNCTION
 331                 || selectNode.getKind() == DIVIDE
 332                 || selectNode.getKind() == CAST
 333                 || selectNode.getKind() == TRIM
 334                 || selectNode.getKind() == TIMES
 335                 || selectNode.getKind() == PLUS
 336                 || selectNode.getKind() == NOT_IN
 337                 || selectNode.getKind() == OR
 338                 || selectNode.getKind() == AND
 339                 || selectNode.getKind() == MINUS
 340                 || selectNode.getKind() == TUMBLE
 341                 || selectNode.getKind() == TUMBLE_START
 342                 || selectNode.getKind() == TUMBLE_END
 343                 || selectNode.getKind() == SESSION
 344                 || selectNode.getKind() == SESSION_START
 345                 || selectNode.getKind() == SESSION_END
 346                 || selectNode.getKind() == HOP
 347                 || selectNode.getKind() == HOP_START
 348                 || selectNode.getKind() == HOP_END
 349                 || selectNode.getKind() == BETWEEN
 350                 || selectNode.getKind() == IS_NULL
 351                 || selectNode.getKind() == IS_NOT_NULL
 352                 || selectNode.getKind() == CONTAINS
 353                 || selectNode.getKind() == TIMESTAMP_ADD
 354                 || selectNode.getKind() == TIMESTAMP_DIFF
 355                 || selectNode.getKind() == LIKE
 356                 || selectNode.getKind() == COALESCE
 357 
 358         ){
 359             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 360             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 361                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 362                 if(sqlNode instanceof SqlLiteral){
 363                     continue;
 364                 }
 365 
 366                 if(sqlNode instanceof SqlDataTypeSpec){
 367                     continue;
 368                 }
 369 
 370                 replaceSelectFieldTable(sqlNode, oldTbName, newTbName, fieldReplaceRef);
 371             }
 372 
 373         }else if(selectNode.getKind() == CASE){
 374             SqlCase sqlCase = (SqlCase) selectNode;
 375             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 376             SqlNodeList thenOperands = sqlCase.getThenOperands();
 377             SqlNode elseNode = sqlCase.getElseOperand();
 378 
 379             for(int i=0; i&lt;whenOperands.size(); i++){
 380                 SqlNode oneOperand = whenOperands.get(i);
 381                 replaceSelectFieldTable(oneOperand, oldTbName, newTbName, fieldReplaceRef);
 382             }
 383 
 384             for(int i=0; i&lt;thenOperands.size(); i++){
 385                 SqlNode oneOperand = thenOperands.get(i);
 386                 replaceSelectFieldTable(oneOperand, oldTbName, newTbName, fieldReplaceRef);
 387 
 388             }
 389 
 390             replaceSelectFieldTable(elseNode, oldTbName, newTbName, fieldReplaceRef);
 391         }else if(selectNode.getKind() == OTHER){
 392             //‰∏çÂ§ÑÁêÜ
 393             return;
 394         }else{
<abbr title=" 395             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 395             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, üîµ</abbr>
 396         }
 397     }
 398 
 399     private static void replaceOneSelectField(SqlIdentifier sqlIdentifier,
 400                                               String newTbName,
 401                                               String oldTbName,
 402                                               HashBiMap&lt;String, String&gt; fieldReplaceRef){
 403         SqlIdentifier newField = sqlIdentifier.setName(0, newTbName);
 404         String fieldName = sqlIdentifier.names.get(1);
 405         String fieldKey = oldTbName + &quot;_&quot; + fieldName;
 406 
 407         if(!fieldReplaceRef.containsKey(fieldKey)){
 408             if(fieldReplaceRef.inverse().get(fieldName) != null){
 409                 //Êç¢‰∏Ä‰∏™ÂêçÂ≠ó
 410                 String mappingFieldName = ParseUtils.dealDuplicateFieldName(fieldReplaceRef, fieldName);
 411                 newField = newField.setName(1, mappingFieldName);
 412                 fieldReplaceRef.put(fieldKey, mappingFieldName);
 413             } else {
 414                 fieldReplaceRef.put(fieldKey, fieldName);
 415             }
 416         }else {
 417             newField = newField.setName(1, fieldReplaceRef.get(fieldKey));
 418         }
 419 
 420         sqlIdentifier.assignNamesFrom(newField);
 421     }
 422 
 423     /**
 424      * ÊõøÊç¢Âè¶Â§ñjoin Ë°®ÁöÑÊåáÂÆöË°®Âêç‰∏∫Êñ∞ÂÖ≥ËÅîÂ§ÑÁêÜÁöÑË°®ÂêçÁß∞
 425      * @param condition
 426      * @param oldTabFieldRefNew
 427      */
<abbr title=" 428     public static void replaceJoinFieldRefTableName(SqlNode condition, Map&lt;String, String&gt; oldTabFieldRefNew){"> 428     public static void replaceJoinFieldRefTableName(SqlNode condition, Map&lt;String, String&gt; oldTabFieldRefüîµ</abbr>
 429         if (null == condition || condition.getKind() == LITERAL) {
 430             return;
 431         }
 432         SqlKind joinKind = condition.getKind();
 433         if( AGGREGATE.contains(joinKind)
 434                 || AVG_AGG_FUNCTIONS.contains(joinKind)
 435                 || COMPARISON.contains(joinKind)
 436                 || joinKind == OTHER_FUNCTION
 437                 || joinKind == DIVIDE
 438                 || joinKind == CAST
 439                 || joinKind == TRIM
 440                 || joinKind == TIMES
 441                 || joinKind == PLUS
 442                 || joinKind == NOT_IN
 443                 || joinKind == OR
 444                 || joinKind == AND
 445                 || joinKind == MINUS
 446                 || joinKind == TUMBLE
 447                 || joinKind == TUMBLE_START
 448                 || joinKind == TUMBLE_END
 449                 || joinKind == SESSION
 450                 || joinKind == SESSION_START
 451                 || joinKind == SESSION_END
 452                 || joinKind == HOP
 453                 || joinKind == HOP_START
 454                 || joinKind == HOP_END
 455                 || joinKind == BETWEEN
 456                 || joinKind == IS_NULL
 457                 || joinKind == IS_NOT_NULL
 458                 || joinKind == CONTAINS
 459                 || joinKind == TIMESTAMP_ADD
 460                 || joinKind == TIMESTAMP_DIFF
 461                 || joinKind == LIKE
 462                 || joinKind == COALESCE
 463                 || joinKind == EQUALS ){
 464 
 465             SqlBasicCall sqlBasicCall = (SqlBasicCall) condition;
 466             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 467                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 468                 if(sqlNode instanceof SqlLiteral){
 469                     continue;
 470                 }
 471 
 472                 if(sqlNode instanceof SqlDataTypeSpec){
 473                     continue;
 474                 }
 475 
 476                 replaceJoinFieldRefTableName(sqlNode, oldTabFieldRefNew);
 477             }
 478 
 479         } else if (condition.getKind() == IDENTIFIER) {
<abbr title=" 480             Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 480             Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must büîµ</abbr>
 481             String fieldRefTable = ((SqlIdentifier)condition).names.get(0);
 482 
<abbr title=" 483             String targetFieldName = TableUtils.getTargetRefField(oldTabFieldRefNew, condition.toString());"> 483             String targetFieldName = TableUtils.getTargetRefField(oldTabFieldRefNew, condition.toString()üîµ</abbr>
 484 
 485             if(StringUtils.isNotBlank(targetFieldName)){
 486                 String[] fieldSplits = StringUtils.split(targetFieldName, &quot;.&quot;);
 487                 SqlIdentifier newField = ((SqlIdentifier)condition).setName(0, fieldSplits[0]);
 488                 newField = newField.setName(1, fieldSplits[1]);
 489                 ((SqlIdentifier)condition).assignNamesFrom(newField);
 490             }
 491         }
 492     }
 493 
 494     public static String getTargetRefTable(Map&lt;String, String&gt; refTableMap, String tableName){
 495         String targetTableName = null;
 496         String preTableName;
 497 
 498         do {
 499             preTableName = targetTableName == null ? tableName : targetTableName;
 500             targetTableName = refTableMap.get(preTableName);
 501         } while (targetTableName != null);
 502 
 503         return preTableName;
 504     }
 505 
 506     public static String getTargetRefField(Map&lt;String, String&gt; refFieldMap, String currFieldName){
 507         String targetFieldName = null;
 508         String preFieldName;
 509 
 510         do {
 511             preFieldName = targetFieldName == null ? currFieldName : targetFieldName;
 512             targetFieldName = refFieldMap.get(preFieldName);
 513         } while (targetFieldName != null);
 514 
 515         return preFieldName;
 516     }
 517 
<abbr title=" 518     public static void replaceWhereCondition(SqlNode parentWhere, String oldTbName, String newTbName, HashBiMap&lt;String, String&gt; fieldReplaceRef){"> 518     public static void replaceWhereCondition(SqlNode parentWhere, String oldTbName, String newTbName, Hasüîµ</abbr>
 519 
 520         if(parentWhere == null){
 521             return;
 522         }
 523 
 524         SqlKind kind = parentWhere.getKind();
 525         if(kind == AND){
<abbr title=" 526             replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[0], oldTbName, newTbName, fieldReplaceRef);"> 526             replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[0], oldTbName, newTbName, fiüîµ</abbr>
<abbr title=" 527             replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[1], oldTbName, newTbName, fieldReplaceRef);"> 527             replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[1], oldTbName, newTbName, fiüîµ</abbr>
 528 
 529         } else {
 530             replaceConditionNode(parentWhere, oldTbName, newTbName, fieldReplaceRef);
 531         }
 532     }
 533 
<abbr title=" 534     private static void replaceConditionNode(SqlNode selectNode, String oldTbName, String newTbName, HashBiMap&lt;String, String&gt; fieldReplaceRef) {"> 534     private static void replaceConditionNode(SqlNode selectNode, String oldTbName, String newTbName, Hashüîµ</abbr>
 535         if(selectNode.getKind() == IDENTIFIER){
 536             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 537 
 538             if(sqlIdentifier.names.size() == 1){
 539                 return;
 540             }
 541 
 542             String tableName = sqlIdentifier.names.asList().get(0);
 543             String tableField = sqlIdentifier.names.asList().get(1);
 544             String fieldKey = tableName + &quot;_&quot; + tableField;
 545 
 546             if(tableName.equalsIgnoreCase(oldTbName)){
 547 
<abbr title=" 548                 String newFieldName = fieldReplaceRef.get(fieldKey) == null ? tableField : fieldReplaceRef.get(fieldKey);"> 548                 String newFieldName = fieldReplaceRef.get(fieldKey) == null ? tableField : fieldReplaceReüîµ</abbr>
 549                 SqlIdentifier newField = ((SqlIdentifier)selectNode).setName(0, newTbName);
 550                 newField = newField.setName(1, newFieldName);
 551                 ((SqlIdentifier)selectNode).assignNamesFrom(newField);
 552             }
 553             return;
 554         }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//Â≠óÈù¢Âê´‰πâ
 555             return;
 556         }else if(  AGGREGATE.contains(selectNode.getKind())
 557                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 558                 || COMPARISON.contains(selectNode.getKind())
 559                 || selectNode.getKind() == OTHER_FUNCTION
 560                 || selectNode.getKind() == DIVIDE
 561                 || selectNode.getKind() == CAST
 562                 || selectNode.getKind() == TRIM
 563                 || selectNode.getKind() == TIMES
 564                 || selectNode.getKind() == PLUS
 565                 || selectNode.getKind() == NOT_IN
 566                 || selectNode.getKind() == OR
 567                 || selectNode.getKind() == AND
 568                 || selectNode.getKind() == MINUS
 569                 || selectNode.getKind() == TUMBLE
 570                 || selectNode.getKind() == TUMBLE_START
 571                 || selectNode.getKind() == TUMBLE_END
 572                 || selectNode.getKind() == SESSION
 573                 || selectNode.getKind() == SESSION_START
 574                 || selectNode.getKind() == SESSION_END
 575                 || selectNode.getKind() == HOP
 576                 || selectNode.getKind() == HOP_START
 577                 || selectNode.getKind() == HOP_END
 578                 || selectNode.getKind() == BETWEEN
 579                 || selectNode.getKind() == IS_NULL
 580                 || selectNode.getKind() == IS_NOT_NULL
 581                 || selectNode.getKind() == CONTAINS
 582                 || selectNode.getKind() == TIMESTAMP_ADD
 583                 || selectNode.getKind() == TIMESTAMP_DIFF
 584                 || selectNode.getKind() == LIKE
 585                 || selectNode.getKind() == COALESCE
 586 
 587         ){
 588             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 589             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 590                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 591                 if(sqlNode instanceof SqlLiteral){
 592                     continue;
 593                 }
 594 
 595                 if(sqlNode instanceof SqlDataTypeSpec){
 596                     continue;
 597                 }
 598 
 599                 replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef);
 600             }
 601 
 602             return;
 603         }else if(selectNode.getKind() == OTHER){
 604             //‰∏çÂ§ÑÁêÜ
 605             return;
 606         } else if (selectNode.getKind() == CASE) {
 607             SqlCase sqlCase = (SqlCase) selectNode;
 608 
<abbr title=" 609             sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef));"> 609             sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbNamüîµ</abbr>
<abbr title=" 610             sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef));"> 610             sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbNamüîµ</abbr>
 611             replaceConditionNode(sqlCase.getElseOperand(), oldTbName, newTbName, fieldReplaceRef);
 612         } else {
<abbr title=" 613             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 613             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, üîµ</abbr>
 614         }
 615     }
 616 
 617     /**
 618      * Ëé∑ÂèñÊù°‰ª∂‰∏≠ÂÖ≥ËÅîÁöÑË°®‰ø°ÊÅØ
 619      * @param selectNode
 620      * @param fieldInfos
 621      */
 622     public static void getConditionRefTable(SqlNode selectNode, Set&lt;String&gt; fieldInfos) {
 623         if (selectNode.getKind() == IDENTIFIER) {
 624             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 625 
 626             fieldInfos.add(sqlIdentifier.toString());
 627             return;
 628         } else if (selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN) {//Â≠óÈù¢Âê´‰πâ
 629             return;
 630         } else if (AGGREGATE.contains(selectNode.getKind())
 631                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 632                 || COMPARISON.contains(selectNode.getKind())
 633                 || selectNode.getKind() == OTHER_FUNCTION
 634                 || selectNode.getKind() == DIVIDE
 635                 || selectNode.getKind() == CAST
 636                 || selectNode.getKind() == TRIM
 637                 || selectNode.getKind() == TIMES
 638                 || selectNode.getKind() == PLUS
 639                 || selectNode.getKind() == NOT_IN
 640                 || selectNode.getKind() == OR
 641                 || selectNode.getKind() == AND
 642                 || selectNode.getKind() == MINUS
 643                 || selectNode.getKind() == TUMBLE
 644                 || selectNode.getKind() == TUMBLE_START
 645                 || selectNode.getKind() == TUMBLE_END
 646                 || selectNode.getKind() == SESSION
 647                 || selectNode.getKind() == SESSION_START
 648                 || selectNode.getKind() == SESSION_END
 649                 || selectNode.getKind() == HOP
 650                 || selectNode.getKind() == HOP_START
 651                 || selectNode.getKind() == HOP_END
 652                 || selectNode.getKind() == BETWEEN
 653                 || selectNode.getKind() == IS_NULL
 654                 || selectNode.getKind() == IS_NOT_NULL
 655                 || selectNode.getKind() == CONTAINS
 656                 || selectNode.getKind() == TIMESTAMP_ADD
 657                 || selectNode.getKind() == TIMESTAMP_DIFF
 658                 || selectNode.getKind() == LIKE
 659                 || selectNode.getKind() == COALESCE
 660 
 661                 ) {
 662             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 663             for (int i = 0; i &lt; sqlBasicCall.getOperands().length; i++) {
 664                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 665                 if (sqlNode instanceof SqlLiteral) {
 666                     continue;
 667                 }
 668 
 669                 if (sqlNode instanceof SqlDataTypeSpec) {
 670                     continue;
 671                 }
 672 
 673                 getConditionRefTable(sqlNode, fieldInfos);
 674             }
 675 
 676             return;
 677         } else if (selectNode.getKind() == OTHER) {
 678             //‰∏çÂ§ÑÁêÜ
 679             return;
 680         } else if (selectNode.getKind() == CASE) {
 681             SqlCase sqlCase = (SqlCase) selectNode;
 682 
<abbr title=" 683             sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfos));"> 683             sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfüîµ</abbr>
<abbr title=" 684             sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfos));"> 684             sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfüîµ</abbr>
 685             getConditionRefTable(sqlCase.getElseOperand(), fieldInfos);
 686         } else {
<abbr title=" 687             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 687             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, üîµ</abbr>
 688         }
 689     }
 690 
 691     public static String buildTableField(String tableName, String fieldName){
 692         return String.format(&quot;%s.%s&quot;, tableName, fieldName);
 693     }
 694 
 695 
 696     public static String buildTableNameWithScope(String tableName, String scope){
 697         if(StringUtils.isEmpty(scope)){
 698             return tableName;
 699         }
 700 
 701         return tableName + &quot;_&quot; + scope;
 702     }
 703 
 704 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 705     /**</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 706      * add constant join fields, using in such as hbase„ÄÅredis etc kv database</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 707      * @param keyMap</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 708      */</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 709     public static void addConstant(Map&lt;String, Object&gt; keyMap, AbstractSideTableInfo sideTableInfo) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 710         List&lt;PredicateInfo&gt; predicateInfos = sideTableInfo.getPredicateInfoes();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 711         final String name = sideTableInfo.getName();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 712         for (PredicateInfo info : predicateInfos) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 713             if (info.getOwnerTable().equals(name)</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 714                 &amp;&amp; info.getOperatorName().equals(&quot;=&quot;)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 715                 String condition = info.getCondition();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 716                 Matcher matcher = stringPattern.matcher(condition);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 717                 if (matcher.matches()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 718                     condition = condition.substring(1, condition.length() - 1);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 719                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 720                 keyMap.put(info.getFieldName(), condition);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 721             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 722         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 723     }</span>
 724 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 725     public static String buildTableField(String tableName, String fieldName){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 726         return String.format(&quot;%s.%s&quot;, tableName, fieldName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 727     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 728 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 729 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 730     public static String buildTableNameWithScope(String tableName, String scope){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 731         if(StringUtils.isEmpty(scope)){</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 732             return tableName;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 733         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 734 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 735         return tableName + &quot;_&quot; + scope;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 736     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 737 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 738 }</span>
 739 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 740     public static String buildTableNameWithScope(String leftTableName, String leftTableAlias, String rightTableName, String scope, Set&lt;String&gt; existTableNames){"> 740     public static String buildTableNameWithScope(String leftTableName, String leftTableAlias, String righüîµ</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 741         //ÂÖºÂÆπÂ∑¶ËæπË°®ÊòØas ÁöÑÊÉÖÂÜµ</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 742         String leftStr = Strings.isNullOrEmpty(leftTableName) ? leftTableAlias : leftTableName;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 743         String newName = leftStr + &quot;_&quot; + rightTableName;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 744         if (CollectionUtils.isEmpty(existTableNames)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 745             return TableUtils.buildTableNameWithScope(newName, scope);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 746         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 747 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 748         if (!existTableNames.contains(newName)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 749             return TableUtils.buildTableNameWithScope(newName, scope);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 750         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 751 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 752         return TableUtils.buildTableNameWithScope(newName, scope) + &quot;_&quot; + System.currentTimeMillis();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 753     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 754 </span>
 755 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 756 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.util;
  21 
  22 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  23 import com.dtstack.flink.sql.side.FieldInfo;
  24 import com.dtstack.flink.sql.side.JoinInfo;
  25 import com.dtstack.flink.sql.side.PredicateInfo;
  26 import com.google.common.base.Preconditions;
  27 import com.google.common.base.Strings;
  28 import com.google.common.collect.HashBasedTable;
  29 import com.google.common.collect.HashBiMap;
  30 import com.google.common.collect.Lists;
  31 import org.apache.calcite.sql.SqlAsOperator;
  32 import org.apache.calcite.sql.SqlBasicCall;
  33 import org.apache.calcite.sql.SqlDataTypeSpec;
  34 import org.apache.calcite.sql.SqlIdentifier;
  35 import org.apache.calcite.sql.SqlJoin;
  36 import org.apache.calcite.sql.SqlKind;
  37 import org.apache.calcite.sql.SqlLiteral;
  38 import org.apache.calcite.sql.SqlNode;
  39 import org.apache.calcite.sql.SqlNodeList;
  40 import org.apache.calcite.sql.SqlOperator;
  41 import org.apache.calcite.sql.SqlSelect;
  42 import org.apache.calcite.sql.fun.SqlCase;
  43 import org.apache.calcite.sql.parser.SqlParserPos;
  44 import org.apache.commons.collections.CollectionUtils;
  45 import org.apache.commons.lang3.StringUtils;
  46 import org.apache.flink.table.api.Table;
  47 
  48 import java.util.List;
  49 import java.util.Map;
  50 import java.util.Queue;
  51 import java.util.Set;
  52 import java.util.regex.Matcher;
  53 import java.util.regex.Pattern;
  54 
  55 import static org.apache.calcite.sql.SqlKind.*;
  56 import static org.apache.calcite.sql.SqlKind.CASE;
  57 import static org.apache.calcite.sql.SqlKind.OTHER;
  58 
  59 /**
  60  * Ë°®ÁöÑËß£ÊûêÁõ∏ÂÖ≥
  61  * Date: 2020/2/17
  62  * Company: www.dtstack.com
  63  * @author xuchao
  64  */
  65 
  66 public class TableUtils {
  67 
  68     public static final char SPLIT = &#x27;_&#x27;;
  69     public static final Pattern stringPattern = Pattern.compile(&quot;\&quot;.*?\&quot;|\&#x27;.*?\&#x27;&quot;);
  70     /**
  71      * Ëé∑Âèñselect ÁöÑÂ≠óÊÆµ
  72      * @param sqlSelect
  73      */
<abbr title="  74     public static List&lt;FieldInfo&gt; parserSelectField(SqlSelect sqlSelect, Map&lt;String, Table&gt; localTableCache){">  74     public static List&lt;FieldInfo&gt; parserSelectField(SqlSelect sqlSelect, Map&lt;String, Table&gt; localTableCacüîµ</abbr>
  75         SqlNodeList sqlNodeList = sqlSelect.getSelectList();
  76         List&lt;FieldInfo&gt; fieldInfoList = Lists.newArrayList();
  77         String fromNode = sqlSelect.getFrom().toString();
  78 
  79         for (SqlNode fieldNode : sqlNodeList.getList()) {
  80             extractSelectFieldToFieldInfo(fieldNode,fromNode,fieldInfoList,localTableCache);
  81         }
  82 
  83         return fieldInfoList;
  84     }
  85 
  86     /**
  87      *  Ëß£Êûêselect Node ÊèêÂèñFieldInfo
  88      * @param fieldNode
  89      * @param fromNode
  90      * @param fieldInfoList
  91      * @param localTableCache
  92      */
<abbr title="  93     public static void extractSelectFieldToFieldInfo(SqlNode fieldNode, String fromNode, List&lt;FieldInfo&gt; fieldInfoList, Map&lt;String, Table&gt; localTableCache) {">  93     public static void extractSelectFieldToFieldInfo(SqlNode fieldNode, String fromNode, List&lt;FieldInfo&gt; üîµ</abbr>
  94         if (fieldNode.getKind() == IDENTIFIER) {
  95             SqlIdentifier identifier = (SqlIdentifier) fieldNode;
  96             if (!identifier.isStar()) {
<abbr title="  97                 String tableName = identifier.names.size() == 1 ? fromNode : identifier.getComponent(0).getSimple();">  97                 String tableName = identifier.names.size() == 1 ? fromNode : identifier.getComponent(0).güîµ</abbr>
<abbr title="  98                 String fieldName = identifier.names.size() == 1 ? identifier.getComponent(0).getSimple() : identifier.getComponent(1).getSimple();">  98                 String fieldName = identifier.names.size() == 1 ? identifier.getComponent(0).getSimple() üîµ</abbr>
  99                 FieldInfo fieldInfo = new FieldInfo();
 100                 fieldInfo.setTable(tableName);
 101                 fieldInfo.setFieldName(fieldName);
 102 
 103                 if (!fieldInfoList.contains(fieldInfo)) {
 104                     fieldInfoList.add(fieldInfo);
 105                 }
 106             } else {
 107                 //Â§ÑÁêÜ
 108                 int identifierSize = identifier.names.size();
 109                 switch (identifierSize) {
 110                     case 1:
 111                         throw new RuntimeException(&quot;not support to parse * without scope of table&quot;);
 112                     default:
 113                         SqlIdentifier tableIdentify = identifier.skipLast(1);
 114                         Table registerTable = localTableCache.get(tableIdentify.getSimple());
 115                         if (registerTable == null) {
<abbr title=" 116                             throw new RuntimeException(&quot;can&#x27;t find table alias &quot; + tableIdentify.getSimple());"> 116                             throw new RuntimeException(&quot;can&#x27;t find table alias &quot; + tableIdentify.getSimplüîµ</abbr>
 117                         }
 118 
 119                         String[] fieldNames = registerTable.getSchema().getFieldNames();
 120                         for (String fieldName : fieldNames) {
 121                             FieldInfo fieldInfo = new FieldInfo();
 122                             fieldInfo.setTable(tableIdentify.getSimple());
 123                             fieldInfo.setFieldName(fieldName);
 124                             fieldInfoList.add(fieldInfo);
 125                         }
 126                 }
 127             }
 128         } else if (AGGREGATE.contains(fieldNode.getKind())
 129                 || AVG_AGG_FUNCTIONS.contains(fieldNode.getKind())
 130                 || COMPARISON.contains(fieldNode.getKind())
 131                 || fieldNode.getKind() == OTHER_FUNCTION
 132                 || fieldNode.getKind() == DIVIDE
 133                 || fieldNode.getKind() == CAST
 134                 || fieldNode.getKind() == TRIM
 135                 || fieldNode.getKind() == TIMES
 136                 || fieldNode.getKind() == PLUS
 137                 || fieldNode.getKind() == NOT_IN
 138                 || fieldNode.getKind() == OR
 139                 || fieldNode.getKind() == AND
 140                 || fieldNode.getKind() == MINUS
 141                 || fieldNode.getKind() == TUMBLE
 142                 || fieldNode.getKind() == TUMBLE_START
 143                 || fieldNode.getKind() == TUMBLE_END
 144                 || fieldNode.getKind() == SESSION
 145                 || fieldNode.getKind() == SESSION_START
 146                 || fieldNode.getKind() == SESSION_END
 147                 || fieldNode.getKind() == HOP
 148                 || fieldNode.getKind() == HOP_START
 149                 || fieldNode.getKind() == HOP_END
 150                 || fieldNode.getKind() == BETWEEN
 151                 || fieldNode.getKind() == IS_NULL
 152                 || fieldNode.getKind() == IS_NOT_NULL
 153                 || fieldNode.getKind() == CONTAINS
 154                 || fieldNode.getKind() == TIMESTAMP_ADD
 155                 || fieldNode.getKind() == TIMESTAMP_DIFF
 156                 || fieldNode.getKind() == LIKE
 157                 || fieldNode.getKind() == COALESCE
 158                 ) {
 159             SqlBasicCall sqlBasicCall = (SqlBasicCall) fieldNode;
 160             for (int i = 0; i &lt; sqlBasicCall.getOperands().length; i++) {
 161                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 162                 if (sqlNode instanceof SqlLiteral) {
 163                     continue;
 164                 }
 165 
 166                 if (sqlNode instanceof SqlDataTypeSpec) {
 167                     continue;
 168                 }
 169                 extractSelectFieldToFieldInfo(sqlNode, fromNode, fieldInfoList, localTableCache);
 170             }
 171         } else if (fieldNode.getKind() == AS) {
 172             SqlNode leftNode = ((SqlBasicCall) fieldNode).getOperands()[0];
 173             extractSelectFieldToFieldInfo(leftNode, fromNode,fieldInfoList, localTableCache);
 174         } else if (fieldNode.getKind() == CASE) {
 175             SqlCase sqlCase = (SqlCase) fieldNode;
 176             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 177             SqlNodeList thenOperands = sqlCase.getThenOperands();
 178             SqlNode elseNode = sqlCase.getElseOperand();
 179 
 180             for (int i = 0; i &lt; whenOperands.size(); i++) {
 181                 SqlNode oneOperand = whenOperands.get(i);
 182                 extractSelectFieldToFieldInfo(oneOperand, fromNode, fieldInfoList, localTableCache);
 183             }
 184 
 185             for (int i = 0; i &lt; thenOperands.size(); i++) {
 186                 SqlNode oneOperand = thenOperands.get(i);
 187                 extractSelectFieldToFieldInfo(oneOperand, fromNode, fieldInfoList, localTableCache);
 188 
 189             }
 190 
 191             extractSelectFieldToFieldInfo(elseNode, fromNode, fieldInfoList, localTableCache);
 192         }
 193     }
 194 
<abbr title=" 195     public static SqlBasicCall buildAsNodeByJoinInfo(JoinInfo joinInfo, SqlNode sqlNode0, String tableAlias) {"> 195     public static SqlBasicCall buildAsNodeByJoinInfo(JoinInfo joinInfo, SqlNode sqlNode0, String tableAliüîµ</abbr>
 196         SqlOperator operator = new SqlAsOperator();
 197 
 198         SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 199         String newTableName = joinInfo.getNewTableName();
 200 
<abbr title=" 201         String newTableAlias = !StringUtils.isEmpty(tableAlias) ? tableAlias : joinInfo.getNewTableAlias();"> 201         String newTableAlias = !StringUtils.isEmpty(tableAlias) ? tableAlias : joinInfo.getNewTableAlias(üîµ</abbr>
 202 
 203         if (null == sqlNode0) {
 204             sqlNode0 = new SqlIdentifier(newTableName, null, sqlParserPos);
 205         }
 206 
 207         SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(newTableAlias, null, sqlParserPos);
 208         SqlNode[] sqlNodes = new SqlNode[2];
 209         sqlNodes[0] = sqlNode0;
 210         sqlNodes[1] = sqlIdentifierAlias;
 211         return new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 212     }
 213 
 214     /**
 215      *
 216      * @param joinInfo
 217      * @param sqlNode
 218      * @param queueInfo
 219      * @return   ‰∏§‰∏™ËæπÂÖ≥ËÅîÂêéÁöÑÊñ∞Ë°®Ë°®Âêç
 220      */
<abbr title=" 221     public static String dealSelectResultWithJoinInfo(JoinInfo joinInfo, SqlSelect sqlNode, Queue&lt;Object&gt; queueInfo) {"> 221     public static String dealSelectResultWithJoinInfo(JoinInfo joinInfo, SqlSelect sqlNode, Queue&lt;Object&gt;üîµ</abbr>
 222         //SideJoinInfo rename
 223         if (joinInfo.checkIsSide()) {
 224             joinInfo.setSelectFields(sqlNode.getSelectList());
 225             joinInfo.setSelectNode(sqlNode);
 226             if (joinInfo.isRightIsSideTable()) {
 227                 //Analyzing left is not a simple table
 228                 if (joinInfo.getLeftNode().getKind() == SELECT) {
 229                     queueInfo.offer(joinInfo.getLeftNode());
 230                 }
 231 
 232                 queueInfo.offer(joinInfo);
 233             } else {
 234                 //Determining right is not a simple table
 235                 if (joinInfo.getRightNode().getKind() == SELECT) {
 236                     queueInfo.offer(joinInfo.getLeftNode());
 237                 }
 238 
 239                 queueInfo.offer(joinInfo);
 240             }
 241             replaceFromNodeForJoin(joinInfo, sqlNode);
 242             return joinInfo.getNewTableName();
 243         }
 244         return &quot;&quot;;
 245     }
 246 
 247     public static void replaceFromNodeForJoin(JoinInfo joinInfo, SqlSelect sqlNode) {
 248         //Update from node
 249         SqlBasicCall sqlBasicCall = buildAsNodeByJoinInfo(joinInfo, null, null);
 250         String newAliasName = sqlBasicCall.operand(1).toString();
 251 
 252         //ÊõøÊç¢select ‰∏≠ÁöÑÂ±ûÊÄß‰∏∫Êñ∞ÁöÑË°®ÂêçÁß∞ÂíåÂ≠óÊÆµ
 253         HashBasedTable&lt;String, String, String&gt; fieldMapping = joinInfo.getTableFieldRef();
 254         Map&lt;String, String&gt; leftFieldMapping = fieldMapping.row(joinInfo.getLeftTableAlias());
 255         Map&lt;String, String&gt; rightFieldMapping = fieldMapping.row(joinInfo.getRightTableAlias());
 256 
 257        /* for(SqlNode oneSelectNode : sqlNode.getSelectList()){
<abbr title=" 258             replaceSelectFieldTable(oneSelectNode, joinInfo.getLeftTableAlias(), newAliasName, null ,leftFieldMapping);"> 258             replaceSelectFieldTable(oneSelectNode, joinInfo.getLeftTableAlias(), newAliasName, null ,leftüîµ</abbr>
<abbr title=" 259             replaceSelectFieldTable(oneSelectNode, joinInfo.getRightTableAlias(), newAliasName, null , rightFieldMapping);"> 259             replaceSelectFieldTable(oneSelectNode, joinInfo.getRightTableAlias(), newAliasName, null , riüîµ</abbr>
 260         }*/
 261 
 262         //where‰∏≠ÁöÑÊù°‰ª∂Â±ûÊÄß‰∏∫Êñ∞ÁöÑË°®ÂêçÁß∞ÂíåÂ≠óÊÆµ
<abbr title=" 263         FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getLeftTableAlias(), newAliasName, leftFieldMapping);"> 263         FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getLeftTableAlias(), newAliasName, leftFieldMüîµ</abbr>
<abbr title=" 264         FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getRightTableAlias(), newAliasName, rightFieldMapping);"> 264         FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getRightTableAlias(), newAliasName, rightFielüîµ</abbr>
 265         sqlNode.setFrom(sqlBasicCall);
 266     }
 267 
 268 
 269     /**
 270      * Ëé∑ÂèñËäÇÁÇπÂÖ≥ËÅîÁöÑÊü•ËØ¢Ë°®
 271      * @param fromTable
 272      * @param tableNameSet
 273      */
 274     public static void getFromTableInfo(SqlNode fromTable, Set&lt;String&gt; tableNameSet){
 275         SqlKind sqlKind = fromTable.getKind();
 276         switch (sqlKind){
 277             case AS:
 278                 SqlNode alias = ((SqlBasicCall) fromTable).getOperands()[1];
 279                 tableNameSet.add(alias.toString());
 280                 return;
 281             case JOIN:
 282                 getFromTableInfo(((SqlJoin)fromTable).getLeft(), tableNameSet);
 283                 getFromTableInfo(((SqlJoin)fromTable).getRight(), tableNameSet);
 284                 return;
 285             case IDENTIFIER:
 286                 tableNameSet.add(((SqlIdentifier)fromTable).getSimple());
 287                 return;
 288             case SELECT:
 289                 getFromTableInfo(((SqlSelect) fromTable).getFrom(), tableNameSet);
 290                 return;
 291             default:
 292                 throw new RuntimeException(&quot;not support sqlKind:&quot; + sqlKind);
 293         }
 294     }
 295 
 296     /**
 297      * ÊõøÊç¢select ‰∏≠ÁöÑÂ≠óÊÆµ‰ø°ÊÅØ
 298      * Â¶ÇÊûúmappingTable ÈùûÁ©∫Âàô‰ªéËØ•ÂèÇÊï∞Ëé∑ÂèñÂ≠óÊÆµÁöÑÊò†Â∞Ñ
 299      * Â¶ÇÊûúmappingTable ‰∏∫Á©∫ÂàôÊ†πÊçÆÊòØÂê¶Â≠òÂú®Êñ∞ÁîüÊàêÂ≠óÊÆµ
 300      * @param selectNode
 301      * @param oldTbName
 302      * @param newTbName
 303      * @param fieldReplaceRef
 304      */
 305     public static void replaceSelectFieldTable(SqlNode selectNode,
 306                                                String oldTbName,
 307                                                String newTbName,
 308                                                HashBiMap&lt;String, String&gt; fieldReplaceRef) {
 309         if (selectNode.getKind() == AS) {
 310             SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 311             replaceSelectFieldTable(leftNode, oldTbName, newTbName, fieldReplaceRef);
 312 
 313         }else if(selectNode.getKind() == IDENTIFIER){
 314             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 315 
 316             if(sqlIdentifier.names.size() == 1){
 317                 return ;
 318             }
 319 
 320             String fieldTableName = sqlIdentifier.names.get(0);
 321             if(oldTbName.equalsIgnoreCase(fieldTableName)){
 322                 replaceOneSelectField(sqlIdentifier, newTbName, oldTbName, fieldReplaceRef);
 323             }
 324 
 325         }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//Â≠óÈù¢Âê´‰πâ
 326             return;
 327         }else if(  AGGREGATE.contains(selectNode.getKind())
 328                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 329                 || COMPARISON.contains(selectNode.getKind())
 330                 || selectNode.getKind() == OTHER_FUNCTION
 331                 || selectNode.getKind() == DIVIDE
 332                 || selectNode.getKind() == CAST
 333                 || selectNode.getKind() == TRIM
 334                 || selectNode.getKind() == TIMES
 335                 || selectNode.getKind() == PLUS
 336                 || selectNode.getKind() == NOT_IN
 337                 || selectNode.getKind() == OR
 338                 || selectNode.getKind() == AND
 339                 || selectNode.getKind() == MINUS
 340                 || selectNode.getKind() == TUMBLE
 341                 || selectNode.getKind() == TUMBLE_START
 342                 || selectNode.getKind() == TUMBLE_END
 343                 || selectNode.getKind() == SESSION
 344                 || selectNode.getKind() == SESSION_START
 345                 || selectNode.getKind() == SESSION_END
 346                 || selectNode.getKind() == HOP
 347                 || selectNode.getKind() == HOP_START
 348                 || selectNode.getKind() == HOP_END
 349                 || selectNode.getKind() == BETWEEN
 350                 || selectNode.getKind() == IS_NULL
 351                 || selectNode.getKind() == IS_NOT_NULL
 352                 || selectNode.getKind() == CONTAINS
 353                 || selectNode.getKind() == TIMESTAMP_ADD
 354                 || selectNode.getKind() == TIMESTAMP_DIFF
 355                 || selectNode.getKind() == LIKE
 356                 || selectNode.getKind() == COALESCE
 357 
 358         ){
 359             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 360             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 361                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 362                 if(sqlNode instanceof SqlLiteral){
 363                     continue;
 364                 }
 365 
 366                 if(sqlNode instanceof SqlDataTypeSpec){
 367                     continue;
 368                 }
 369 
 370                 replaceSelectFieldTable(sqlNode, oldTbName, newTbName, fieldReplaceRef);
 371             }
 372 
 373         }else if(selectNode.getKind() == CASE){
 374             SqlCase sqlCase = (SqlCase) selectNode;
 375             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 376             SqlNodeList thenOperands = sqlCase.getThenOperands();
 377             SqlNode elseNode = sqlCase.getElseOperand();
 378 
 379             for(int i=0; i&lt;whenOperands.size(); i++){
 380                 SqlNode oneOperand = whenOperands.get(i);
 381                 replaceSelectFieldTable(oneOperand, oldTbName, newTbName, fieldReplaceRef);
 382             }
 383 
 384             for(int i=0; i&lt;thenOperands.size(); i++){
 385                 SqlNode oneOperand = thenOperands.get(i);
 386                 replaceSelectFieldTable(oneOperand, oldTbName, newTbName, fieldReplaceRef);
 387 
 388             }
 389 
 390             replaceSelectFieldTable(elseNode, oldTbName, newTbName, fieldReplaceRef);
 391         }else if(selectNode.getKind() == OTHER){
 392             //‰∏çÂ§ÑÁêÜ
 393             return;
 394         }else{
<abbr title=" 395             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 395             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, üîµ</abbr>
 396         }
 397     }
 398 
 399     private static void replaceOneSelectField(SqlIdentifier sqlIdentifier,
 400                                               String newTbName,
 401                                               String oldTbName,
 402                                               HashBiMap&lt;String, String&gt; fieldReplaceRef){
 403         SqlIdentifier newField = sqlIdentifier.setName(0, newTbName);
 404         String fieldName = sqlIdentifier.names.get(1);
 405         String fieldKey = oldTbName + &quot;_&quot; + fieldName;
 406 
 407         if(!fieldReplaceRef.containsKey(fieldKey)){
 408             if(fieldReplaceRef.inverse().get(fieldName) != null){
 409                 //Êç¢‰∏Ä‰∏™ÂêçÂ≠ó
 410                 String mappingFieldName = ParseUtils.dealDuplicateFieldName(fieldReplaceRef, fieldName);
 411                 newField = newField.setName(1, mappingFieldName);
 412                 fieldReplaceRef.put(fieldKey, mappingFieldName);
 413             } else {
 414                 fieldReplaceRef.put(fieldKey, fieldName);
 415             }
 416         }else {
 417             newField = newField.setName(1, fieldReplaceRef.get(fieldKey));
 418         }
 419 
 420         sqlIdentifier.assignNamesFrom(newField);
 421     }
 422 
 423     /**
 424      * ÊõøÊç¢Âè¶Â§ñjoin Ë°®ÁöÑÊåáÂÆöË°®Âêç‰∏∫Êñ∞ÂÖ≥ËÅîÂ§ÑÁêÜÁöÑË°®ÂêçÁß∞
 425      * @param condition
 426      * @param oldTabFieldRefNew
 427      */
<abbr title=" 428     public static void replaceJoinFieldRefTableName(SqlNode condition, Map&lt;String, String&gt; oldTabFieldRefNew){"> 428     public static void replaceJoinFieldRefTableName(SqlNode condition, Map&lt;String, String&gt; oldTabFieldRefüîµ</abbr>
 429         if (null == condition || condition.getKind() == LITERAL) {
 430             return;
 431         }
 432         SqlKind joinKind = condition.getKind();
 433         if( AGGREGATE.contains(joinKind)
 434                 || AVG_AGG_FUNCTIONS.contains(joinKind)
 435                 || COMPARISON.contains(joinKind)
 436                 || joinKind == OTHER_FUNCTION
 437                 || joinKind == DIVIDE
 438                 || joinKind == CAST
 439                 || joinKind == TRIM
 440                 || joinKind == TIMES
 441                 || joinKind == PLUS
 442                 || joinKind == NOT_IN
 443                 || joinKind == OR
 444                 || joinKind == AND
 445                 || joinKind == MINUS
 446                 || joinKind == TUMBLE
 447                 || joinKind == TUMBLE_START
 448                 || joinKind == TUMBLE_END
 449                 || joinKind == SESSION
 450                 || joinKind == SESSION_START
 451                 || joinKind == SESSION_END
 452                 || joinKind == HOP
 453                 || joinKind == HOP_START
 454                 || joinKind == HOP_END
 455                 || joinKind == BETWEEN
 456                 || joinKind == IS_NULL
 457                 || joinKind == IS_NOT_NULL
 458                 || joinKind == CONTAINS
 459                 || joinKind == TIMESTAMP_ADD
 460                 || joinKind == TIMESTAMP_DIFF
 461                 || joinKind == LIKE
 462                 || joinKind == COALESCE
 463                 || joinKind == EQUALS ){
 464 
 465             SqlBasicCall sqlBasicCall = (SqlBasicCall) condition;
 466             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 467                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 468                 if(sqlNode instanceof SqlLiteral){
 469                     continue;
 470                 }
 471 
 472                 if(sqlNode instanceof SqlDataTypeSpec){
 473                     continue;
 474                 }
 475 
 476                 replaceJoinFieldRefTableName(sqlNode, oldTabFieldRefNew);
 477             }
 478 
 479         } else if (condition.getKind() == IDENTIFIER) {
<abbr title=" 480             Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 480             Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must büîµ</abbr>
 481             String fieldRefTable = ((SqlIdentifier)condition).names.get(0);
 482 
<abbr title=" 483             String targetFieldName = TableUtils.getTargetRefField(oldTabFieldRefNew, condition.toString());"> 483             String targetFieldName = TableUtils.getTargetRefField(oldTabFieldRefNew, condition.toString()üîµ</abbr>
 484 
 485             if(StringUtils.isNotBlank(targetFieldName)){
 486                 String[] fieldSplits = StringUtils.split(targetFieldName, &quot;.&quot;);
 487                 SqlIdentifier newField = ((SqlIdentifier)condition).setName(0, fieldSplits[0]);
 488                 newField = newField.setName(1, fieldSplits[1]);
 489                 ((SqlIdentifier)condition).assignNamesFrom(newField);
 490             }
 491         }
 492     }
 493 
 494     public static String getTargetRefTable(Map&lt;String, String&gt; refTableMap, String tableName){
 495         String targetTableName = null;
 496         String preTableName;
 497 
 498         do {
 499             preTableName = targetTableName == null ? tableName : targetTableName;
 500             targetTableName = refTableMap.get(preTableName);
 501         } while (targetTableName != null);
 502 
 503         return preTableName;
 504     }
 505 
 506     public static String getTargetRefField(Map&lt;String, String&gt; refFieldMap, String currFieldName){
 507         String targetFieldName = null;
 508         String preFieldName;
 509 
 510         do {
 511             preFieldName = targetFieldName == null ? currFieldName : targetFieldName;
 512             targetFieldName = refFieldMap.get(preFieldName);
 513         } while (targetFieldName != null);
 514 
 515         return preFieldName;
 516     }
 517 
<abbr title=" 518     public static void replaceWhereCondition(SqlNode parentWhere, String oldTbName, String newTbName, HashBiMap&lt;String, String&gt; fieldReplaceRef){"> 518     public static void replaceWhereCondition(SqlNode parentWhere, String oldTbName, String newTbName, Hasüîµ</abbr>
 519 
 520         if(parentWhere == null){
 521             return;
 522         }
 523 
 524         SqlKind kind = parentWhere.getKind();
 525         if(kind == AND){
<abbr title=" 526             replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[0], oldTbName, newTbName, fieldReplaceRef);"> 526             replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[0], oldTbName, newTbName, fiüîµ</abbr>
<abbr title=" 527             replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[1], oldTbName, newTbName, fieldReplaceRef);"> 527             replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[1], oldTbName, newTbName, fiüîµ</abbr>
 528 
 529         } else {
 530             replaceConditionNode(parentWhere, oldTbName, newTbName, fieldReplaceRef);
 531         }
 532     }
 533 
<abbr title=" 534     private static void replaceConditionNode(SqlNode selectNode, String oldTbName, String newTbName, HashBiMap&lt;String, String&gt; fieldReplaceRef) {"> 534     private static void replaceConditionNode(SqlNode selectNode, String oldTbName, String newTbName, Hashüîµ</abbr>
 535         if(selectNode.getKind() == IDENTIFIER){
 536             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 537 
 538             if(sqlIdentifier.names.size() == 1){
 539                 return;
 540             }
 541 
 542             String tableName = sqlIdentifier.names.asList().get(0);
 543             String tableField = sqlIdentifier.names.asList().get(1);
 544             String fieldKey = tableName + &quot;_&quot; + tableField;
 545 
 546             if(tableName.equalsIgnoreCase(oldTbName)){
 547 
<abbr title=" 548                 String newFieldName = fieldReplaceRef.get(fieldKey) == null ? tableField : fieldReplaceRef.get(fieldKey);"> 548                 String newFieldName = fieldReplaceRef.get(fieldKey) == null ? tableField : fieldReplaceReüîµ</abbr>
 549                 SqlIdentifier newField = ((SqlIdentifier)selectNode).setName(0, newTbName);
 550                 newField = newField.setName(1, newFieldName);
 551                 ((SqlIdentifier)selectNode).assignNamesFrom(newField);
 552             }
 553             return;
 554         }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//Â≠óÈù¢Âê´‰πâ
 555             return;
 556         }else if(  AGGREGATE.contains(selectNode.getKind())
 557                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 558                 || COMPARISON.contains(selectNode.getKind())
 559                 || selectNode.getKind() == OTHER_FUNCTION
 560                 || selectNode.getKind() == DIVIDE
 561                 || selectNode.getKind() == CAST
 562                 || selectNode.getKind() == TRIM
 563                 || selectNode.getKind() == TIMES
 564                 || selectNode.getKind() == PLUS
 565                 || selectNode.getKind() == NOT_IN
 566                 || selectNode.getKind() == OR
 567                 || selectNode.getKind() == AND
 568                 || selectNode.getKind() == MINUS
 569                 || selectNode.getKind() == TUMBLE
 570                 || selectNode.getKind() == TUMBLE_START
 571                 || selectNode.getKind() == TUMBLE_END
 572                 || selectNode.getKind() == SESSION
 573                 || selectNode.getKind() == SESSION_START
 574                 || selectNode.getKind() == SESSION_END
 575                 || selectNode.getKind() == HOP
 576                 || selectNode.getKind() == HOP_START
 577                 || selectNode.getKind() == HOP_END
 578                 || selectNode.getKind() == BETWEEN
 579                 || selectNode.getKind() == IS_NULL
 580                 || selectNode.getKind() == IS_NOT_NULL
 581                 || selectNode.getKind() == CONTAINS
 582                 || selectNode.getKind() == TIMESTAMP_ADD
 583                 || selectNode.getKind() == TIMESTAMP_DIFF
 584                 || selectNode.getKind() == LIKE
 585                 || selectNode.getKind() == COALESCE
 586 
 587         ){
 588             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 589             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 590                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 591                 if(sqlNode instanceof SqlLiteral){
 592                     continue;
 593                 }
 594 
 595                 if(sqlNode instanceof SqlDataTypeSpec){
 596                     continue;
 597                 }
 598 
 599                 replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef);
 600             }
 601 
 602             return;
 603         }else if(selectNode.getKind() == OTHER){
 604             //‰∏çÂ§ÑÁêÜ
 605             return;
 606         } else if (selectNode.getKind() == CASE) {
 607             SqlCase sqlCase = (SqlCase) selectNode;
 608 
<abbr title=" 609             sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef));"> 609             sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbNamüîµ</abbr>
<abbr title=" 610             sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef));"> 610             sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbNamüîµ</abbr>
 611             replaceConditionNode(sqlCase.getElseOperand(), oldTbName, newTbName, fieldReplaceRef);
 612         } else {
<abbr title=" 613             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 613             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, üîµ</abbr>
 614         }
 615     }
 616 
 617     /**
 618      * Ëé∑ÂèñÊù°‰ª∂‰∏≠ÂÖ≥ËÅîÁöÑË°®‰ø°ÊÅØ
 619      * @param selectNode
 620      * @param fieldInfos
 621      */
 622     public static void getConditionRefTable(SqlNode selectNode, Set&lt;String&gt; fieldInfos) {
 623         if (selectNode.getKind() == IDENTIFIER) {
 624             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 625 
 626             fieldInfos.add(sqlIdentifier.toString());
 627             return;
 628         } else if (selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN) {//Â≠óÈù¢Âê´‰πâ
 629             return;
 630         } else if (AGGREGATE.contains(selectNode.getKind())
 631                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 632                 || COMPARISON.contains(selectNode.getKind())
 633                 || selectNode.getKind() == OTHER_FUNCTION
 634                 || selectNode.getKind() == DIVIDE
 635                 || selectNode.getKind() == CAST
 636                 || selectNode.getKind() == TRIM
 637                 || selectNode.getKind() == TIMES
 638                 || selectNode.getKind() == PLUS
 639                 || selectNode.getKind() == NOT_IN
 640                 || selectNode.getKind() == OR
 641                 || selectNode.getKind() == AND
 642                 || selectNode.getKind() == MINUS
 643                 || selectNode.getKind() == TUMBLE
 644                 || selectNode.getKind() == TUMBLE_START
 645                 || selectNode.getKind() == TUMBLE_END
 646                 || selectNode.getKind() == SESSION
 647                 || selectNode.getKind() == SESSION_START
 648                 || selectNode.getKind() == SESSION_END
 649                 || selectNode.getKind() == HOP
 650                 || selectNode.getKind() == HOP_START
 651                 || selectNode.getKind() == HOP_END
 652                 || selectNode.getKind() == BETWEEN
 653                 || selectNode.getKind() == IS_NULL
 654                 || selectNode.getKind() == IS_NOT_NULL
 655                 || selectNode.getKind() == CONTAINS
 656                 || selectNode.getKind() == TIMESTAMP_ADD
 657                 || selectNode.getKind() == TIMESTAMP_DIFF
 658                 || selectNode.getKind() == LIKE
 659                 || selectNode.getKind() == COALESCE
 660 
 661                 ) {
 662             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 663             for (int i = 0; i &lt; sqlBasicCall.getOperands().length; i++) {
 664                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 665                 if (sqlNode instanceof SqlLiteral) {
 666                     continue;
 667                 }
 668 
 669                 if (sqlNode instanceof SqlDataTypeSpec) {
 670                     continue;
 671                 }
 672 
 673                 getConditionRefTable(sqlNode, fieldInfos);
 674             }
 675 
 676             return;
 677         } else if (selectNode.getKind() == OTHER) {
 678             //‰∏çÂ§ÑÁêÜ
 679             return;
 680         } else if (selectNode.getKind() == CASE) {
 681             SqlCase sqlCase = (SqlCase) selectNode;
 682 
<abbr title=" 683             sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfos));"> 683             sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfüîµ</abbr>
<abbr title=" 684             sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfos));"> 684             sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfüîµ</abbr>
 685             getConditionRefTable(sqlCase.getElseOperand(), fieldInfos);
 686         } else {
<abbr title=" 687             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 687             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, üîµ</abbr>
 688         }
 689     }
 690 
 691     public static String buildTableField(String tableName, String fieldName){
 692         return String.format(&quot;%s.%s&quot;, tableName, fieldName);
 693     }
 694 
 695 
 696     public static String buildTableNameWithScope(String tableName, String scope){
 697         if(StringUtils.isEmpty(scope)){
 698             return tableName;
 699         }
 700 
 701         return tableName + &quot;_&quot; + scope;
 702     }
 703 
 704     /**
 705      * add constant join fields, using in such as hbase„ÄÅredis etc kv database
 706      * @param keyMap
 707      */
 708     public static void addConstant(Map&lt;String, Object&gt; keyMap, AbstractSideTableInfo sideTableInfo) {
 709         List&lt;PredicateInfo&gt; predicateInfos = sideTableInfo.getPredicateInfoes();
 710         final String name = sideTableInfo.getName();
 711         for (PredicateInfo info : predicateInfos) {
 712             if (info.getOwnerTable().equals(name)
 713                 &amp;&amp; info.getOperatorName().equals(&quot;=&quot;)) {
 714                 String condition = info.getCondition();
 715                 Matcher matcher = stringPattern.matcher(condition);
 716                 if (matcher.matches()) {
 717                     condition = condition.substring(1, condition.length() - 1);
 718                 }
 719                 keyMap.put(info.getFieldName(), condition);
 720             }
 721         }
 722     }
 723 
<abbr title=" 724     public static String buildTableNameWithScope(String leftTableName, String leftTableAlias, String rightTableName, String scope, Set&lt;String&gt; existTableNames){"> 724     public static String buildTableNameWithScope(String leftTableName, String leftTableAlias, String righüîµ</abbr>
 725         //ÂÖºÂÆπÂ∑¶ËæπË°®ÊòØas ÁöÑÊÉÖÂÜµ
 726         String leftStr = Strings.isNullOrEmpty(leftTableName) ? leftTableAlias : leftTableName;
 727         String newName = leftStr + &quot;_&quot; + rightTableName;
 728         if (CollectionUtils.isEmpty(existTableNames)) {
 729             return TableUtils.buildTableNameWithScope(newName, scope);
 730         }
 731 
 732         if (!existTableNames.contains(newName)) {
 733             return TableUtils.buildTableNameWithScope(newName, scope);
 734         }
 735 
 736         return TableUtils.buildTableNameWithScope(newName, scope) + &quot;_&quot; + System.currentTimeMillis();
 737     }
 738 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.util;
  19 
  20 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  21 import com.dtstack.flink.sql.side.FieldInfo;
  22 import com.dtstack.flink.sql.side.JoinInfo;
  23 import com.dtstack.flink.sql.side.PredicateInfo;
  24 import com.google.common.base.Preconditions;
  25 import com.google.common.base.Strings;
  26 import com.google.common.collect.HashBasedTable;
  27 import com.google.common.collect.HashBiMap;
  28 import com.google.common.collect.Lists;
  29 import java.util.List;
  30 import java.util.Map;
  31 import java.util.Queue;
  32 import java.util.Set;
  33 import java.util.regex.Matcher;
  34 import java.util.regex.Pattern;
  35 import org.apache.calcite.sql.SqlAsOperator;
  36 import org.apache.calcite.sql.SqlBasicCall;
  37 import org.apache.calcite.sql.SqlDataTypeSpec;
  38 import org.apache.calcite.sql.SqlIdentifier;
  39 import org.apache.calcite.sql.SqlJoin;
  40 import org.apache.calcite.sql.SqlKind;
  41 import org.apache.calcite.sql.SqlLiteral;
  42 import org.apache.calcite.sql.SqlNode;
  43 import org.apache.calcite.sql.SqlNodeList;
  44 import org.apache.calcite.sql.SqlOperator;
  45 import org.apache.calcite.sql.SqlSelect;
  46 import org.apache.calcite.sql.fun.SqlCase;
  47 import org.apache.calcite.sql.parser.SqlParserPos;
  48 import org.apache.commons.collections.CollectionUtils;
  49 import org.apache.commons.lang3.StringUtils;
  50 import org.apache.flink.table.api.Table;
  51 import static org.apache.calcite.sql.SqlKind.*;
  52 import static org.apache.calcite.sql.SqlKind.CASE;
  53 import static org.apache.calcite.sql.SqlKind.OTHER;
  54 
  55 
  56 /**
  57  * Ë°®ÁöÑËß£ÊûêÁõ∏ÂÖ≥
  58  * Date: 2020/2/17
  59  * Company: www.dtstack.com
  60  * @author xuchao
  61  */
  62 public class TableUtils {
  63     public static final char SPLIT = &#x27;_&#x27;;
  64 
  65     public static final Pattern stringPattern = Pattern.compile(&quot;\&quot;.*?\&quot;|\&#x27;.*?\&#x27;&quot;);
  66 
  67     /**
  68      * Ëé∑Âèñselect ÁöÑÂ≠óÊÆµ
  69      * @param sqlSelect
  70      */
<abbr title="  71     public static List&lt;FieldInfo&gt; parserSelectField(SqlSelect sqlSelect, Map&lt;String, Table&gt; localTableCache){">  71     public static List&lt;FieldInfo&gt; parserSelectField(SqlSelect sqlSelect, Map&lt;String, Table&gt; localTableCacüîµ</abbr>
  72         SqlNodeList sqlNodeList = sqlSelect.getSelectList();
  73         List&lt;FieldInfo&gt; fieldInfoList = Lists.newArrayList();
  74         String fromNode = sqlSelect.getFrom().toString();
  75 
  76         for (SqlNode fieldNode : sqlNodeList.getList()) {
  77             extractSelectFieldToFieldInfo(fieldNode,fromNode,fieldInfoList,localTableCache);
  78         }
  79 
  80         return fieldInfoList;
  81     }
  82 
  83     /**
  84      *  Ëß£Êûêselect Node ÊèêÂèñFieldInfo
  85      * @param fieldNode
  86      * @param fromNode
  87      * @param fieldInfoList
  88      * @param localTableCache
  89      */
<abbr title="  90     public static void extractSelectFieldToFieldInfo(SqlNode fieldNode, String fromNode, List&lt;FieldInfo&gt; fieldInfoList, Map&lt;String, Table&gt; localTableCache) {">  90     public static void extractSelectFieldToFieldInfo(SqlNode fieldNode, String fromNode, List&lt;FieldInfo&gt; üîµ</abbr>
  91         if (fieldNode.getKind() == IDENTIFIER) {
  92             SqlIdentifier identifier = (SqlIdentifier) fieldNode;
  93             if (!identifier.isStar()) {
<abbr title="  94                 String tableName = identifier.names.size() == 1 ? fromNode : identifier.getComponent(0).getSimple();">  94                 String tableName = identifier.names.size() == 1 ? fromNode : identifier.getComponent(0).güîµ</abbr>
<abbr title="  95                 String fieldName = identifier.names.size() == 1 ? identifier.getComponent(0).getSimple() : identifier.getComponent(1).getSimple();">  95                 String fieldName = identifier.names.size() == 1 ? identifier.getComponent(0).getSimple() üîµ</abbr>
  96                 FieldInfo fieldInfo = new FieldInfo();
  97                 fieldInfo.setTable(tableName);
  98                 fieldInfo.setFieldName(fieldName);
  99 
 100                 if (!fieldInfoList.contains(fieldInfo)) {
 101                     fieldInfoList.add(fieldInfo);
 102                 }
 103             } else {
 104                 //Â§ÑÁêÜ
 105                 int identifierSize = identifier.names.size();
 106                 switch (identifierSize) {
 107                     case 1:
 108                         throw new RuntimeException(&quot;not support to parse * without scope of table&quot;);
 109                     default:
 110                         SqlIdentifier tableIdentify = identifier.skipLast(1);
 111                         Table registerTable = localTableCache.get(tableIdentify.getSimple());
 112                         if (registerTable == null) {
<abbr title=" 113                             throw new RuntimeException(&quot;can&#x27;t find table alias &quot; + tableIdentify.getSimple());"> 113                             throw new RuntimeException(&quot;can&#x27;t find table alias &quot; + tableIdentify.getSimplüîµ</abbr>
 114                         }
 115 
 116                         String[] fieldNames = registerTable.getSchema().getFieldNames();
 117                         for (String fieldName : fieldNames) {
 118                             FieldInfo fieldInfo = new FieldInfo();
 119                             fieldInfo.setTable(tableIdentify.getSimple());
 120                             fieldInfo.setFieldName(fieldName);
 121                             fieldInfoList.add(fieldInfo);
 122                         }
 123                 }
 124             }
 125         } else if (AGGREGATE.contains(fieldNode.getKind())
 126                 || AVG_AGG_FUNCTIONS.contains(fieldNode.getKind())
 127                 || COMPARISON.contains(fieldNode.getKind())
 128                 || fieldNode.getKind() == OTHER_FUNCTION
 129                 || fieldNode.getKind() == DIVIDE
 130                 || fieldNode.getKind() == CAST
 131                 || fieldNode.getKind() == TRIM
 132                 || fieldNode.getKind() == TIMES
 133                 || fieldNode.getKind() == PLUS
 134                 || fieldNode.getKind() == NOT_IN
 135                 || fieldNode.getKind() == OR
 136                 || fieldNode.getKind() == AND
 137                 || fieldNode.getKind() == MINUS
 138                 || fieldNode.getKind() == TUMBLE
 139                 || fieldNode.getKind() == TUMBLE_START
 140                 || fieldNode.getKind() == TUMBLE_END
 141                 || fieldNode.getKind() == SESSION
 142                 || fieldNode.getKind() == SESSION_START
 143                 || fieldNode.getKind() == SESSION_END
 144                 || fieldNode.getKind() == HOP
 145                 || fieldNode.getKind() == HOP_START
 146                 || fieldNode.getKind() == HOP_END
 147                 || fieldNode.getKind() == BETWEEN
 148                 || fieldNode.getKind() == IS_NULL
 149                 || fieldNode.getKind() == IS_NOT_NULL
 150                 || fieldNode.getKind() == CONTAINS
 151                 || fieldNode.getKind() == TIMESTAMP_ADD
 152                 || fieldNode.getKind() == TIMESTAMP_DIFF
 153                 || fieldNode.getKind() == LIKE
 154                 || fieldNode.getKind() == COALESCE
 155                 ) {
 156             SqlBasicCall sqlBasicCall = (SqlBasicCall) fieldNode;
 157             for (int i = 0; i &lt; sqlBasicCall.getOperands().length; i++) {
 158                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 159                 if (sqlNode instanceof SqlLiteral) {
 160                     continue;
 161                 }
 162 
 163                 if (sqlNode instanceof SqlDataTypeSpec) {
 164                     continue;
 165                 }
 166                 extractSelectFieldToFieldInfo(sqlNode, fromNode, fieldInfoList, localTableCache);
 167             }
 168         } else if (fieldNode.getKind() == AS) {
 169             SqlNode leftNode = ((SqlBasicCall) fieldNode).getOperands()[0];
 170             extractSelectFieldToFieldInfo(leftNode, fromNode,fieldInfoList, localTableCache);
 171         } else if (fieldNode.getKind() == CASE) {
 172             SqlCase sqlCase = (SqlCase) fieldNode;
 173             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 174             SqlNodeList thenOperands = sqlCase.getThenOperands();
 175             SqlNode elseNode = sqlCase.getElseOperand();
 176 
 177             for (int i = 0; i &lt; whenOperands.size(); i++) {
 178                 SqlNode oneOperand = whenOperands.get(i);
 179                 extractSelectFieldToFieldInfo(oneOperand, fromNode, fieldInfoList, localTableCache);
 180             }
 181 
 182             for (int i = 0; i &lt; thenOperands.size(); i++) {
 183                 SqlNode oneOperand = thenOperands.get(i);
 184                 extractSelectFieldToFieldInfo(oneOperand, fromNode, fieldInfoList, localTableCache);
 185 
 186             }
 187 
 188             extractSelectFieldToFieldInfo(elseNode, fromNode, fieldInfoList, localTableCache);
 189         }
 190     }
 191 
<abbr title=" 192     public static SqlBasicCall buildAsNodeByJoinInfo(JoinInfo joinInfo, SqlNode sqlNode0, String tableAlias) {"> 192     public static SqlBasicCall buildAsNodeByJoinInfo(JoinInfo joinInfo, SqlNode sqlNode0, String tableAliüîµ</abbr>
 193         SqlOperator operator = new SqlAsOperator();
 194         SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 195         String newTableName = joinInfo.getNewTableName();
<abbr title=" 196         String newTableAlias = (!StringUtils.isEmpty(tableAlias)) ? tableAlias : joinInfo.getNewTableAlias();"> 196         String newTableAlias = (!StringUtils.isEmpty(tableAlias)) ? tableAlias : joinInfo.getNewTableAliaüîµ</abbr>
 197         if (null == sqlNode0) {
 198             sqlNode0 = new SqlIdentifier(newTableName, null, sqlParserPos);
 199         }
 200         SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(newTableAlias, null, sqlParserPos);
 201         SqlNode[] sqlNodes = new SqlNode[2];
 202         sqlNodes[0] = sqlNode0;
 203         sqlNodes[1] = sqlIdentifierAlias;
 204         return new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 205     }
 206 
 207     /**
 208      *
 209      * @param joinInfo
 210      * @param sqlNode
 211      * @param queueInfo
 212      * @return   ‰∏§‰∏™ËæπÂÖ≥ËÅîÂêéÁöÑÊñ∞Ë°®Ë°®Âêç
 213      */
<abbr title=" 214     public static String dealSelectResultWithJoinInfo(JoinInfo joinInfo, SqlSelect sqlNode, Queue&lt;Object&gt; queueInfo) {"> 214     public static String dealSelectResultWithJoinInfo(JoinInfo joinInfo, SqlSelect sqlNode, Queue&lt;Object&gt;üîµ</abbr>
 215         //SideJoinInfo rename
 216         if (joinInfo.checkIsSide()) {
 217             joinInfo.setSelectFields(sqlNode.getSelectList());
 218             joinInfo.setSelectNode(sqlNode);
 219             if (joinInfo.isRightIsSideTable()) {
 220                 //Analyzing left is not a simple table
 221                 if (joinInfo.getLeftNode().getKind() == SELECT) {
 222                     queueInfo.offer(joinInfo.getLeftNode());
 223                 }
 224 
 225                 queueInfo.offer(joinInfo);
 226             } else {
 227                 //Determining right is not a simple table
 228                 if (joinInfo.getRightNode().getKind() == SELECT) {
 229                     queueInfo.offer(joinInfo.getLeftNode());
 230                 }
 231 
 232                 queueInfo.offer(joinInfo);
 233             }
 234             replaceFromNodeForJoin(joinInfo, sqlNode);
 235             return joinInfo.getNewTableName();
 236         }
 237         return &quot;&quot;;
 238     }
 239 
 240     public static void replaceFromNodeForJoin(JoinInfo joinInfo, SqlSelect sqlNode) {
 241         //Update from node
 242         SqlBasicCall sqlBasicCall = buildAsNodeByJoinInfo(joinInfo, null, null);
 243         String newAliasName = sqlBasicCall.operand(1).toString();
 244 
 245         //ÊõøÊç¢select ‰∏≠ÁöÑÂ±ûÊÄß‰∏∫Êñ∞ÁöÑË°®ÂêçÁß∞ÂíåÂ≠óÊÆµ
 246         HashBasedTable&lt;String, String, String&gt; fieldMapping = joinInfo.getTableFieldRef();
 247         Map&lt;String, String&gt; leftFieldMapping = fieldMapping.row(joinInfo.getLeftTableAlias());
 248         Map&lt;String, String&gt; rightFieldMapping = fieldMapping.row(joinInfo.getRightTableAlias());
 249 
 250        /* for(SqlNode oneSelectNode : sqlNode.getSelectList()){
<abbr title=" 251             replaceSelectFieldTable(oneSelectNode, joinInfo.getLeftTableAlias(), newAliasName, null ,leftFieldMapping);"> 251             replaceSelectFieldTable(oneSelectNode, joinInfo.getLeftTableAlias(), newAliasName, null ,leftüîµ</abbr>
<abbr title=" 252             replaceSelectFieldTable(oneSelectNode, joinInfo.getRightTableAlias(), newAliasName, null , rightFieldMapping);"> 252             replaceSelectFieldTable(oneSelectNode, joinInfo.getRightTableAlias(), newAliasName, null , riüîµ</abbr>
 253         }*/
 254 
 255         //where‰∏≠ÁöÑÊù°‰ª∂Â±ûÊÄß‰∏∫Êñ∞ÁöÑË°®ÂêçÁß∞ÂíåÂ≠óÊÆµ
<abbr title=" 256         FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getLeftTableAlias(), newAliasName, leftFieldMapping);"> 256         FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getLeftTableAlias(), newAliasName, leftFieldMüîµ</abbr>
<abbr title=" 257         FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getRightTableAlias(), newAliasName, rightFieldMapping);"> 257         FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getRightTableAlias(), newAliasName, rightFielüîµ</abbr>
 258         sqlNode.setFrom(sqlBasicCall);
 259     }
 260 
 261     /**
 262      * Ëé∑ÂèñËäÇÁÇπÂÖ≥ËÅîÁöÑÊü•ËØ¢Ë°®
 263      * @param fromTable
 264      * @param tableNameSet
 265      */
 266     public static void getFromTableInfo(SqlNode fromTable, Set&lt;String&gt; tableNameSet){
 267         SqlKind sqlKind = fromTable.getKind();
 268         switch (sqlKind){
 269             case AS:
 270                 SqlNode alias = ((SqlBasicCall) fromTable).getOperands()[1];
 271                 tableNameSet.add(alias.toString());
 272                 return;
 273             case JOIN:
 274                 getFromTableInfo(((SqlJoin)fromTable).getLeft(), tableNameSet);
 275                 getFromTableInfo(((SqlJoin)fromTable).getRight(), tableNameSet);
 276                 return;
 277             case IDENTIFIER:
 278                 tableNameSet.add(((SqlIdentifier)fromTable).getSimple());
 279                 return;
 280             case SELECT:
 281                 getFromTableInfo(((SqlSelect) fromTable).getFrom(), tableNameSet);
 282                 return;
 283             default:
 284                 throw new RuntimeException(&quot;not support sqlKind:&quot; + sqlKind);
 285         }
 286     }
 287 
 288     /**
 289      * ÊõøÊç¢select ‰∏≠ÁöÑÂ≠óÊÆµ‰ø°ÊÅØ
 290      * Â¶ÇÊûúmappingTable ÈùûÁ©∫Âàô‰ªéËØ•ÂèÇÊï∞Ëé∑ÂèñÂ≠óÊÆµÁöÑÊò†Â∞Ñ
 291      * Â¶ÇÊûúmappingTable ‰∏∫Á©∫ÂàôÊ†πÊçÆÊòØÂê¶Â≠òÂú®Êñ∞ÁîüÊàêÂ≠óÊÆµ
 292      * @param selectNode
 293      * @param oldTbName
 294      * @param newTbName
 295      * @param fieldReplaceRef
 296      */
 297     public static void replaceSelectFieldTable(SqlNode selectNode,
 298                                                String oldTbName,
 299                                                String newTbName,
 300                                                HashBiMap&lt;String, String&gt; fieldReplaceRef) {
 301         if (selectNode.getKind() == AS) {
 302             SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 303             replaceSelectFieldTable(leftNode, oldTbName, newTbName, fieldReplaceRef);
 304 
 305         }else if(selectNode.getKind() == IDENTIFIER){
 306             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 307 
 308             if(sqlIdentifier.names.size() == 1){
 309                 return ;
 310             }
 311 
 312             String fieldTableName = sqlIdentifier.names.get(0);
 313             if(oldTbName.equalsIgnoreCase(fieldTableName)){
 314                 replaceOneSelectField(sqlIdentifier, newTbName, oldTbName, fieldReplaceRef);
 315             }
 316 
 317         }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//Â≠óÈù¢Âê´‰πâ
 318             return;
 319         }else if(  AGGREGATE.contains(selectNode.getKind())
 320                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 321                 || COMPARISON.contains(selectNode.getKind())
 322                 || selectNode.getKind() == OTHER_FUNCTION
 323                 || selectNode.getKind() == DIVIDE
 324                 || selectNode.getKind() == CAST
 325                 || selectNode.getKind() == TRIM
 326                 || selectNode.getKind() == TIMES
 327                 || selectNode.getKind() == PLUS
 328                 || selectNode.getKind() == NOT_IN
 329                 || selectNode.getKind() == OR
 330                 || selectNode.getKind() == AND
 331                 || selectNode.getKind() == MINUS
 332                 || selectNode.getKind() == TUMBLE
 333                 || selectNode.getKind() == TUMBLE_START
 334                 || selectNode.getKind() == TUMBLE_END
 335                 || selectNode.getKind() == SESSION
 336                 || selectNode.getKind() == SESSION_START
 337                 || selectNode.getKind() == SESSION_END
 338                 || selectNode.getKind() == HOP
 339                 || selectNode.getKind() == HOP_START
 340                 || selectNode.getKind() == HOP_END
 341                 || selectNode.getKind() == BETWEEN
 342                 || selectNode.getKind() == IS_NULL
 343                 || selectNode.getKind() == IS_NOT_NULL
 344                 || selectNode.getKind() == CONTAINS
 345                 || selectNode.getKind() == TIMESTAMP_ADD
 346                 || selectNode.getKind() == TIMESTAMP_DIFF
 347                 || selectNode.getKind() == LIKE
 348                 || selectNode.getKind() == COALESCE
 349 
 350         ){
 351             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 352             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 353                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 354                 if(sqlNode instanceof SqlLiteral){
 355                     continue;
 356                 }
 357 
 358                 if(sqlNode instanceof SqlDataTypeSpec){
 359                     continue;
 360                 }
 361 
 362                 replaceSelectFieldTable(sqlNode, oldTbName, newTbName, fieldReplaceRef);
 363             }
 364 
 365         }else if(selectNode.getKind() == CASE){
 366             SqlCase sqlCase = (SqlCase) selectNode;
 367             SqlNodeList whenOperands = sqlCase.getWhenOperands();
 368             SqlNodeList thenOperands = sqlCase.getThenOperands();
 369             SqlNode elseNode = sqlCase.getElseOperand();
 370 
 371             for(int i=0; i&lt;whenOperands.size(); i++){
 372                 SqlNode oneOperand = whenOperands.get(i);
 373                 replaceSelectFieldTable(oneOperand, oldTbName, newTbName, fieldReplaceRef);
 374             }
 375 
 376             for(int i=0; i&lt;thenOperands.size(); i++){
 377                 SqlNode oneOperand = thenOperands.get(i);
 378                 replaceSelectFieldTable(oneOperand, oldTbName, newTbName, fieldReplaceRef);
 379 
 380             }
 381 
 382             replaceSelectFieldTable(elseNode, oldTbName, newTbName, fieldReplaceRef);
 383         }else if(selectNode.getKind() == OTHER){
 384             //‰∏çÂ§ÑÁêÜ
 385             return;
 386         }else{
<abbr title=" 387             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 387             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, üîµ</abbr>
 388         }
 389     }
 390 
 391     private static void replaceOneSelectField(SqlIdentifier sqlIdentifier,
 392                                               String newTbName,
 393                                               String oldTbName,
 394                                               HashBiMap&lt;String, String&gt; fieldReplaceRef){
 395         SqlIdentifier newField = sqlIdentifier.setName(0, newTbName);
 396         String fieldName = sqlIdentifier.names.get(1);
 397         String fieldKey = oldTbName + &quot;_&quot; + fieldName;
 398 
 399         if(!fieldReplaceRef.containsKey(fieldKey)){
 400             if(fieldReplaceRef.inverse().get(fieldName) != null){
 401                 //Êç¢‰∏Ä‰∏™ÂêçÂ≠ó
 402                 String mappingFieldName = ParseUtils.dealDuplicateFieldName(fieldReplaceRef, fieldName);
 403                 newField = newField.setName(1, mappingFieldName);
 404                 fieldReplaceRef.put(fieldKey, mappingFieldName);
 405             } else {
 406                 fieldReplaceRef.put(fieldKey, fieldName);
 407             }
 408         }else {
 409             newField = newField.setName(1, fieldReplaceRef.get(fieldKey));
 410         }
 411 
 412         sqlIdentifier.assignNamesFrom(newField);
 413     }
 414 
 415     /**
 416      * ÊõøÊç¢Âè¶Â§ñjoin Ë°®ÁöÑÊåáÂÆöË°®Âêç‰∏∫Êñ∞ÂÖ≥ËÅîÂ§ÑÁêÜÁöÑË°®ÂêçÁß∞
 417      * @param condition
 418      * @param oldTabFieldRefNew
 419      */
<abbr title=" 420     public static void replaceJoinFieldRefTableName(SqlNode condition, Map&lt;String, String&gt; oldTabFieldRefNew){"> 420     public static void replaceJoinFieldRefTableName(SqlNode condition, Map&lt;String, String&gt; oldTabFieldRefüîµ</abbr>
 421         if (null == condition || condition.getKind() == LITERAL) {
 422             return;
 423         }
 424         SqlKind joinKind = condition.getKind();
 425         if( AGGREGATE.contains(joinKind)
 426                 || AVG_AGG_FUNCTIONS.contains(joinKind)
 427                 || COMPARISON.contains(joinKind)
 428                 || joinKind == OTHER_FUNCTION
 429                 || joinKind == DIVIDE
 430                 || joinKind == CAST
 431                 || joinKind == TRIM
 432                 || joinKind == TIMES
 433                 || joinKind == PLUS
 434                 || joinKind == NOT_IN
 435                 || joinKind == OR
 436                 || joinKind == AND
 437                 || joinKind == MINUS
 438                 || joinKind == TUMBLE
 439                 || joinKind == TUMBLE_START
 440                 || joinKind == TUMBLE_END
 441                 || joinKind == SESSION
 442                 || joinKind == SESSION_START
 443                 || joinKind == SESSION_END
 444                 || joinKind == HOP
 445                 || joinKind == HOP_START
 446                 || joinKind == HOP_END
 447                 || joinKind == BETWEEN
 448                 || joinKind == IS_NULL
 449                 || joinKind == IS_NOT_NULL
 450                 || joinKind == CONTAINS
 451                 || joinKind == TIMESTAMP_ADD
 452                 || joinKind == TIMESTAMP_DIFF
 453                 || joinKind == LIKE
 454                 || joinKind == COALESCE
 455                 || joinKind == EQUALS ){
 456 
 457             SqlBasicCall sqlBasicCall = (SqlBasicCall) condition;
 458             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 459                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 460                 if(sqlNode instanceof SqlLiteral){
 461                     continue;
 462                 }
 463 
 464                 if(sqlNode instanceof SqlDataTypeSpec){
 465                     continue;
 466                 }
 467 
 468                 replaceJoinFieldRefTableName(sqlNode, oldTabFieldRefNew);
 469             }
 470 
 471         } else if (condition.getKind() == IDENTIFIER) {
<abbr title=" 472             Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 472             Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must büîµ</abbr>
 473             String fieldRefTable = ((SqlIdentifier)condition).names.get(0);
 474 
<abbr title=" 475             String targetFieldName = TableUtils.getTargetRefField(oldTabFieldRefNew, condition.toString());"> 475             String targetFieldName = TableUtils.getTargetRefField(oldTabFieldRefNew, condition.toString()üîµ</abbr>
 476 
 477             if(StringUtils.isNotBlank(targetFieldName)){
 478                 String[] fieldSplits = StringUtils.split(targetFieldName, &quot;.&quot;);
 479                 SqlIdentifier newField = ((SqlIdentifier)condition).setName(0, fieldSplits[0]);
 480                 newField = newField.setName(1, fieldSplits[1]);
 481                 ((SqlIdentifier)condition).assignNamesFrom(newField);
 482             }
 483         }
 484     }
 485 
 486     public static String getTargetRefTable(Map&lt;String, String&gt; refTableMap, String tableName){
 487         String targetTableName = null;
 488         String preTableName;
 489 
 490         do {
 491             preTableName = targetTableName == null ? tableName : targetTableName;
 492             targetTableName = refTableMap.get(preTableName);
 493         } while (targetTableName != null);
 494 
 495         return preTableName;
 496     }
 497 
 498     public static String getTargetRefField(Map&lt;String, String&gt; refFieldMap, String currFieldName){
 499         String targetFieldName = null;
 500         String preFieldName;
 501 
 502         do {
 503             preFieldName = targetFieldName == null ? currFieldName : targetFieldName;
 504             targetFieldName = refFieldMap.get(preFieldName);
 505         } while (targetFieldName != null);
 506 
 507         return preFieldName;
 508     }
 509 
<abbr title=" 510     public static void replaceWhereCondition(SqlNode parentWhere, String oldTbName, String newTbName, HashBiMap&lt;String, String&gt; fieldReplaceRef){"> 510     public static void replaceWhereCondition(SqlNode parentWhere, String oldTbName, String newTbName, Hasüîµ</abbr>
 511 
 512         if(parentWhere == null){
 513             return;
 514         }
 515 
 516         SqlKind kind = parentWhere.getKind();
 517         if(kind == AND){
<abbr title=" 518             replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[0], oldTbName, newTbName, fieldReplaceRef);"> 518             replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[0], oldTbName, newTbName, fiüîµ</abbr>
<abbr title=" 519             replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[1], oldTbName, newTbName, fieldReplaceRef);"> 519             replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[1], oldTbName, newTbName, fiüîµ</abbr>
 520 
 521         } else {
 522             replaceConditionNode(parentWhere, oldTbName, newTbName, fieldReplaceRef);
 523         }
 524     }
 525 
<abbr title=" 526     private static void replaceConditionNode(SqlNode selectNode, String oldTbName, String newTbName, HashBiMap&lt;String, String&gt; fieldReplaceRef) {"> 526     private static void replaceConditionNode(SqlNode selectNode, String oldTbName, String newTbName, Hashüîµ</abbr>
 527         if(selectNode.getKind() == IDENTIFIER){
 528             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 529 
 530             if(sqlIdentifier.names.size() == 1){
 531                 return;
 532             }
 533 
 534             String tableName = sqlIdentifier.names.asList().get(0);
 535             String tableField = sqlIdentifier.names.asList().get(1);
 536             String fieldKey = tableName + &quot;_&quot; + tableField;
 537 
 538             if(tableName.equalsIgnoreCase(oldTbName)){
 539 
<abbr title=" 540                 String newFieldName = fieldReplaceRef.get(fieldKey) == null ? tableField : fieldReplaceRef.get(fieldKey);"> 540                 String newFieldName = fieldReplaceRef.get(fieldKey) == null ? tableField : fieldReplaceReüîµ</abbr>
 541                 SqlIdentifier newField = ((SqlIdentifier)selectNode).setName(0, newTbName);
 542                 newField = newField.setName(1, newFieldName);
 543                 ((SqlIdentifier)selectNode).assignNamesFrom(newField);
 544             }
 545             return;
 546         }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//Â≠óÈù¢Âê´‰πâ
 547             return;
 548         }else if(  AGGREGATE.contains(selectNode.getKind())
 549                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 550                 || COMPARISON.contains(selectNode.getKind())
 551                 || selectNode.getKind() == OTHER_FUNCTION
 552                 || selectNode.getKind() == DIVIDE
 553                 || selectNode.getKind() == CAST
 554                 || selectNode.getKind() == TRIM
 555                 || selectNode.getKind() == TIMES
 556                 || selectNode.getKind() == PLUS
 557                 || selectNode.getKind() == NOT_IN
 558                 || selectNode.getKind() == OR
 559                 || selectNode.getKind() == AND
 560                 || selectNode.getKind() == MINUS
 561                 || selectNode.getKind() == TUMBLE
 562                 || selectNode.getKind() == TUMBLE_START
 563                 || selectNode.getKind() == TUMBLE_END
 564                 || selectNode.getKind() == SESSION
 565                 || selectNode.getKind() == SESSION_START
 566                 || selectNode.getKind() == SESSION_END
 567                 || selectNode.getKind() == HOP
 568                 || selectNode.getKind() == HOP_START
 569                 || selectNode.getKind() == HOP_END
 570                 || selectNode.getKind() == BETWEEN
 571                 || selectNode.getKind() == IS_NULL
 572                 || selectNode.getKind() == IS_NOT_NULL
 573                 || selectNode.getKind() == CONTAINS
 574                 || selectNode.getKind() == TIMESTAMP_ADD
 575                 || selectNode.getKind() == TIMESTAMP_DIFF
 576                 || selectNode.getKind() == LIKE
 577                 || selectNode.getKind() == COALESCE
 578 
 579         ){
 580             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 581             for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 582                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 583                 if(sqlNode instanceof SqlLiteral){
 584                     continue;
 585                 }
 586 
 587                 if(sqlNode instanceof SqlDataTypeSpec){
 588                     continue;
 589                 }
 590 
 591                 replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef);
 592             }
 593 
 594             return;
 595         }else if(selectNode.getKind() == OTHER){
 596             //‰∏çÂ§ÑÁêÜ
 597             return;
 598         } else if (selectNode.getKind() == CASE) {
 599             SqlCase sqlCase = (SqlCase) selectNode;
 600 
<abbr title=" 601             sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef));"> 601             sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbNamüîµ</abbr>
<abbr title=" 602             sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef));"> 602             sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbNamüîµ</abbr>
 603             replaceConditionNode(sqlCase.getElseOperand(), oldTbName, newTbName, fieldReplaceRef);
 604         } else {
<abbr title=" 605             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 605             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, üîµ</abbr>
 606         }
 607     }
 608 
 609     /**
 610      * Ëé∑ÂèñÊù°‰ª∂‰∏≠ÂÖ≥ËÅîÁöÑË°®‰ø°ÊÅØ
 611      * @param selectNode
 612      * @param fieldInfos
 613      */
 614     public static void getConditionRefTable(SqlNode selectNode, Set&lt;String&gt; fieldInfos) {
 615         if (selectNode.getKind() == IDENTIFIER) {
 616             SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 617 
 618             fieldInfos.add(sqlIdentifier.toString());
 619             return;
 620         } else if (selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN) {//Â≠óÈù¢Âê´‰πâ
 621             return;
 622         } else if (AGGREGATE.contains(selectNode.getKind())
 623                 || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 624                 || COMPARISON.contains(selectNode.getKind())
 625                 || selectNode.getKind() == OTHER_FUNCTION
 626                 || selectNode.getKind() == DIVIDE
 627                 || selectNode.getKind() == CAST
 628                 || selectNode.getKind() == TRIM
 629                 || selectNode.getKind() == TIMES
 630                 || selectNode.getKind() == PLUS
 631                 || selectNode.getKind() == NOT_IN
 632                 || selectNode.getKind() == OR
 633                 || selectNode.getKind() == AND
 634                 || selectNode.getKind() == MINUS
 635                 || selectNode.getKind() == TUMBLE
 636                 || selectNode.getKind() == TUMBLE_START
 637                 || selectNode.getKind() == TUMBLE_END
 638                 || selectNode.getKind() == SESSION
 639                 || selectNode.getKind() == SESSION_START
 640                 || selectNode.getKind() == SESSION_END
 641                 || selectNode.getKind() == HOP
 642                 || selectNode.getKind() == HOP_START
 643                 || selectNode.getKind() == HOP_END
 644                 || selectNode.getKind() == BETWEEN
 645                 || selectNode.getKind() == IS_NULL
 646                 || selectNode.getKind() == IS_NOT_NULL
 647                 || selectNode.getKind() == CONTAINS
 648                 || selectNode.getKind() == TIMESTAMP_ADD
 649                 || selectNode.getKind() == TIMESTAMP_DIFF
 650                 || selectNode.getKind() == LIKE
 651                 || selectNode.getKind() == COALESCE
 652 
 653                 ) {
 654             SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 655             for (int i = 0; i &lt; sqlBasicCall.getOperands().length; i++) {
 656                 SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 657                 if (sqlNode instanceof SqlLiteral) {
 658                     continue;
 659                 }
 660 
 661                 if (sqlNode instanceof SqlDataTypeSpec) {
 662                     continue;
 663                 }
 664 
 665                 getConditionRefTable(sqlNode, fieldInfos);
 666             }
 667 
 668             return;
 669         } else if (selectNode.getKind() == OTHER) {
 670             //‰∏çÂ§ÑÁêÜ
 671             return;
 672         } else if (selectNode.getKind() == CASE) {
 673             SqlCase sqlCase = (SqlCase) selectNode;
 674 
<abbr title=" 675             sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfos));"> 675             sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfüîµ</abbr>
<abbr title=" 676             sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfos));"> 676             sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfüîµ</abbr>
 677             getConditionRefTable(sqlCase.getElseOperand(), fieldInfos);
 678         } else {
<abbr title=" 679             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 679             throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, üîµ</abbr>
 680         }
 681     }
 682 
 683     public static String buildTableField(String tableName, String fieldName){
 684         return String.format(&quot;%s.%s&quot;, tableName, fieldName);
 685     }
 686 
 687     public static String buildTableNameWithScope(String tableName, String scope){
 688         if(StringUtils.isEmpty(scope)){
 689             return tableName;
 690         }
 691 
 692         return tableName + &quot;_&quot; + scope;
 693     }
 694 
 695     /**
 696      * add constant join fields, using in such as hbase„ÄÅredis etc kv database
 697      * @param keyMap
 698      */
 699     public static void addConstant(Map&lt;String, Object&gt; keyMap, AbstractSideTableInfo sideTableInfo) {
 700         List&lt;PredicateInfo&gt; predicateInfos = sideTableInfo.getPredicateInfoes();
 701         final String name = sideTableInfo.getName();
 702         for (PredicateInfo info : predicateInfos) {
 703             if (info.getOwnerTable().equals(name)
 704                 &amp;&amp; info.getOperatorName().equals(&quot;=&quot;)) {
 705                 String condition = info.getCondition();
 706                 Matcher matcher = stringPattern.matcher(condition);
 707                 if (matcher.matches()) {
 708                     condition = condition.substring(1, condition.length() - 1);
 709                 }
 710                 keyMap.put(info.getFieldName(), condition);
 711             }
 712         }
 713     }
 714 
<abbr title=" 715     public static String buildTableNameWithScope(String leftTableName, String leftTableAlias, String rightTableName, String scope, Set&lt;String&gt; existTableNames) {"> 715     public static String buildTableNameWithScope(String leftTableName, String leftTableAlias, String righüîµ</abbr>
 716         //ÂÖºÂÆπÂ∑¶ËæπË°®ÊòØas ÁöÑÊÉÖÂÜµ
 717         String leftStr = (Strings.isNullOrEmpty(leftTableName)) ? leftTableAlias : leftTableName;
 718         String newName = (leftStr + &quot;_&quot;) + rightTableName;
 719         if (CollectionUtils.isEmpty(existTableNames)) {
 720             return TableUtils.buildTableNameWithScope(newName, scope);
 721         }
 722         if (!existTableNames.contains(newName)) {
 723             return TableUtils.buildTableNameWithScope(newName, scope);
 724         }
 725         return (TableUtils.buildTableNameWithScope(newName, scope) + &quot;_&quot;) + System.currentTimeMillis();
 726     }
 727 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.util;
  21  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  22 +import com.dtstack.flink.sql.side.AbstractSideTableInfo;</span>
  23  import com.dtstack.flink.sql.side.FieldInfo;
  24  import com.dtstack.flink.sql.side.JoinInfo;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import com.dtstack.flink.sql.side.PredicateInfo;</span>
  26  import com.google.common.base.Preconditions;
  27  import com.google.common.base.Strings;
  28  import com.google.common.collect.HashBasedTable;
  29  import com.google.common.collect.HashBiMap;
  30  import com.google.common.collect.Lists;
  31  import com.google.common.collect.Sets;
  32  import com.typesafe.config.ConfigException;
  33  import org.apache.calcite.sql.SqlAsOperator;
  34  import org.apache.calcite.sql.SqlBasicCall;
  35  import org.apache.calcite.sql.SqlDataTypeSpec;
  36  import org.apache.calcite.sql.SqlIdentifier;
  37  import org.apache.calcite.sql.SqlJoin;
  38  import org.apache.calcite.sql.SqlKind;
  39  import org.apache.calcite.sql.SqlLiteral;
  40  import org.apache.calcite.sql.SqlNode;
  41  import org.apache.calcite.sql.SqlNodeList;
  42  import org.apache.calcite.sql.SqlOperator;
  43  import org.apache.calcite.sql.SqlSelect;
  44  import org.apache.calcite.sql.fun.SqlCase;
  45  import org.apache.calcite.sql.parser.SqlParserPos;

  46  import org.apache.commons.lang3.StringUtils;
  47  import org.apache.flink.table.api.Table;
  48  
  49  import java.util.List;
  50  import java.util.Map;
  51  import java.util.Queue;
  52  import java.util.Set;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  53 +import java.util.regex.Matcher;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  54 +import java.util.regex.Pattern;</span>
  55  
  56  import static org.apache.calcite.sql.SqlKind.*;
  57  import static org.apache.calcite.sql.SqlKind.CASE;
  58  import static org.apache.calcite.sql.SqlKind.OTHER;
  59  
  60  /**
  61   * Ë°®ÁöÑËß£ÊûêÁõ∏ÂÖ≥
  62   * Date: 2020/2/17
  63   * Company: www.dtstack.com
  64   * @author xuchao
  65   */
  66  
  67  public class TableUtils {
  68  
  69      public static final char SPLIT = &#x27;_&#x27;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  70 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  71 +    public static final Pattern stringPattern = Pattern.compile(&quot;\&quot;.*?\&quot;|\&#x27;.*?\&#x27;&quot;);</span>
  72      /**
  73       * Ëé∑Âèñselect ÁöÑÂ≠óÊÆµ
  74       * @param sqlSelect
  75       */
  76      public static List&lt;FieldInfo&gt; parserSelectField(SqlSelect sqlSelect, Map&lt;String, Table&gt; localTableCache){
  77          SqlNodeList sqlNodeList = sqlSelect.getSelectList();
  78          List&lt;FieldInfo&gt; fieldInfoList = Lists.newArrayList();
  79          String fromNode = sqlSelect.getFrom().toString();
  80  
  81          for (SqlNode fieldNode : sqlNodeList.getList()) {
  82              extractSelectFieldToFieldInfo(fieldNode,fromNode,fieldInfoList,localTableCache);
  83          }
  84  
  85          return fieldInfoList;
  86      }
  87  
  88      /**
  89       *  Ëß£Êûêselect Node ÊèêÂèñFieldInfo
  90       * @param fieldNode
  91       * @param fromNode
  92       * @param fieldInfoList
  93       * @param localTableCache
  94       */
<abbr title="  95      public static void extractSelectFieldToFieldInfo(SqlNode fieldNode, String fromNode, List&lt;FieldInfo&gt; fieldInfoList, Map&lt;String, Table&gt; localTableCache) {">  95      public static void extractSelectFieldToFieldInfo(SqlNode fieldNode, String fromNode, List&lt;FieldInfo&gt; fieldInfoüîµ</abbr>
  96          if (fieldNode.getKind() == IDENTIFIER) {
  97              SqlIdentifier identifier = (SqlIdentifier) fieldNode;
  98              if (!identifier.isStar()) {
<abbr title="  99                  String tableName = identifier.names.size() == 1 ? fromNode : identifier.getComponent(0).getSimple();">  99                  String tableName = identifier.names.size() == 1 ? fromNode : identifier.getComponent(0).getSimple(üîµ</abbr>
<abbr title=" 100                  String fieldName = identifier.names.size() == 1 ? identifier.getComponent(0).getSimple() : identifier.getComponent(1).getSimple();"> 100                  String fieldName = identifier.names.size() == 1 ? identifier.getComponent(0).getSimple() : identifüîµ</abbr>
 101                  FieldInfo fieldInfo = new FieldInfo();
 102                  fieldInfo.setTable(tableName);
 103                  fieldInfo.setFieldName(fieldName);
 104  
 105                  if (!fieldInfoList.contains(fieldInfo)) {
 106                      fieldInfoList.add(fieldInfo);
 107                  }
 108              } else {
 109                  //Â§ÑÁêÜ
 110                  int identifierSize = identifier.names.size();
 111                  switch (identifierSize) {
 112                      case 1:
 113                          throw new RuntimeException(&quot;not support to parse * without scope of table&quot;);
 114                      default:
 115                          SqlIdentifier tableIdentify = identifier.skipLast(1);
 116                          Table registerTable = localTableCache.get(tableIdentify.getSimple());
 117                          if (registerTable == null) {
 118                              throw new RuntimeException(&quot;can&#x27;t find table alias &quot; + tableIdentify.getSimple());
 119                          }
 120  
 121                          String[] fieldNames = registerTable.getSchema().getFieldNames();
 122                          for (String fieldName : fieldNames) {
 123                              FieldInfo fieldInfo = new FieldInfo();
 124                              fieldInfo.setTable(tableIdentify.getSimple());
 125                              fieldInfo.setFieldName(fieldName);
 126                              fieldInfoList.add(fieldInfo);
 127                          }
 128                  }
 129              }
 130          } else if (AGGREGATE.contains(fieldNode.getKind())
 131                  || AVG_AGG_FUNCTIONS.contains(fieldNode.getKind())
 132                  || COMPARISON.contains(fieldNode.getKind())
 133                  || fieldNode.getKind() == OTHER_FUNCTION
 134                  || fieldNode.getKind() == DIVIDE
 135                  || fieldNode.getKind() == CAST
 136                  || fieldNode.getKind() == TRIM
 137                  || fieldNode.getKind() == TIMES
 138                  || fieldNode.getKind() == PLUS
 139                  || fieldNode.getKind() == NOT_IN
 140                  || fieldNode.getKind() == OR
 141                  || fieldNode.getKind() == AND
 142                  || fieldNode.getKind() == MINUS
 143                  || fieldNode.getKind() == TUMBLE
 144                  || fieldNode.getKind() == TUMBLE_START
 145                  || fieldNode.getKind() == TUMBLE_END
 146                  || fieldNode.getKind() == SESSION
 147                  || fieldNode.getKind() == SESSION_START
 148                  || fieldNode.getKind() == SESSION_END
 149                  || fieldNode.getKind() == HOP
 150                  || fieldNode.getKind() == HOP_START
 151                  || fieldNode.getKind() == HOP_END
 152                  || fieldNode.getKind() == BETWEEN
 153                  || fieldNode.getKind() == IS_NULL
 154                  || fieldNode.getKind() == IS_NOT_NULL
 155                  || fieldNode.getKind() == CONTAINS
 156                  || fieldNode.getKind() == TIMESTAMP_ADD
 157                  || fieldNode.getKind() == TIMESTAMP_DIFF
 158                  || fieldNode.getKind() == LIKE
 159                  || fieldNode.getKind() == COALESCE
 160                  ) {
 161              SqlBasicCall sqlBasicCall = (SqlBasicCall) fieldNode;
 162              for (int i = 0; i &lt; sqlBasicCall.getOperands().length; i++) {
 163                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 164                  if (sqlNode instanceof SqlLiteral) {
 165                      continue;
 166                  }
 167  
 168                  if (sqlNode instanceof SqlDataTypeSpec) {
 169                      continue;
 170                  }
 171                  extractSelectFieldToFieldInfo(sqlNode, fromNode, fieldInfoList, localTableCache);
 172              }
 173          } else if (fieldNode.getKind() == AS) {
 174              SqlNode leftNode = ((SqlBasicCall) fieldNode).getOperands()[0];
 175              extractSelectFieldToFieldInfo(leftNode, fromNode,fieldInfoList, localTableCache);
 176          } else if (fieldNode.getKind() == CASE) {
 177              SqlCase sqlCase = (SqlCase) fieldNode;
 178              SqlNodeList whenOperands = sqlCase.getWhenOperands();
 179              SqlNodeList thenOperands = sqlCase.getThenOperands();
 180              SqlNode elseNode = sqlCase.getElseOperand();
 181  
 182              for (int i = 0; i &lt; whenOperands.size(); i++) {
 183                  SqlNode oneOperand = whenOperands.get(i);
 184                  extractSelectFieldToFieldInfo(oneOperand, fromNode, fieldInfoList, localTableCache);
 185              }
 186  
 187              for (int i = 0; i &lt; thenOperands.size(); i++) {
 188                  SqlNode oneOperand = thenOperands.get(i);
 189                  extractSelectFieldToFieldInfo(oneOperand, fromNode, fieldInfoList, localTableCache);
 190  
 191              }
 192  
 193              extractSelectFieldToFieldInfo(elseNode, fromNode, fieldInfoList, localTableCache);
 194          }
 195      }
 196  
 197      public static String buildInternalTableName(String left, char split, String right) {
 198          StringBuilder sb = new StringBuilder();
 199          return sb.append(left).append(split).append(right).toString();
 200      }
 201  
 202      public static SqlBasicCall buildAsNodeByJoinInfo(JoinInfo joinInfo, SqlNode sqlNode0, String tableAlias) {
 203          SqlOperator operator = new SqlAsOperator();
 204  
 205          SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 206          String newTableName = joinInfo.getNewTableName();
 207          String lefTbAlias = joinInfo.getLeftTableAlias();
 208  
 209          if(Strings.isNullOrEmpty(lefTbAlias)){
 210              Set&lt;String&gt; fromTableSet = Sets.newHashSet();
 211              TableUtils.getFromTableInfo(joinInfo.getLeftNode(), fromTableSet);
 212              lefTbAlias = StringUtils.join(fromTableSet, &quot;_&quot;);
 213          }
 214  
<abbr title=" 215          String newTableAlias = !StringUtils.isEmpty(tableAlias) ? tableAlias : buildInternalTableName(lefTbAlias, SPLIT, joinInfo.getRightTableAlias());"> 215          String newTableAlias = !StringUtils.isEmpty(tableAlias) ? tableAlias : buildInternalTableName(lefTbAlias, üîµ</abbr>


 216  
 217          if (null == sqlNode0) {
 218              sqlNode0 = new SqlIdentifier(newTableName, null, sqlParserPos);
 219          }
 220  
 221          SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(newTableAlias, null, sqlParserPos);
 222          SqlNode[] sqlNodes = new SqlNode[2];
 223          sqlNodes[0] = sqlNode0;
 224          sqlNodes[1] = sqlIdentifierAlias;
 225          return new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 226      }
 227  
 228      /**
 229       *
 230       * @param joinInfo
 231       * @param sqlNode
 232       * @param queueInfo
 233       * @return   ‰∏§‰∏™ËæπÂÖ≥ËÅîÂêéÁöÑÊñ∞Ë°®Ë°®Âêç
 234       */
<abbr title=" 235      public static String dealSelectResultWithJoinInfo(JoinInfo joinInfo, SqlSelect sqlNode, Queue&lt;Object&gt; queueInfo) {"> 235      public static String dealSelectResultWithJoinInfo(JoinInfo joinInfo, SqlSelect sqlNode, Queue&lt;Object&gt; queueInfüîµ</abbr>
 236          //SideJoinInfo rename
 237          if (joinInfo.checkIsSide()) {
 238              joinInfo.setSelectFields(sqlNode.getSelectList());
 239              joinInfo.setSelectNode(sqlNode);
 240              if (joinInfo.isRightIsSideTable()) {
 241                  //Analyzing left is not a simple table
 242                  if (joinInfo.getLeftNode().getKind() == SELECT) {
 243                      queueInfo.offer(joinInfo.getLeftNode());
 244                  }
 245  
 246                  queueInfo.offer(joinInfo);
 247              } else {
 248                  //Determining right is not a simple table
 249                  if (joinInfo.getRightNode().getKind() == SELECT) {
 250                      queueInfo.offer(joinInfo.getLeftNode());
 251                  }
 252  
 253                  queueInfo.offer(joinInfo);
 254              }
 255              replaceFromNodeForJoin(joinInfo, sqlNode);
 256              return joinInfo.getNewTableName();
 257          }
 258          return &quot;&quot;;
 259      }
 260  
 261      public static void replaceFromNodeForJoin(JoinInfo joinInfo, SqlSelect sqlNode) {
 262          //Update from node
 263          SqlBasicCall sqlBasicCall = buildAsNodeByJoinInfo(joinInfo, null, null);
 264          String newAliasName = sqlBasicCall.operand(1).toString();
 265  
 266          //ÊõøÊç¢select ‰∏≠ÁöÑÂ±ûÊÄß‰∏∫Êñ∞ÁöÑË°®ÂêçÁß∞ÂíåÂ≠óÊÆµ
 267          HashBasedTable&lt;String, String, String&gt; fieldMapping = joinInfo.getTableFieldRef();
 268          Map&lt;String, String&gt; leftFieldMapping = fieldMapping.row(joinInfo.getLeftTableAlias());
 269          Map&lt;String, String&gt; rightFieldMapping = fieldMapping.row(joinInfo.getRightTableAlias());
 270  
 271         /* for(SqlNode oneSelectNode : sqlNode.getSelectList()){
<abbr title=" 272              replaceSelectFieldTable(oneSelectNode, joinInfo.getLeftTableAlias(), newAliasName, null ,leftFieldMapping);"> 272              replaceSelectFieldTable(oneSelectNode, joinInfo.getLeftTableAlias(), newAliasName, null ,leftFieldMappüîµ</abbr>
<abbr title=" 273              replaceSelectFieldTable(oneSelectNode, joinInfo.getRightTableAlias(), newAliasName, null , rightFieldMapping);"> 273              replaceSelectFieldTable(oneSelectNode, joinInfo.getRightTableAlias(), newAliasName, null , rightFieldMüîµ</abbr>
 274          }*/
 275  
 276          //where‰∏≠ÁöÑÊù°‰ª∂Â±ûÊÄß‰∏∫Êñ∞ÁöÑË°®ÂêçÁß∞ÂíåÂ≠óÊÆµ
 277          FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getLeftTableAlias(), newAliasName, leftFieldMapping);
<abbr title=" 278          FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getRightTableAlias(), newAliasName, rightFieldMapping);"> 278          FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getRightTableAlias(), newAliasName, rightFieldMapping)üîµ</abbr>
 279          sqlNode.setFrom(sqlBasicCall);
 280      }
 281  
 282  
 283      /**
 284       * Ëé∑ÂèñËäÇÁÇπÂÖ≥ËÅîÁöÑÊü•ËØ¢Ë°®
 285       * @param fromTable
 286       * @param tableNameSet
 287       */
 288      public static void getFromTableInfo(SqlNode fromTable, Set&lt;String&gt; tableNameSet){
 289          SqlKind sqlKind = fromTable.getKind();
 290          switch (sqlKind){
 291              case AS:
 292                  SqlNode alias = ((SqlBasicCall) fromTable).getOperands()[1];
 293                  tableNameSet.add(alias.toString());
 294                  return;
 295              case JOIN:
 296                  getFromTableInfo(((SqlJoin)fromTable).getLeft(), tableNameSet);
 297                  getFromTableInfo(((SqlJoin)fromTable).getRight(), tableNameSet);
 298                  return;
 299              case IDENTIFIER:
 300                  tableNameSet.add(((SqlIdentifier)fromTable).getSimple());
 301                  return;
 302              case SELECT:
 303                  getFromTableInfo(((SqlSelect) fromTable).getFrom(), tableNameSet);
 304                  return;
 305              default:
 306                  throw new RuntimeException(&quot;not support sqlKind:&quot; + sqlKind);
 307          }
 308      }
 309  
 310      /**
 311       * ÊõøÊç¢select ‰∏≠ÁöÑÂ≠óÊÆµ‰ø°ÊÅØ
 312       * Â¶ÇÊûúmappingTable ÈùûÁ©∫Âàô‰ªéËØ•ÂèÇÊï∞Ëé∑ÂèñÂ≠óÊÆµÁöÑÊò†Â∞Ñ
 313       * Â¶ÇÊûúmappingTable ‰∏∫Á©∫ÂàôÊ†πÊçÆÊòØÂê¶Â≠òÂú®Êñ∞ÁîüÊàêÂ≠óÊÆµ
 314       * @param selectNode
 315       * @param oldTbName
 316       * @param newTbName
 317       * @param fieldReplaceRef
 318       */
 319      public static void replaceSelectFieldTable(SqlNode selectNode,
 320                                                 String oldTbName,
 321                                                 String newTbName,
 322                                                 HashBiMap&lt;String, String&gt; fieldReplaceRef) {
 323          if (selectNode.getKind() == AS) {
 324              SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 325              replaceSelectFieldTable(leftNode, oldTbName, newTbName, fieldReplaceRef);
 326  
 327          }else if(selectNode.getKind() == IDENTIFIER){
 328              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 329  
 330              if(sqlIdentifier.names.size() == 1){
 331                  return ;
 332              }
 333  
 334              String fieldTableName = sqlIdentifier.names.get(0);
 335              if(oldTbName.equalsIgnoreCase(fieldTableName)){
 336                  replaceOneSelectField(sqlIdentifier, newTbName, oldTbName, fieldReplaceRef);
 337              }
 338  
 339          }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//Â≠óÈù¢Âê´‰πâ
 340              return;
 341          }else if(  AGGREGATE.contains(selectNode.getKind())
 342                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 343                  || COMPARISON.contains(selectNode.getKind())
 344                  || selectNode.getKind() == OTHER_FUNCTION
 345                  || selectNode.getKind() == DIVIDE
 346                  || selectNode.getKind() == CAST
 347                  || selectNode.getKind() == TRIM
 348                  || selectNode.getKind() == TIMES
 349                  || selectNode.getKind() == PLUS
 350                  || selectNode.getKind() == NOT_IN
 351                  || selectNode.getKind() == OR
 352                  || selectNode.getKind() == AND
 353                  || selectNode.getKind() == MINUS
 354                  || selectNode.getKind() == TUMBLE
 355                  || selectNode.getKind() == TUMBLE_START
 356                  || selectNode.getKind() == TUMBLE_END
 357                  || selectNode.getKind() == SESSION
 358                  || selectNode.getKind() == SESSION_START
 359                  || selectNode.getKind() == SESSION_END
 360                  || selectNode.getKind() == HOP
 361                  || selectNode.getKind() == HOP_START
 362                  || selectNode.getKind() == HOP_END
 363                  || selectNode.getKind() == BETWEEN
 364                  || selectNode.getKind() == IS_NULL
 365                  || selectNode.getKind() == IS_NOT_NULL
 366                  || selectNode.getKind() == CONTAINS
 367                  || selectNode.getKind() == TIMESTAMP_ADD
 368                  || selectNode.getKind() == TIMESTAMP_DIFF
 369                  || selectNode.getKind() == LIKE
 370                  || selectNode.getKind() == COALESCE
 371  
 372          ){
 373              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 374              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 375                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 376                  if(sqlNode instanceof SqlLiteral){
 377                      continue;
 378                  }
 379  
 380                  if(sqlNode instanceof SqlDataTypeSpec){
 381                      continue;
 382                  }
 383  
 384                  replaceSelectFieldTable(sqlNode, oldTbName, newTbName, fieldReplaceRef);
 385              }
 386  
 387          }else if(selectNode.getKind() == CASE){
 388              SqlCase sqlCase = (SqlCase) selectNode;
 389              SqlNodeList whenOperands = sqlCase.getWhenOperands();
 390              SqlNodeList thenOperands = sqlCase.getThenOperands();
 391              SqlNode elseNode = sqlCase.getElseOperand();
 392  
 393              for(int i=0; i&lt;whenOperands.size(); i++){
 394                  SqlNode oneOperand = whenOperands.get(i);
 395                  replaceSelectFieldTable(oneOperand, oldTbName, newTbName, fieldReplaceRef);
 396              }
 397  
 398              for(int i=0; i&lt;thenOperands.size(); i++){
 399                  SqlNode oneOperand = thenOperands.get(i);
 400                  replaceSelectFieldTable(oneOperand, oldTbName, newTbName, fieldReplaceRef);
 401  
 402              }
 403  
 404              replaceSelectFieldTable(elseNode, oldTbName, newTbName, fieldReplaceRef);
 405          }else if(selectNode.getKind() == OTHER){
 406              //‰∏çÂ§ÑÁêÜ
 407              return;
 408          }else{
<abbr title=" 409              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 409              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNodüîµ</abbr>
 410          }
 411      }
 412  
 413      private static void replaceOneSelectField(SqlIdentifier sqlIdentifier,
 414                                                String newTbName,
 415                                                String oldTbName,
 416                                                HashBiMap&lt;String, String&gt; fieldReplaceRef){
 417          SqlIdentifier newField = sqlIdentifier.setName(0, newTbName);
 418          String fieldName = sqlIdentifier.names.get(1);
 419          String fieldKey = oldTbName + &quot;_&quot; + fieldName;
 420  
 421          if(!fieldReplaceRef.containsKey(fieldKey)){
 422              if(fieldReplaceRef.inverse().get(fieldName) != null){
 423                  //Êç¢‰∏Ä‰∏™ÂêçÂ≠ó
 424                  String mappingFieldName = ParseUtils.dealDuplicateFieldName(fieldReplaceRef, fieldName);
 425                  newField = newField.setName(1, mappingFieldName);
 426                  fieldReplaceRef.put(fieldKey, mappingFieldName);
 427              } else {
 428                  fieldReplaceRef.put(fieldKey, fieldName);
 429              }
 430          }else {
 431              newField = newField.setName(1, fieldReplaceRef.get(fieldKey));
 432          }
 433  
 434          sqlIdentifier.assignNamesFrom(newField);
 435      }
 436  
 437      /**
 438       * ÊõøÊç¢Âè¶Â§ñjoin Ë°®ÁöÑÊåáÂÆöË°®Âêç‰∏∫Êñ∞ÂÖ≥ËÅîÂ§ÑÁêÜÁöÑË°®ÂêçÁß∞
 439       * @param condition
 440       * @param oldTabFieldRefNew
 441       */
 442      public static void replaceJoinFieldRefTableName(SqlNode condition, Map&lt;String, String&gt; oldTabFieldRefNew){
 443          if (null == condition || condition.getKind() == LITERAL) {
 444              return;
 445          }
 446          SqlKind joinKind = condition.getKind();
 447          if( AGGREGATE.contains(joinKind)
 448                  || AVG_AGG_FUNCTIONS.contains(joinKind)
 449                  || COMPARISON.contains(joinKind)
 450                  || joinKind == OTHER_FUNCTION
 451                  || joinKind == DIVIDE
 452                  || joinKind == CAST
 453                  || joinKind == TRIM
 454                  || joinKind == TIMES
 455                  || joinKind == PLUS
 456                  || joinKind == NOT_IN
 457                  || joinKind == OR
 458                  || joinKind == AND
 459                  || joinKind == MINUS
 460                  || joinKind == TUMBLE
 461                  || joinKind == TUMBLE_START
 462                  || joinKind == TUMBLE_END
 463                  || joinKind == SESSION
 464                  || joinKind == SESSION_START
 465                  || joinKind == SESSION_END
 466                  || joinKind == HOP
 467                  || joinKind == HOP_START
 468                  || joinKind == HOP_END
 469                  || joinKind == BETWEEN
 470                  || joinKind == IS_NULL
 471                  || joinKind == IS_NOT_NULL
 472                  || joinKind == CONTAINS
 473                  || joinKind == TIMESTAMP_ADD
 474                  || joinKind == TIMESTAMP_DIFF
 475                  || joinKind == LIKE
 476                  || joinKind == COALESCE
 477                  || joinKind == EQUALS ){
 478  
 479              SqlBasicCall sqlBasicCall = (SqlBasicCall) condition;
 480              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 481                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 482                  if(sqlNode instanceof SqlLiteral){
 483                      continue;
 484                  }
 485  
 486                  if(sqlNode instanceof SqlDataTypeSpec){
 487                      continue;
 488                  }
 489  
 490                  replaceJoinFieldRefTableName(sqlNode, oldTabFieldRefNew);
 491              }
 492  
 493          } else if (condition.getKind() == IDENTIFIER) {
<abbr title=" 494              Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 494              Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must be format üîµ</abbr>
 495              String fieldRefTable = ((SqlIdentifier)condition).names.get(0);
 496  
 497              String targetFieldName = TableUtils.getTargetRefField(oldTabFieldRefNew, condition.toString());
 498  
 499              if(StringUtils.isNotBlank(targetFieldName)){
 500                  String[] fieldSplits = StringUtils.split(targetFieldName, &quot;.&quot;);
 501                  SqlIdentifier newField = ((SqlIdentifier)condition).setName(0, fieldSplits[0]);
 502                  newField = newField.setName(1, fieldSplits[1]);
 503                  ((SqlIdentifier)condition).assignNamesFrom(newField);
 504              }
 505          }
 506      }
 507  
 508      public static String getTargetRefTable(Map&lt;String, String&gt; refTableMap, String tableName){
 509          String targetTableName = null;
 510          String preTableName;
 511  
 512          do {
 513              preTableName = targetTableName == null ? tableName : targetTableName;
 514              targetTableName = refTableMap.get(preTableName);
 515          } while (targetTableName != null);
 516  
 517          return preTableName;
 518      }
 519  
 520      public static String getTargetRefField(Map&lt;String, String&gt; refFieldMap, String currFieldName){
 521          String targetFieldName = null;
 522          String preFieldName;
 523  
 524          do {
 525              preFieldName = targetFieldName == null ? currFieldName : targetFieldName;
 526              targetFieldName = refFieldMap.get(preFieldName);
 527          } while (targetFieldName != null);
 528  
 529          return preFieldName;
 530      }
 531  
<abbr title=" 532      public static void replaceWhereCondition(SqlNode parentWhere, String oldTbName, String newTbName, HashBiMap&lt;String, String&gt; fieldReplaceRef){"> 532      public static void replaceWhereCondition(SqlNode parentWhere, String oldTbName, String newTbName, HashBiMap&lt;Stüîµ</abbr>
 533  
 534          if(parentWhere == null){
 535              return;
 536          }
 537  
 538          SqlKind kind = parentWhere.getKind();
 539          if(kind == AND){
<abbr title=" 540              replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[0], oldTbName, newTbName, fieldReplaceRef);"> 540              replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[0], oldTbName, newTbName, fieldReplacüîµ</abbr>
<abbr title=" 541              replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[1], oldTbName, newTbName, fieldReplaceRef);"> 541              replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[1], oldTbName, newTbName, fieldReplacüîµ</abbr>
 542  
 543          } else {
 544              replaceConditionNode(parentWhere, oldTbName, newTbName, fieldReplaceRef);
 545          }
 546      }
 547  
<abbr title=" 548      private static void replaceConditionNode(SqlNode selectNode, String oldTbName, String newTbName, HashBiMap&lt;String, String&gt; fieldReplaceRef) {"> 548      private static void replaceConditionNode(SqlNode selectNode, String oldTbName, String newTbName, HashBiMap&lt;Strüîµ</abbr>
 549          if(selectNode.getKind() == IDENTIFIER){
 550              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 551  
 552              if(sqlIdentifier.names.size() == 1){
 553                  return;
 554              }
 555  
 556              String tableName = sqlIdentifier.names.asList().get(0);
 557              String tableField = sqlIdentifier.names.asList().get(1);
 558              String fieldKey = tableName + &quot;_&quot; + tableField;
 559  
 560              if(tableName.equalsIgnoreCase(oldTbName)){
 561  
<abbr title=" 562                  String newFieldName = fieldReplaceRef.get(fieldKey) == null ? tableField : fieldReplaceRef.get(fieldKey);"> 562                  String newFieldName = fieldReplaceRef.get(fieldKey) == null ? tableField : fieldReplaceRef.get(fieüîµ</abbr>
 563                  SqlIdentifier newField = ((SqlIdentifier)selectNode).setName(0, newTbName);
 564                  newField = newField.setName(1, newFieldName);
 565                  ((SqlIdentifier)selectNode).assignNamesFrom(newField);
 566              }
 567              return;
 568          }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//Â≠óÈù¢Âê´‰πâ
 569              return;
 570          }else if(  AGGREGATE.contains(selectNode.getKind())
 571                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 572                  || COMPARISON.contains(selectNode.getKind())
 573                  || selectNode.getKind() == OTHER_FUNCTION
 574                  || selectNode.getKind() == DIVIDE
 575                  || selectNode.getKind() == CAST
 576                  || selectNode.getKind() == TRIM
 577                  || selectNode.getKind() == TIMES
 578                  || selectNode.getKind() == PLUS
 579                  || selectNode.getKind() == NOT_IN
 580                  || selectNode.getKind() == OR
 581                  || selectNode.getKind() == AND
 582                  || selectNode.getKind() == MINUS
 583                  || selectNode.getKind() == TUMBLE
 584                  || selectNode.getKind() == TUMBLE_START
 585                  || selectNode.getKind() == TUMBLE_END
 586                  || selectNode.getKind() == SESSION
 587                  || selectNode.getKind() == SESSION_START
 588                  || selectNode.getKind() == SESSION_END
 589                  || selectNode.getKind() == HOP
 590                  || selectNode.getKind() == HOP_START
 591                  || selectNode.getKind() == HOP_END
 592                  || selectNode.getKind() == BETWEEN
 593                  || selectNode.getKind() == IS_NULL
 594                  || selectNode.getKind() == IS_NOT_NULL
 595                  || selectNode.getKind() == CONTAINS
 596                  || selectNode.getKind() == TIMESTAMP_ADD
 597                  || selectNode.getKind() == TIMESTAMP_DIFF
 598                  || selectNode.getKind() == LIKE
 599                  || selectNode.getKind() == COALESCE
 600  
 601          ){
 602              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 603              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 604                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 605                  if(sqlNode instanceof SqlLiteral){
 606                      continue;
 607                  }
 608  
 609                  if(sqlNode instanceof SqlDataTypeSpec){
 610                      continue;
 611                  }
 612  
 613                  replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef);
 614              }
 615  
 616              return;
 617          }else if(selectNode.getKind() == OTHER){
 618              //‰∏çÂ§ÑÁêÜ
 619              return;
 620          } else if (selectNode.getKind() == CASE) {
 621              SqlCase sqlCase = (SqlCase) selectNode;
 622  
<abbr title=" 623              sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef));"> 623              sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbName, newTbNüîµ</abbr>
<abbr title=" 624              sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef));"> 624              sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbName, newTbNüîµ</abbr>
 625              replaceConditionNode(sqlCase.getElseOperand(), oldTbName, newTbName, fieldReplaceRef);
 626          } else {
<abbr title=" 627              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 627              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNodüîµ</abbr>
 628          }
 629      }
 630  
 631      /**
 632       * Ëé∑ÂèñÊù°‰ª∂‰∏≠ÂÖ≥ËÅîÁöÑË°®‰ø°ÊÅØ
 633       * @param selectNode
 634       * @param fieldInfos
 635       */
 636      public static void getConditionRefTable(SqlNode selectNode, Set&lt;String&gt; fieldInfos) {
 637          if (selectNode.getKind() == IDENTIFIER) {
 638              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 639  
 640              fieldInfos.add(sqlIdentifier.toString());
 641              return;
 642          } else if (selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN) {//Â≠óÈù¢Âê´‰πâ
 643              return;
 644          } else if (AGGREGATE.contains(selectNode.getKind())
 645                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 646                  || COMPARISON.contains(selectNode.getKind())
 647                  || selectNode.getKind() == OTHER_FUNCTION
 648                  || selectNode.getKind() == DIVIDE
 649                  || selectNode.getKind() == CAST
 650                  || selectNode.getKind() == TRIM
 651                  || selectNode.getKind() == TIMES
 652                  || selectNode.getKind() == PLUS
 653                  || selectNode.getKind() == NOT_IN
 654                  || selectNode.getKind() == OR
 655                  || selectNode.getKind() == AND
 656                  || selectNode.getKind() == MINUS
 657                  || selectNode.getKind() == TUMBLE
 658                  || selectNode.getKind() == TUMBLE_START
 659                  || selectNode.getKind() == TUMBLE_END
 660                  || selectNode.getKind() == SESSION
 661                  || selectNode.getKind() == SESSION_START
 662                  || selectNode.getKind() == SESSION_END
 663                  || selectNode.getKind() == HOP
 664                  || selectNode.getKind() == HOP_START
 665                  || selectNode.getKind() == HOP_END
 666                  || selectNode.getKind() == BETWEEN
 667                  || selectNode.getKind() == IS_NULL
 668                  || selectNode.getKind() == IS_NOT_NULL
 669                  || selectNode.getKind() == CONTAINS
 670                  || selectNode.getKind() == TIMESTAMP_ADD
 671                  || selectNode.getKind() == TIMESTAMP_DIFF
 672                  || selectNode.getKind() == LIKE
 673                  || selectNode.getKind() == COALESCE
 674  
 675                  ) {
 676              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 677              for (int i = 0; i &lt; sqlBasicCall.getOperands().length; i++) {
 678                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 679                  if (sqlNode instanceof SqlLiteral) {
 680                      continue;
 681                  }
 682  
 683                  if (sqlNode instanceof SqlDataTypeSpec) {
 684                      continue;
 685                  }
 686  
 687                  getConditionRefTable(sqlNode, fieldInfos);
 688              }
 689  
 690              return;
 691          } else if (selectNode.getKind() == OTHER) {
 692              //‰∏çÂ§ÑÁêÜ
 693              return;
 694          } else if (selectNode.getKind() == CASE) {
 695              SqlCase sqlCase = (SqlCase) selectNode;
 696  
 697              sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfos));
 698              sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfos));
 699              getConditionRefTable(sqlCase.getElseOperand(), fieldInfos);
 700          } else {
<abbr title=" 701              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 701              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNodüîµ</abbr>
 702          }
 703      }
 704  
 705      public static String buildTableField(String tableName, String fieldName){
 706          return String.format(&quot;%s.%s&quot;, tableName, fieldName);
 707      }
 708  
 709  
 710      public static String buildTableNameWithScope(String tableName, String scope){
 711          if(StringUtils.isEmpty(scope)){
 712              return tableName;
 713          }
 714  
 715          return tableName + &quot;_&quot; + scope;
 716      }
 717  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 718 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 719 +     * add constant join fields, using in such as hbase„ÄÅredis etc kv database</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 720 +     * @param keyMap</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 721 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 722 +    public static void addConstant(Map&lt;String, Object&gt; keyMap, AbstractSideTableInfo sideTableInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 723 +        List&lt;PredicateInfo&gt; predicateInfos = sideTableInfo.getPredicateInfoes();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 724 +        final String name = sideTableInfo.getName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 725 +        for (PredicateInfo info : predicateInfos) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 726 +            if (info.getOwnerTable().equals(name)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 727 +                &amp;&amp; info.getOperatorName().equals(&quot;=&quot;)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 728 +                String condition = info.getCondition();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 729 +                Matcher matcher = stringPattern.matcher(condition);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 730 +                if (matcher.matches()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 731 +                    condition = condition.substring(1, condition.length() - 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 732 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 733 +                keyMap.put(info.getFieldName(), condition);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 734 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 735 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 736 +    }</span>
 737  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.util;
  21  

  22  import com.dtstack.flink.sql.side.FieldInfo;
  23  import com.dtstack.flink.sql.side.JoinInfo;

  24  import com.google.common.base.Preconditions;
  25  import com.google.common.base.Strings;
  26  import com.google.common.collect.HashBasedTable;
  27  import com.google.common.collect.HashBiMap;
  28  import com.google.common.collect.Lists;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  29 -import com.google.common.collect.Sets;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  30 -import com.typesafe.config.ConfigException;</span>
  31  import org.apache.calcite.sql.SqlAsOperator;
  32  import org.apache.calcite.sql.SqlBasicCall;
  33  import org.apache.calcite.sql.SqlDataTypeSpec;
  34  import org.apache.calcite.sql.SqlIdentifier;
  35  import org.apache.calcite.sql.SqlJoin;
  36  import org.apache.calcite.sql.SqlKind;
  37  import org.apache.calcite.sql.SqlLiteral;
  38  import org.apache.calcite.sql.SqlNode;
  39  import org.apache.calcite.sql.SqlNodeList;
  40  import org.apache.calcite.sql.SqlOperator;
  41  import org.apache.calcite.sql.SqlSelect;
  42  import org.apache.calcite.sql.fun.SqlCase;
  43  import org.apache.calcite.sql.parser.SqlParserPos;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  44 +import org.apache.commons.collections.CollectionUtils;</span>
  45  import org.apache.commons.lang3.StringUtils;
  46  import org.apache.flink.table.api.Table;
  47  
  48  import java.util.List;
  49  import java.util.Map;
  50  import java.util.Queue;
  51  import java.util.Set;


  52  
  53  import static org.apache.calcite.sql.SqlKind.*;
  54  import static org.apache.calcite.sql.SqlKind.CASE;
  55  import static org.apache.calcite.sql.SqlKind.OTHER;
  56  
  57  /**
  58   * Ë°®ÁöÑËß£ÊûêÁõ∏ÂÖ≥
  59   * Date: 2020/2/17
  60   * Company: www.dtstack.com
  61   * @author xuchao
  62   */
  63  
  64  public class TableUtils {
  65  
  66      public static final char SPLIT = &#x27;_&#x27;;
  67  

  68      /**
  69       * Ëé∑Âèñselect ÁöÑÂ≠óÊÆµ
  70       * @param sqlSelect
  71       */
  72      public static List&lt;FieldInfo&gt; parserSelectField(SqlSelect sqlSelect, Map&lt;String, Table&gt; localTableCache){
  73          SqlNodeList sqlNodeList = sqlSelect.getSelectList();
  74          List&lt;FieldInfo&gt; fieldInfoList = Lists.newArrayList();
  75          String fromNode = sqlSelect.getFrom().toString();
  76  
  77          for (SqlNode fieldNode : sqlNodeList.getList()) {
  78              extractSelectFieldToFieldInfo(fieldNode,fromNode,fieldInfoList,localTableCache);
  79          }
  80  
  81          return fieldInfoList;
  82      }
  83  
  84      /**
  85       *  Ëß£Êûêselect Node ÊèêÂèñFieldInfo
  86       * @param fieldNode
  87       * @param fromNode
  88       * @param fieldInfoList
  89       * @param localTableCache
  90       */
<abbr title="  91      public static void extractSelectFieldToFieldInfo(SqlNode fieldNode, String fromNode, List&lt;FieldInfo&gt; fieldInfoList, Map&lt;String, Table&gt; localTableCache) {">  91      public static void extractSelectFieldToFieldInfo(SqlNode fieldNode, String fromNode, List&lt;FieldInfo&gt; fieldInfoüîµ</abbr>
  92          if (fieldNode.getKind() == IDENTIFIER) {
  93              SqlIdentifier identifier = (SqlIdentifier) fieldNode;
  94              if (!identifier.isStar()) {
<abbr title="  95                  String tableName = identifier.names.size() == 1 ? fromNode : identifier.getComponent(0).getSimple();">  95                  String tableName = identifier.names.size() == 1 ? fromNode : identifier.getComponent(0).getSimple(üîµ</abbr>
<abbr title="  96                  String fieldName = identifier.names.size() == 1 ? identifier.getComponent(0).getSimple() : identifier.getComponent(1).getSimple();">  96                  String fieldName = identifier.names.size() == 1 ? identifier.getComponent(0).getSimple() : identifüîµ</abbr>
  97                  FieldInfo fieldInfo = new FieldInfo();
  98                  fieldInfo.setTable(tableName);
  99                  fieldInfo.setFieldName(fieldName);
 100  
 101                  if (!fieldInfoList.contains(fieldInfo)) {
 102                      fieldInfoList.add(fieldInfo);
 103                  }
 104              } else {
 105                  //Â§ÑÁêÜ
 106                  int identifierSize = identifier.names.size();
 107                  switch (identifierSize) {
 108                      case 1:
 109                          throw new RuntimeException(&quot;not support to parse * without scope of table&quot;);
 110                      default:
 111                          SqlIdentifier tableIdentify = identifier.skipLast(1);
 112                          Table registerTable = localTableCache.get(tableIdentify.getSimple());
 113                          if (registerTable == null) {
 114                              throw new RuntimeException(&quot;can&#x27;t find table alias &quot; + tableIdentify.getSimple());
 115                          }
 116  
 117                          String[] fieldNames = registerTable.getSchema().getFieldNames();
 118                          for (String fieldName : fieldNames) {
 119                              FieldInfo fieldInfo = new FieldInfo();
 120                              fieldInfo.setTable(tableIdentify.getSimple());
 121                              fieldInfo.setFieldName(fieldName);
 122                              fieldInfoList.add(fieldInfo);
 123                          }
 124                  }
 125              }
 126          } else if (AGGREGATE.contains(fieldNode.getKind())
 127                  || AVG_AGG_FUNCTIONS.contains(fieldNode.getKind())
 128                  || COMPARISON.contains(fieldNode.getKind())
 129                  || fieldNode.getKind() == OTHER_FUNCTION
 130                  || fieldNode.getKind() == DIVIDE
 131                  || fieldNode.getKind() == CAST
 132                  || fieldNode.getKind() == TRIM
 133                  || fieldNode.getKind() == TIMES
 134                  || fieldNode.getKind() == PLUS
 135                  || fieldNode.getKind() == NOT_IN
 136                  || fieldNode.getKind() == OR
 137                  || fieldNode.getKind() == AND
 138                  || fieldNode.getKind() == MINUS
 139                  || fieldNode.getKind() == TUMBLE
 140                  || fieldNode.getKind() == TUMBLE_START
 141                  || fieldNode.getKind() == TUMBLE_END
 142                  || fieldNode.getKind() == SESSION
 143                  || fieldNode.getKind() == SESSION_START
 144                  || fieldNode.getKind() == SESSION_END
 145                  || fieldNode.getKind() == HOP
 146                  || fieldNode.getKind() == HOP_START
 147                  || fieldNode.getKind() == HOP_END
 148                  || fieldNode.getKind() == BETWEEN
 149                  || fieldNode.getKind() == IS_NULL
 150                  || fieldNode.getKind() == IS_NOT_NULL
 151                  || fieldNode.getKind() == CONTAINS
 152                  || fieldNode.getKind() == TIMESTAMP_ADD
 153                  || fieldNode.getKind() == TIMESTAMP_DIFF
 154                  || fieldNode.getKind() == LIKE
 155                  || fieldNode.getKind() == COALESCE
 156                  ) {
 157              SqlBasicCall sqlBasicCall = (SqlBasicCall) fieldNode;
 158              for (int i = 0; i &lt; sqlBasicCall.getOperands().length; i++) {
 159                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 160                  if (sqlNode instanceof SqlLiteral) {
 161                      continue;
 162                  }
 163  
 164                  if (sqlNode instanceof SqlDataTypeSpec) {
 165                      continue;
 166                  }
 167                  extractSelectFieldToFieldInfo(sqlNode, fromNode, fieldInfoList, localTableCache);
 168              }
 169          } else if (fieldNode.getKind() == AS) {
 170              SqlNode leftNode = ((SqlBasicCall) fieldNode).getOperands()[0];
 171              extractSelectFieldToFieldInfo(leftNode, fromNode,fieldInfoList, localTableCache);
 172          } else if (fieldNode.getKind() == CASE) {
 173              SqlCase sqlCase = (SqlCase) fieldNode;
 174              SqlNodeList whenOperands = sqlCase.getWhenOperands();
 175              SqlNodeList thenOperands = sqlCase.getThenOperands();
 176              SqlNode elseNode = sqlCase.getElseOperand();
 177  
 178              for (int i = 0; i &lt; whenOperands.size(); i++) {
 179                  SqlNode oneOperand = whenOperands.get(i);
 180                  extractSelectFieldToFieldInfo(oneOperand, fromNode, fieldInfoList, localTableCache);
 181              }
 182  
 183              for (int i = 0; i &lt; thenOperands.size(); i++) {
 184                  SqlNode oneOperand = thenOperands.get(i);
 185                  extractSelectFieldToFieldInfo(oneOperand, fromNode, fieldInfoList, localTableCache);
 186  
 187              }
 188  
 189              extractSelectFieldToFieldInfo(elseNode, fromNode, fieldInfoList, localTableCache);
 190          }
 191      }
 192  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 193 -    public static String buildInternalTableName(String left, char split, String right) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 194 -        StringBuilder sb = new StringBuilder();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 195 -        return sb.append(left).append(split).append(right).toString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 196 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 197 -</span>
 198      public static SqlBasicCall buildAsNodeByJoinInfo(JoinInfo joinInfo, SqlNode sqlNode0, String tableAlias) {
 199          SqlOperator operator = new SqlAsOperator();
 200  
 201          SqlParserPos sqlParserPos = new SqlParserPos(0, 0);
 202          String newTableName = joinInfo.getNewTableName();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 203 -        String lefTbAlias = joinInfo.getLeftTableAlias();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 204 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 205 -        if(Strings.isNullOrEmpty(lefTbAlias)){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 206 -            Set&lt;String&gt; fromTableSet = Sets.newHashSet();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 207 -            TableUtils.getFromTableInfo(joinInfo.getLeftNode(), fromTableSet);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 208 -            lefTbAlias = StringUtils.join(fromTableSet, &quot;_&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 209 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 210 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 211 -        String newTableAlias = !StringUtils.isEmpty(tableAlias) ? tableAlias : buildInternalTableName(lefTbAlias, SPLIT, joinInfo.getRightTableAlias());"> 211 -        String newTableAlias = !StringUtils.isEmpty(tableAlias) ? tableAlias : buildInternalTableName(lefTbAlias, üîµ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +        String newTableAlias = !StringUtils.isEmpty(tableAlias) ? tableAlias : joinInfo.getNewTableAlias();</span>
 214  
 215          if (null == sqlNode0) {
 216              sqlNode0 = new SqlIdentifier(newTableName, null, sqlParserPos);
 217          }
 218  
 219          SqlIdentifier sqlIdentifierAlias = new SqlIdentifier(newTableAlias, null, sqlParserPos);
 220          SqlNode[] sqlNodes = new SqlNode[2];
 221          sqlNodes[0] = sqlNode0;
 222          sqlNodes[1] = sqlIdentifierAlias;
 223          return new SqlBasicCall(operator, sqlNodes, sqlParserPos);
 224      }
 225  
 226      /**
 227       *
 228       * @param joinInfo
 229       * @param sqlNode
 230       * @param queueInfo
 231       * @return   ‰∏§‰∏™ËæπÂÖ≥ËÅîÂêéÁöÑÊñ∞Ë°®Ë°®Âêç
 232       */
<abbr title=" 233      public static String dealSelectResultWithJoinInfo(JoinInfo joinInfo, SqlSelect sqlNode, Queue&lt;Object&gt; queueInfo) {"> 233      public static String dealSelectResultWithJoinInfo(JoinInfo joinInfo, SqlSelect sqlNode, Queue&lt;Object&gt; queueInfüîµ</abbr>
 234          //SideJoinInfo rename
 235          if (joinInfo.checkIsSide()) {
 236              joinInfo.setSelectFields(sqlNode.getSelectList());
 237              joinInfo.setSelectNode(sqlNode);
 238              if (joinInfo.isRightIsSideTable()) {
 239                  //Analyzing left is not a simple table
 240                  if (joinInfo.getLeftNode().getKind() == SELECT) {
 241                      queueInfo.offer(joinInfo.getLeftNode());
 242                  }
 243  
 244                  queueInfo.offer(joinInfo);
 245              } else {
 246                  //Determining right is not a simple table
 247                  if (joinInfo.getRightNode().getKind() == SELECT) {
 248                      queueInfo.offer(joinInfo.getLeftNode());
 249                  }
 250  
 251                  queueInfo.offer(joinInfo);
 252              }
 253              replaceFromNodeForJoin(joinInfo, sqlNode);
 254              return joinInfo.getNewTableName();
 255          }
 256          return &quot;&quot;;
 257      }
 258  
 259      public static void replaceFromNodeForJoin(JoinInfo joinInfo, SqlSelect sqlNode) {
 260          //Update from node
 261          SqlBasicCall sqlBasicCall = buildAsNodeByJoinInfo(joinInfo, null, null);
 262          String newAliasName = sqlBasicCall.operand(1).toString();
 263  
 264          //ÊõøÊç¢select ‰∏≠ÁöÑÂ±ûÊÄß‰∏∫Êñ∞ÁöÑË°®ÂêçÁß∞ÂíåÂ≠óÊÆµ
 265          HashBasedTable&lt;String, String, String&gt; fieldMapping = joinInfo.getTableFieldRef();
 266          Map&lt;String, String&gt; leftFieldMapping = fieldMapping.row(joinInfo.getLeftTableAlias());
 267          Map&lt;String, String&gt; rightFieldMapping = fieldMapping.row(joinInfo.getRightTableAlias());
 268  
 269         /* for(SqlNode oneSelectNode : sqlNode.getSelectList()){
<abbr title=" 270              replaceSelectFieldTable(oneSelectNode, joinInfo.getLeftTableAlias(), newAliasName, null ,leftFieldMapping);"> 270              replaceSelectFieldTable(oneSelectNode, joinInfo.getLeftTableAlias(), newAliasName, null ,leftFieldMappüîµ</abbr>
<abbr title=" 271              replaceSelectFieldTable(oneSelectNode, joinInfo.getRightTableAlias(), newAliasName, null , rightFieldMapping);"> 271              replaceSelectFieldTable(oneSelectNode, joinInfo.getRightTableAlias(), newAliasName, null , rightFieldMüîµ</abbr>
 272          }*/
 273  
 274          //where‰∏≠ÁöÑÊù°‰ª∂Â±ûÊÄß‰∏∫Êñ∞ÁöÑË°®ÂêçÁß∞ÂíåÂ≠óÊÆµ
 275          FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getLeftTableAlias(), newAliasName, leftFieldMapping);
<abbr title=" 276          FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getRightTableAlias(), newAliasName, rightFieldMapping);"> 276          FieldReplaceUtil.replaceFieldName(sqlNode, joinInfo.getRightTableAlias(), newAliasName, rightFieldMapping)üîµ</abbr>
 277          sqlNode.setFrom(sqlBasicCall);
 278      }
 279  
 280  
 281      /**
 282       * Ëé∑ÂèñËäÇÁÇπÂÖ≥ËÅîÁöÑÊü•ËØ¢Ë°®
 283       * @param fromTable
 284       * @param tableNameSet
 285       */
 286      public static void getFromTableInfo(SqlNode fromTable, Set&lt;String&gt; tableNameSet){
 287          SqlKind sqlKind = fromTable.getKind();
 288          switch (sqlKind){
 289              case AS:
 290                  SqlNode alias = ((SqlBasicCall) fromTable).getOperands()[1];
 291                  tableNameSet.add(alias.toString());
 292                  return;
 293              case JOIN:
 294                  getFromTableInfo(((SqlJoin)fromTable).getLeft(), tableNameSet);
 295                  getFromTableInfo(((SqlJoin)fromTable).getRight(), tableNameSet);
 296                  return;
 297              case IDENTIFIER:
 298                  tableNameSet.add(((SqlIdentifier)fromTable).getSimple());
 299                  return;
 300              case SELECT:
 301                  getFromTableInfo(((SqlSelect) fromTable).getFrom(), tableNameSet);
 302                  return;
 303              default:
 304                  throw new RuntimeException(&quot;not support sqlKind:&quot; + sqlKind);
 305          }
 306      }
 307  
 308      /**
 309       * ÊõøÊç¢select ‰∏≠ÁöÑÂ≠óÊÆµ‰ø°ÊÅØ
 310       * Â¶ÇÊûúmappingTable ÈùûÁ©∫Âàô‰ªéËØ•ÂèÇÊï∞Ëé∑ÂèñÂ≠óÊÆµÁöÑÊò†Â∞Ñ
 311       * Â¶ÇÊûúmappingTable ‰∏∫Á©∫ÂàôÊ†πÊçÆÊòØÂê¶Â≠òÂú®Êñ∞ÁîüÊàêÂ≠óÊÆµ
 312       * @param selectNode
 313       * @param oldTbName
 314       * @param newTbName
 315       * @param fieldReplaceRef
 316       */
 317      public static void replaceSelectFieldTable(SqlNode selectNode,
 318                                                 String oldTbName,
 319                                                 String newTbName,
 320                                                 HashBiMap&lt;String, String&gt; fieldReplaceRef) {
 321          if (selectNode.getKind() == AS) {
 322              SqlNode leftNode = ((SqlBasicCall) selectNode).getOperands()[0];
 323              replaceSelectFieldTable(leftNode, oldTbName, newTbName, fieldReplaceRef);
 324  
 325          }else if(selectNode.getKind() == IDENTIFIER){
 326              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 327  
 328              if(sqlIdentifier.names.size() == 1){
 329                  return ;
 330              }
 331  
 332              String fieldTableName = sqlIdentifier.names.get(0);
 333              if(oldTbName.equalsIgnoreCase(fieldTableName)){
 334                  replaceOneSelectField(sqlIdentifier, newTbName, oldTbName, fieldReplaceRef);
 335              }
 336  
 337          }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//Â≠óÈù¢Âê´‰πâ
 338              return;
 339          }else if(  AGGREGATE.contains(selectNode.getKind())
 340                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 341                  || COMPARISON.contains(selectNode.getKind())
 342                  || selectNode.getKind() == OTHER_FUNCTION
 343                  || selectNode.getKind() == DIVIDE
 344                  || selectNode.getKind() == CAST
 345                  || selectNode.getKind() == TRIM
 346                  || selectNode.getKind() == TIMES
 347                  || selectNode.getKind() == PLUS
 348                  || selectNode.getKind() == NOT_IN
 349                  || selectNode.getKind() == OR
 350                  || selectNode.getKind() == AND
 351                  || selectNode.getKind() == MINUS
 352                  || selectNode.getKind() == TUMBLE
 353                  || selectNode.getKind() == TUMBLE_START
 354                  || selectNode.getKind() == TUMBLE_END
 355                  || selectNode.getKind() == SESSION
 356                  || selectNode.getKind() == SESSION_START
 357                  || selectNode.getKind() == SESSION_END
 358                  || selectNode.getKind() == HOP
 359                  || selectNode.getKind() == HOP_START
 360                  || selectNode.getKind() == HOP_END
 361                  || selectNode.getKind() == BETWEEN
 362                  || selectNode.getKind() == IS_NULL
 363                  || selectNode.getKind() == IS_NOT_NULL
 364                  || selectNode.getKind() == CONTAINS
 365                  || selectNode.getKind() == TIMESTAMP_ADD
 366                  || selectNode.getKind() == TIMESTAMP_DIFF
 367                  || selectNode.getKind() == LIKE
 368                  || selectNode.getKind() == COALESCE
 369  
 370          ){
 371              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 372              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 373                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 374                  if(sqlNode instanceof SqlLiteral){
 375                      continue;
 376                  }
 377  
 378                  if(sqlNode instanceof SqlDataTypeSpec){
 379                      continue;
 380                  }
 381  
 382                  replaceSelectFieldTable(sqlNode, oldTbName, newTbName, fieldReplaceRef);
 383              }
 384  
 385          }else if(selectNode.getKind() == CASE){
 386              SqlCase sqlCase = (SqlCase) selectNode;
 387              SqlNodeList whenOperands = sqlCase.getWhenOperands();
 388              SqlNodeList thenOperands = sqlCase.getThenOperands();
 389              SqlNode elseNode = sqlCase.getElseOperand();
 390  
 391              for(int i=0; i&lt;whenOperands.size(); i++){
 392                  SqlNode oneOperand = whenOperands.get(i);
 393                  replaceSelectFieldTable(oneOperand, oldTbName, newTbName, fieldReplaceRef);
 394              }
 395  
 396              for(int i=0; i&lt;thenOperands.size(); i++){
 397                  SqlNode oneOperand = thenOperands.get(i);
 398                  replaceSelectFieldTable(oneOperand, oldTbName, newTbName, fieldReplaceRef);
 399  
 400              }
 401  
 402              replaceSelectFieldTable(elseNode, oldTbName, newTbName, fieldReplaceRef);
 403          }else if(selectNode.getKind() == OTHER){
 404              //‰∏çÂ§ÑÁêÜ
 405              return;
 406          }else{
<abbr title=" 407              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 407              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNodüîµ</abbr>
 408          }
 409      }
 410  
 411      private static void replaceOneSelectField(SqlIdentifier sqlIdentifier,
 412                                                String newTbName,
 413                                                String oldTbName,
 414                                                HashBiMap&lt;String, String&gt; fieldReplaceRef){
 415          SqlIdentifier newField = sqlIdentifier.setName(0, newTbName);
 416          String fieldName = sqlIdentifier.names.get(1);
 417          String fieldKey = oldTbName + &quot;_&quot; + fieldName;
 418  
 419          if(!fieldReplaceRef.containsKey(fieldKey)){
 420              if(fieldReplaceRef.inverse().get(fieldName) != null){
 421                  //Êç¢‰∏Ä‰∏™ÂêçÂ≠ó
 422                  String mappingFieldName = ParseUtils.dealDuplicateFieldName(fieldReplaceRef, fieldName);
 423                  newField = newField.setName(1, mappingFieldName);
 424                  fieldReplaceRef.put(fieldKey, mappingFieldName);
 425              } else {
 426                  fieldReplaceRef.put(fieldKey, fieldName);
 427              }
 428          }else {
 429              newField = newField.setName(1, fieldReplaceRef.get(fieldKey));
 430          }
 431  
 432          sqlIdentifier.assignNamesFrom(newField);
 433      }
 434  
 435      /**
 436       * ÊõøÊç¢Âè¶Â§ñjoin Ë°®ÁöÑÊåáÂÆöË°®Âêç‰∏∫Êñ∞ÂÖ≥ËÅîÂ§ÑÁêÜÁöÑË°®ÂêçÁß∞
 437       * @param condition
 438       * @param oldTabFieldRefNew
 439       */
 440      public static void replaceJoinFieldRefTableName(SqlNode condition, Map&lt;String, String&gt; oldTabFieldRefNew){
 441          if (null == condition || condition.getKind() == LITERAL) {
 442              return;
 443          }
 444          SqlKind joinKind = condition.getKind();
 445          if( AGGREGATE.contains(joinKind)
 446                  || AVG_AGG_FUNCTIONS.contains(joinKind)
 447                  || COMPARISON.contains(joinKind)
 448                  || joinKind == OTHER_FUNCTION
 449                  || joinKind == DIVIDE
 450                  || joinKind == CAST
 451                  || joinKind == TRIM
 452                  || joinKind == TIMES
 453                  || joinKind == PLUS
 454                  || joinKind == NOT_IN
 455                  || joinKind == OR
 456                  || joinKind == AND
 457                  || joinKind == MINUS
 458                  || joinKind == TUMBLE
 459                  || joinKind == TUMBLE_START
 460                  || joinKind == TUMBLE_END
 461                  || joinKind == SESSION
 462                  || joinKind == SESSION_START
 463                  || joinKind == SESSION_END
 464                  || joinKind == HOP
 465                  || joinKind == HOP_START
 466                  || joinKind == HOP_END
 467                  || joinKind == BETWEEN
 468                  || joinKind == IS_NULL
 469                  || joinKind == IS_NOT_NULL
 470                  || joinKind == CONTAINS
 471                  || joinKind == TIMESTAMP_ADD
 472                  || joinKind == TIMESTAMP_DIFF
 473                  || joinKind == LIKE
 474                  || joinKind == COALESCE
 475                  || joinKind == EQUALS ){
 476  
 477              SqlBasicCall sqlBasicCall = (SqlBasicCall) condition;
 478              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 479                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 480                  if(sqlNode instanceof SqlLiteral){
 481                      continue;
 482                  }
 483  
 484                  if(sqlNode instanceof SqlDataTypeSpec){
 485                      continue;
 486                  }
 487  
 488                  replaceJoinFieldRefTableName(sqlNode, oldTabFieldRefNew);
 489              }
 490  
 491          } else if (condition.getKind() == IDENTIFIER) {
<abbr title=" 492              Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must be format table.field&quot;);"> 492              Preconditions.checkState(((SqlIdentifier)condition).names.size() == 2, &quot;join condition must be format üîµ</abbr>
 493              String fieldRefTable = ((SqlIdentifier)condition).names.get(0);
 494  
 495              String targetFieldName = TableUtils.getTargetRefField(oldTabFieldRefNew, condition.toString());
 496  
 497              if(StringUtils.isNotBlank(targetFieldName)){
 498                  String[] fieldSplits = StringUtils.split(targetFieldName, &quot;.&quot;);
 499                  SqlIdentifier newField = ((SqlIdentifier)condition).setName(0, fieldSplits[0]);
 500                  newField = newField.setName(1, fieldSplits[1]);
 501                  ((SqlIdentifier)condition).assignNamesFrom(newField);
 502              }
 503          }
 504      }
 505  
 506      public static String getTargetRefTable(Map&lt;String, String&gt; refTableMap, String tableName){
 507          String targetTableName = null;
 508          String preTableName;
 509  
 510          do {
 511              preTableName = targetTableName == null ? tableName : targetTableName;
 512              targetTableName = refTableMap.get(preTableName);
 513          } while (targetTableName != null);
 514  
 515          return preTableName;
 516      }
 517  
 518      public static String getTargetRefField(Map&lt;String, String&gt; refFieldMap, String currFieldName){
 519          String targetFieldName = null;
 520          String preFieldName;
 521  
 522          do {
 523              preFieldName = targetFieldName == null ? currFieldName : targetFieldName;
 524              targetFieldName = refFieldMap.get(preFieldName);
 525          } while (targetFieldName != null);
 526  
 527          return preFieldName;
 528      }
 529  
<abbr title=" 530      public static void replaceWhereCondition(SqlNode parentWhere, String oldTbName, String newTbName, HashBiMap&lt;String, String&gt; fieldReplaceRef){"> 530      public static void replaceWhereCondition(SqlNode parentWhere, String oldTbName, String newTbName, HashBiMap&lt;Stüîµ</abbr>
 531  
 532          if(parentWhere == null){
 533              return;
 534          }
 535  
 536          SqlKind kind = parentWhere.getKind();
 537          if(kind == AND){
<abbr title=" 538              replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[0], oldTbName, newTbName, fieldReplaceRef);"> 538              replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[0], oldTbName, newTbName, fieldReplacüîµ</abbr>
<abbr title=" 539              replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[1], oldTbName, newTbName, fieldReplaceRef);"> 539              replaceWhereCondition(((SqlBasicCall) parentWhere).getOperands()[1], oldTbName, newTbName, fieldReplacüîµ</abbr>
 540  
 541          } else {
 542              replaceConditionNode(parentWhere, oldTbName, newTbName, fieldReplaceRef);
 543          }
 544      }
 545  
<abbr title=" 546      private static void replaceConditionNode(SqlNode selectNode, String oldTbName, String newTbName, HashBiMap&lt;String, String&gt; fieldReplaceRef) {"> 546      private static void replaceConditionNode(SqlNode selectNode, String oldTbName, String newTbName, HashBiMap&lt;Strüîµ</abbr>
 547          if(selectNode.getKind() == IDENTIFIER){
 548              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 549  
 550              if(sqlIdentifier.names.size() == 1){
 551                  return;
 552              }
 553  
 554              String tableName = sqlIdentifier.names.asList().get(0);
 555              String tableField = sqlIdentifier.names.asList().get(1);
 556              String fieldKey = tableName + &quot;_&quot; + tableField;
 557  
 558              if(tableName.equalsIgnoreCase(oldTbName)){
 559  
<abbr title=" 560                  String newFieldName = fieldReplaceRef.get(fieldKey) == null ? tableField : fieldReplaceRef.get(fieldKey);"> 560                  String newFieldName = fieldReplaceRef.get(fieldKey) == null ? tableField : fieldReplaceRef.get(fieüîµ</abbr>
 561                  SqlIdentifier newField = ((SqlIdentifier)selectNode).setName(0, newTbName);
 562                  newField = newField.setName(1, newFieldName);
 563                  ((SqlIdentifier)selectNode).assignNamesFrom(newField);
 564              }
 565              return;
 566          }else if(selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN){//Â≠óÈù¢Âê´‰πâ
 567              return;
 568          }else if(  AGGREGATE.contains(selectNode.getKind())
 569                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 570                  || COMPARISON.contains(selectNode.getKind())
 571                  || selectNode.getKind() == OTHER_FUNCTION
 572                  || selectNode.getKind() == DIVIDE
 573                  || selectNode.getKind() == CAST
 574                  || selectNode.getKind() == TRIM
 575                  || selectNode.getKind() == TIMES
 576                  || selectNode.getKind() == PLUS
 577                  || selectNode.getKind() == NOT_IN
 578                  || selectNode.getKind() == OR
 579                  || selectNode.getKind() == AND
 580                  || selectNode.getKind() == MINUS
 581                  || selectNode.getKind() == TUMBLE
 582                  || selectNode.getKind() == TUMBLE_START
 583                  || selectNode.getKind() == TUMBLE_END
 584                  || selectNode.getKind() == SESSION
 585                  || selectNode.getKind() == SESSION_START
 586                  || selectNode.getKind() == SESSION_END
 587                  || selectNode.getKind() == HOP
 588                  || selectNode.getKind() == HOP_START
 589                  || selectNode.getKind() == HOP_END
 590                  || selectNode.getKind() == BETWEEN
 591                  || selectNode.getKind() == IS_NULL
 592                  || selectNode.getKind() == IS_NOT_NULL
 593                  || selectNode.getKind() == CONTAINS
 594                  || selectNode.getKind() == TIMESTAMP_ADD
 595                  || selectNode.getKind() == TIMESTAMP_DIFF
 596                  || selectNode.getKind() == LIKE
 597                  || selectNode.getKind() == COALESCE
 598  
 599          ){
 600              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 601              for(int i=0; i&lt;sqlBasicCall.getOperands().length; i++){
 602                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 603                  if(sqlNode instanceof SqlLiteral){
 604                      continue;
 605                  }
 606  
 607                  if(sqlNode instanceof SqlDataTypeSpec){
 608                      continue;
 609                  }
 610  
 611                  replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef);
 612              }
 613  
 614              return;
 615          }else if(selectNode.getKind() == OTHER){
 616              //‰∏çÂ§ÑÁêÜ
 617              return;
 618          } else if (selectNode.getKind() == CASE) {
 619              SqlCase sqlCase = (SqlCase) selectNode;
 620  
<abbr title=" 621              sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef));"> 621              sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbName, newTbNüîµ</abbr>
<abbr title=" 622              sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbName, newTbName, fieldReplaceRef));"> 622              sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; replaceConditionNode(sqlNode, oldTbName, newTbNüîµ</abbr>
 623              replaceConditionNode(sqlCase.getElseOperand(), oldTbName, newTbName, fieldReplaceRef);
 624          } else {
<abbr title=" 625              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 625              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNodüîµ</abbr>
 626          }
 627      }
 628  
 629      /**
 630       * Ëé∑ÂèñÊù°‰ª∂‰∏≠ÂÖ≥ËÅîÁöÑË°®‰ø°ÊÅØ
 631       * @param selectNode
 632       * @param fieldInfos
 633       */
 634      public static void getConditionRefTable(SqlNode selectNode, Set&lt;String&gt; fieldInfos) {
 635          if (selectNode.getKind() == IDENTIFIER) {
 636              SqlIdentifier sqlIdentifier = (SqlIdentifier) selectNode;
 637  
 638              fieldInfos.add(sqlIdentifier.toString());
 639              return;
 640          } else if (selectNode.getKind() == LITERAL || selectNode.getKind() == LITERAL_CHAIN) {//Â≠óÈù¢Âê´‰πâ
 641              return;
 642          } else if (AGGREGATE.contains(selectNode.getKind())
 643                  || AVG_AGG_FUNCTIONS.contains(selectNode.getKind())
 644                  || COMPARISON.contains(selectNode.getKind())
 645                  || selectNode.getKind() == OTHER_FUNCTION
 646                  || selectNode.getKind() == DIVIDE
 647                  || selectNode.getKind() == CAST
 648                  || selectNode.getKind() == TRIM
 649                  || selectNode.getKind() == TIMES
 650                  || selectNode.getKind() == PLUS
 651                  || selectNode.getKind() == NOT_IN
 652                  || selectNode.getKind() == OR
 653                  || selectNode.getKind() == AND
 654                  || selectNode.getKind() == MINUS
 655                  || selectNode.getKind() == TUMBLE
 656                  || selectNode.getKind() == TUMBLE_START
 657                  || selectNode.getKind() == TUMBLE_END
 658                  || selectNode.getKind() == SESSION
 659                  || selectNode.getKind() == SESSION_START
 660                  || selectNode.getKind() == SESSION_END
 661                  || selectNode.getKind() == HOP
 662                  || selectNode.getKind() == HOP_START
 663                  || selectNode.getKind() == HOP_END
 664                  || selectNode.getKind() == BETWEEN
 665                  || selectNode.getKind() == IS_NULL
 666                  || selectNode.getKind() == IS_NOT_NULL
 667                  || selectNode.getKind() == CONTAINS
 668                  || selectNode.getKind() == TIMESTAMP_ADD
 669                  || selectNode.getKind() == TIMESTAMP_DIFF
 670                  || selectNode.getKind() == LIKE
 671                  || selectNode.getKind() == COALESCE
 672  
 673                  ) {
 674              SqlBasicCall sqlBasicCall = (SqlBasicCall) selectNode;
 675              for (int i = 0; i &lt; sqlBasicCall.getOperands().length; i++) {
 676                  SqlNode sqlNode = sqlBasicCall.getOperands()[i];
 677                  if (sqlNode instanceof SqlLiteral) {
 678                      continue;
 679                  }
 680  
 681                  if (sqlNode instanceof SqlDataTypeSpec) {
 682                      continue;
 683                  }
 684  
 685                  getConditionRefTable(sqlNode, fieldInfos);
 686              }
 687  
 688              return;
 689          } else if (selectNode.getKind() == OTHER) {
 690              //‰∏çÂ§ÑÁêÜ
 691              return;
 692          } else if (selectNode.getKind() == CASE) {
 693              SqlCase sqlCase = (SqlCase) selectNode;
 694  
 695              sqlCase.getWhenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfos));
 696              sqlCase.getThenOperands().getList().forEach(sqlNode -&gt; getConditionRefTable(sqlNode, fieldInfos));
 697              getConditionRefTable(sqlCase.getElseOperand(), fieldInfos);
 698          } else {
<abbr title=" 699              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNode.getKind()));"> 699              throw new RuntimeException(String.format(&quot;not support node kind of %s to replace name now.&quot;, selectNodüîµ</abbr>
 700          }
 701      }
 702  
 703      public static String buildTableField(String tableName, String fieldName){
 704          return String.format(&quot;%s.%s&quot;, tableName, fieldName);
 705      }
 706  
 707  
 708      public static String buildTableNameWithScope(String tableName, String scope){
 709          if(StringUtils.isEmpty(scope)){
 710              return tableName;
 711          }
 712  
 713          return tableName + &quot;_&quot; + scope;
 714      }
 715  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 716 +    public static String buildTableNameWithScope(String leftTableName, String leftTableAlias, String rightTableName, String scope, Set&lt;String&gt; existTableNames){"> 716 +    public static String buildTableNameWithScope(String leftTableName, String leftTableAlias, String rightTableNamüîµ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 717 +        //ÂÖºÂÆπÂ∑¶ËæπË°®ÊòØas ÁöÑÊÉÖÂÜµ</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 718 +        String leftStr = Strings.isNullOrEmpty(leftTableName) ? leftTableAlias : leftTableName;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 719 +        String newName = leftStr + &quot;_&quot; + rightTableName;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 720 +        if (CollectionUtils.isEmpty(existTableNames)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 721 +            return TableUtils.buildTableNameWithScope(newName, scope);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 722 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 723 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 724 +        if (!existTableNames.contains(newName)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 725 +            return TableUtils.buildTableNameWithScope(newName, scope);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 726 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 727 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 728 +        return TableUtils.buildTableNameWithScope(newName, scope) + &quot;_&quot; + System.currentTimeMillis();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 729 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 730 +</span>




 731  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            