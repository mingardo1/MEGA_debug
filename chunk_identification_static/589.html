<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>589</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    589
                    <a href="588.html">prev</a>
                    <a href="590.html">next</a>
                    <a href="589_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_3f89d1e66187447b56be7b8b76e9b09af9b9850d_core/src/main/java/com/dtstack/flink/sql/exec/FlinkSQLExec.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;3f89d1e66187447b56be7b8b76e9b09af9b9850d:core/src/main/java/com/dtstack/flink/sql/exec/FlinkSQLExec.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;3f89d1e66187447b56be7b8b76e9b09af9b9850d^1:core/src/main/java/com/dtstack/flink/sql/exec/FlinkSQLExec.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;3f89d1e66187447b56be7b8b76e9b09af9b9850d^2:core/src/main/java/com/dtstack/flink/sql/exec/FlinkSQLExec.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;b2e4085e6d35798d51707eb23aa215e0e694591e:core/src/main/java/com/dtstack/flink/sql/exec/FlinkSQLExec.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  * http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.exec;
  20 
  21 import org.apache.calcite.sql.SqlIdentifier;
  22 import org.apache.calcite.sql.SqlInsert;
  23 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  24 import org.apache.flink.sql.parser.dml.RichSqlInsert;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  25 import org.apache.flink.table.api.Table;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  26 import org.apache.flink.table.api.ValidationException;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  27 import org.apache.flink.table.api.internal.TableEnvironmentImpl;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  28 import org.apache.flink.table.api.internal.TableImpl;</span>
  29 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  30 import org.apache.calcite.sql.SqlNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  31 import org.apache.flink.table.api.*;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  32 import org.apache.flink.table.api.java.StreamTableEnvironment;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  33 import org.apache.flink.table.calcite.FlinkPlannerImpl;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  34 import org.apache.flink.table.plan.logical.LogicalRelNode;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  35 import org.apache.flink.table.plan.schema.TableSinkTable;</span>
  36 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  37 import org.apache.calcite.sql.SqlNode;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  38 import org.apache.flink.table.api.StreamQueryConfig;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  39 import org.apache.flink.table.api.Table;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  40 import org.apache.flink.table.api.TableEnvironment;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  41 import org.apache.flink.table.api.TableException;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  42 import org.apache.flink.table.api.ValidationException;</span>
  43 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  44 import org.apache.flink.table.api.java.StreamTableEnvironment;
  45 import org.apache.flink.table.api.java.internal.StreamTableEnvironmentImpl;
  46 import org.apache.flink.table.operations.QueryOperation;
  47 import org.apache.flink.table.planner.calcite.FlinkPlannerImpl;
  48 import org.apache.flink.table.planner.delegation.PlannerBase;
  49 import org.apache.flink.table.planner.delegation.StreamPlanner;
  50 import org.apache.flink.table.planner.operations.PlannerQueryOperation;
  51 import org.apache.flink.table.planner.operations.SqlToOperationConverter;
  52 import org.apache.flink.table.sinks.TableSink;
  53 import org.slf4j.Logger;
  54 import org.slf4j.LoggerFactory;
  55 import scala.Option;
  56 
  57 import java.lang.reflect.InvocationTargetException;
  58 import java.lang.reflect.Method;
  59 import java.util.Arrays;
  60 import java.util.List;
  61 
  62 
  63 /**
  64  * @description:  mapping by name when insert into sink table
  65  * @author: maqi
  66  * @create: 2019/08/15 11:09
  67  */
  68 public class FlinkSQLExec {
  69     private static final Logger LOG = LoggerFactory.getLogger(FlinkSQLExec.class);
  70     public static void sqlUpdate(StreamTableEnvironment tableEnv, String stmt) throws Exception {
  71         StreamTableEnvironmentImpl tableEnvImpl = ((StreamTableEnvironmentImpl) tableEnv);
  72         StreamPlanner streamPlanner = (StreamPlanner)tableEnvImpl.getPlanner();
  73         FlinkPlannerImpl flinkPlanner = streamPlanner.createFlinkPlanner();
  74 
  75         RichSqlInsert insert = (RichSqlInsert)flinkPlanner.parse(stmt);
  76         TableImpl queryResult = extractQueryTableFromInsertCaluse(tableEnvImpl, flinkPlanner, insert);
  77 
  78         String targetTableName = ((SqlIdentifier) ((SqlInsert) insert).getTargetTable()).names.get(0);
  79         TableSink tableSink = getTableSinkByPlanner(streamPlanner, targetTableName);
  80 
  81         String[] sinkFieldNames = tableSink.getTableSchema().getFieldNames();
  82         String[] queryFieldNames = queryResult.getSchema().getFieldNames();
  83 
  84         if (sinkFieldNames.length != queryFieldNames.length) {
  85             throw new ValidationException(
<abbr title="  86                     &quot;Field name of query result and registered TableSink &quot; + targetTableName + &quot; do not match.\n&quot; +">  86                     &quot;Field name of query result and registered TableSink &quot; + targetTableName + &quot; do not mðŸ”µ</abbr>
  87                             &quot;Query result schema: &quot; + String.join(&quot;,&quot;, queryFieldNames) + &quot;\n&quot; +
  88                             &quot;TableSink schema: &quot; + String.join(&quot;,&quot;, sinkFieldNames));
  89         }
  90 
  91 
  92         Table newTable = null;
  93         try {
  94             newTable = queryResult.select(String.join(&quot;,&quot;, sinkFieldNames));
  95         } catch (Exception e) {
  96             throw new ValidationException(
<abbr title="  97                     &quot;Field name of query result and registered TableSink &quot;+targetTableName +&quot; do not match.\n&quot; +">  97                     &quot;Field name of query result and registered TableSink &quot;+targetTableName +&quot; do not matcðŸ”µ</abbr>
  98                     &quot;Query result schema: &quot; + String.join(&quot;,&quot;, queryFieldNames) + &quot;\n&quot; +
  99                     &quot;TableSink schema: &quot; + String.join(&quot;,&quot;, sinkFieldNames));
 100         }
 101 
 102         try {
 103             tableEnv.insertInto(newTable, targetTableName);
 104         } catch (Exception e) {
 105             LOG.warn(&quot;Field name case of query result and registered TableSink do not match. &quot;, e);
 106             newTable = queryResult.select(String.join(&quot;,&quot;, ignoreCase(queryFieldNames, sinkFieldNames)));
 107             tableEnv.insertInto(newTable, targetTableName);
 108         }
 109 
 110     }
 111 
 112     private static TableSink getTableSinkByPlanner(StreamPlanner streamPlanner, String targetTableName)
 113             throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
 114         Method getTableSink = PlannerBase.class.getDeclaredMethod(&quot;getTableSink&quot;, List.class);
 115         getTableSink.setAccessible(true);
<abbr title=" 116         Option tableSinkOption = (Option) getTableSink.invoke(streamPlanner, Arrays.asList(targetTableName));"> 116         Option tableSinkOption = (Option) getTableSink.invoke(streamPlanner, Arrays.asList(targetTableNamðŸ”µ</abbr>
 117         return (TableSink) tableSinkOption.get();
 118     }
 119 
<abbr title=" 120     private static TableImpl extractQueryTableFromInsertCaluse(StreamTableEnvironmentImpl tableEnvImpl, FlinkPlannerImpl flinkPlanner, RichSqlInsert insert)"> 120     private static TableImpl extractQueryTableFromInsertCaluse(StreamTableEnvironmentImpl tableEnvImpl, FðŸ”µ</abbr>
 121             throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
 122 
<abbr title=" 123         PlannerQueryOperation queryOperation = (PlannerQueryOperation) SqlToOperationConverter.convert(flinkPlanner,"> 123         PlannerQueryOperation queryOperation = (PlannerQueryOperation) SqlToOperationConverter.convert(flðŸ”µ</abbr>
 124                 insert.getSource());
<abbr title=" 125         Method createTableMethod = TableEnvironmentImpl.class.getDeclaredMethod(&quot;createTable&quot;, QueryOperation.class);"> 125         Method createTableMethod = TableEnvironmentImpl.class.getDeclaredMethod(&quot;createTable&quot;, QueryOperaðŸ”µ</abbr>
 126         createTableMethod.setAccessible(true);
 127         return (TableImpl) createTableMethod.invoke(tableEnvImpl, queryOperation);
 128     }
 129 
 130     private static String[] ignoreCase(String[] queryFieldNames, String[] sinkFieldNames) {
 131         String[] newFieldNames = sinkFieldNames;
 132         for (int i = 0; i &lt; newFieldNames.length; i++) {
 133             for (String queryFieldName : queryFieldNames) {
 134                 if (newFieldNames[i].equalsIgnoreCase(queryFieldName)) {
 135                     newFieldNames[i] = queryFieldName;
 136                     break;
 137                 }
 138             }
 139         }
 140         return newFieldNames;
 141     }
 142 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  * http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.exec;
  20 
  21 import org.apache.calcite.sql.SqlIdentifier;
  22 import org.apache.calcite.sql.SqlInsert;
  23 import org.apache.flink.sql.parser.dml.RichSqlInsert;
  24 import org.apache.flink.table.api.StreamQueryConfig;
  25 import org.apache.flink.table.api.Table;
  26 import org.apache.flink.table.api.TableEnvironment;
  27 import org.apache.flink.table.api.TableException;
  28 import org.apache.flink.table.api.ValidationException;
  29 import org.apache.flink.table.api.internal.TableEnvironmentImpl;
  30 import org.apache.flink.table.api.internal.TableImpl;
  31 import org.apache.flink.table.api.java.StreamTableEnvironment;
  32 import org.apache.flink.table.api.java.internal.StreamTableEnvironmentImpl;
  33 import org.apache.flink.table.operations.QueryOperation;
  34 import org.apache.flink.table.planner.calcite.FlinkPlannerImpl;
  35 import org.apache.flink.table.planner.delegation.PlannerBase;
  36 import org.apache.flink.table.planner.delegation.StreamPlanner;
  37 import org.apache.flink.table.planner.operations.PlannerQueryOperation;
  38 import org.apache.flink.table.planner.operations.SqlToOperationConverter;
  39 import org.apache.flink.table.sinks.TableSink;
  40 import org.slf4j.Logger;
  41 import org.slf4j.LoggerFactory;
  42 import scala.Option;
  43 
  44 import java.lang.reflect.InvocationTargetException;
  45 import java.lang.reflect.Method;
  46 import java.util.Arrays;
  47 import java.util.List;
  48 
  49 
  50 /**
  51  * @description:  mapping by name when insert into sink table
  52  * @author: maqi
  53  * @create: 2019/08/15 11:09
  54  */
  55 public class FlinkSQLExec {
  56     private static final Logger LOG = LoggerFactory.getLogger(FlinkSQLExec.class);
  57     public static void sqlUpdate(StreamTableEnvironment tableEnv, String stmt) throws Exception {
  58         StreamTableEnvironmentImpl tableEnvImpl = ((StreamTableEnvironmentImpl) tableEnv);
  59         StreamPlanner streamPlanner = (StreamPlanner)tableEnvImpl.getPlanner();
  60         FlinkPlannerImpl flinkPlanner = streamPlanner.createFlinkPlanner();
  61 
  62         RichSqlInsert insert = (RichSqlInsert)flinkPlanner.parse(stmt);
  63         TableImpl queryResult = extractQueryTableFromInsertCaluse(tableEnvImpl, flinkPlanner, insert);
  64 
  65         String targetTableName = ((SqlIdentifier) ((SqlInsert) insert).getTargetTable()).names.get(0);
  66         TableSink tableSink = getTableSinkByPlanner(streamPlanner, targetTableName);
  67 
  68         String[] sinkFieldNames = tableSink.getTableSchema().getFieldNames();
  69         String[] queryFieldNames = queryResult.getSchema().getFieldNames();
  70 
  71         if (sinkFieldNames.length != queryFieldNames.length) {
  72             throw new ValidationException(
<abbr title="  73                     &quot;Field name of query result and registered TableSink &quot; + targetTableName + &quot; do not match.\n&quot; +">  73                     &quot;Field name of query result and registered TableSink &quot; + targetTableName + &quot; do not mðŸ”µ</abbr>
  74                             &quot;Query result schema: &quot; + String.join(&quot;,&quot;, queryFieldNames) + &quot;\n&quot; +
  75                             &quot;TableSink schema: &quot; + String.join(&quot;,&quot;, sinkFieldNames));
  76         }
  77 
  78 
  79         Table newTable = null;
  80         try {
  81             newTable = queryResult.select(String.join(&quot;,&quot;, sinkFieldNames));
  82         } catch (Exception e) {
  83             throw new ValidationException(
<abbr title="  84                     &quot;Field name of query result and registered TableSink &quot;+targetTableName +&quot; do not match.\n&quot; +">  84                     &quot;Field name of query result and registered TableSink &quot;+targetTableName +&quot; do not matcðŸ”µ</abbr>
  85                     &quot;Query result schema: &quot; + String.join(&quot;,&quot;, queryFieldNames) + &quot;\n&quot; +
  86                     &quot;TableSink schema: &quot; + String.join(&quot;,&quot;, sinkFieldNames));
  87         }
  88 
  89         try {
  90             tableEnv.insertInto(newTable, targetTableName);
  91         } catch (Exception e) {
  92             LOG.warn(&quot;Field name case of query result and registered TableSink do not match. &quot;, e);
  93             newTable = queryResult.select(String.join(&quot;,&quot;, ignoreCase(queryFieldNames, sinkFieldNames)));
  94             tableEnv.insertInto(newTable, targetTableName);
  95         }
  96 
  97     }
  98 
  99     private static TableSink getTableSinkByPlanner(StreamPlanner streamPlanner, String targetTableName)
 100             throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
 101         Method getTableSink = PlannerBase.class.getDeclaredMethod(&quot;getTableSink&quot;, List.class);
 102         getTableSink.setAccessible(true);
<abbr title=" 103         Option tableSinkOption = (Option) getTableSink.invoke(streamPlanner, Arrays.asList(targetTableName));"> 103         Option tableSinkOption = (Option) getTableSink.invoke(streamPlanner, Arrays.asList(targetTableNamðŸ”µ</abbr>
 104         return (TableSink) tableSinkOption.get();
 105     }
 106 
<abbr title=" 107     private static TableImpl extractQueryTableFromInsertCaluse(StreamTableEnvironmentImpl tableEnvImpl, FlinkPlannerImpl flinkPlanner, RichSqlInsert insert)"> 107     private static TableImpl extractQueryTableFromInsertCaluse(StreamTableEnvironmentImpl tableEnvImpl, FðŸ”µ</abbr>
 108             throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
 109 
<abbr title=" 110         PlannerQueryOperation queryOperation = (PlannerQueryOperation) SqlToOperationConverter.convert(flinkPlanner,"> 110         PlannerQueryOperation queryOperation = (PlannerQueryOperation) SqlToOperationConverter.convert(flðŸ”µ</abbr>
 111                 insert.getSource());
<abbr title=" 112         Method createTableMethod = TableEnvironmentImpl.class.getDeclaredMethod(&quot;createTable&quot;, QueryOperation.class);"> 112         Method createTableMethod = TableEnvironmentImpl.class.getDeclaredMethod(&quot;createTable&quot;, QueryOperaðŸ”µ</abbr>
 113         createTableMethod.setAccessible(true);
 114         return (TableImpl) createTableMethod.invoke(tableEnvImpl, queryOperation);
 115     }
 116 
 117     private static String[] ignoreCase(String[] queryFieldNames, String[] sinkFieldNames) {
 118         String[] newFieldNames = sinkFieldNames;
 119         for (int i = 0; i &lt; newFieldNames.length; i++) {
 120             for (String queryFieldName : queryFieldNames) {
 121                 if (newFieldNames[i].equalsIgnoreCase(queryFieldName)) {
 122                     newFieldNames[i] = queryFieldName;
 123                     break;
 124                 }
 125             }
 126         }
 127         return newFieldNames;
 128     }
 129 }
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  * http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.exec;
  19 
  20 import java.lang.reflect.InvocationTargetException;
  21 import java.lang.reflect.Method;
  22 import java.util.Arrays;
  23 import java.util.List;
  24 import org.apache.calcite.sql.SqlIdentifier;
  25 import org.apache.calcite.sql.SqlInsert;
  26 import org.apache.flink.sql.parser.dml.RichSqlInsert;
  27 import org.apache.flink.table.api.StreamQueryConfig;
  28 import org.apache.flink.table.api.Table;
  29 import org.apache.flink.table.api.TableEnvironment;
  30 import org.apache.flink.table.api.TableException;
  31 import org.apache.flink.table.api.ValidationException;
  32 import org.apache.flink.table.api.internal.TableEnvironmentImpl;
  33 import org.apache.flink.table.api.internal.TableImpl;
  34 import org.apache.flink.table.api.java.StreamTableEnvironment;
  35 import org.apache.flink.table.api.java.internal.StreamTableEnvironmentImpl;
  36 import org.apache.flink.table.operations.QueryOperation;
  37 import org.apache.flink.table.planner.calcite.FlinkPlannerImpl;
  38 import org.apache.flink.table.planner.delegation.PlannerBase;
  39 import org.apache.flink.table.planner.delegation.StreamPlanner;
  40 import org.apache.flink.table.planner.operations.PlannerQueryOperation;
  41 import org.apache.flink.table.planner.operations.SqlToOperationConverter;
  42 import org.apache.flink.table.sinks.TableSink;
  43 import org.slf4j.Logger;
  44 import org.slf4j.LoggerFactory;
  45 import scala.Option;
  46 
  47 
  48 /**
  49  * @description:  mapping by name when insert into sink table
  50  * @author: maqi
  51  * @create: 2019/08/15 11:09
  52  */
  53 public class FlinkSQLExec {
  54     private static final Logger LOG = LoggerFactory.getLogger(FlinkSQLExec.class);
  55 
  56     public static void sqlUpdate(StreamTableEnvironment tableEnv, String stmt) throws Exception {
  57         StreamTableEnvironmentImpl tableEnvImpl = ((StreamTableEnvironmentImpl) (tableEnv));
  58         StreamPlanner streamPlanner = ((StreamPlanner) (tableEnvImpl.getPlanner()));
  59         FlinkPlannerImpl flinkPlanner = streamPlanner.createFlinkPlanner();
  60         RichSqlInsert insert = ((RichSqlInsert) (flinkPlanner.parse(stmt)));
  61         TableImpl queryResult = extractQueryTableFromInsertCaluse(tableEnvImpl, flinkPlanner, insert);
<abbr title="  62         String targetTableName = ((SqlIdentifier) (((SqlInsert) (insert)).getTargetTable())).names.get(0);">  62         String targetTableName = ((SqlIdentifier) (((SqlInsert) (insert)).getTargetTable())).names.get(0)ðŸ”µ</abbr>
  63         TableSink tableSink = getTableSinkByPlanner(streamPlanner, targetTableName);
  64         String[] sinkFieldNames = tableSink.getTableSchema().getFieldNames();
  65         String[] queryFieldNames = queryResult.getSchema().getFieldNames();
  66         if (sinkFieldNames.length != queryFieldNames.length) {
<abbr title="  67             throw new ValidationException(((((((&quot;Field name of query result and registered TableSink &quot; + targetTableName) + &quot; do not match.\n&quot;) + &quot;Query result schema: &quot;) + String.join(&quot;,&quot;, queryFieldNames)) + &quot;\n&quot;) + &quot;TableSink schema: &quot;) + String.join(&quot;,&quot;, sinkFieldNames));">  67             throw new ValidationException(((((((&quot;Field name of query result and registered TableSink &quot; + ðŸ”µ</abbr>
  68         }
  69         Table newTable = null;
  70         try {
  71             newTable = queryResult.select(String.join(&quot;,&quot;, sinkFieldNames));
  72         } catch (java.lang.Exception e) {
<abbr title="  73             throw new ValidationException(((((((&quot;Field name of query result and registered TableSink &quot; + targetTableName) + &quot; do not match.\n&quot;) + &quot;Query result schema: &quot;) + String.join(&quot;,&quot;, queryFieldNames)) + &quot;\n&quot;) + &quot;TableSink schema: &quot;) + String.join(&quot;,&quot;, sinkFieldNames));">  73             throw new ValidationException(((((((&quot;Field name of query result and registered TableSink &quot; + ðŸ”µ</abbr>
  74         }
  75         try {
  76             tableEnv.insertInto(newTable, targetTableName);
  77         } catch (java.lang.Exception e) {
  78             LOG.warn(&quot;Field name case of query result and registered TableSink do not match. &quot;, e);
  79             newTable = queryResult.select(String.join(&quot;,&quot;, ignoreCase(queryFieldNames, sinkFieldNames)));
  80             tableEnv.insertInto(newTable, targetTableName);
  81         }
  82     }
  83 
  84     private static TableSink getTableSinkByPlanner(StreamPlanner streamPlanner, String targetTableName)
  85             throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {
  86         Method getTableSink = PlannerBase.class.getDeclaredMethod(&quot;getTableSink&quot;, List.class);
  87         getTableSink.setAccessible(true);
<abbr title="  88         Option tableSinkOption = (Option) getTableSink.invoke(streamPlanner, Arrays.asList(targetTableName));">  88         Option tableSinkOption = (Option) getTableSink.invoke(streamPlanner, Arrays.asList(targetTableNamðŸ”µ</abbr>
  89         return (TableSink) tableSinkOption.get();
  90     }
  91 
<abbr title="  92     private static TableImpl extractQueryTableFromInsertCaluse(StreamTableEnvironmentImpl tableEnvImpl, FlinkPlannerImpl flinkPlanner, RichSqlInsert insert) throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {">  92     private static TableImpl extractQueryTableFromInsertCaluse(StreamTableEnvironmentImpl tableEnvImpl, FðŸ”µ</abbr>
<abbr title="  93         PlannerQueryOperation queryOperation = ((PlannerQueryOperation) (SqlToOperationConverter.convert(flinkPlanner, insert.getSource())));">  93         PlannerQueryOperation queryOperation = ((PlannerQueryOperation) (SqlToOperationConverter.convert(ðŸ”µ</abbr>
<abbr title="  94         Method createTableMethod = TableEnvironmentImpl.class.getDeclaredMethod(&quot;createTable&quot;, QueryOperation.class);">  94         Method createTableMethod = TableEnvironmentImpl.class.getDeclaredMethod(&quot;createTable&quot;, QueryOperaðŸ”µ</abbr>
  95         createTableMethod.setAccessible(true);
  96         return ((TableImpl) (createTableMethod.invoke(tableEnvImpl, queryOperation)));
  97     }
  98 
  99     private static String[] ignoreCase(String[] queryFieldNames, String[] sinkFieldNames) {
 100         String[] newFieldNames = sinkFieldNames;
 101         for (int i = 0; i &lt; newFieldNames.length; i++) {
 102             for (String queryFieldName : queryFieldNames) {
 103                 if (newFieldNames[i].equalsIgnoreCase(queryFieldName)) {
 104                     newFieldNames[i] = queryFieldName;
 105                     break;
 106                 }
 107             }
 108         }
 109         return newFieldNames;
 110     }
 111 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   * http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.exec;
  20  
  21  import org.apache.calcite.sql.SqlIdentifier;
  22  import org.apache.calcite.sql.SqlInsert;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 -import org.apache.calcite.sql.SqlNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  24 -import org.apache.flink.table.api.*;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import org.apache.flink.sql.parser.dml.RichSqlInsert;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +import org.apache.flink.table.api.Table;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import org.apache.flink.table.api.ValidationException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import org.apache.flink.table.api.internal.TableEnvironmentImpl;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import org.apache.flink.table.api.internal.TableImpl;</span>
  30  import org.apache.flink.table.api.java.StreamTableEnvironment;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  31 -import org.apache.flink.table.calcite.FlinkPlannerImpl;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -import org.apache.flink.table.plan.logical.LogicalRelNode;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 -import org.apache.flink.table.plan.schema.TableSinkTable;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 -import org.apache.flink.table.plan.schema.TableSourceSinkTable;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import org.apache.flink.table.api.java.internal.StreamTableEnvironmentImpl;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +import org.apache.flink.table.operations.QueryOperation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  37 +import org.apache.flink.table.planner.calcite.FlinkPlannerImpl;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  38 +import org.apache.flink.table.planner.delegation.PlannerBase;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  39 +import org.apache.flink.table.planner.delegation.StreamPlanner;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  40 +import org.apache.flink.table.planner.operations.PlannerQueryOperation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  41 +import org.apache.flink.table.planner.operations.SqlToOperationConverter;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  42 +import org.apache.flink.table.sinks.TableSink;</span>
  43  import org.slf4j.Logger;
  44  import org.slf4j.LoggerFactory;
  45  import scala.Option;
  46  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  47 +import java.lang.reflect.InvocationTargetException;</span>
  48  import java.lang.reflect.Method;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  49 +import java.util.Arrays;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  50 +import java.util.List;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  51 +</span>
  52  
  53  /**
  54   * @description:  mapping by name when insert into sink table
  55   * @author: maqi
  56   * @create: 2019/08/15 11:09
  57   */
  58  public class FlinkSQLExec {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +    private static final Logger LOG = LoggerFactory.getLogger(FlinkSQLExec.class);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +    public static void sqlUpdate(StreamTableEnvironment tableEnv, String stmt) throws Exception {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +        StreamTableEnvironmentImpl tableEnvImpl = ((StreamTableEnvironmentImpl) tableEnv);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +        StreamPlanner streamPlanner = (StreamPlanner)tableEnvImpl.getPlanner();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +        FlinkPlannerImpl flinkPlanner = streamPlanner.createFlinkPlanner();</span>
  64  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  65 -    private static final Logger LOG = LoggerFactory.getLogger(FlinkSQLExec.class);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  66 +        RichSqlInsert insert = (RichSqlInsert)flinkPlanner.parse(stmt);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  67 +        TableImpl queryResult = extractQueryTableFromInsertCaluse(tableEnvImpl, flinkPlanner, insert);</span>
  68  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  69 -    public static void sqlUpdate(StreamTableEnvironment tableEnv, String stmt, StreamQueryConfig queryConfig) throws Exception {">  69 -    public static void sqlUpdate(StreamTableEnvironment tableEnv, String stmt, StreamQueryConfig queryConfig) throðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  70 +        String targetTableName = ((SqlIdentifier) ((SqlInsert) insert).getTargetTable()).names.get(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  71 +        TableSink tableSink = getTableSinkByPlanner(streamPlanner, targetTableName);</span>
  72  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  73 -        FlinkPlannerImpl planner = new FlinkPlannerImpl(tableEnv.getFrameworkConfig(), tableEnv.getPlanner(), tableEnv.getTypeFactory());">  73 -        FlinkPlannerImpl planner = new FlinkPlannerImpl(tableEnv.getFrameworkConfig(), tableEnv.getPlanner(), tablðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  74 -        SqlNode insert = planner.parse(stmt);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  75 +        String[] sinkFieldNames = tableSink.getTableSchema().getFieldNames();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  76 +        String[] queryFieldNames = queryResult.getSchema().getFieldNames();</span>
  77  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  78 -        if (!(insert instanceof SqlInsert)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  79 -            throw new TableException(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  80 -                    &quot;Unsupported SQL query! sqlUpdate() only accepts SQL statements of type INSERT.&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  81 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  82 -        SqlNode query = ((SqlInsert) insert).getSource();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  83 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  84 -        SqlNode validatedQuery = planner.validate(query);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  85 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  86 -        Table queryResult = new Table(tableEnv, new LogicalRelNode(planner.rel(validatedQuery).rel));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  87 -        String targetTableName = ((SqlIdentifier) ((SqlInsert) insert).getTargetTable()).names.get(0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  88 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  89 -        Method method = TableEnvironment.class.getDeclaredMethod(&quot;getTable&quot;, String.class);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  90 -        method.setAccessible(true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  91 -        Option sinkTab = (Option)method.invoke(tableEnv, targetTableName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  92 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  93 -        if (sinkTab.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  94 -            throw  new ValidationException(&quot;Sink table &quot; + targetTableName + &quot;not found in flink&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  95 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  96 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  97 -        TableSourceSinkTable targetTable = (TableSourceSinkTable) sinkTab.get();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  98 -        TableSinkTable tableSinkTable = (TableSinkTable)targetTable.tableSinkTable().get();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  99 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 100 -        StreamQueryConfig config = null == queryConfig ? tableEnv.queryConfig() : queryConfig;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 101 -        String[] sinkFieldNames = tableSinkTable.tableSink().getFieldNames();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -        String[] queryFieldNames = queryResult.getSchema().getColumnNames();</span>
 103          if (sinkFieldNames.length != queryFieldNames.length) {
 104              throw new ValidationException(
<abbr title=" 105                      &quot;Field name of query result and registered TableSink &quot; + targetTableName + &quot; do not match.\n&quot; +"> 105                      &quot;Field name of query result and registered TableSink &quot; + targetTableName + &quot; do not match.\n&quot; ðŸ”µ</abbr>
 106                              &quot;Query result schema: &quot; + String.join(&quot;,&quot;, queryFieldNames) + &quot;\n&quot; +
 107                              &quot;TableSink schema: &quot; + String.join(&quot;,&quot;, sinkFieldNames));
 108          }
 109  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +</span>
 111          Table newTable = null;
 112          try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 113 -            // sinkFieldNames not in queryResult error</span>
 114              newTable = queryResult.select(String.join(&quot;,&quot;, sinkFieldNames));
 115          } catch (Exception e) {
 116              throw new ValidationException(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 117 -                    &quot;Field name of query result and registered TableSink &quot; + targetTableName + &quot; do not match.\n&quot; +"> 117 -                    &quot;Field name of query result and registered TableSink &quot; + targetTableName + &quot; do not match.\n&quot; ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 118 -                            &quot;Query result schema: &quot; + String.join(&quot;,&quot;, queryResult.getSchema().getColumnNames()) + &quot;\n&quot; +"> 118 -                            &quot;Query result schema: &quot; + String.join(&quot;,&quot;, queryResult.getSchema().getColumnNames()) +ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 119 -                            &quot;TableSink schema: &quot; + String.join(&quot;,&quot;, sinkFieldNames));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +                    &quot;Field name of query result and registered TableSink &quot;+targetTableName +&quot; do not match.\n&quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +                    &quot;Query result schema: &quot; + String.join(&quot;,&quot;, queryFieldNames) + &quot;\n&quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 122 +                    &quot;TableSink schema: &quot; + String.join(&quot;,&quot;, sinkFieldNames));</span>
 123          }
 124  
 125          try {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 126 -            tableEnv.insertInto(newTable, targetTableName, config);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 127 -        } catch (Exception ex) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 128 -            LOG.warn(&quot;Field name case of query result and registered TableSink &quot; + targetTableName + &quot;do not match. &quot; + ex.getMessage());"> 128 -            LOG.warn(&quot;Field name case of query result and registered TableSink &quot; + targetTableName + &quot;do not matchðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 129 +            tableEnv.insertInto(newTable, targetTableName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 130 +        } catch (Exception e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +            LOG.warn(&quot;Field name case of query result and registered TableSink do not match. &quot;, e);</span>
 132              newTable = queryResult.select(String.join(&quot;,&quot;, ignoreCase(queryFieldNames, sinkFieldNames)));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 133 -            tableEnv.insertInto(newTable, targetTableName, config);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 134 +            tableEnv.insertInto(newTable, targetTableName);</span>
 135          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 136 +</span>
 137      }
 138  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -    public static String[] ignoreCase(String[] queryFieldNames, String[] sinkFieldNames) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 140 +    private static TableSink getTableSinkByPlanner(StreamPlanner streamPlanner, String targetTableName)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 141 +            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 142 +        Method getTableSink = PlannerBase.class.getDeclaredMethod(&quot;getTableSink&quot;, List.class);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +        getTableSink.setAccessible(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 144 +        Option tableSinkOption = (Option) getTableSink.invoke(streamPlanner, Arrays.asList(targetTableName));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 145 +        return (TableSink) tableSinkOption.get();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 146 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 148 +    private static TableImpl extractQueryTableFromInsertCaluse(StreamTableEnvironmentImpl tableEnvImpl, FlinkPlannerImpl flinkPlanner, RichSqlInsert insert)"> 148 +    private static TableImpl extractQueryTableFromInsertCaluse(StreamTableEnvironmentImpl tableEnvImpl, FlinkPlannðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +            throws NoSuchMethodException, IllegalAccessException, InvocationTargetException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 151 +        PlannerQueryOperation queryOperation = (PlannerQueryOperation) SqlToOperationConverter.convert(flinkPlanner,"> 151 +        PlannerQueryOperation queryOperation = (PlannerQueryOperation) SqlToOperationConverter.convert(flinkPlanneðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +                insert.getSource());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 153 +        Method createTableMethod = TableEnvironmentImpl.class.getDeclaredMethod(&quot;createTable&quot;, QueryOperation.class);"> 153 +        Method createTableMethod = TableEnvironmentImpl.class.getDeclaredMethod(&quot;createTable&quot;, QueryOperation.clasðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +        createTableMethod.setAccessible(true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 155 +        return (TableImpl) createTableMethod.invoke(tableEnvImpl, queryOperation);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 156 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 157 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 158 +    private static String[] ignoreCase(String[] queryFieldNames, String[] sinkFieldNames) {</span>
 159          String[] newFieldNames = sinkFieldNames;
 160          for (int i = 0; i &lt; newFieldNames.length; i++) {
 161              for (String queryFieldName : queryFieldNames) {
 162                  if (newFieldNames[i].equalsIgnoreCase(queryFieldName)) {
 163                      newFieldNames[i] = queryFieldName;
 164                      break;
 165                  }
 166              }
 167          }
 168          return newFieldNames;
 169      }
 170  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   * http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  package com.dtstack.flink.sql.exec;
  20  
  21  import org.apache.calcite.sql.SqlIdentifier;
  22  import org.apache.calcite.sql.SqlInsert;
  23  import org.apache.calcite.sql.SqlNode;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  24 -import org.apache.flink.table.api.*;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import org.apache.flink.table.api.StreamQueryConfig;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +import org.apache.flink.table.api.Table;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import org.apache.flink.table.api.TableEnvironment;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import org.apache.flink.table.api.TableException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import org.apache.flink.table.api.ValidationException;</span>
  30  import org.apache.flink.table.api.java.StreamTableEnvironment;
  31  import org.apache.flink.table.calcite.FlinkPlannerImpl;
  32  import org.apache.flink.table.plan.logical.LogicalRelNode;
  33  import org.apache.flink.table.plan.schema.TableSinkTable;
  34  import org.apache.flink.table.plan.schema.TableSourceSinkTable;








  35  import org.slf4j.Logger;
  36  import org.slf4j.LoggerFactory;
  37  import scala.Option;
  38  

  39  import java.lang.reflect.Method;



  40  
  41  /**
  42   * @description:  mapping by name when insert into sink table
  43   * @author: maqi
  44   * @create: 2019/08/15 11:09
  45   */
  46  public class FlinkSQLExec {





  47  
  48      private static final Logger LOG = LoggerFactory.getLogger(FlinkSQLExec.class);


  49  
<abbr title="  50      public static void sqlUpdate(StreamTableEnvironment tableEnv, String stmt, StreamQueryConfig queryConfig) throws Exception {">  50      public static void sqlUpdate(StreamTableEnvironment tableEnv, String stmt, StreamQueryConfig queryConfig) throðŸ”µ</abbr>


  51  
<abbr title="  52          FlinkPlannerImpl planner = new FlinkPlannerImpl(tableEnv.getFrameworkConfig(), tableEnv.getPlanner(), tableEnv.getTypeFactory());">  52          FlinkPlannerImpl planner = new FlinkPlannerImpl(tableEnv.getFrameworkConfig(), tableEnv.getPlanner(), tablðŸ”µ</abbr>
  53          SqlNode insert = planner.parse(stmt);


  54  
  55          if (!(insert instanceof SqlInsert)) {
  56              throw new TableException(
  57                      &quot;Unsupported SQL query! sqlUpdate() only accepts SQL statements of type INSERT.&quot;);
  58          }
  59          SqlNode query = ((SqlInsert) insert).getSource();
  60  
  61          SqlNode validatedQuery = planner.validate(query);
  62  
  63          Table queryResult = new Table(tableEnv, new LogicalRelNode(planner.rel(validatedQuery).rel));
  64          String targetTableName = ((SqlIdentifier) ((SqlInsert) insert).getTargetTable()).names.get(0);
  65  
  66          Method method = TableEnvironment.class.getDeclaredMethod(&quot;getTable&quot;, String.class);
  67          method.setAccessible(true);
  68          Option sinkTab = (Option)method.invoke(tableEnv, targetTableName);
  69  
  70          if (sinkTab.isEmpty()) {
  71              throw  new ValidationException(&quot;Sink table &quot; + targetTableName + &quot;not found in flink&quot;);
  72          }
  73  
  74          TableSourceSinkTable targetTable = (TableSourceSinkTable) sinkTab.get();
  75          TableSinkTable tableSinkTable = (TableSinkTable)targetTable.tableSinkTable().get();
  76  
  77          StreamQueryConfig config = null == queryConfig ? tableEnv.queryConfig() : queryConfig;
  78          String[] sinkFieldNames = tableSinkTable.tableSink().getFieldNames();
  79          String[] queryFieldNames = queryResult.getSchema().getColumnNames();
  80          if (sinkFieldNames.length != queryFieldNames.length) {
  81              throw new ValidationException(
<abbr title="  82                      &quot;Field name of query result and registered TableSink &quot; + targetTableName + &quot; do not match.\n&quot; +">  82                      &quot;Field name of query result and registered TableSink &quot; + targetTableName + &quot; do not match.\n&quot; ðŸ”µ</abbr>
  83                              &quot;Query result schema: &quot; + String.join(&quot;,&quot;, queryFieldNames) + &quot;\n&quot; +
  84                              &quot;TableSink schema: &quot; + String.join(&quot;,&quot;, sinkFieldNames));
  85          }
  86  

  87          Table newTable = null;
  88          try {
  89              // sinkFieldNames not in queryResult error
  90              newTable = queryResult.select(String.join(&quot;,&quot;, sinkFieldNames));
  91          } catch (Exception e) {
  92              throw new ValidationException(
<abbr title="  93                      &quot;Field name of query result and registered TableSink &quot; + targetTableName + &quot; do not match.\n&quot; +">  93                      &quot;Field name of query result and registered TableSink &quot; + targetTableName + &quot; do not match.\n&quot; ðŸ”µ</abbr>
<abbr title="  94                              &quot;Query result schema: &quot; + String.join(&quot;,&quot;, queryResult.getSchema().getColumnNames()) + &quot;\n&quot; +">  94                              &quot;Query result schema: &quot; + String.join(&quot;,&quot;, queryResult.getSchema().getColumnNames()) +ðŸ”µ</abbr>
  95                              &quot;TableSink schema: &quot; + String.join(&quot;,&quot;, sinkFieldNames));



  96          }
  97  
  98          try {
  99              tableEnv.insertInto(newTable, targetTableName, config);
 100          } catch (Exception ex) {
<abbr title=" 101              LOG.warn(&quot;Field name case of query result and registered TableSink &quot; + targetTableName + &quot;do not match. &quot; + ex.getMessage());"> 101              LOG.warn(&quot;Field name case of query result and registered TableSink &quot; + targetTableName + &quot;do not matchðŸ”µ</abbr>



 102              newTable = queryResult.select(String.join(&quot;,&quot;, ignoreCase(queryFieldNames, sinkFieldNames)));
 103              tableEnv.insertInto(newTable, targetTableName, config);

 104          }

 105      }
 106  
 107      public static String[] ignoreCase(String[] queryFieldNames, String[] sinkFieldNames) {



















 108          String[] newFieldNames = sinkFieldNames;
 109          for (int i = 0; i &lt; newFieldNames.length; i++) {
 110              for (String queryFieldName : queryFieldNames) {
 111                  if (newFieldNames[i].equalsIgnoreCase(queryFieldName)) {
 112                      newFieldNames[i] = queryFieldName;
 113                      break;
 114                  }
 115              }
 116          }
 117          return newFieldNames;
 118      }
 119  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            