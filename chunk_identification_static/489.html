<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>489</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    489
                    <a href="488.html">prev</a>
                    <a href="490.html">next</a>
                    <a href="489_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_cb68efb9e51ba697e771581059b9c11c3fe66ccb_hbase/hbase-side/hbase-async-side/src/main/java/com/dtstack/flink/sql/side/hbase/HbaseAsyncReqRow.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;cb68efb9e51ba697e771581059b9c11c3fe66ccb:hbase/hbase-side/hbase-async-side/src/main/java/com/dtstack/flink/sql/side/hbase/HbaseAsyncReqRow.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;cb68efb9e51ba697e771581059b9c11c3fe66ccb^1:hbase/hbase-side/hbase-async-side/src/main/java/com/dtstack/flink/sql/side/hbase/HbaseAsyncReqRow.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;cb68efb9e51ba697e771581059b9c11c3fe66ccb^2:hbase/hbase-side/hbase-async-side/src/main/java/com/dtstack/flink/sql/side/hbase/HbaseAsyncReqRow.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;828062ef514a8028632086b1c19ef248140da519:hbase/hbase-side/hbase-async-side/src/main/java/com/dtstack/flink/sql/side/hbase/HbaseAsyncReqRow.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19  
  20 
  21 package com.dtstack.flink.sql.side.hbase;
  22 
  23 import com.dtstack.flink.sql.enums.ECacheContentType;
  24 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  25 import com.dtstack.flink.sql.side.FieldInfo;
  26 import com.dtstack.flink.sql.side.JoinInfo;
  27 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  28 import com.dtstack.flink.sql.side.cache.CacheObj;
  29 import com.dtstack.flink.sql.side.hbase.rowkeydealer.AbstractRowKeyModeDealer;
  30 import com.dtstack.flink.sql.side.hbase.rowkeydealer.PreRowKeyModeDealerDealer;
  31 import com.dtstack.flink.sql.side.hbase.rowkeydealer.RowKeyEqualModeDealer;
  32 import com.dtstack.flink.sql.side.hbase.table.HbaseSideTableInfo;
  33 import com.dtstack.flink.sql.factory.DTThreadFactory;
  34 import com.dtstack.flink.sql.side.hbase.utils.HbaseConfigUtils;
  35 import com.dtstack.flink.sql.util.AuthUtil;
  36 import com.google.common.collect.Maps;
  37 import com.stumbleupon.async.Deferred;
  38 import org.apache.flink.api.java.tuple.Tuple2;
  39 import org.apache.commons.lang3.StringUtils;
  40 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  41 import org.apache.flink.configuration.Configuration;
  42 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  43 import org.apache.flink.types.Row;
  44 import org.hbase.async.Config;
  45 import org.hbase.async.HBaseClient;
  46 import org.slf4j.Logger;
  47 import org.slf4j.LoggerFactory;
  48 
  49 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
  50 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  51 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  52 import java.sql.Timestamp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  53 import java.util.Collections;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  54 import java.util.List;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  55 import java.util.Map;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  56 import java.util.concurrent.ExecutorService;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  57 import java.util.concurrent.LinkedBlockingQueue;</span>
  58 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  59 import java.io.File;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  60 import java.io.IOException;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  61 import java.sql.Timestamp;</span>
  62 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  63 import java.util.Collections;
  64 import java.util.List;
  65 import java.util.Map;
  66 import java.util.concurrent.ExecutorService;
  67 import java.util.concurrent.LinkedBlockingQueue;
  68 import java.util.concurrent.ThreadPoolExecutor;
  69 import java.util.concurrent.TimeUnit;
  70 
  71 /**
  72  * Date: 2018/8/21
  73  * Company: www.dtstack.com
  74  * @author xuchao
  75  */
  76 
  77 public class HbaseAsyncReqRow extends BaseAsyncReqRow {
  78 
  79     private static final long serialVersionUID = 2098635104857937717L;
  80 
  81     private static final Logger LOG = LoggerFactory.getLogger(HbaseAsyncReqRow.class);
  82 
  83     //match to the rule of netty3
  84     private static final int DEFAULT_BOSS_THREADS = 1;
  85 
  86     private static final int DEFAULT_IO_THREADS = Runtime.getRuntime().availableProcessors() * 2;
  87 
  88     private static final int DEFAULT_POOL_SIZE = DEFAULT_IO_THREADS + DEFAULT_BOSS_THREADS;
  89 
  90     private transient HBaseClient hBaseClient;
  91 
  92     private transient AbstractRowKeyModeDealer rowKeyMode;
  93 
  94     private String tableName;
  95 
  96     private String[] colNames;
  97 
<abbr title="  98     public HbaseAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  98     public HbaseAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  99         super(new HbaseAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
 100 
 101         tableName = ((HbaseSideTableInfo)sideTableInfo).getTableName();
 102         colNames =  StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
 103     }
 104 
 105 
 106     @Override
 107     public void open(Configuration parameters) throws Exception {
 108         super.open(parameters);
 109         AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
 110         HbaseSideTableInfo hbaseSideTableInfo = (HbaseSideTableInfo) sideTableInfo;
 111         Map&lt;String, Object&gt; hbaseConfig = hbaseSideTableInfo.getHbaseConfig();
 112 
 113         ExecutorService executorService =new ThreadPoolExecutor(DEFAULT_POOL_SIZE, DEFAULT_POOL_SIZE,
 114                 0L, TimeUnit.MILLISECONDS,
 115                 new LinkedBlockingQueue&lt;&gt;(), new DTThreadFactory(&quot;hbase-aysnc&quot;));
 116 
 117         Config config = new Config();
 118         config.overrideConfig(HbaseConfigUtils.KEY_HBASE_ZOOKEEPER_QUORUM, hbaseSideTableInfo.getHost());
<abbr title=" 119         config.overrideConfig(HbaseConfigUtils.KEY_HBASE_ZOOKEEPER_ZNODE_QUORUM, hbaseSideTableInfo.getParent());"> 119         config.overrideConfig(HbaseConfigUtils.KEY_HBASE_ZOOKEEPER_ZNODE_QUORUM, hbaseSideTableInfo.getPaðŸ”µ</abbr>
 120         HbaseConfigUtils.loadKrb5Conf(hbaseConfig);
 121         hbaseConfig.entrySet().forEach(entity -&gt; {
 122             config.overrideConfig(entity.getKey(), (String) entity.getValue());
 123         });
 124 
 125         if (HbaseConfigUtils.asyncOpenKerberos(hbaseConfig)) {
 126             String jaasStr = HbaseConfigUtils.buildJaasStr(hbaseConfig);
 127             String jaasFilePath = HbaseConfigUtils.creatJassFile(jaasStr);
 128             config.overrideConfig(HbaseConfigUtils.KEY_JAVA_SECURITY_AUTH_LOGIN_CONF, jaasFilePath);
 129         }
 130 
 131         hBaseClient = new HBaseClient(config, executorService);
 132 
 133         try {
 134             Deferred deferred = hBaseClient.ensureTableExists(tableName)
<abbr title=" 135                     .addCallbacks(arg -&gt; new CheckResult(true, &quot;&quot;), arg -&gt; new CheckResult(false, arg.toString()));"> 135                     .addCallbacks(arg -&gt; new CheckResult(true, &quot;&quot;), arg -&gt; new CheckResult(false, arg.toSðŸ”µ</abbr>
 136 
 137             CheckResult result = (CheckResult) deferred.join();
 138             if(!result.isConnect()){
 139                 throw new RuntimeException(result.getExceptionMsg());
 140             }
 141 
 142         } catch (Exception e) {
 143             throw new RuntimeException(&quot;create hbase connection fail:&quot;, e);
 144         }
 145 
 146         HbaseAsyncSideInfo hbaseAsyncSideInfo = (HbaseAsyncSideInfo) sideInfo;
 147         if(hbaseSideTableInfo.isPreRowKey()){
<abbr title=" 148             rowKeyMode = new PreRowKeyModeDealerDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBaseClient,"> 148             rowKeyMode = new PreRowKeyModeDealerDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBasðŸ”µ</abbr>
 149                     openCache(), sideInfo.getJoinType(), sideInfo.getOutFieldInfoList(),
 150                     sideInfo.getInFieldIndex(), sideInfo.getSideFieldIndex());
 151         }else{
<abbr title=" 152             rowKeyMode = new RowKeyEqualModeDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBaseClient,"> 152             rowKeyMode = new RowKeyEqualModeDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBaseCliðŸ”µ</abbr>
 153                     openCache(), sideInfo.getJoinType(), sideInfo.getOutFieldInfoList(),
 154                     sideInfo.getInFieldIndex(), sideInfo.getSideFieldIndex());
 155         }
 156     }
 157 
 158     @Override
<abbr title=" 159     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 159     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFuturðŸ”µ</abbr>
<abbr title=" 160         rowKeyMode.asyncGetData(tableName, buildCacheKey(inputParams), input, resultFuture, sideInfo.getSideCache());"> 160         rowKeyMode.asyncGetData(tableName, buildCacheKey(inputParams), input, resultFuture, sideInfo.getSðŸ”µ</abbr>
 161     }
 162 
 163     @Override
 164     public String buildCacheKey(Map&lt;String, Object&gt; inputParams) {
 165         return ((HbaseAsyncSideInfo)sideInfo).getRowKeyBuilder().getRowKey(inputParams);
 166     }
 167 
 168     @Override
 169     public Row fillData(Row input, Object sideInput){
 170         List&lt;Object&gt; sideInputList = (List&lt;Object&gt;) sideInput;
 171         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 172         for(Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()){
 173             Object obj = input.getField(entry.getValue());
 174             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);
 175             row.setField(entry.getKey(), obj);
 176         }
 177 
 178         for(Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()){
 179             if(sideInputList == null){
 180                 row.setField(entry.getKey(), null);
 181             }else{
 182                 row.setField(entry.getKey(), sideInputList.get(entry.getValue()));
 183             }
 184         }
 185 
 186         return row;
 187     }
 188 
 189     @Override
 190     public void close() throws Exception {
 191         super.close();
 192         hBaseClient.shutdown();
 193     }
 194 
 195     class CheckResult{
 196 
 197         private boolean connect;
 198 
 199         private String exceptionMsg;
 200 
 201         CheckResult(boolean connect, String msg){
 202             this.connect = connect;
 203             this.exceptionMsg = msg;
 204         }
 205 
 206         public boolean isConnect() {
 207             return connect;
 208         }
 209 
 210         public void setConnect(boolean connect) {
 211             this.connect = connect;
 212         }
 213 
 214         public String getExceptionMsg() {
 215             return exceptionMsg;
 216         }
 217 
 218         public void setExceptionMsg(String exceptionMsg) {
 219             this.exceptionMsg = exceptionMsg;
 220         }
 221     }
 222 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.side.hbase;
  22 
  23 import com.dtstack.flink.sql.enums.ECacheContentType;
  24 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  25 import com.dtstack.flink.sql.side.FieldInfo;
  26 import com.dtstack.flink.sql.side.JoinInfo;
  27 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  28 import com.dtstack.flink.sql.side.cache.CacheObj;
  29 import com.dtstack.flink.sql.side.hbase.rowkeydealer.AbstractRowKeyModeDealer;
  30 import com.dtstack.flink.sql.side.hbase.rowkeydealer.PreRowKeyModeDealerDealer;
  31 import com.dtstack.flink.sql.side.hbase.rowkeydealer.RowKeyEqualModeDealer;
  32 import com.dtstack.flink.sql.side.hbase.table.HbaseSideTableInfo;
  33 import com.dtstack.flink.sql.factory.DTThreadFactory;
  34 import com.dtstack.flink.sql.side.hbase.utils.HbaseConfigUtils;
  35 import com.dtstack.flink.sql.util.AuthUtil;
  36 import com.google.common.collect.Maps;
  37 import com.stumbleupon.async.Deferred;
  38 import org.apache.flink.api.java.tuple.Tuple2;
  39 import org.apache.commons.lang3.StringUtils;
  40 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  41 import org.apache.flink.configuration.Configuration;
  42 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  43 import org.apache.flink.types.Row;
  44 import org.hbase.async.Config;
  45 import org.hbase.async.HBaseClient;
  46 import org.slf4j.Logger;
  47 import org.slf4j.LoggerFactory;
  48 
  49 import java.io.File;
  50 import java.io.IOException;
  51 
  52 import java.util.Collections;
  53 import java.util.List;
  54 import java.util.Map;
  55 import java.util.concurrent.ExecutorService;
  56 import java.util.concurrent.LinkedBlockingQueue;
  57 import java.util.concurrent.ThreadPoolExecutor;
  58 import java.util.concurrent.TimeUnit;
  59 
  60 /**
  61  * Date: 2018/8/21
  62  * Company: www.dtstack.com
  63  * @author xuchao
  64  */
  65 
  66 public class HbaseAsyncReqRow extends BaseAsyncReqRow {
  67 
  68     private static final long serialVersionUID = 2098635104857937717L;
  69 
  70     private static final Logger LOG = LoggerFactory.getLogger(HbaseAsyncReqRow.class);
  71 
  72     //match to the rule of netty3
  73     private static final int DEFAULT_BOSS_THREADS = 1;
  74 
  75     private static final int DEFAULT_IO_THREADS = Runtime.getRuntime().availableProcessors() * 2;
  76 
  77     private static final int DEFAULT_POOL_SIZE = DEFAULT_IO_THREADS + DEFAULT_BOSS_THREADS;
  78 
  79     private transient HBaseClient hBaseClient;
  80 
  81     private transient AbstractRowKeyModeDealer rowKeyMode;
  82 
  83     private String tableName;
  84 
  85     private String[] colNames;
  86 
<abbr title="  87     public HbaseAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  87     public HbaseAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  88         super(new HbaseAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  89 
  90         tableName = ((HbaseSideTableInfo)sideTableInfo).getTableName();
  91         colNames =  StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
  92     }
  93 
  94 
  95     @Override
  96     public void open(Configuration parameters) throws Exception {
  97         super.open(parameters);
  98         AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
  99         HbaseSideTableInfo hbaseSideTableInfo = (HbaseSideTableInfo) sideTableInfo;
 100         Map&lt;String, Object&gt; hbaseConfig = hbaseSideTableInfo.getHbaseConfig();
 101 
 102         ExecutorService executorService =new ThreadPoolExecutor(DEFAULT_POOL_SIZE, DEFAULT_POOL_SIZE,
 103                 0L, TimeUnit.MILLISECONDS,
 104                 new LinkedBlockingQueue&lt;&gt;(), new DTThreadFactory(&quot;hbase-aysnc&quot;));
 105 
 106         Config config = new Config();
 107         config.overrideConfig(HbaseConfigUtils.KEY_HBASE_ZOOKEEPER_QUORUM, hbaseSideTableInfo.getHost());
<abbr title=" 108         config.overrideConfig(HbaseConfigUtils.KEY_HBASE_ZOOKEEPER_ZNODE_QUORUM, hbaseSideTableInfo.getParent());"> 108         config.overrideConfig(HbaseConfigUtils.KEY_HBASE_ZOOKEEPER_ZNODE_QUORUM, hbaseSideTableInfo.getPaðŸ”µ</abbr>
 109         HbaseConfigUtils.loadKrb5Conf(hbaseConfig);
 110         hbaseConfig.entrySet().forEach(entity -&gt; {
 111             config.overrideConfig(entity.getKey(), (String) entity.getValue());
 112         });
 113 
 114         if (HbaseConfigUtils.asyncOpenKerberos(hbaseConfig)) {
 115             String jaasStr = HbaseConfigUtils.buildJaasStr(hbaseConfig);
 116             String jaasFilePath = HbaseConfigUtils.creatJassFile(jaasStr);
 117             config.overrideConfig(HbaseConfigUtils.KEY_JAVA_SECURITY_AUTH_LOGIN_CONF, jaasFilePath);
 118         }
 119 
 120         hBaseClient = new HBaseClient(config, executorService);
 121 
 122         try {
 123             Deferred deferred = hBaseClient.ensureTableExists(tableName)
<abbr title=" 124                     .addCallbacks(arg -&gt; new CheckResult(true, &quot;&quot;), arg -&gt; new CheckResult(false, arg.toString()));"> 124                     .addCallbacks(arg -&gt; new CheckResult(true, &quot;&quot;), arg -&gt; new CheckResult(false, arg.toSðŸ”µ</abbr>
 125 
 126             CheckResult result = (CheckResult) deferred.join();
 127             if(!result.isConnect()){
 128                 throw new RuntimeException(result.getExceptionMsg());
 129             }
 130 
 131         } catch (Exception e) {
 132             throw new RuntimeException(&quot;create hbase connection fail:&quot;, e);
 133         }
 134 
 135         HbaseAsyncSideInfo hbaseAsyncSideInfo = (HbaseAsyncSideInfo) sideInfo;
 136         if(hbaseSideTableInfo.isPreRowKey()){
<abbr title=" 137             rowKeyMode = new PreRowKeyModeDealerDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBaseClient,"> 137             rowKeyMode = new PreRowKeyModeDealerDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBasðŸ”µ</abbr>
 138                     openCache(), sideInfo.getJoinType(), sideInfo.getOutFieldInfoList(),
 139                     sideInfo.getInFieldIndex(), sideInfo.getSideFieldIndex());
 140         }else{
<abbr title=" 141             rowKeyMode = new RowKeyEqualModeDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBaseClient,"> 141             rowKeyMode = new RowKeyEqualModeDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBaseCliðŸ”µ</abbr>
 142                     openCache(), sideInfo.getJoinType(), sideInfo.getOutFieldInfoList(),
 143                     sideInfo.getInFieldIndex(), sideInfo.getSideFieldIndex());
 144         }
 145     }
 146 
 147     @Override
<abbr title=" 148     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 148     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFuturðŸ”µ</abbr>
<abbr title=" 149         rowKeyMode.asyncGetData(tableName, buildCacheKey(inputParams), input, resultFuture, sideInfo.getSideCache());"> 149         rowKeyMode.asyncGetData(tableName, buildCacheKey(inputParams), input, resultFuture, sideInfo.getSðŸ”µ</abbr>
 150     }
 151 
 152     @Override
 153     public String buildCacheKey(Map&lt;String, Object&gt; inputParams) {
 154         return ((HbaseAsyncSideInfo)sideInfo).getRowKeyBuilder().getRowKey(inputParams);
 155     }
 156 
 157     @Override
 158     public Row fillData(Row input, Object sideInput){
 159         List&lt;Object&gt; sideInputList = (List&lt;Object&gt;) sideInput;
 160         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 161         for(Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()){
 162             Object obj = input.getField(entry.getValue());
 163             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);
 164             row.setField(entry.getKey(), obj);
 165         }
 166 
 167         for(Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()){
 168             if(sideInputList == null){
 169                 row.setField(entry.getKey(), null);
 170             }else{
 171                 row.setField(entry.getKey(), sideInputList.get(entry.getValue()));
 172             }
 173         }
 174 
 175         return row;
 176     }
 177 
 178     @Override
 179     public void close() throws Exception {
 180         super.close();
 181         hBaseClient.shutdown();
 182     }
 183 
 184     class CheckResult{
 185 
 186         private boolean connect;
 187 
 188         private String exceptionMsg;
 189 
 190         CheckResult(boolean connect, String msg){
 191             this.connect = connect;
 192             this.exceptionMsg = msg;
 193         }
 194 
 195         public boolean isConnect() {
 196             return connect;
 197         }
 198 
 199         public void setConnect(boolean connect) {
 200             this.connect = connect;
 201         }
 202 
 203         public String getExceptionMsg() {
 204             return exceptionMsg;
 205         }
 206 
 207         public void setExceptionMsg(String exceptionMsg) {
 208             this.exceptionMsg = exceptionMsg;
 209         }
 210     }
 211 }
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.side.hbase;
  19 
  20 import com.dtstack.flink.sql.enums.ECacheContentType;
  21 import com.dtstack.flink.sql.factory.DTThreadFactory;
  22 import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  23 import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  24 import com.dtstack.flink.sql.side.FieldInfo;
  25 import com.dtstack.flink.sql.side.JoinInfo;
  26 import com.dtstack.flink.sql.side.cache.CacheObj;
  27 import com.dtstack.flink.sql.side.hbase.rowkeydealer.AbstractRowKeyModeDealer;
  28 import com.dtstack.flink.sql.side.hbase.rowkeydealer.PreRowKeyModeDealerDealer;
  29 import com.dtstack.flink.sql.side.hbase.rowkeydealer.RowKeyEqualModeDealer;
  30 import com.dtstack.flink.sql.side.hbase.table.HbaseSideTableInfo;
  31 import com.dtstack.flink.sql.side.hbase.utils.HbaseConfigUtils;
  32 import com.dtstack.flink.sql.util.AuthUtil;
  33 import com.google.common.collect.Maps;
  34 import com.stumbleupon.async.Deferred;
  35 import java.io.File;
  36 import java.io.IOException;
  37 import java.util.Collections;
  38 import java.util.List;
  39 import java.util.Map;
  40 import java.util.concurrent.ExecutorService;
  41 import java.util.concurrent.LinkedBlockingQueue;
  42 import java.util.concurrent.ThreadPoolExecutor;
  43 import java.util.concurrent.TimeUnit;
  44 import org.apache.commons.lang3.StringUtils;
  45 import org.apache.flink.api.java.tuple.Tuple2;
  46 import org.apache.flink.api.java.typeutils.RowTypeInfo;
  47 import org.apache.flink.configuration.Configuration;
  48 import org.apache.flink.streaming.api.functions.async.ResultFuture;
  49 import org.apache.flink.types.Row;
  50 import org.hbase.async.Config;
  51 import org.hbase.async.HBaseClient;
  52 import org.slf4j.Logger;
  53 import org.slf4j.LoggerFactory;
  54 
  55 
  56 /**
  57  * Date: 2018/8/21
  58  * Company: www.dtstack.com
  59  * @author xuchao
  60  */
  61 public class HbaseAsyncReqRow extends BaseAsyncReqRow {
  62     private static final long serialVersionUID = 2098635104857937717L;
  63 
  64     private static final Logger LOG = LoggerFactory.getLogger(HbaseAsyncReqRow.class);
  65 
  66     //match to the rule of netty3
  67     //match to the rule of netty3
  68     private static final int DEFAULT_BOSS_THREADS = 1;
  69 
  70     private static final int DEFAULT_IO_THREADS = Runtime.getRuntime().availableProcessors() * 2;
  71 
  72     private static final int DEFAULT_POOL_SIZE = DEFAULT_IO_THREADS + DEFAULT_BOSS_THREADS;
  73 
  74     private transient HBaseClient hBaseClient;
  75 
  76     private transient AbstractRowKeyModeDealer rowKeyMode;
  77 
  78     private String tableName;
  79 
  80     private String[] colNames;
  81 
<abbr title="  82     public HbaseAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  82     public HbaseAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList,ðŸ”µ</abbr>
  83         super(new HbaseAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  84         tableName = ((HbaseSideTableInfo) (sideTableInfo)).getTableName();
  85         colNames = StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
  86     }
  87 
  88     @Override
  89     public void open(Configuration parameters) throws Exception {
  90         super.open(parameters);
  91         AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
  92         HbaseSideTableInfo hbaseSideTableInfo = ((HbaseSideTableInfo) (sideTableInfo));
  93         Map&lt;String, Object&gt; hbaseConfig = hbaseSideTableInfo.getHbaseConfig();
<abbr title="  94         ExecutorService executorService = new ThreadPoolExecutor(DEFAULT_POOL_SIZE, DEFAULT_POOL_SIZE, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(), new DTThreadFactory(&quot;hbase-aysnc&quot;));">  94         ExecutorService executorService = new ThreadPoolExecutor(DEFAULT_POOL_SIZE, DEFAULT_POOL_SIZE, 0LðŸ”µ</abbr>
  95         Config config = new Config();
  96         config.overrideConfig(HbaseConfigUtils.KEY_HBASE_ZOOKEEPER_QUORUM, hbaseSideTableInfo.getHost());
<abbr title="  97         config.overrideConfig(HbaseConfigUtils.KEY_HBASE_ZOOKEEPER_ZNODE_QUORUM, hbaseSideTableInfo.getParent());">  97         config.overrideConfig(HbaseConfigUtils.KEY_HBASE_ZOOKEEPER_ZNODE_QUORUM, hbaseSideTableInfo.getPaðŸ”µ</abbr>
  98         HbaseConfigUtils.loadKrb5Conf(hbaseConfig);
  99         hbaseConfig.entrySet().forEach(( entity) -&gt; {
 100             config.overrideConfig(entity.getKey(), ((String) (entity.getValue())));
 101         });
 102         if (HbaseConfigUtils.asyncOpenKerberos(hbaseConfig)) {
 103             String jaasStr = HbaseConfigUtils.buildJaasStr(hbaseConfig);
 104             String jaasFilePath = HbaseConfigUtils.creatJassFile(jaasStr);
 105             config.overrideConfig(HbaseConfigUtils.KEY_JAVA_SECURITY_AUTH_LOGIN_CONF, jaasFilePath);
 106         }
 107         hBaseClient = new HBaseClient(config, executorService);
 108         try {
<abbr title=" 109             Deferred deferred = hBaseClient.ensureTableExists(tableName).addCallbacks(( arg) -&gt; new CheckResult(true, &quot;&quot;), ( arg) -&gt; new CheckResult(false, arg.toString()));"> 109             Deferred deferred = hBaseClient.ensureTableExists(tableName).addCallbacks(( arg) -&gt; new CheckðŸ”µ</abbr>
 110             CheckResult result = ((CheckResult) (deferred.join()));
 111             if (!result.isConnect()) {
 112                 throw new RuntimeException(result.getExceptionMsg());
 113             }
 114         } catch (java.lang.Exception e) {
 115             throw new RuntimeException(&quot;create hbase connection fail:&quot;, e);
 116         }
 117         HbaseAsyncSideInfo hbaseAsyncSideInfo = ((HbaseAsyncSideInfo) (sideInfo));
 118         if (hbaseSideTableInfo.isPreRowKey()) {
<abbr title=" 119             rowKeyMode = new PreRowKeyModeDealerDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBaseClient, openCache(), sideInfo.getJoinType(), sideInfo.getOutFieldInfoList(), sideInfo.getInFieldIndex(), sideInfo.getSideFieldIndex());"> 119             rowKeyMode = new PreRowKeyModeDealerDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBasðŸ”µ</abbr>
 120         } else {
<abbr title=" 121             rowKeyMode = new RowKeyEqualModeDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBaseClient, openCache(), sideInfo.getJoinType(), sideInfo.getOutFieldInfoList(), sideInfo.getInFieldIndex(), sideInfo.getSideFieldIndex());"> 121             rowKeyMode = new RowKeyEqualModeDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBaseCliðŸ”µ</abbr>
 122         }
 123     }
 124 
 125     @Override
<abbr title=" 126     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean, Row&gt;&gt; resultFuture) throws Exception {"> 126     public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean, Row&gt; input, ResultFutuðŸ”µ</abbr>
<abbr title=" 127         rowKeyMode.asyncGetData(tableName, buildCacheKey(inputParams), input, resultFuture, sideInfo.getSideCache());"> 127         rowKeyMode.asyncGetData(tableName, buildCacheKey(inputParams), input, resultFuture, sideInfo.getSðŸ”µ</abbr>
 128     }
 129 
 130     @Override
 131     public String buildCacheKey(Map&lt;String, Object&gt; inputParams) {
 132         return ((HbaseAsyncSideInfo)sideInfo).getRowKeyBuilder().getRowKey(inputParams);
 133     }
 134 
 135     @Override
 136     public Row fillData(Row input, Object sideInput) {
 137         List&lt;Object&gt; sideInputList = ((List&lt;Object&gt;) (sideInput));
 138         Row row = new Row(sideInfo.getOutFieldInfoList().size());
 139         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()) {
 140             Object obj = input.getField(entry.getValue());
 141             obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);
 142             row.setField(entry.getKey(), obj);
 143         }
 144         for (Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()) {
 145             if (sideInputList == null) {
 146                 row.setField(entry.getKey(), null);
 147             } else {
 148                 row.setField(entry.getKey(), sideInputList.get(entry.getValue()));
 149             }
 150         }
 151         return row;
 152     }
 153 
 154     @Override
 155     public void close() throws Exception {
 156         super.close();
 157         hBaseClient.shutdown();
 158     }
 159 
 160     class CheckResult {
 161         private boolean connect;
 162 
 163         private String exceptionMsg;
 164 
 165         CheckResult(boolean connect, String msg) {
 166             this.connect = connect;
 167             this.exceptionMsg = msg;
 168         }
 169 
 170         public boolean isConnect() {
 171             return connect;
 172         }
 173 
 174         public void setConnect(boolean connect) {
 175             this.connect = connect;
 176         }
 177 
 178         public String getExceptionMsg() {
 179             return exceptionMsg;
 180         }
 181 
 182         public void setExceptionMsg(String exceptionMsg) {
 183             this.exceptionMsg = exceptionMsg;
 184         }
 185     }
 186 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side.hbase;
  22  
  23  import com.dtstack.flink.sql.enums.ECacheContentType;
  24  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  25  import com.dtstack.flink.sql.side.FieldInfo;
  26  import com.dtstack.flink.sql.side.JoinInfo;
  27  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  28  import com.dtstack.flink.sql.side.cache.CacheObj;
  29  import com.dtstack.flink.sql.side.hbase.rowkeydealer.AbstractRowKeyModeDealer;
  30  import com.dtstack.flink.sql.side.hbase.rowkeydealer.PreRowKeyModeDealerDealer;
  31  import com.dtstack.flink.sql.side.hbase.rowkeydealer.RowKeyEqualModeDealer;
  32  import com.dtstack.flink.sql.side.hbase.table.HbaseSideTableInfo;
  33  import com.dtstack.flink.sql.factory.DTThreadFactory;


  34  import com.google.common.collect.Maps;
  35  import com.stumbleupon.async.Deferred;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +import org.apache.flink.api.java.tuple.Tuple2;</span>
  37  import org.apache.commons.lang3.StringUtils;
  38  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  39  import org.apache.flink.configuration.Configuration;
  40  import org.apache.flink.streaming.api.functions.async.ResultFuture;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  41 -import org.apache.flink.table.runtime.types.CRow;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  42 -import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;</span>
  43  import org.apache.flink.types.Row;

  44  import org.hbase.async.HBaseClient;
  45  import org.slf4j.Logger;
  46  import org.slf4j.LoggerFactory;
  47  


<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  48 -import java.sql.Timestamp;</span>
  49  import java.util.Collections;
  50  import java.util.List;
  51  import java.util.Map;
  52  import java.util.concurrent.ExecutorService;
  53  import java.util.concurrent.LinkedBlockingQueue;
  54  import java.util.concurrent.ThreadPoolExecutor;
  55  import java.util.concurrent.TimeUnit;
  56  
  57  /**
  58   * Date: 2018/8/21
  59   * Company: www.dtstack.com
  60   * @author xuchao
  61   */
  62  
  63  public class HbaseAsyncReqRow extends BaseAsyncReqRow {
  64  
  65      private static final long serialVersionUID = 2098635104857937717L;
  66  
  67      private static final Logger LOG = LoggerFactory.getLogger(HbaseAsyncReqRow.class);
  68  
  69      //match to the rule of netty3
  70      private static final int DEFAULT_BOSS_THREADS = 1;
  71  
  72      private static final int DEFAULT_IO_THREADS = Runtime.getRuntime().availableProcessors() * 2;
  73  
  74      private static final int DEFAULT_POOL_SIZE = DEFAULT_IO_THREADS + DEFAULT_BOSS_THREADS;
  75  
  76      private transient HBaseClient hBaseClient;
  77  
  78      private transient AbstractRowKeyModeDealer rowKeyMode;
  79  
  80      private String tableName;
  81  
  82      private String[] colNames;
  83  
<abbr title="  84      public HbaseAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  84      public HbaseAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractðŸ”µ</abbr>
  85          super(new HbaseAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  86  
  87          tableName = ((HbaseSideTableInfo)sideTableInfo).getTableName();
  88          colNames =  StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
  89      }
  90  
  91  
  92      @Override
  93      public void open(Configuration parameters) throws Exception {
  94          super.open(parameters);
  95          AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
  96          HbaseSideTableInfo hbaseSideTableInfo = (HbaseSideTableInfo) sideTableInfo;


  97          ExecutorService executorService =new ThreadPoolExecutor(DEFAULT_POOL_SIZE, DEFAULT_POOL_SIZE,
  98                  0L, TimeUnit.MILLISECONDS,
  99                  new LinkedBlockingQueue&lt;&gt;(), new DTThreadFactory(&quot;hbase-aysnc&quot;));
 100  
<abbr title=" 101          hBaseClient = new HBaseClient(hbaseSideTableInfo.getHost(), hbaseSideTableInfo.getParent(), executorService);"> 101          hBaseClient = new HBaseClient(hbaseSideTableInfo.getHost(), hbaseSideTableInfo.getParent(), executorServicðŸ”µ</abbr>















 102  
 103          try {
 104              Deferred deferred = hBaseClient.ensureTableExists(tableName)
<abbr title=" 105                      .addCallbacks(arg -&gt; new CheckResult(true, &quot;&quot;), arg -&gt; new CheckResult(false, arg.toString()));"> 105                      .addCallbacks(arg -&gt; new CheckResult(true, &quot;&quot;), arg -&gt; new CheckResult(false, arg.toString()))ðŸ”µ</abbr>
 106  
 107              CheckResult result = (CheckResult) deferred.join();
 108              if(!result.isConnect()){
 109                  throw new RuntimeException(result.getExceptionMsg());
 110              }
 111  
 112          } catch (Exception e) {
 113              throw new RuntimeException(&quot;create hbase connection fail:&quot;, e);
 114          }
 115  
 116          HbaseAsyncSideInfo hbaseAsyncSideInfo = (HbaseAsyncSideInfo) sideInfo;
 117          if(hbaseSideTableInfo.isPreRowKey()){
 118              rowKeyMode = new PreRowKeyModeDealerDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBaseClient,
 119                      openCache(), sideInfo.getJoinType(), sideInfo.getOutFieldInfoList(),
 120                      sideInfo.getInFieldIndex(), sideInfo.getSideFieldIndex());
 121          }else{
 122              rowKeyMode = new RowKeyEqualModeDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBaseClient,
 123                      openCache(), sideInfo.getJoinType(), sideInfo.getOutFieldInfoList(),
 124                      sideInfo.getInFieldIndex(), sideInfo.getSideFieldIndex());
 125          }
 126      }
 127  
 128      @Override
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 129 -    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 129 -    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) thðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 130 +    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;Boolean,Row&gt;&gt; resultFuture) throws Exception {"> 130 +    public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, Tuple2&lt;Boolean,Row&gt; input, ResultFuture&lt;Tuple2&lt;ðŸ”µ</abbr></span>
<abbr title=" 131          rowKeyMode.asyncGetData(tableName, buildCacheKey(inputParams), input, resultFuture, sideInfo.getSideCache());"> 131          rowKeyMode.asyncGetData(tableName, buildCacheKey(inputParams), input, resultFuture, sideInfo.getSideCache(ðŸ”µ</abbr>
 132      }
 133  
 134      @Override
 135      public String buildCacheKey(Map&lt;String, Object&gt; inputParams) {
 136          return ((HbaseAsyncSideInfo)sideInfo).getRowKeyBuilder().getRowKey(inputParams);
 137      }
 138  
 139      @Override
 140      public Row fillData(Row input, Object sideInput){
 141          List&lt;Object&gt; sideInputList = (List&lt;Object&gt;) sideInput;
 142          Row row = new Row(sideInfo.getOutFieldInfoList().size());
 143          for(Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()){
 144              Object obj = input.getField(entry.getValue());
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 145 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 145 -            boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfoðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 146 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 147 -            if(obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 148 -                obj = ((Timestamp)obj).getTime();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 149 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 150 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +            obj = convertTimeIndictorTypeInfo(entry.getValue(), obj);</span>
 152              row.setField(entry.getKey(), obj);
 153          }
 154  
 155          for(Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()){
 156              if(sideInputList == null){
 157                  row.setField(entry.getKey(), null);
 158              }else{
 159                  row.setField(entry.getKey(), sideInputList.get(entry.getValue()));
 160              }
 161          }
 162  
 163          return row;
 164      }
 165  
 166      @Override
 167      public void close() throws Exception {
 168          super.close();
 169          hBaseClient.shutdown();
 170      }
 171  
 172  
 173      class CheckResult{
 174  
 175          private boolean connect;
 176  
 177          private String exceptionMsg;
 178  
 179          CheckResult(boolean connect, String msg){
 180              this.connect = connect;
 181              this.exceptionMsg = msg;
 182          }
 183  
 184          public boolean isConnect() {
 185              return connect;
 186          }
 187  
 188          public void setConnect(boolean connect) {
 189              this.connect = connect;
 190          }
 191  
 192          public String getExceptionMsg() {
 193              return exceptionMsg;
 194          }
 195  
 196          public void setExceptionMsg(String exceptionMsg) {
 197              this.exceptionMsg = exceptionMsg;
 198          }
 199      }
 200  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  
  21  package com.dtstack.flink.sql.side.hbase;
  22  
  23  import com.dtstack.flink.sql.enums.ECacheContentType;
  24  import com.dtstack.flink.sql.side.BaseAsyncReqRow;
  25  import com.dtstack.flink.sql.side.FieldInfo;
  26  import com.dtstack.flink.sql.side.JoinInfo;
  27  import com.dtstack.flink.sql.side.AbstractSideTableInfo;
  28  import com.dtstack.flink.sql.side.cache.CacheObj;
  29  import com.dtstack.flink.sql.side.hbase.rowkeydealer.AbstractRowKeyModeDealer;
  30  import com.dtstack.flink.sql.side.hbase.rowkeydealer.PreRowKeyModeDealerDealer;
  31  import com.dtstack.flink.sql.side.hbase.rowkeydealer.RowKeyEqualModeDealer;
  32  import com.dtstack.flink.sql.side.hbase.table.HbaseSideTableInfo;
  33  import com.dtstack.flink.sql.factory.DTThreadFactory;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import com.dtstack.flink.sql.side.hbase.utils.HbaseConfigUtils;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import com.dtstack.flink.sql.util.AuthUtil;</span>
  36  import com.google.common.collect.Maps;
  37  import com.stumbleupon.async.Deferred;

  38  import org.apache.commons.lang3.StringUtils;
  39  import org.apache.flink.api.java.typeutils.RowTypeInfo;
  40  import org.apache.flink.configuration.Configuration;
  41  import org.apache.flink.streaming.api.functions.async.ResultFuture;
  42  import org.apache.flink.table.runtime.types.CRow;
  43  import org.apache.flink.table.typeutils.TimeIndicatorTypeInfo;
  44  import org.apache.flink.types.Row;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +import org.hbase.async.Config;</span>
  46  import org.hbase.async.HBaseClient;
  47  import org.slf4j.Logger;
  48  import org.slf4j.LoggerFactory;
  49  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  50 +import java.io.File;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  51 +import java.io.IOException;</span>
  52  import java.sql.Timestamp;
  53  import java.util.Collections;
  54  import java.util.List;
  55  import java.util.Map;
  56  import java.util.concurrent.ExecutorService;
  57  import java.util.concurrent.LinkedBlockingQueue;
  58  import java.util.concurrent.ThreadPoolExecutor;
  59  import java.util.concurrent.TimeUnit;
  60  
  61  /**
  62   * Date: 2018/8/21
  63   * Company: www.dtstack.com
  64   * @author xuchao
  65   */
  66  
  67  public class HbaseAsyncReqRow extends BaseAsyncReqRow {
  68  
  69      private static final long serialVersionUID = 2098635104857937717L;
  70  
  71      private static final Logger LOG = LoggerFactory.getLogger(HbaseAsyncReqRow.class);
  72  
  73      //match to the rule of netty3
  74      private static final int DEFAULT_BOSS_THREADS = 1;
  75  
  76      private static final int DEFAULT_IO_THREADS = Runtime.getRuntime().availableProcessors() * 2;
  77  
  78      private static final int DEFAULT_POOL_SIZE = DEFAULT_IO_THREADS + DEFAULT_BOSS_THREADS;
  79  
  80      private transient HBaseClient hBaseClient;
  81  
  82      private transient AbstractRowKeyModeDealer rowKeyMode;
  83  
  84      private String tableName;
  85  
  86      private String[] colNames;
  87  
<abbr title="  88      public HbaseAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractSideTableInfo sideTableInfo) {">  88      public HbaseAsyncReqRow(RowTypeInfo rowTypeInfo, JoinInfo joinInfo, List&lt;FieldInfo&gt; outFieldInfoList, AbstractðŸ”µ</abbr>
  89          super(new HbaseAsyncSideInfo(rowTypeInfo, joinInfo, outFieldInfoList, sideTableInfo));
  90  
  91          tableName = ((HbaseSideTableInfo)sideTableInfo).getTableName();
  92          colNames =  StringUtils.split(sideInfo.getSideSelectFields(), &quot;,&quot;);
  93      }
  94  
  95  
  96      @Override
  97      public void open(Configuration parameters) throws Exception {
  98          super.open(parameters);
  99          AbstractSideTableInfo sideTableInfo = sideInfo.getSideTableInfo();
 100          HbaseSideTableInfo hbaseSideTableInfo = (HbaseSideTableInfo) sideTableInfo;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 101 +        Map&lt;String, Object&gt; hbaseConfig = hbaseSideTableInfo.getHbaseConfig();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 102 +</span>
 103          ExecutorService executorService =new ThreadPoolExecutor(DEFAULT_POOL_SIZE, DEFAULT_POOL_SIZE,
 104                  0L, TimeUnit.MILLISECONDS,
 105                  new LinkedBlockingQueue&lt;&gt;(), new DTThreadFactory(&quot;hbase-aysnc&quot;));
 106  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 107 -        hBaseClient = new HBaseClient(hbaseSideTableInfo.getHost(), hbaseSideTableInfo.getParent(), executorService);"> 107 -        hBaseClient = new HBaseClient(hbaseSideTableInfo.getHost(), hbaseSideTableInfo.getParent(), executorServicðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 108 +        Config config = new Config();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +        config.overrideConfig(HbaseConfigUtils.KEY_HBASE_ZOOKEEPER_QUORUM, hbaseSideTableInfo.getHost());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +        config.overrideConfig(HbaseConfigUtils.KEY_HBASE_ZOOKEEPER_ZNODE_QUORUM, hbaseSideTableInfo.getParent());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 111 +        HbaseConfigUtils.loadKrb5Conf(hbaseConfig);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 112 +        hbaseConfig.entrySet().forEach(entity -&gt; {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +            config.overrideConfig(entity.getKey(), (String) entity.getValue());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +        });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 115 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 116 +        if (HbaseConfigUtils.asyncOpenKerberos(hbaseConfig)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +            String jaasStr = HbaseConfigUtils.buildJaasStr(hbaseConfig);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +            String jaasFilePath = HbaseConfigUtils.creatJassFile(jaasStr);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +            config.overrideConfig(HbaseConfigUtils.KEY_JAVA_SECURITY_AUTH_LOGIN_CONF, jaasFilePath);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 122 +        hBaseClient = new HBaseClient(config, executorService);</span>
 123  
 124          try {
 125              Deferred deferred = hBaseClient.ensureTableExists(tableName)
<abbr title=" 126                      .addCallbacks(arg -&gt; new CheckResult(true, &quot;&quot;), arg -&gt; new CheckResult(false, arg.toString()));"> 126                      .addCallbacks(arg -&gt; new CheckResult(true, &quot;&quot;), arg -&gt; new CheckResult(false, arg.toString()))ðŸ”µ</abbr>
 127  
 128              CheckResult result = (CheckResult) deferred.join();
 129              if(!result.isConnect()){
 130                  throw new RuntimeException(result.getExceptionMsg());
 131              }
 132  
 133          } catch (Exception e) {
 134              throw new RuntimeException(&quot;create hbase connection fail:&quot;, e);
 135          }
 136  
 137          HbaseAsyncSideInfo hbaseAsyncSideInfo = (HbaseAsyncSideInfo) sideInfo;
 138          if(hbaseSideTableInfo.isPreRowKey()){
 139              rowKeyMode = new PreRowKeyModeDealerDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBaseClient,
 140                      openCache(), sideInfo.getJoinType(), sideInfo.getOutFieldInfoList(),
 141                      sideInfo.getInFieldIndex(), sideInfo.getSideFieldIndex());
 142          }else{
 143              rowKeyMode = new RowKeyEqualModeDealer(hbaseAsyncSideInfo.getColRefType(), colNames, hBaseClient,
 144                      openCache(), sideInfo.getJoinType(), sideInfo.getOutFieldInfoList(),
 145                      sideInfo.getInFieldIndex(), sideInfo.getSideFieldIndex());
 146          }
 147      }
 148  
 149      @Override
<abbr title=" 150      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) throws Exception {"> 150      public void handleAsyncInvoke(Map&lt;String, Object&gt; inputParams, CRow input, ResultFuture&lt;CRow&gt; resultFuture) thðŸ”µ</abbr>

<abbr title=" 151          rowKeyMode.asyncGetData(tableName, buildCacheKey(inputParams), input, resultFuture, sideInfo.getSideCache());"> 151          rowKeyMode.asyncGetData(tableName, buildCacheKey(inputParams), input, resultFuture, sideInfo.getSideCache(ðŸ”µ</abbr>
 152      }
 153  
 154      @Override
 155      public String buildCacheKey(Map&lt;String, Object&gt; inputParams) {
 156          return ((HbaseAsyncSideInfo)sideInfo).getRowKeyBuilder().getRowKey(inputParams);
 157      }
 158  
 159      @Override
 160      public Row fillData(Row input, Object sideInput){
 161          List&lt;Object&gt; sideInputList = (List&lt;Object&gt;) sideInput;
 162          Row row = new Row(sideInfo.getOutFieldInfoList().size());
 163          for(Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getInFieldIndex().entrySet()){
 164              Object obj = input.getField(entry.getValue());
<abbr title=" 165              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfo().getTypeAt(entry.getValue()).getClass());"> 165              boolean isTimeIndicatorTypeInfo = TimeIndicatorTypeInfo.class.isAssignableFrom(sideInfo.getRowTypeInfoðŸ”µ</abbr>
 166  
 167              if(obj instanceof Timestamp &amp;&amp; isTimeIndicatorTypeInfo){
 168                  obj = ((Timestamp)obj).getTime();
 169              }
 170  

 171              row.setField(entry.getKey(), obj);
 172          }
 173  
 174          for(Map.Entry&lt;Integer, Integer&gt; entry : sideInfo.getSideFieldIndex().entrySet()){
 175              if(sideInputList == null){
 176                  row.setField(entry.getKey(), null);
 177              }else{
 178                  row.setField(entry.getKey(), sideInputList.get(entry.getValue()));
 179              }
 180          }
 181  
 182          return row;
 183      }
 184  
 185      @Override
 186      public void close() throws Exception {
 187          super.close();
 188          hBaseClient.shutdown();
 189      }
 190  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 191 -</span>
 192      class CheckResult{
 193  
 194          private boolean connect;
 195  
 196          private String exceptionMsg;
 197  
 198          CheckResult(boolean connect, String msg){
 199              this.connect = connect;
 200              this.exceptionMsg = msg;
 201          }
 202  
 203          public boolean isConnect() {
 204              return connect;
 205          }
 206  
 207          public void setConnect(boolean connect) {
 208              this.connect = connect;
 209          }
 210  
 211          public String getExceptionMsg() {
 212              return exceptionMsg;
 213          }
 214  
 215          public void setExceptionMsg(String exceptionMsg) {
 216              this.exceptionMsg = exceptionMsg;
 217          }
 218      }
 219  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            