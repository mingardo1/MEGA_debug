<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>223</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    223
                    <a href="222.html">prev</a>
                    <a href="224.html">next</a>
                    <a href="223_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_c63b8b82d3cd7dbb375f92cf8e3bf62d73bc0f81_src/com/android/launcher3/LauncherProvider.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;c63b8b82d3cd7dbb375f92cf8e3bf62d73bc0f81:src/com/android/launcher3/LauncherProvider.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;c63b8b82d3cd7dbb375f92cf8e3bf62d73bc0f81^1:src/com/android/launcher3/LauncherProvider.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;c63b8b82d3cd7dbb375f92cf8e3bf62d73bc0f81^2:src/com/android/launcher3/LauncherProvider.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;7470c817e46f241bf37a7874fa7cf7493fc7cf94:src/com/android/launcher3/LauncherProvider.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [j], [j]], subset: [[b], [bj], [j]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.appwidget.AppWidgetHost;
  20 import android.appwidget.AppWidgetManager;
  21 import android.content.ComponentName;
  22 import android.content.ContentProvider;
  23 import android.content.ContentProviderOperation;
  24 import android.content.ContentProviderResult;
  25 import android.content.ContentResolver;
  26 import android.content.ContentUris;
  27 import android.content.ContentValues;
  28 import android.content.Context;
  29 import android.content.Intent;
  30 import android.content.OperationApplicationException;
  31 import android.content.SharedPreferences;
  32 import android.content.res.Resources;
  33 import android.database.Cursor;
  34 import android.database.SQLException;
  35 import android.database.sqlite.SQLiteDatabase;
  36 import android.database.sqlite.SQLiteOpenHelper;
  37 import android.database.sqlite.SQLiteQueryBuilder;
  38 import android.net.Uri;
  39 import android.os.StrictMode;
  40 import android.text.TextUtils;
  41 import android.util.Log;
  42 import android.util.SparseArray;
  43 
  44 import com.android.launcher3.AutoInstallsLayout.LayoutParserCallback;
  45 import com.android.launcher3.LauncherSettings.Favorites;
  46 import com.android.launcher3.compat.UserHandleCompat;
  47 import com.android.launcher3.compat.UserManagerCompat;
  48 import com.android.launcher3.config.ProviderConfig;
  49 
  50 import java.io.File;
  51 import java.net.URISyntaxException;
  52 import java.util.ArrayList;
  53 import java.util.Collections;
  54 import java.util.HashSet;
  55 
  56 public class LauncherProvider extends ContentProvider {
  57     private static final String TAG = &quot;Launcher.LauncherProvider&quot;;
  58     private static final boolean LOGD = false;
  59 
  60 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  61     private static final int DATABASE_VERSION = 21;</span>
  62 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  63     private static final int MIN_DATABASE_VERSION = 12;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  64     private static final int DATABASE_VERSION = 21;</span>
  65 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  66     private static final int MIN_DATABASE_VERSION = 12;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  67     private static final int DATABASE_VERSION = 22;</span>
  68 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  69 
  70     static final String OLD_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
  71     static final String AUTHORITY = ProviderConfig.AUTHORITY;
  72 
  73     static final String TABLE_FAVORITES = &quot;favorites&quot;;
  74     static final String TABLE_WORKSPACE_SCREENS = &quot;workspaceScreens&quot;;
  75     static final String PARAMETER_NOTIFY = &quot;notify&quot;;
  76     static final String EMPTY_DATABASE_CREATED = &quot;EMPTY_DATABASE_CREATED&quot;;
  77 
  78     private static final String URI_PARAM_IS_EXTERNAL_ADD = &quot;isExternalAdd&quot;;
  79 
  80     private LauncherProviderChangeListener mListener;
  81 
  82     /**
  83      * {@link Uri} triggered at any registered {@link android.database.ContentObserver} when
  84      * {@link AppWidgetHost#deleteHost()} is called during database creation.
  85      * Use this to recall {@link AppWidgetHost#startListening()} if needed.
  86      */
  87     static final Uri CONTENT_APPWIDGET_RESET_URI =
  88             Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/appWidgetReset&quot;);
  89 
  90     private DatabaseHelper mOpenHelper;
  91 
  92     @Override
  93     public boolean onCreate() {
  94         final Context context = getContext();
  95         StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();
  96         mOpenHelper = new DatabaseHelper(context);
  97         StrictMode.setThreadPolicy(oldPolicy);
  98         LauncherAppState.setLauncherProvider(this);
  99         return true;
 100     }
 101 
 102     public boolean wasNewDbCreated() {
 103         return mOpenHelper.wasNewDbCreated();
 104     }
 105 
 106     public void setLauncherProviderChangeListener(LauncherProviderChangeListener listener) {
 107         mListener = listener;
 108     }
 109 
 110     @Override
 111     public String getType(Uri uri) {
 112         SqlArguments args = new SqlArguments(uri, null, null);
 113         if (TextUtils.isEmpty(args.where)) {
 114             return &quot;vnd.android.cursor.dir/&quot; + args.table;
 115         } else {
 116             return &quot;vnd.android.cursor.item/&quot; + args.table;
 117         }
 118     }
 119 
 120     @Override
 121     public Cursor query(Uri uri, String[] projection, String selection,
 122             String[] selectionArgs, String sortOrder) {
 123 
 124         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 125         SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
 126         qb.setTables(args.table);
 127 
 128         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 129         Cursor result = qb.query(db, projection, args.where, args.args, null, null, sortOrder);
 130         result.setNotificationUri(getContext().getContentResolver(), uri);
 131 
 132         return result;
 133     }
 134 
 135     private static long dbInsertAndCheck(DatabaseHelper helper,
 136             SQLiteDatabase db, String table, String nullColumnHack, ContentValues values) {
 137         if (values == null) {
 138             throw new RuntimeException(&quot;Error: attempting to insert null values&quot;);
 139         }
 140         if (!values.containsKey(LauncherSettings.ChangeLogColumns._ID)) {
 141             throw new RuntimeException(&quot;Error: attempting to add item without specifying an id&quot;);
 142         }
 143         helper.checkId(table, values);
 144         return db.insert(table, nullColumnHack, values);
 145     }
 146 
 147     @Override
 148     public Uri insert(Uri uri, ContentValues initialValues) {
 149         SqlArguments args = new SqlArguments(uri);
 150 
 151         // In very limited cases, we support system|signature permission apps to add to the db
 152         String externalAdd = uri.getQueryParameter(URI_PARAM_IS_EXTERNAL_ADD);
 153         if (externalAdd != null &amp;&amp; &quot;true&quot;.equals(externalAdd)) {
 154             if (!mOpenHelper.initializeExternalAdd(initialValues)) {
 155                 return null;
 156             }
 157         }
 158 
 159         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 160         addModifiedTime(initialValues);
 161         final long rowId = dbInsertAndCheck(mOpenHelper, db, args.table, null, initialValues);
 162         if (rowId &lt;= 0) return null;
 163 
 164         uri = ContentUris.withAppendedId(uri, rowId);
 165         sendNotify(uri);
 166 
 167         return uri;
 168     }
 169 
 170 
 171     @Override
 172     public int bulkInsert(Uri uri, ContentValues[] values) {
 173         SqlArguments args = new SqlArguments(uri);
 174 
 175         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 176         db.beginTransaction();
 177         try {
 178             int numValues = values.length;
 179             for (int i = 0; i &lt; numValues; i++) {
 180                 addModifiedTime(values[i]);
 181                 if (dbInsertAndCheck(mOpenHelper, db, args.table, null, values[i]) &lt; 0) {
 182                     return 0;
 183                 }
 184             }
 185             db.setTransactionSuccessful();
 186         } finally {
 187             db.endTransaction();
 188         }
 189 
 190         sendNotify(uri);
 191         return values.length;
 192     }
 193 
 194     @Override
 195     public ContentProviderResult[] applyBatch(ArrayList&lt;ContentProviderOperation&gt; operations)
 196             throws OperationApplicationException {
 197         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 198         db.beginTransaction();
 199         try {
 200             ContentProviderResult[] result =  super.applyBatch(operations);
 201             db.setTransactionSuccessful();
 202             return result;
 203         } finally {
 204             db.endTransaction();
 205         }
 206     }
 207 
 208     @Override
 209     public int delete(Uri uri, String selection, String[] selectionArgs) {
 210         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 211 
 212         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 213         int count = db.delete(args.table, args.where, args.args);
 214         if (count &gt; 0) sendNotify(uri);
 215 
 216         return count;
 217     }
 218 
 219     @Override
 220     public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
 221         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 222 
 223         addModifiedTime(values);
 224         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 225         int count = db.update(args.table, values, args.where, args.args);
 226         if (count &gt; 0) sendNotify(uri);
 227 
 228         return count;
 229     }
 230 
 231     private void sendNotify(Uri uri) {
 232         String notify = uri.getQueryParameter(PARAMETER_NOTIFY);
 233         if (notify == null || &quot;true&quot;.equals(notify)) {
 234             getContext().getContentResolver().notifyChange(uri, null);
 235         }
 236 
 237         // always notify the backup agent
 238         LauncherBackupAgentHelper.dataChanged(getContext());
 239         if (mListener != null) {
 240             mListener.onLauncherProviderChange();
 241         }
 242     }
 243 
 244     private static void addModifiedTime(ContentValues values) {
 245         values.put(LauncherSettings.ChangeLogColumns.MODIFIED, System.currentTimeMillis());
 246     }
 247 
 248     public long generateNewItemId() {
 249         return mOpenHelper.generateNewItemId();
 250     }
 251 
 252     public void updateMaxItemId(long id) {
 253         mOpenHelper.updateMaxItemId(id);
 254     }
 255 
 256     public long generateNewScreenId() {
 257         return mOpenHelper.generateNewScreenId();
 258     }
 259 
 260     /**
 261      * Clears all the data for a fresh start.
 262      */
 263     synchronized public void createEmptyDB() {
 264         mOpenHelper.createEmptyDB(mOpenHelper.getWritableDatabase());
 265     }
 266 
 267     public void clearFlagEmptyDbCreated() {
 268         String spKey = LauncherAppState.getSharedPreferencesKey();
 269         getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE)
 270             .edit()
 271             .remove(EMPTY_DATABASE_CREATED)
 272             .commit();
 273     }
 274 
 275     /**
 276      * Loads the default workspace based on the following priority scheme:
 277      *   1) From a package provided by play store
 278      *   2) From a partner configuration APK, already in the system image
 279      *   3) The default configuration for the particular device
 280      */
 281     synchronized public void loadDefaultFavoritesIfNecessary() {
 282         String spKey = LauncherAppState.getSharedPreferencesKey();
 283         SharedPreferences sp = getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE);
 284 
 285         if (sp.getBoolean(EMPTY_DATABASE_CREATED, false)) {
 286             Log.d(TAG, &quot;loading default workspace&quot;);
 287 
 288             AutoInstallsLayout loader = AutoInstallsLayout.get(getContext(),
 289                     mOpenHelper.mAppWidgetHost, mOpenHelper);
 290 
 291             if (loader == null) {
 292                 final Partner partner = Partner.get(getContext().getPackageManager());
 293                 if (partner != null &amp;&amp; partner.hasDefaultLayout()) {
 294                     final Resources partnerRes = partner.getResources();
 295                     int workspaceResId = partnerRes.getIdentifier(Partner.RES_DEFAULT_LAYOUT,
 296                             &quot;xml&quot;, partner.getPackageName());
 297                     if (workspaceResId != 0) {
 298                         loader = new DefaultLayoutParser(getContext(), mOpenHelper.mAppWidgetHost,
 299                                 mOpenHelper, partnerRes, workspaceResId);
 300                     }
 301                 }
 302             }
 303 
 304             final boolean usingExternallyProvidedLayout = loader != null;
 305             if (loader == null) {
 306                 loader = getDefaultLayoutParser();
 307             }
 308             // Populate favorites table with initial favorites
 309             if ((mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(), loader) &lt;= 0)
 310                     &amp;&amp; usingExternallyProvidedLayout) {
 311                 // Unable to load external layout. Cleanup and load the internal layout.
 312                 createEmptyDB();
 313                 mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(),
 314                         getDefaultLayoutParser());
 315             }
 316             clearFlagEmptyDbCreated();
 317         }
 318     }
 319 
 320     private DefaultLayoutParser getDefaultLayoutParser() {
 321         int defaultLayout = LauncherAppState.getInstance()
 322                 .getDynamicGrid().getDeviceProfile().defaultLayoutId;
 323         return new DefaultLayoutParser(getContext(), mOpenHelper.mAppWidgetHost,
 324                 mOpenHelper, getContext().getResources(), defaultLayout);
 325     }
 326 
 327     public void migrateLauncher2Shortcuts() {
 328         mOpenHelper.migrateLauncher2Shortcuts(mOpenHelper.getWritableDatabase(),
 329                 Uri.parse(getContext().getString(R.string.old_launcher_provider_uri)));
 330     }
 331 
 332     public void updateFolderItemsRank() {
 333         mOpenHelper.updateFolderItemsRank(mOpenHelper.getWritableDatabase(), false);
 334     }
 335 
 336     public void deleteDatabase() {
 337         // Are you sure? (y/n)
 338         final SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 339         final File dbFile = new File(db.getPath());
 340         mOpenHelper.close();
 341         if (dbFile.exists()) {
 342             SQLiteDatabase.deleteDatabase(dbFile);
 343         }
 344         mOpenHelper = new DatabaseHelper(getContext());
 345     }
 346 
 347     private static class DatabaseHelper extends SQLiteOpenHelper implements LayoutParserCallback {
 348         private final Context mContext;
 349         private final AppWidgetHost mAppWidgetHost;
 350         private long mMaxItemId = -1;
 351         private long mMaxScreenId = -1;
 352 
 353         private boolean mNewDbCreated = false;
 354 
 355         DatabaseHelper(Context context) {
 356             super(context, LauncherFiles.LAUNCHER_DB, null, DATABASE_VERSION);
 357             mContext = context;
 358             mAppWidgetHost = new AppWidgetHost(context, Launcher.APPWIDGET_HOST_ID);
 359 
 360             // In the case where neither onCreate nor onUpgrade gets called, we read the maxId from
 361             // the DB here
 362             if (mMaxItemId == -1) {
 363                 mMaxItemId = initializeMaxItemId(getWritableDatabase());
 364             }
 365             if (mMaxScreenId == -1) {
 366                 mMaxScreenId = initializeMaxScreenId(getWritableDatabase());
 367             }
 368         }
 369 
 370         public boolean wasNewDbCreated() {
 371             return mNewDbCreated;
 372         }
 373 
 374         /**
 375          * Send notification that we&#x27;ve deleted the {@link AppWidgetHost},
 376          * probably as part of the initial database creation. The receiver may
 377          * want to re-call {@link AppWidgetHost#startListening()} to ensure
 378          * callbacks are correctly set.
 379          */
 380         private void sendAppWidgetResetNotify() {
 381             final ContentResolver resolver = mContext.getContentResolver();
 382             resolver.notifyChange(CONTENT_APPWIDGET_RESET_URI, null);
 383         }
 384 
 385         @Override
 386         public void onCreate(SQLiteDatabase db) {
 387             if (LOGD) Log.d(TAG, &quot;creating new launcher database&quot;);
 388 
 389             mMaxItemId = 1;
 390             mMaxScreenId = 0;
 391             mNewDbCreated = true;
 392 
 393             UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 394             long userSerialNumber = userManager.getSerialNumberForUser(
 395                     UserHandleCompat.myUserHandle());
 396 
 397             db.execSQL(&quot;CREATE TABLE favorites (&quot; +
 398                     &quot;_id INTEGER PRIMARY KEY,&quot; +
 399                     &quot;title TEXT,&quot; +
 400                     &quot;intent TEXT,&quot; +
 401                     &quot;container INTEGER,&quot; +
 402                     &quot;screen INTEGER,&quot; +
 403                     &quot;cellX INTEGER,&quot; +
 404                     &quot;cellY INTEGER,&quot; +
 405                     &quot;spanX INTEGER,&quot; +
 406                     &quot;spanY INTEGER,&quot; +
 407                     &quot;itemType INTEGER,&quot; +
 408                     &quot;appWidgetId INTEGER NOT NULL DEFAULT -1,&quot; +
 409                     &quot;isShortcut INTEGER,&quot; +
 410                     &quot;iconType INTEGER,&quot; +
 411                     &quot;iconPackage TEXT,&quot; +
 412                     &quot;iconResource TEXT,&quot; +
 413                     &quot;icon BLOB,&quot; +
 414                     &quot;uri TEXT,&quot; +
 415                     &quot;displayMode INTEGER,&quot; +
 416                     &quot;appWidgetProvider TEXT,&quot; +
 417                     &quot;modified INTEGER NOT NULL DEFAULT 0,&quot; +
 418                     &quot;restored INTEGER NOT NULL DEFAULT 0,&quot; +
 419                     &quot;profileId INTEGER DEFAULT &quot; + userSerialNumber + &quot;,&quot; +
 420                     &quot;rank INTEGER NOT NULL DEFAULT 0&quot; +
 421                     &quot;);&quot;);
 422             addWorkspacesTable(db);
 423 
 424             // Database was just created, so wipe any previous widgets
 425             if (mAppWidgetHost != null) {
 426                 mAppWidgetHost.deleteHost();
 427                 sendAppWidgetResetNotify();
 428             }
 429 
 430             // Fresh and clean launcher DB.
 431             mMaxItemId = initializeMaxItemId(db);
 432             setFlagEmptyDbCreated();
 433         }
 434 
 435         private void addWorkspacesTable(SQLiteDatabase db) {
 436             db.execSQL(&quot;CREATE TABLE &quot; + TABLE_WORKSPACE_SCREENS + &quot; (&quot; +
 437                     LauncherSettings.WorkspaceScreens._ID + &quot; INTEGER PRIMARY KEY,&quot; +
 438                     LauncherSettings.WorkspaceScreens.SCREEN_RANK + &quot; INTEGER,&quot; +
 439                     LauncherSettings.ChangeLogColumns.MODIFIED + &quot; INTEGER NOT NULL DEFAULT 0&quot; +
 440                     &quot;);&quot;);
 441         }
 442 
 443         private void removeOrphanedItems(SQLiteDatabase db) {
 444             // Delete items directly on the workspace who&#x27;s screen id doesn&#x27;t exist
 445             //  &quot;DELETE FROM favorites WHERE screen NOT IN (SELECT _id FROM workspaceScreens)
 446             //   AND container = -100&quot;
 447             String removeOrphanedDesktopItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +
 448                     &quot; WHERE &quot; +
 449                     LauncherSettings.Favorites.SCREEN + &quot; NOT IN (SELECT &quot; +
 450                     LauncherSettings.WorkspaceScreens._ID + &quot; FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot;)&quot; +
 451                     &quot; AND &quot; +
 452                     LauncherSettings.Favorites.CONTAINER + &quot; = &quot; +
 453                     LauncherSettings.Favorites.CONTAINER_DESKTOP;
 454             db.execSQL(removeOrphanedDesktopItems);
 455 
 456             // Delete items contained in folders which no longer exist (after above statement)
 457             //  &quot;DELETE FROM favorites  WHERE container &lt;&gt; -100 AND container &lt;&gt; -101 AND container
 458             //   NOT IN (SELECT _id FROM favorites WHERE itemType = 2)&quot;
 459             String removeOrphanedFolderItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +
 460                     &quot; WHERE &quot; +
 461                     LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +
 462                     LauncherSettings.Favorites.CONTAINER_DESKTOP +
 463                     &quot; AND &quot;
 464                     + LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +
 465                     LauncherSettings.Favorites.CONTAINER_HOTSEAT +
 466                     &quot; AND &quot;
 467                     + LauncherSettings.Favorites.CONTAINER + &quot; NOT IN (SELECT &quot; +
 468                     LauncherSettings.Favorites._ID + &quot; FROM &quot; + TABLE_FAVORITES +
 469                     &quot; WHERE &quot; + LauncherSettings.Favorites.ITEM_TYPE + &quot; = &quot; +
 470                     LauncherSettings.Favorites.ITEM_TYPE_FOLDER + &quot;)&quot;;
 471             db.execSQL(removeOrphanedFolderItems);
 472         }
 473 
 474         private void setFlagJustLoadedOldDb() {
 475             String spKey = LauncherAppState.getSharedPreferencesKey();
 476             SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 477             sp.edit().putBoolean(EMPTY_DATABASE_CREATED, false).commit();
 478         }
 479 
 480         private void setFlagEmptyDbCreated() {
 481             String spKey = LauncherAppState.getSharedPreferencesKey();
 482             SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 483             sp.edit().putBoolean(EMPTY_DATABASE_CREATED, true).commit();
 484         }
 485 
 486         @Override
 487         public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 488             if (LOGD) Log.d(TAG, &quot;onUpgrade triggered: &quot; + oldVersion);
 489             switch (oldVersion) {
 490                 // The version cannot be lower that 12, as Launcher3 never supported a lower
 491                 // version of the DB.
 492                 case 12: {
 493                     // With the new shrink-wrapped and re-orderable workspaces, it makes sense
 494                     // to persist workspace screens and their relative order.
 495                     mMaxScreenId = 0;
 496                     addWorkspacesTable(db);
 497                 }
 498                 case 13: {
 499                     db.beginTransaction();
 500                     try {
 501                         // Insert new column for holding widget provider name
 502                         db.execSQL(&quot;ALTER TABLE favorites &quot; +
 503                                 &quot;ADD COLUMN appWidgetProvider TEXT;&quot;);
 504                         db.setTransactionSuccessful();
 505                     } catch (SQLException ex) {
 506                         Log.e(TAG, ex.getMessage(), ex);
 507                         // Old version remains, which means we wipe old data
 508                         break;
 509                     } finally {
 510                         db.endTransaction();
 511                     }
 512                 }
 513                 case 14: {
 514                     db.beginTransaction();
 515                     try {
 516                         // Insert new column for holding update timestamp
 517                         db.execSQL(&quot;ALTER TABLE favorites &quot; +
 518                                 &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);
 519                         db.execSQL(&quot;ALTER TABLE workspaceScreens &quot; +
 520                                 &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);
 521                         db.setTransactionSuccessful();
 522                     } catch (SQLException ex) {
 523                         Log.e(TAG, ex.getMessage(), ex);
 524                         // Old version remains, which means we wipe old data
 525                         break;
 526                     } finally {
 527                         db.endTransaction();
 528                     }
 529                 }
 530                 case 15: {
 531                     db.beginTransaction();
 532                     try {
 533                         // Insert new column for holding restore status
 534                         db.execSQL(&quot;ALTER TABLE favorites &quot; +
 535                                 &quot;ADD COLUMN restored INTEGER NOT NULL DEFAULT 0;&quot;);
 536                         db.setTransactionSuccessful();
 537                     } catch (SQLException ex) {
 538                         Log.e(TAG, ex.getMessage(), ex);
 539                         // Old version remains, which means we wipe old data
 540                         break;
 541                     } finally {
 542                         db.endTransaction();
 543                     }
 544                 }
 545                 case 16: {
 546                     // We use the db version upgrade here to identify users who may not have seen
 547                     // clings yet (because they weren&#x27;t available), but for whom the clings are now
 548                     // available (tablet users). Because one of the possible cling flows (migration)
 549                     // is very destructive (wipes out workspaces), we want to prevent this from showing
 550                     // until clear data. We do so by marking that the clings have been shown.
 551                     LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);
 552                 }
 553                 case 17: {
 554                     // No-op
 555                 }
 556                 case 18: {
 557                     // Due to a data loss bug, some users may have items associated with screen ids
 558                     // which no longer exist. Since this can cause other problems, and since the user
 559                     // will never see these items anyway, we use database upgrade as an opportunity to
 560                     // clean things up.
 561                     removeOrphanedItems(db);
 562                 }
 563                 case 19: {
 564                     // Add userId column
 565                     if (!addProfileColumn(db)) {
 566                         // Old version remains, which means we wipe old data
 567                         break;
 568                     }
 569                 }
 570                 case 20:
 571                     if (!updateFolderItemsRank(db, true)) {
 572                         break;
 573                     }
 574                 case 21: {
 575                     // DB Upgraded successfully
 576                     return;
 577                 }
 578             }
 579 
 580 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 581             // DB was not upgraded</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 582             Log.w(TAG, &quot;Destroying all old data.&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 583             createEmptyDB(db);</span>
 584 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 585             if (version &lt; 15) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 586                 db.beginTransaction();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 587                 try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 588                     // Insert new column for holding update timestamp</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 589                     db.execSQL(&quot;ALTER TABLE favorites &quot; +</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 590                             &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 591                     db.execSQL(&quot;ALTER TABLE workspaceScreens &quot; +</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 592                             &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 593                     db.setTransactionSuccessful();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 594                     version = 15;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 595                 } catch (SQLException ex) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 596                     // Old version remains, which means we wipe old data</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 597                     Log.e(TAG, ex.getMessage(), ex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 598                 } finally {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 599                     db.endTransaction();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 600                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 601             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 602 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 603 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 604             if (version &lt; 16) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 605                 db.beginTransaction();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 606                 try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 607                     // Insert new column for holding restore status</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 608                     db.execSQL(&quot;ALTER TABLE favorites &quot; +</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 609                             &quot;ADD COLUMN restored INTEGER NOT NULL DEFAULT 0;&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 610                     db.setTransactionSuccessful();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 611                     version = 16;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 612                 } catch (SQLException ex) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 613                     // Old version remains, which means we wipe old data</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 614                     Log.e(TAG, ex.getMessage(), ex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 615                 } finally {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 616                     db.endTransaction();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 617                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 618             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 619 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 620             if (version &lt; 17) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 621                 // We use the db version upgrade here to identify users who may not have seen</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 622                 // clings yet (because they weren&#x27;t available), but for whom the clings are now</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 623                 // available (tablet users). Because one of the possible cling flows (migration)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 624                 // is very destructive (wipes out workspaces), we want to prevent this from showing</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 625                 // until clear data. We do so by marking that the clings have been shown.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 626                 LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 627                 version = 17;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 628             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 629 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 630             if (version &lt; 18) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 631                 // No-op</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 632                 version = 18;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 633             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 634 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 635             if (version &lt; 19) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 636                 // Due to a data loss bug, some users may have items associated with screen ids</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 637                 // which no longer exist. Since this can cause other problems, and since the user</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 638                 // will never see these items anyway, we use database upgrade as an opportunity to</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 639                 // clean things up.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 640                 removeOrphanedItems(db);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 641                 version = 19;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 642             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 643 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 644             if (version &lt; 20) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 645                 // Add userId column</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 646                 if (addProfileColumn(db)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 647                     version = 20;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 648                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 649                 // else old version remains, which means we wipe old data</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 650             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 651 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 652             if (version &lt; 21) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 653                 if (updateFolderItemsRank(db, true)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 654                     version  = 21;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 655                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 656             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 657 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 658             if (version != DATABASE_VERSION) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 659                 Log.w(TAG, &quot;Destroying all old data.&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 660                 createEmptyDB(db);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 661             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 662         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 663 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 664         @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 665         public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 666             // This shouldn&#x27;t happen -- throw our hands up in the air and start over.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 667             Log.w(TAG, &quot;Database version downgrade from: &quot; + oldVersion + &quot; to &quot; + newVersion +</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 668                     &quot;. Wiping databse.&quot;);</span>
 669 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 670             if (version &lt; 15) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 671                 db.beginTransaction();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 672                 try {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 673                     // Insert new column for holding update timestamp</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 674                     db.execSQL(&quot;ALTER TABLE favorites &quot; +</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 675                             &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 676                     db.execSQL(&quot;ALTER TABLE workspaceScreens &quot; +</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 677                             &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 678                     db.setTransactionSuccessful();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 679                     version = 15;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 680                 } catch (SQLException ex) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 681                     // Old version remains, which means we wipe old data</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 682                     Log.e(TAG, ex.getMessage(), ex);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 683                 } finally {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 684                     db.endTransaction();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 685                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 686             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 687 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 688 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 689             if (version &lt; 16) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 690                 db.beginTransaction();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 691                 try {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 692                     // Insert new column for holding restore status</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 693                     db.execSQL(&quot;ALTER TABLE favorites &quot; +</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 694                             &quot;ADD COLUMN restored INTEGER NOT NULL DEFAULT 0;&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 695                     db.setTransactionSuccessful();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 696                     version = 16;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 697                 } catch (SQLException ex) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 698                     // Old version remains, which means we wipe old data</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 699                     Log.e(TAG, ex.getMessage(), ex);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 700                 } finally {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 701                     db.endTransaction();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 702                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 703             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 704 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 705             if (version &lt; 17) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 706                 // We use the db version upgrade here to identify users who may not have seen</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 707                 // clings yet (because they weren&#x27;t available), but for whom the clings are now</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 708                 // available (tablet users). Because one of the possible cling flows (migration)</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 709                 // is very destructive (wipes out workspaces), we want to prevent this from showing</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 710                 // until clear data. We do so by marking that the clings have been shown.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 711                 LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 712                 version = 17;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 713             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 714 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 715             if (version &lt; 18) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 716                 // No-op</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 717                 version = 18;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 718             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 719 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 720             if (version &lt; 19) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 721                 // Due to a data loss bug, some users may have items associated with screen ids</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 722                 // which no longer exist. Since this can cause other problems, and since the user</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 723                 // will never see these items anyway, we use database upgrade as an opportunity to</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 724                 // clean things up.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 725                 removeOrphanedItems(db);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 726                 version = 19;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 727             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 728 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 729             if (version &lt; 20) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 730                 // Add userId column</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 731                 if (addProfileColumn(db)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 732                     version = 20;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 733                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 734                 // else old version remains, which means we wipe old data</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 735             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 736 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 737             if (version &lt; 21) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 738                 if (updateFolderItemsRank(db, true)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 739                     version  = 21;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 740                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 741             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 742 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 743             if (version == 21) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 744                 // Recreate workspace table with screen id a primary key</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 745                 if (recreateWorkspaceTable(db)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 746                     version = 22;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 747                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 748             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 749 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 750             if (version != DATABASE_VERSION) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 751                 Log.w(TAG, &quot;Destroying all old data.&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 752                 createEmptyDB(db);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 753             }</span>
 754 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 755         }
 756 
 757         @Override
 758         public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 759             // This shouldn&#x27;t happen -- throw our hands up in the air and start over.
 760             Log.w(TAG, &quot;Database version downgrade from: &quot; + oldVersion + &quot; to &quot; + newVersion +
 761                     &quot;. Wiping databse.&quot;);
 762             createEmptyDB(db);
 763         }
 764 
 765 
 766         /**
 767          * Clears all the data for a fresh start.
 768          */
 769         public void createEmptyDB(SQLiteDatabase db) {
 770             db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_FAVORITES);
 771             db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
 772             onCreate(db);
 773         }
 774 
 775         /**
 776          * Recreates workspace table and migrates data to the new table.
 777          */
 778         public boolean recreateWorkspaceTable(SQLiteDatabase db) {
 779             db.beginTransaction();
 780             try {
 781                 Cursor c = db.query(TABLE_WORKSPACE_SCREENS,
 782                         new String[] {LauncherSettings.WorkspaceScreens._ID},
 783                         null, null, null, null,
 784                         LauncherSettings.WorkspaceScreens.SCREEN_RANK);
 785                 ArrayList&lt;Long&gt; sortedIDs = new ArrayList&lt;Long&gt;();
 786                 long maxId = 0;
 787                 try {
 788                     while (c.moveToNext()) {
 789                         Long id = c.getLong(0);
 790                         if (!sortedIDs.contains(id)) {
 791                             sortedIDs.add(id);
 792                             maxId = Math.max(maxId, id);
 793                         }
 794                     }
 795                 } finally {
 796                     c.close();
 797                 }
 798 
 799                 db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
 800                 addWorkspacesTable(db);
 801 
 802                 // Add all screen ids back
 803                 int total = sortedIDs.size();
 804                 for (int i = 0; i &lt; total; i++) {
 805                     ContentValues values = new ContentValues();
 806                     values.put(LauncherSettings.WorkspaceScreens._ID, sortedIDs.get(i));
 807                     values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
 808                     addModifiedTime(values);
 809                     db.insertOrThrow(TABLE_WORKSPACE_SCREENS, null, values);
 810                 }
 811                 db.setTransactionSuccessful();
 812                 mMaxScreenId = maxId;
 813             } catch (SQLException ex) {
 814                 // Old version remains, which means we wipe old data
 815                 Log.e(TAG, ex.getMessage(), ex);
 816                 return false;
 817             } finally {
 818                 db.endTransaction();
 819             }
 820             return true;
 821         }
 822 
 823         private boolean updateFolderItemsRank(SQLiteDatabase db, boolean addRankColumn) {
 824             db.beginTransaction();
 825             try {
 826                 if (addRankColumn) {
 827                     // Insert new column for holding rank
 828                     db.execSQL(&quot;ALTER TABLE favorites ADD COLUMN rank INTEGER NOT NULL DEFAULT 0;&quot;);
 829                 }
 830 
 831                 // Get a map for folder ID to folder width
 832                 Cursor c = db.rawQuery(&quot;SELECT container, MAX(cellX) FROM favorites&quot;
 833                         + &quot; WHERE container IN (SELECT _id FROM favorites WHERE itemType = ?)&quot;
 834                         + &quot; GROUP BY container;&quot;,
 835                         new String[] {Integer.toString(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)});
 836 
 837                 while (c.moveToNext()) {
 838                     db.execSQL(&quot;UPDATE favorites SET rank=cellX+(cellY*?) WHERE &quot;
 839                             + &quot;container=? AND cellX IS NOT NULL AND cellY IS NOT NULL;&quot;,
 840                             new Object[] {c.getLong(1) + 1, c.getLong(0)});
 841                 }
 842 
 843                 c.close();
 844                 db.setTransactionSuccessful();
 845             } catch (SQLException ex) {
 846                 // Old version remains, which means we wipe old data
 847                 Log.e(TAG, ex.getMessage(), ex);
 848                 return false;
 849             } finally {
 850                 db.endTransaction();
 851             }
 852             return true;
 853         }
 854 
 855         private boolean addProfileColumn(SQLiteDatabase db) {
 856             db.beginTransaction();
 857             try {
 858                 UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 859                 // Default to the serial number of this user, for older
 860                 // shortcuts.
 861                 long userSerialNumber = userManager.getSerialNumberForUser(
 862                         UserHandleCompat.myUserHandle());
 863                 // Insert new column for holding user serial number
 864                 db.execSQL(&quot;ALTER TABLE favorites &quot; +
 865                         &quot;ADD COLUMN profileId INTEGER DEFAULT &quot;
 866                                         + userSerialNumber + &quot;;&quot;);
 867                 db.setTransactionSuccessful();
 868             } catch (SQLException ex) {
 869                 // Old version remains, which means we wipe old data
 870                 Log.e(TAG, ex.getMessage(), ex);
 871                 return false;
 872             } finally {
 873                 db.endTransaction();
 874             }
 875             return true;
 876         }
 877 
 878         // Generates a new ID to use for an object in your database. This method should be only
 879         // called from the main UI thread. As an exception, we do call it when we call the
 880         // constructor from the worker thread; however, this doesn&#x27;t extend until after the
 881         // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
 882         // after that point
 883         @Override
 884         public long generateNewItemId() {
 885             if (mMaxItemId &lt; 0) {
 886                 throw new RuntimeException(&quot;Error: max item id was not initialized&quot;);
 887             }
 888             mMaxItemId += 1;
 889             return mMaxItemId;
 890         }
 891 
 892         @Override
 893         public long insertAndCheck(SQLiteDatabase db, ContentValues values) {
 894             return dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values);
 895         }
 896 
 897         public void updateMaxItemId(long id) {
 898             mMaxItemId = id + 1;
 899         }
 900 
 901         public void checkId(String table, ContentValues values) {
 902             long id = values.getAsLong(LauncherSettings.BaseLauncherColumns._ID);
 903             if (table == LauncherProvider.TABLE_WORKSPACE_SCREENS) {
 904                 mMaxScreenId = Math.max(id, mMaxScreenId);
 905             }  else {
 906                 mMaxItemId = Math.max(id, mMaxItemId);
 907             }
 908         }
 909 
 910         private long initializeMaxItemId(SQLiteDatabase db) {
 911             Cursor c = db.rawQuery(&quot;SELECT MAX(_id) FROM favorites&quot;, null);
 912 
 913             // get the result
 914             final int maxIdIndex = 0;
 915             long id = -1;
 916             if (c != null &amp;&amp; c.moveToNext()) {
 917                 id = c.getLong(maxIdIndex);
 918             }
 919             if (c != null) {
 920                 c.close();
 921             }
 922 
 923             if (id == -1) {
 924                 throw new RuntimeException(&quot;Error: could not query max item id&quot;);
 925             }
 926 
 927             return id;
 928         }
 929 
 930         // Generates a new ID to use for an workspace screen in your database. This method
 931         // should be only called from the main UI thread. As an exception, we do call it when we
 932         // call the constructor from the worker thread; however, this doesn&#x27;t extend until after the
 933         // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
 934         // after that point
 935         public long generateNewScreenId() {
 936             if (mMaxScreenId &lt; 0) {
 937                 throw new RuntimeException(&quot;Error: max screen id was not initialized&quot;);
 938             }
 939             mMaxScreenId += 1;
 940             // Log to disk
 941             Launcher.addDumpLog(TAG, &quot;11683562 - generateNewScreenId(): &quot; + mMaxScreenId, true);
 942             return mMaxScreenId;
 943         }
 944 
 945         private long initializeMaxScreenId(SQLiteDatabase db) {
<abbr title=" 946             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);"> 946             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TA</abbr>
 947 
 948             // get the result
 949             final int maxIdIndex = 0;
 950             long id = -1;
 951             if (c != null &amp;&amp; c.moveToNext()) {
 952                 id = c.getLong(maxIdIndex);
 953             }
 954             if (c != null) {
 955                 c.close();
 956             }
 957 
 958             if (id == -1) {
 959                 throw new RuntimeException(&quot;Error: could not query max screen id&quot;);
 960             }
 961 
 962             // Log to disk
 963             Launcher.addDumpLog(TAG, &quot;11683562 - initializeMaxScreenId(): &quot; + id, true);
 964             return id;
 965         }
 966 
 967         private boolean initializeExternalAdd(ContentValues values) {
 968             // 1. Ensure that externally added items have a valid item id
 969             long id = generateNewItemId();
 970             values.put(LauncherSettings.Favorites._ID, id);
 971 
 972             // 2. In the case of an app widget, and if no app widget id is specified, we
 973             // attempt allocate and bind the widget.
 974             Integer itemType = values.getAsInteger(LauncherSettings.Favorites.ITEM_TYPE);
 975             if (itemType != null &amp;&amp;
 976                     itemType.intValue() == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;
 977                     !values.containsKey(LauncherSettings.Favorites.APPWIDGET_ID)) {
 978 
 979                 final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
 980                 ComponentName cn = ComponentName.unflattenFromString(
 981                         values.getAsString(Favorites.APPWIDGET_PROVIDER));
 982 
 983                 if (cn != null) {
 984                     try {
 985                         int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
 986                         values.put(LauncherSettings.Favorites.APPWIDGET_ID, appWidgetId);
 987                         if (!appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,cn)) {
 988                             return false;
 989                         }
 990                     } catch (RuntimeException e) {
 991                         Log.e(TAG, &quot;Failed to initialize external widget&quot;, e);
 992                         return false;
 993                     }
 994                 } else {
 995                     return false;
 996                 }
 997             }
 998 
 999             // Add screen id if not present
1000             long screenId = values.getAsLong(LauncherSettings.Favorites.SCREEN);
1001             if (!addScreenIdIfNecessary(screenId)) {
1002                 return false;
1003             }
1004             return true;
1005         }
1006 
1007         // Returns true of screen id exists, or if successfully added
1008         private boolean addScreenIdIfNecessary(long screenId) {
1009             if (!hasScreenId(screenId)) {
1010                 int rank = getMaxScreenRank() + 1;
1011 
1012                 ContentValues v = new ContentValues();
1013                 v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1014                 v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
1015                 if (dbInsertAndCheck(this, getWritableDatabase(),
1016                         TABLE_WORKSPACE_SCREENS, null, v) &lt; 0) {
1017                     return false;
1018                 }
1019             }
1020             return true;
1021         }
1022 
1023         private boolean hasScreenId(long screenId) {
1024             SQLiteDatabase db = getWritableDatabase();
1025             Cursor c = db.rawQuery(&quot;SELECT * FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot; WHERE &quot;
1026                     + LauncherSettings.WorkspaceScreens._ID + &quot; = &quot; + screenId, null);
1027             if (c != null) {
1028                 int count = c.getCount();
1029                 c.close();
1030                 return count &gt; 0;
1031             } else {
1032                 return false;
1033             }
1034         }
1035 
1036         private int getMaxScreenRank() {
1037             SQLiteDatabase db = getWritableDatabase();
1038             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens.SCREEN_RANK
1039                     + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);
1040 
1041             // get the result
1042             final int maxRankIndex = 0;
1043             int rank = -1;
1044             if (c != null &amp;&amp; c.moveToNext()) {
1045                 rank = c.getInt(maxRankIndex);
1046             }
1047             if (c != null) {
1048                 c.close();
1049             }
1050 
1051             return rank;
1052         }
1053 
1054         private int loadFavorites(SQLiteDatabase db, AutoInstallsLayout loader) {
1055             ArrayList&lt;Long&gt; screenIds = new ArrayList&lt;Long&gt;();
1056             // TODO: Use multiple loaders with fall-back and transaction.
1057             int count = loader.loadLayout(db, screenIds);
1058 
1059             // Add the screens specified by the items above
1060             Collections.sort(screenIds);
1061             int rank = 0;
1062             ContentValues values = new ContentValues();
1063             for (Long id : screenIds) {
1064                 values.clear();
1065                 values.put(LauncherSettings.WorkspaceScreens._ID, id);
1066                 values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
1067                 if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values) &lt; 0) {
1068                     throw new RuntimeException(&quot;Failed initialize screen table&quot;
1069                             + &quot;from default layout&quot;);
1070                 }
1071                 rank++;
1072             }
1073 
1074             // Ensure that the max ids are initialized
1075             mMaxItemId = initializeMaxItemId(db);
1076             mMaxScreenId = initializeMaxScreenId(db);
1077 
1078             return count;
1079         }
1080 
1081         private void migrateLauncher2Shortcuts(SQLiteDatabase db, Uri uri) {
1082             final ContentResolver resolver = mContext.getContentResolver();
1083             Cursor c = null;
1084             int count = 0;
1085             int curScreen = 0;
1086 
1087             try {
1088                 c = resolver.query(uri, null, null, null, &quot;title ASC&quot;);
1089             } catch (Exception e) {
1090                 // Ignore
1091             }
1092 
1093             // We already have a favorites database in the old provider
1094             if (c != null) {
1095                 try {
1096                     if (c.getCount() &gt; 0) {
1097                         final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1098                         final int intentIndex
1099                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
1100                         final int titleIndex
1101                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
1102                         final int iconTypeIndex
1103                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);
1104                         final int iconIndex
1105                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1106                         final int iconPackageIndex
1107                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);
1108                         final int iconResourceIndex
1109                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);
1110                         final int containerIndex
1111                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
1112                         final int itemTypeIndex
1113                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
1114                         final int screenIndex
1115                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1116                         final int cellXIndex
1117                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1118                         final int cellYIndex
1119                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1120                         final int uriIndex
1121                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1122                         final int displayModeIndex
1123                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE);
1124                         final int profileIndex
1125                                 = c.getColumnIndex(LauncherSettings.Favorites.PROFILE_ID);
1126 
1127                         int i = 0;
1128                         int curX = 0;
1129                         int curY = 0;
1130 
1131                         final LauncherAppState app = LauncherAppState.getInstance();
1132                         final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1133                         final int width = (int) grid.numColumns;
1134                         final int height = (int) grid.numRows;
1135                         final int hotseatWidth = (int) grid.numHotseatIcons;
1136 
1137                         final HashSet&lt;String&gt; seenIntents = new HashSet&lt;String&gt;(c.getCount());
1138 
1139                         final ArrayList&lt;ContentValues&gt; shortcuts = new ArrayList&lt;ContentValues&gt;();
1140                         final ArrayList&lt;ContentValues&gt; folders = new ArrayList&lt;ContentValues&gt;();
1141                         final SparseArray&lt;ContentValues&gt; hotseat = new SparseArray&lt;ContentValues&gt;();
1142 
1143                         while (c.moveToNext()) {
1144                             final int itemType = c.getInt(itemTypeIndex);
1145                             if (itemType != Favorites.ITEM_TYPE_APPLICATION
1146                                     &amp;&amp; itemType != Favorites.ITEM_TYPE_SHORTCUT
1147                                     &amp;&amp; itemType != Favorites.ITEM_TYPE_FOLDER) {
1148                                 continue;
1149                             }
1150 
1151                             final int cellX = c.getInt(cellXIndex);
1152                             final int cellY = c.getInt(cellYIndex);
1153                             final int screen = c.getInt(screenIndex);
1154                             int container = c.getInt(containerIndex);
1155                             final String intentStr = c.getString(intentIndex);
1156 
1157                             UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
1158                             UserHandleCompat userHandle;
1159                             final long userSerialNumber;
1160                             if (profileIndex != -1 &amp;&amp; !c.isNull(profileIndex)) {
1161                                 userSerialNumber = c.getInt(profileIndex);
1162                                 userHandle = userManager.getUserForSerialNumber(userSerialNumber);
1163                             } else {
1164                                 // Default to the serial number of this user, for older
1165                                 // shortcuts.
1166                                 userHandle = UserHandleCompat.myUserHandle();
1167                                 userSerialNumber = userManager.getSerialNumberForUser(userHandle);
1168                             }
1169 
1170                             if (userHandle == null) {
1171                                 Launcher.addDumpLog(TAG, &quot;skipping deleted user&quot;, true);
1172                                 continue;
1173                             }
1174 
1175                             Launcher.addDumpLog(TAG, &quot;migrating \&quot;&quot;
1176                                 + c.getString(titleIndex) + &quot;\&quot; (&quot;
1177                                 + cellX + &quot;,&quot; + cellY + &quot;@&quot;
1178                                 + LauncherSettings.Favorites.containerToString(container)
1179                                 + &quot;/&quot; + screen
1180                                 + &quot;): &quot; + intentStr, true);
1181 
1182                             if (itemType != Favorites.ITEM_TYPE_FOLDER) {
1183 
1184                                 final Intent intent;
1185                                 final ComponentName cn;
1186                                 try {
1187                                     intent = Intent.parseUri(intentStr, 0);
1188                                 } catch (URISyntaxException e) {
1189                                     // bogus intent?
1190                                     Launcher.addDumpLog(TAG,
1191                                             &quot;skipping invalid intent uri&quot;, true);
1192                                     continue;
1193                                 }
1194 
1195                                 cn = intent.getComponent();
1196                                 if (TextUtils.isEmpty(intentStr)) {
1197                                     // no intent? no icon
1198                                     Launcher.addDumpLog(TAG, &quot;skipping empty intent&quot;, true);
1199                                     continue;
1200                                 } else if (cn != null &amp;&amp;
1201                                         !LauncherModel.isValidPackageActivity(mContext, cn,
1202                                                 userHandle)) {
1203                                     // component no longer exists.
1204                                     Launcher.addDumpLog(TAG, &quot;skipping item whose component &quot; +
1205                                             &quot;no longer exists.&quot;, true);
1206                                     continue;
1207                                 } else if (container ==
1208                                         LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1209                                     // Dedupe icons directly on the workspace
1210 
1211                                     // Canonicalize
1212                                     // the Play Store sets the package parameter, but Launcher
1213                                     // does not, so we clear that out to keep them the same.
1214                                     // Also ignore intent flags for the purposes of deduping.
1215                                     intent.setPackage(null);
1216                                     int flags = intent.getFlags();
1217                                     intent.setFlags(0);
1218                                     final String key = intent.toUri(0);
1219                                     intent.setFlags(flags);
1220                                     if (seenIntents.contains(key)) {
1221                                         Launcher.addDumpLog(TAG, &quot;skipping duplicate&quot;, true);
1222                                         continue;
1223                                     } else {
1224                                         seenIntents.add(key);
1225                                     }
1226                                 }
1227                             }
1228 
1229                             ContentValues values = new ContentValues(c.getColumnCount());
1230                             values.put(LauncherSettings.Favorites._ID, c.getInt(idIndex));
1231                             values.put(LauncherSettings.Favorites.INTENT, intentStr);
1232                             values.put(LauncherSettings.Favorites.TITLE, c.getString(titleIndex));
1233                             values.put(LauncherSettings.Favorites.ICON_TYPE,
1234                                     c.getInt(iconTypeIndex));
1235                             values.put(LauncherSettings.Favorites.ICON, c.getBlob(iconIndex));
1236                             values.put(LauncherSettings.Favorites.ICON_PACKAGE,
1237                                     c.getString(iconPackageIndex));
1238                             values.put(LauncherSettings.Favorites.ICON_RESOURCE,
1239                                     c.getString(iconResourceIndex));
1240                             values.put(LauncherSettings.Favorites.ITEM_TYPE, itemType);
1241                             values.put(LauncherSettings.Favorites.APPWIDGET_ID, -1);
1242                             values.put(LauncherSettings.Favorites.URI, c.getString(uriIndex));
1243                             values.put(LauncherSettings.Favorites.DISPLAY_MODE,
1244                                     c.getInt(displayModeIndex));
1245                             values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
1246 
1247                             if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1248                                 hotseat.put(screen, values);
1249                             }
1250 
1251                             if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1252                                 // In a folder or in the hotseat, preserve position
1253                                 values.put(LauncherSettings.Favorites.SCREEN, screen);
1254                                 values.put(LauncherSettings.Favorites.CELLX, cellX);
1255                                 values.put(LauncherSettings.Favorites.CELLY, cellY);
1256                             } else {
1257                                 // For items contained directly on one of the workspace screen,
1258                                 // we&#x27;ll determine their location (screen, x, y) in a second pass.
1259                             }
1260 
1261                             values.put(LauncherSettings.Favorites.CONTAINER, container);
1262 
1263                             if (itemType != Favorites.ITEM_TYPE_FOLDER) {
1264                                 shortcuts.add(values);
1265                             } else {
1266                                 folders.add(values);
1267                             }
1268                         }
1269 
1270                         // Now that we have all the hotseat icons, let&#x27;s go through them left-right
1271                         // and assign valid locations for them in the new hotseat
1272                         final int N = hotseat.size();
1273                         for (int idx=0; idx&lt;N; idx++) {
1274                             int hotseatX = hotseat.keyAt(idx);
1275                             ContentValues values = hotseat.valueAt(idx);
1276 
1277                             if (hotseatX == grid.hotseatAllAppsRank) {
1278                                 // let&#x27;s drop this in the next available hole in the hotseat
1279                                 while (++hotseatX &lt; hotseatWidth) {
1280                                     if (hotseat.get(hotseatX) == null) {
1281                                         // found a spot! move it here
1282                                         values.put(LauncherSettings.Favorites.SCREEN,
1283                                                 hotseatX);
1284                                         break;
1285                                     }
1286                                 }
1287                             }
1288                             if (hotseatX &gt;= hotseatWidth) {
1289                                 // no room for you in the hotseat? it&#x27;s off to the desktop with you
1290                                 values.put(LauncherSettings.Favorites.CONTAINER,
1291                                            Favorites.CONTAINER_DESKTOP);
1292                             }
1293                         }
1294 
1295                         final ArrayList&lt;ContentValues&gt; allItems = new ArrayList&lt;ContentValues&gt;();
1296                         // Folders first
1297                         allItems.addAll(folders);
1298                         // Then shortcuts
1299                         allItems.addAll(shortcuts);
1300 
1301                         // Layout all the folders
1302                         for (ContentValues values: allItems) {
1303                             if (values.getAsInteger(LauncherSettings.Favorites.CONTAINER) !=
1304                                     LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1305                                 // Hotseat items and folder items have already had their
1306                                 // location information set. Nothing to be done here.
1307                                 continue;
1308                             }
1309                             values.put(LauncherSettings.Favorites.SCREEN, curScreen);
1310                             values.put(LauncherSettings.Favorites.CELLX, curX);
1311                             values.put(LauncherSettings.Favorites.CELLY, curY);
1312                             curX = (curX + 1) % width;
1313                             if (curX == 0) {
1314                                 curY = (curY + 1);
1315                             }
1316                             // Leave the last row of icons blank on every screen
1317                             if (curY == height - 1) {
1318                                 curScreen = (int) generateNewScreenId();
1319                                 curY = 0;
1320                             }
1321                         }
1322 
1323                         if (allItems.size() &gt; 0) {
1324                             db.beginTransaction();
1325                             try {
1326                                 for (ContentValues row: allItems) {
1327                                     if (row == null) continue;
1328                                     if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, row)
1329                                             &lt; 0) {
1330                                         return;
1331                                     } else {
1332                                         count++;
1333                                     }
1334                                 }
1335                                 db.setTransactionSuccessful();
1336                             } finally {
1337                                 db.endTransaction();
1338                             }
1339                         }
1340 
1341                         db.beginTransaction();
1342                         try {
1343                             for (i=0; i&lt;=curScreen; i++) {
1344                                 final ContentValues values = new ContentValues();
1345                                 values.put(LauncherSettings.WorkspaceScreens._ID, i);
1346                                 values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1347                                 if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values)
1348                                         &lt; 0) {
1349                                     return;
1350                                 }
1351                             }
1352                             db.setTransactionSuccessful();
1353                         } finally {
1354                             db.endTransaction();
1355                         }
1356 
1357                         updateFolderItemsRank(db, false);
1358                     }
1359                 } finally {
1360                     c.close();
1361                 }
1362             }
1363 
1364             Launcher.addDumpLog(TAG, &quot;migrated &quot; + count + &quot; icons from Launcher2 into &quot;
1365                     + (curScreen+1) + &quot; screens&quot;, true);
1366 
1367             // ensure that new screens are created to hold these icons
1368             setFlagJustLoadedOldDb();
1369 
1370             // Update max IDs; very important since we just grabbed IDs from another database
1371             mMaxItemId = initializeMaxItemId(db);
1372             mMaxScreenId = initializeMaxScreenId(db);
1373             if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId + &quot; mMaxScreenId: &quot; + mMaxScreenId);
1374         }
1375     }
1376 
1377     static class SqlArguments {
1378         public final String table;
1379         public final String where;
1380         public final String[] args;
1381 
1382         SqlArguments(Uri url, String where, String[] args) {
1383             if (url.getPathSegments().size() == 1) {
1384                 this.table = url.getPathSegments().get(0);
1385                 this.where = where;
1386                 this.args = args;
1387             } else if (url.getPathSegments().size() != 2) {
1388                 throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
1389             } else if (!TextUtils.isEmpty(where)) {
1390                 throw new UnsupportedOperationException(&quot;WHERE clause not supported: &quot; + url);
1391             } else {
1392                 this.table = url.getPathSegments().get(0);
1393                 this.where = &quot;_id=&quot; + ContentUris.parseId(url);
1394                 this.args = null;
1395             }
1396         }
1397 
1398         SqlArguments(Uri url) {
1399             if (url.getPathSegments().size() == 1) {
1400                 table = url.getPathSegments().get(0);
1401                 where = null;
1402                 args = null;
1403             } else {
1404                 throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
1405             }
1406         }
1407     }
1408 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.appwidget.AppWidgetHost;
  20 import android.appwidget.AppWidgetManager;
  21 import android.content.ComponentName;
  22 import android.content.ContentProvider;
  23 import android.content.ContentProviderOperation;
  24 import android.content.ContentProviderResult;
  25 import android.content.ContentResolver;
  26 import android.content.ContentUris;
  27 import android.content.ContentValues;
  28 import android.content.Context;
  29 import android.content.Intent;
  30 import android.content.OperationApplicationException;
  31 import android.content.SharedPreferences;
  32 import android.content.res.Resources;
  33 import android.database.Cursor;
  34 import android.database.SQLException;
  35 import android.database.sqlite.SQLiteDatabase;
  36 import android.database.sqlite.SQLiteOpenHelper;
  37 import android.database.sqlite.SQLiteQueryBuilder;
  38 import android.net.Uri;
  39 import android.os.StrictMode;
  40 import android.text.TextUtils;
  41 import android.util.Log;
  42 import android.util.SparseArray;
  43 
  44 import com.android.launcher3.AutoInstallsLayout.LayoutParserCallback;
  45 import com.android.launcher3.LauncherSettings.Favorites;
  46 import com.android.launcher3.compat.UserHandleCompat;
  47 import com.android.launcher3.compat.UserManagerCompat;
  48 import com.android.launcher3.config.ProviderConfig;
  49 
  50 import java.io.File;
  51 import java.net.URISyntaxException;
  52 import java.util.ArrayList;
  53 import java.util.Collections;
  54 import java.util.HashSet;
  55 
  56 public class LauncherProvider extends ContentProvider {
  57     private static final String TAG = &quot;Launcher.LauncherProvider&quot;;
  58     private static final boolean LOGD = false;
  59 
  60     private static final int DATABASE_VERSION = 22;
  61 
  62     static final String OLD_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
  63     static final String AUTHORITY = ProviderConfig.AUTHORITY;
  64 
  65     static final String TABLE_FAVORITES = &quot;favorites&quot;;
  66     static final String TABLE_WORKSPACE_SCREENS = &quot;workspaceScreens&quot;;
  67     static final String PARAMETER_NOTIFY = &quot;notify&quot;;
  68     static final String EMPTY_DATABASE_CREATED = &quot;EMPTY_DATABASE_CREATED&quot;;
  69 
  70     private static final String URI_PARAM_IS_EXTERNAL_ADD = &quot;isExternalAdd&quot;;
  71 
  72     private LauncherProviderChangeListener mListener;
  73 
  74     /**
  75      * {@link Uri} triggered at any registered {@link android.database.ContentObserver} when
  76      * {@link AppWidgetHost#deleteHost()} is called during database creation.
  77      * Use this to recall {@link AppWidgetHost#startListening()} if needed.
  78      */
  79     static final Uri CONTENT_APPWIDGET_RESET_URI =
  80             Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/appWidgetReset&quot;);
  81 
  82     private DatabaseHelper mOpenHelper;
  83 
  84     @Override
  85     public boolean onCreate() {
  86         final Context context = getContext();
  87         StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();
  88         mOpenHelper = new DatabaseHelper(context);
  89         StrictMode.setThreadPolicy(oldPolicy);
  90         LauncherAppState.setLauncherProvider(this);
  91         return true;
  92     }
  93 
  94     public boolean wasNewDbCreated() {
  95         return mOpenHelper.wasNewDbCreated();
  96     }
  97 
  98     public void setLauncherProviderChangeListener(LauncherProviderChangeListener listener) {
  99         mListener = listener;
 100     }
 101 
 102     @Override
 103     public String getType(Uri uri) {
 104         SqlArguments args = new SqlArguments(uri, null, null);
 105         if (TextUtils.isEmpty(args.where)) {
 106             return &quot;vnd.android.cursor.dir/&quot; + args.table;
 107         } else {
 108             return &quot;vnd.android.cursor.item/&quot; + args.table;
 109         }
 110     }
 111 
 112     @Override
 113     public Cursor query(Uri uri, String[] projection, String selection,
 114             String[] selectionArgs, String sortOrder) {
 115 
 116         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 117         SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
 118         qb.setTables(args.table);
 119 
 120         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 121         Cursor result = qb.query(db, projection, args.where, args.args, null, null, sortOrder);
 122         result.setNotificationUri(getContext().getContentResolver(), uri);
 123 
 124         return result;
 125     }
 126 
 127     private static long dbInsertAndCheck(DatabaseHelper helper,
 128             SQLiteDatabase db, String table, String nullColumnHack, ContentValues values) {
 129         if (values == null) {
 130             throw new RuntimeException(&quot;Error: attempting to insert null values&quot;);
 131         }
 132         if (!values.containsKey(LauncherSettings.ChangeLogColumns._ID)) {
 133             throw new RuntimeException(&quot;Error: attempting to add item without specifying an id&quot;);
 134         }
 135         helper.checkId(table, values);
 136         return db.insert(table, nullColumnHack, values);
 137     }
 138 
 139     @Override
 140     public Uri insert(Uri uri, ContentValues initialValues) {
 141         SqlArguments args = new SqlArguments(uri);
 142 
 143         // In very limited cases, we support system|signature permission apps to add to the db
 144         String externalAdd = uri.getQueryParameter(URI_PARAM_IS_EXTERNAL_ADD);
 145         if (externalAdd != null &amp;&amp; &quot;true&quot;.equals(externalAdd)) {
 146             if (!mOpenHelper.initializeExternalAdd(initialValues)) {
 147                 return null;
 148             }
 149         }
 150 
 151         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 152         addModifiedTime(initialValues);
 153         final long rowId = dbInsertAndCheck(mOpenHelper, db, args.table, null, initialValues);
 154         if (rowId &lt;= 0) return null;
 155 
 156         uri = ContentUris.withAppendedId(uri, rowId);
 157         sendNotify(uri);
 158 
 159         return uri;
 160     }
 161 
 162 
 163     @Override
 164     public int bulkInsert(Uri uri, ContentValues[] values) {
 165         SqlArguments args = new SqlArguments(uri);
 166 
 167         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 168         db.beginTransaction();
 169         try {
 170             int numValues = values.length;
 171             for (int i = 0; i &lt; numValues; i++) {
 172                 addModifiedTime(values[i]);
 173                 if (dbInsertAndCheck(mOpenHelper, db, args.table, null, values[i]) &lt; 0) {
 174                     return 0;
 175                 }
 176             }
 177             db.setTransactionSuccessful();
 178         } finally {
 179             db.endTransaction();
 180         }
 181 
 182         sendNotify(uri);
 183         return values.length;
 184     }
 185 
 186     @Override
 187     public ContentProviderResult[] applyBatch(ArrayList&lt;ContentProviderOperation&gt; operations)
 188             throws OperationApplicationException {
 189         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 190         db.beginTransaction();
 191         try {
 192             ContentProviderResult[] result =  super.applyBatch(operations);
 193             db.setTransactionSuccessful();
 194             return result;
 195         } finally {
 196             db.endTransaction();
 197         }
 198     }
 199 
 200     @Override
 201     public int delete(Uri uri, String selection, String[] selectionArgs) {
 202         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 203 
 204         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 205         int count = db.delete(args.table, args.where, args.args);
 206         if (count &gt; 0) sendNotify(uri);
 207 
 208         return count;
 209     }
 210 
 211     @Override
 212     public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
 213         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 214 
 215         addModifiedTime(values);
 216         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 217         int count = db.update(args.table, values, args.where, args.args);
 218         if (count &gt; 0) sendNotify(uri);
 219 
 220         return count;
 221     }
 222 
 223     private void sendNotify(Uri uri) {
 224         String notify = uri.getQueryParameter(PARAMETER_NOTIFY);
 225         if (notify == null || &quot;true&quot;.equals(notify)) {
 226             getContext().getContentResolver().notifyChange(uri, null);
 227         }
 228 
 229         // always notify the backup agent
 230         LauncherBackupAgentHelper.dataChanged(getContext());
 231         if (mListener != null) {
 232             mListener.onLauncherProviderChange();
 233         }
 234     }
 235 
 236     private static void addModifiedTime(ContentValues values) {
 237         values.put(LauncherSettings.ChangeLogColumns.MODIFIED, System.currentTimeMillis());
 238     }
 239 
 240     public long generateNewItemId() {
 241         return mOpenHelper.generateNewItemId();
 242     }
 243 
 244     public void updateMaxItemId(long id) {
 245         mOpenHelper.updateMaxItemId(id);
 246     }
 247 
 248     public long generateNewScreenId() {
 249         return mOpenHelper.generateNewScreenId();
 250     }
 251 
 252     // This is only required one time while loading the workspace during the
 253     // upgrade path, and should never be called from anywhere else.
 254 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
 255 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 256 public void updateMaxScreenId(long maxScreenId) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 257             // Log to disk</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 258             Launcher.addDumpLog(TAG, &quot;11683562 - updateMaxScreenId(): &quot; + maxScreenId, true);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 259             mMaxScreenId = maxScreenId;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 260         }</span>
 261 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 262 public void updateMaxScreenId(long maxScreenId) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 263         mOpenHelper.updateMaxScreenId(maxScreenId);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 264     }</span>
 265 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 266 
 267 
 268     /**
 269      * Clears all the data for a fresh start.
 270      */
 271     synchronized public void createEmptyDB() {
 272         mOpenHelper.createEmptyDB(mOpenHelper.getWritableDatabase());
 273     }
 274 
 275     public void clearFlagEmptyDbCreated() {
 276         String spKey = LauncherAppState.getSharedPreferencesKey();
 277         getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE)
 278             .edit()
 279             .remove(EMPTY_DATABASE_CREATED)
 280             .commit();
 281     }
 282 
 283     /**
 284      * Loads the default workspace based on the following priority scheme:
 285      *   1) From a package provided by play store
 286      *   2) From a partner configuration APK, already in the system image
 287      *   3) The default configuration for the particular device
 288      */
 289     synchronized public void loadDefaultFavoritesIfNecessary() {
 290         String spKey = LauncherAppState.getSharedPreferencesKey();
 291         SharedPreferences sp = getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE);
 292 
 293         if (sp.getBoolean(EMPTY_DATABASE_CREATED, false)) {
 294             Log.d(TAG, &quot;loading default workspace&quot;);
 295 
 296             AutoInstallsLayout loader = AutoInstallsLayout.get(getContext(),
 297                     mOpenHelper.mAppWidgetHost, mOpenHelper);
 298 
 299             if (loader == null) {
 300                 final Partner partner = Partner.get(getContext().getPackageManager());
 301                 if (partner != null &amp;&amp; partner.hasDefaultLayout()) {
 302                     final Resources partnerRes = partner.getResources();
 303                     int workspaceResId = partnerRes.getIdentifier(Partner.RES_DEFAULT_LAYOUT,
 304                             &quot;xml&quot;, partner.getPackageName());
 305                     if (workspaceResId != 0) {
 306                         loader = new DefaultLayoutParser(getContext(), mOpenHelper.mAppWidgetHost,
 307                                 mOpenHelper, partnerRes, workspaceResId);
 308                     }
 309                 }
 310             }
 311 
 312             final boolean usingExternallyProvidedLayout = loader != null;
 313             if (loader == null) {
 314                 loader = getDefaultLayoutParser();
 315             }
 316             // Populate favorites table with initial favorites
 317             if ((mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(), loader) &lt;= 0)
 318                     &amp;&amp; usingExternallyProvidedLayout) {
 319                 // Unable to load external layout. Cleanup and load the internal layout.
 320                 createEmptyDB();
 321                 mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(),
 322                         getDefaultLayoutParser());
 323             }
 324             clearFlagEmptyDbCreated();
 325         }
 326     }
 327 
 328     private DefaultLayoutParser getDefaultLayoutParser() {
 329         int defaultLayout = LauncherAppState.getInstance()
 330                 .getDynamicGrid().getDeviceProfile().defaultLayoutId;
 331         return new DefaultLayoutParser(getContext(), mOpenHelper.mAppWidgetHost,
 332                 mOpenHelper, getContext().getResources(), defaultLayout);
 333     }
 334 
 335     public void migrateLauncher2Shortcuts() {
 336         mOpenHelper.migrateLauncher2Shortcuts(mOpenHelper.getWritableDatabase(),
 337                 Uri.parse(getContext().getString(R.string.old_launcher_provider_uri)));
 338     }
 339 
 340     public void updateFolderItemsRank() {
 341         mOpenHelper.updateFolderItemsRank(mOpenHelper.getWritableDatabase(), false);
 342     }
 343 
 344     public void deleteDatabase() {
 345         // Are you sure? (y/n)
 346         final SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 347         final File dbFile = new File(db.getPath());
 348         mOpenHelper.close();
 349         if (dbFile.exists()) {
 350             SQLiteDatabase.deleteDatabase(dbFile);
 351         }
 352         mOpenHelper = new DatabaseHelper(getContext());
 353     }
 354 
 355     private static class DatabaseHelper extends SQLiteOpenHelper implements LayoutParserCallback {
 356         private final Context mContext;
 357         private final AppWidgetHost mAppWidgetHost;
 358         private long mMaxItemId = -1;
 359         private long mMaxScreenId = -1;
 360 
 361         private boolean mNewDbCreated = false;
 362 
 363         DatabaseHelper(Context context) {
 364             super(context, LauncherFiles.LAUNCHER_DB, null, DATABASE_VERSION);
 365             mContext = context;
 366             mAppWidgetHost = new AppWidgetHost(context, Launcher.APPWIDGET_HOST_ID);
 367 
 368             // In the case where neither onCreate nor onUpgrade gets called, we read the maxId from
 369             // the DB here
 370             if (mMaxItemId == -1) {
 371                 mMaxItemId = initializeMaxItemId(getWritableDatabase());
 372             }
 373             if (mMaxScreenId == -1) {
 374                 mMaxScreenId = initializeMaxScreenId(getWritableDatabase());
 375             }
 376         }
 377 
 378         public boolean wasNewDbCreated() {
 379             return mNewDbCreated;
 380         }
 381 
 382         /**
 383          * Send notification that we&#x27;ve deleted the {@link AppWidgetHost},
 384          * probably as part of the initial database creation. The receiver may
 385          * want to re-call {@link AppWidgetHost#startListening()} to ensure
 386          * callbacks are correctly set.
 387          */
 388         private void sendAppWidgetResetNotify() {
 389             final ContentResolver resolver = mContext.getContentResolver();
 390             resolver.notifyChange(CONTENT_APPWIDGET_RESET_URI, null);
 391         }
 392 
 393         @Override
 394         public void onCreate(SQLiteDatabase db) {
 395             if (LOGD) Log.d(TAG, &quot;creating new launcher database&quot;);
 396 
 397             mMaxItemId = 1;
 398             mMaxScreenId = 0;
 399             mNewDbCreated = true;
 400 
 401             UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 402             long userSerialNumber = userManager.getSerialNumberForUser(
 403                     UserHandleCompat.myUserHandle());
 404 
 405             db.execSQL(&quot;CREATE TABLE favorites (&quot; +
 406                     &quot;_id INTEGER PRIMARY KEY,&quot; +
 407                     &quot;title TEXT,&quot; +
 408                     &quot;intent TEXT,&quot; +
 409                     &quot;container INTEGER,&quot; +
 410                     &quot;screen INTEGER,&quot; +
 411                     &quot;cellX INTEGER,&quot; +
 412                     &quot;cellY INTEGER,&quot; +
 413                     &quot;spanX INTEGER,&quot; +
 414                     &quot;spanY INTEGER,&quot; +
 415                     &quot;itemType INTEGER,&quot; +
 416                     &quot;appWidgetId INTEGER NOT NULL DEFAULT -1,&quot; +
 417                     &quot;isShortcut INTEGER,&quot; +
 418                     &quot;iconType INTEGER,&quot; +
 419                     &quot;iconPackage TEXT,&quot; +
 420                     &quot;iconResource TEXT,&quot; +
 421                     &quot;icon BLOB,&quot; +
 422                     &quot;uri TEXT,&quot; +
 423                     &quot;displayMode INTEGER,&quot; +
 424                     &quot;appWidgetProvider TEXT,&quot; +
 425                     &quot;modified INTEGER NOT NULL DEFAULT 0,&quot; +
 426                     &quot;restored INTEGER NOT NULL DEFAULT 0,&quot; +
 427                     &quot;profileId INTEGER DEFAULT &quot; + userSerialNumber + &quot;,&quot; +
 428                     &quot;rank INTEGER NOT NULL DEFAULT 0&quot; +
 429                     &quot;);&quot;);
 430             addWorkspacesTable(db);
 431 
 432             // Database was just created, so wipe any previous widgets
 433             if (mAppWidgetHost != null) {
 434                 mAppWidgetHost.deleteHost();
 435                 sendAppWidgetResetNotify();
 436             }
 437 
 438             // Fresh and clean launcher DB.
 439             mMaxItemId = initializeMaxItemId(db);
 440             setFlagEmptyDbCreated();
 441         }
 442 
 443         private void addWorkspacesTable(SQLiteDatabase db) {
 444             db.execSQL(&quot;CREATE TABLE &quot; + TABLE_WORKSPACE_SCREENS + &quot; (&quot; +
 445                     LauncherSettings.WorkspaceScreens._ID + &quot; INTEGER PRIMARY KEY,&quot; +
 446                     LauncherSettings.WorkspaceScreens.SCREEN_RANK + &quot; INTEGER,&quot; +
 447                     LauncherSettings.ChangeLogColumns.MODIFIED + &quot; INTEGER NOT NULL DEFAULT 0&quot; +
 448                     &quot;);&quot;);
 449         }
 450 
 451         private void removeOrphanedItems(SQLiteDatabase db) {
 452             // Delete items directly on the workspace who&#x27;s screen id doesn&#x27;t exist
 453             //  &quot;DELETE FROM favorites WHERE screen NOT IN (SELECT _id FROM workspaceScreens)
 454             //   AND container = -100&quot;
 455             String removeOrphanedDesktopItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +
 456                     &quot; WHERE &quot; +
 457                     LauncherSettings.Favorites.SCREEN + &quot; NOT IN (SELECT &quot; +
 458                     LauncherSettings.WorkspaceScreens._ID + &quot; FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot;)&quot; +
 459                     &quot; AND &quot; +
 460                     LauncherSettings.Favorites.CONTAINER + &quot; = &quot; +
 461                     LauncherSettings.Favorites.CONTAINER_DESKTOP;
 462             db.execSQL(removeOrphanedDesktopItems);
 463 
 464             // Delete items contained in folders which no longer exist (after above statement)
 465             //  &quot;DELETE FROM favorites  WHERE container &lt;&gt; -100 AND container &lt;&gt; -101 AND container
 466             //   NOT IN (SELECT _id FROM favorites WHERE itemType = 2)&quot;
 467             String removeOrphanedFolderItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +
 468                     &quot; WHERE &quot; +
 469                     LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +
 470                     LauncherSettings.Favorites.CONTAINER_DESKTOP +
 471                     &quot; AND &quot;
 472                     + LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +
 473                     LauncherSettings.Favorites.CONTAINER_HOTSEAT +
 474                     &quot; AND &quot;
 475                     + LauncherSettings.Favorites.CONTAINER + &quot; NOT IN (SELECT &quot; +
 476                     LauncherSettings.Favorites._ID + &quot; FROM &quot; + TABLE_FAVORITES +
 477                     &quot; WHERE &quot; + LauncherSettings.Favorites.ITEM_TYPE + &quot; = &quot; +
 478                     LauncherSettings.Favorites.ITEM_TYPE_FOLDER + &quot;)&quot;;
 479             db.execSQL(removeOrphanedFolderItems);
 480         }
 481 
 482         private void setFlagJustLoadedOldDb() {
 483             String spKey = LauncherAppState.getSharedPreferencesKey();
 484             SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 485             sp.edit().putBoolean(EMPTY_DATABASE_CREATED, false).commit();
 486         }
 487 
 488         private void setFlagEmptyDbCreated() {
 489             String spKey = LauncherAppState.getSharedPreferencesKey();
 490             SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 491             sp.edit().putBoolean(EMPTY_DATABASE_CREATED, true).commit();
 492         }
 493 
 494         @Override
 495         public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 496             if (LOGD) Log.d(TAG, &quot;onUpgrade triggered: &quot; + oldVersion);
 497             switch (oldVersion) {
 498                 // The version cannot be lower that 12, as Launcher3 never supported a lower
 499                 // version of the DB.
 500                 case 12: {
 501                 // With the new shrink-wrapped and re-orderable workspaces, it makes sense
 502                 // to persist workspace screens and their relative order.
 503                 mMaxScreenId = 0;
 504                 addWorkspacesTable(db);
 505             }
 506                 case 13: {
 507                 db.beginTransaction();
 508                 try {
 509                     // Insert new column for holding widget provider name
 510                     db.execSQL(&quot;ALTER TABLE favorites &quot; +
 511                             &quot;ADD COLUMN appWidgetProvider TEXT;&quot;);
 512                     db.setTransactionSuccessful();
 513                 } catch (SQLException ex) {
 514                     Log.e(TAG, ex.getMessage(), ex);
 515                         // Old version remains, which means we wipe old data
 516                         break;
 517                 } finally {
 518                     db.endTransaction();
 519                 }
 520             }
 521                 case 14: {
 522                 db.beginTransaction();
 523                 try {
 524                     // Insert new column for holding update timestamp
 525                     db.execSQL(&quot;ALTER TABLE favorites &quot; +
 526                             &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);
 527                     db.execSQL(&quot;ALTER TABLE workspaceScreens &quot; +
 528                             &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);
 529                     db.setTransactionSuccessful();
 530                 } catch (SQLException ex) {
 531                     Log.e(TAG, ex.getMessage(), ex);
 532                         // Old version remains, which means we wipe old data
 533                         break;
 534                 } finally {
 535                     db.endTransaction();
 536                 }
 537             }
 538                 case 15: {
 539                 db.beginTransaction();
 540                 try {
 541                     // Insert new column for holding restore status
 542                     db.execSQL(&quot;ALTER TABLE favorites &quot; +
 543                             &quot;ADD COLUMN restored INTEGER NOT NULL DEFAULT 0;&quot;);
 544                     db.setTransactionSuccessful();
 545                 } catch (SQLException ex) {
 546                     Log.e(TAG, ex.getMessage(), ex);
 547                         // Old version remains, which means we wipe old data
 548                         break;
 549                 } finally {
 550                     db.endTransaction();
 551                 }
 552             }
 553                 case 16: {
 554                 // We use the db version upgrade here to identify users who may not have seen
 555                 // clings yet (because they weren&#x27;t available), but for whom the clings are now
 556                 // available (tablet users). Because one of the possible cling flows (migration)
 557                 // is very destructive (wipes out workspaces), we want to prevent this from showing
 558                 // until clear data. We do so by marking that the clings have been shown.
 559                 LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);
 560             }
 561                 case 17: {
 562                 // No-op
 563             }
 564                 case 18: {
 565                 // Due to a data loss bug, some users may have items associated with screen ids
 566                 // which no longer exist. Since this can cause other problems, and since the user
 567                 // will never see these items anyway, we use database upgrade as an opportunity to
 568                 // clean things up.
 569                 removeOrphanedItems(db);
 570             }
 571                 case 19: {
 572                 // Add userId column
 573                     if (!addProfileColumn(db)) {
 574                         // Old version remains, which means we wipe old data
 575                         break;
 576                 }
 577             }
 578                 case 20:
 579                     if (!updateFolderItemsRank(db, true)) {
 580                         break;
 581                     }
 582                 case 21: {
 583                     // DB Upgraded successfully
 584                     return;
 585                 }
 586             }
 587 
 588 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 589             // DB was not upgraded</span>
 590 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 591             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 592 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 593             if (version &lt; 20) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 594                 // Add userId column</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 595                 if (addProfileColumn(db)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 596                     version = 20;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 597                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 598                 // else old version remains, which means we wipe old data</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 599             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 600 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 601             if (version &lt; 21) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 602                 if (updateFolderItemsRank(db, true)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 603                     version  = 21;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 604                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 605             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 606 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 607             if (version != DATABASE_VERSION) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 608                 Log.w(TAG, &quot;Destroying all old data.&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 609                 createEmptyDB(db);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 610             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 611         }</span>
 612 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 613             if (version == 21) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 614                 // Recreate workspace table with screen id a primary key</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 615                 if (recreateWorkspaceTable(db)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 616                     version = 22;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 617                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 618             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 619 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 620             if (version != DATABASE_VERSION) {</span>
 621 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 622                 Log.w(TAG, &quot;Destroying all old data.&quot;);
 623                 createEmptyDB(db);
 624             }
 625 
 626         @Override
 627         public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 628             // This shouldn&#x27;t happen -- throw our hands up in the air and start over.
 629             Log.w(TAG, &quot;Database version downgrade from: &quot; + oldVersion + &quot; to &quot; + newVersion +
 630                     &quot;. Wiping databse.&quot;);
 631             createEmptyDB(db);
 632         }
 633 
 634 
 635         /**
 636          * Clears all the data for a fresh start.
 637          */
 638         public void createEmptyDB(SQLiteDatabase db) {
 639             db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_FAVORITES);
 640             db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
 641             onCreate(db);
 642         }
 643 
 644         /**
 645          * Recreates workspace table and migrates data to the new table.
 646          */
 647         public boolean recreateWorkspaceTable(SQLiteDatabase db) {
 648             db.beginTransaction();
 649             try {
 650                 Cursor c = db.query(TABLE_WORKSPACE_SCREENS,
 651                         new String[] {LauncherSettings.WorkspaceScreens._ID},
 652                         null, null, null, null,
 653                         LauncherSettings.WorkspaceScreens.SCREEN_RANK);
 654                 ArrayList&lt;Long&gt; sortedIDs = new ArrayList&lt;Long&gt;();
 655                 long maxId = 0;
 656                 try {
 657                     while (c.moveToNext()) {
 658                         Long id = c.getLong(0);
 659                         if (!sortedIDs.contains(id)) {
 660                             sortedIDs.add(id);
 661                             maxId = Math.max(maxId, id);
 662                         }
 663                     }
 664                 } finally {
 665                     c.close();
 666                 }
 667 
 668                 db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
 669                 addWorkspacesTable(db);
 670 
 671                 // Add all screen ids back
 672                 int total = sortedIDs.size();
 673                 for (int i = 0; i &lt; total; i++) {
 674                     ContentValues values = new ContentValues();
 675                     values.put(LauncherSettings.WorkspaceScreens._ID, sortedIDs.get(i));
 676                     values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
 677                     addModifiedTime(values);
 678                     db.insertOrThrow(TABLE_WORKSPACE_SCREENS, null, values);
 679                 }
 680                 db.setTransactionSuccessful();
 681                 mMaxScreenId = maxId;
 682             } catch (SQLException ex) {
 683                 // Old version remains, which means we wipe old data
 684                 Log.e(TAG, ex.getMessage(), ex);
 685                 return false;
 686             } finally {
 687                 db.endTransaction();
 688             }
 689             return true;
 690         }
 691 
 692         private boolean updateFolderItemsRank(SQLiteDatabase db, boolean addRankColumn) {
 693             db.beginTransaction();
 694             try {
 695                 if (addRankColumn) {
 696                     // Insert new column for holding rank
 697                     db.execSQL(&quot;ALTER TABLE favorites ADD COLUMN rank INTEGER NOT NULL DEFAULT 0;&quot;);
 698                 }
 699 
 700                 // Get a map for folder ID to folder width
 701                 Cursor c = db.rawQuery(&quot;SELECT container, MAX(cellX) FROM favorites&quot;
 702                         + &quot; WHERE container IN (SELECT _id FROM favorites WHERE itemType = ?)&quot;
 703                         + &quot; GROUP BY container;&quot;,
 704                         new String[] {Integer.toString(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)});
 705 
 706                 while (c.moveToNext()) {
 707                     db.execSQL(&quot;UPDATE favorites SET rank=cellX+(cellY*?) WHERE &quot;
 708                             + &quot;container=? AND cellX IS NOT NULL AND cellY IS NOT NULL;&quot;,
 709                             new Object[] {c.getLong(1) + 1, c.getLong(0)});
 710                 }
 711 
 712                 c.close();
 713                 db.setTransactionSuccessful();
 714             } catch (SQLException ex) {
 715                 // Old version remains, which means we wipe old data
 716                 Log.e(TAG, ex.getMessage(), ex);
 717                 return false;
 718             } finally {
 719                 db.endTransaction();
 720             }
 721             return true;
 722         }
 723 
 724         private boolean addProfileColumn(SQLiteDatabase db) {
 725             db.beginTransaction();
 726             try {
 727                 UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 728                 // Default to the serial number of this user, for older
 729                 // shortcuts.
 730                 long userSerialNumber = userManager.getSerialNumberForUser(
 731                         UserHandleCompat.myUserHandle());
 732                 // Insert new column for holding user serial number
 733                 db.execSQL(&quot;ALTER TABLE favorites &quot; +
 734                         &quot;ADD COLUMN profileId INTEGER DEFAULT &quot;
 735                                         + userSerialNumber + &quot;;&quot;);
 736                 db.setTransactionSuccessful();
 737             } catch (SQLException ex) {
 738                 // Old version remains, which means we wipe old data
 739                 Log.e(TAG, ex.getMessage(), ex);
 740                 return false;
 741             } finally {
 742                 db.endTransaction();
 743             }
 744             return true;
 745         }
 746 
 747         // Generates a new ID to use for an object in your database. This method should be only
 748         // called from the main UI thread. As an exception, we do call it when we call the
 749         // constructor from the worker thread; however, this doesn&#x27;t extend until after the
 750         // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
 751         // after that point
 752         @Override
 753         public long generateNewItemId() {
 754             if (mMaxItemId &lt; 0) {
 755                 throw new RuntimeException(&quot;Error: max item id was not initialized&quot;);
 756             }
 757             mMaxItemId += 1;
 758             return mMaxItemId;
 759         }
 760 
 761         @Override
 762         public long insertAndCheck(SQLiteDatabase db, ContentValues values) {
 763             return dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values);
 764         }
 765 
 766         public void updateMaxItemId(long id) {
 767             mMaxItemId = id + 1;
 768         }
 769 
 770         public void checkId(String table, ContentValues values) {
 771             long id = values.getAsLong(LauncherSettings.BaseLauncherColumns._ID);
 772             if (table == LauncherProvider.TABLE_WORKSPACE_SCREENS) {
 773                 mMaxScreenId = Math.max(id, mMaxScreenId);
 774             }  else {
 775                 mMaxItemId = Math.max(id, mMaxItemId);
 776             }
 777         }
 778 
 779         private long initializeMaxItemId(SQLiteDatabase db) {
 780             Cursor c = db.rawQuery(&quot;SELECT MAX(_id) FROM favorites&quot;, null);
 781 
 782             // get the result
 783             final int maxIdIndex = 0;
 784             long id = -1;
 785             if (c != null &amp;&amp; c.moveToNext()) {
 786                 id = c.getLong(maxIdIndex);
 787             }
 788             if (c != null) {
 789                 c.close();
 790             }
 791 
 792             if (id == -1) {
 793                 throw new RuntimeException(&quot;Error: could not query max item id&quot;);
 794             }
 795 
 796             return id;
 797         }
 798 
 799         // Generates a new ID to use for an workspace screen in your database. This method
 800         // should be only called from the main UI thread. As an exception, we do call it when we
 801         // call the constructor from the worker thread; however, this doesn&#x27;t extend until after the
 802         // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
 803         // after that point
 804         public long generateNewScreenId() {
 805             if (mMaxScreenId &lt; 0) {
 806                 throw new RuntimeException(&quot;Error: max screen id was not initialized&quot;);
 807             }
 808             mMaxScreenId += 1;
 809             // Log to disk
 810             Launcher.addDumpLog(TAG, &quot;11683562 - generateNewScreenId(): &quot; + mMaxScreenId, true);
 811             return mMaxScreenId;
 812         }
 813 
 814         private long initializeMaxScreenId(SQLiteDatabase db) {
<abbr title=" 815             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);"> 815             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TA</abbr>
 816 
 817             // get the result
 818             final int maxIdIndex = 0;
 819             long id = -1;
 820             if (c != null &amp;&amp; c.moveToNext()) {
 821                 id = c.getLong(maxIdIndex);
 822             }
 823             if (c != null) {
 824                 c.close();
 825             }
 826 
 827             if (id == -1) {
 828                 throw new RuntimeException(&quot;Error: could not query max screen id&quot;);
 829             }
 830 
 831             // Log to disk
 832             Launcher.addDumpLog(TAG, &quot;11683562 - initializeMaxScreenId(): &quot; + id, true);
 833             return id;
 834         }
 835 
 836         private boolean initializeExternalAdd(ContentValues values) {
 837             // 1. Ensure that externally added items have a valid item id
 838             long id = generateNewItemId();
 839             values.put(LauncherSettings.Favorites._ID, id);
 840 
 841             // 2. In the case of an app widget, and if no app widget id is specified, we
 842             // attempt allocate and bind the widget.
 843             Integer itemType = values.getAsInteger(LauncherSettings.Favorites.ITEM_TYPE);
 844             if (itemType != null &amp;&amp;
 845                     itemType.intValue() == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;
 846                     !values.containsKey(LauncherSettings.Favorites.APPWIDGET_ID)) {
 847 
 848                 final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
 849                 ComponentName cn = ComponentName.unflattenFromString(
 850                         values.getAsString(Favorites.APPWIDGET_PROVIDER));
 851 
 852                 if (cn != null) {
 853                     try {
 854                         int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
 855                         values.put(LauncherSettings.Favorites.APPWIDGET_ID, appWidgetId);
 856                         if (!appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,cn)) {
 857                             return false;
 858                         }
 859                     } catch (RuntimeException e) {
 860                         Log.e(TAG, &quot;Failed to initialize external widget&quot;, e);
 861                         return false;
 862                     }
 863                 } else {
 864                     return false;
 865                 }
 866             }
 867 
 868             // Add screen id if not present
 869             long screenId = values.getAsLong(LauncherSettings.Favorites.SCREEN);
 870             if (!addScreenIdIfNecessary(screenId)) {
 871                 return false;
 872             }
 873             return true;
 874         }
 875 
 876         // Returns true of screen id exists, or if successfully added
 877         private boolean addScreenIdIfNecessary(long screenId) {
 878             if (!hasScreenId(screenId)) {
 879                 int rank = getMaxScreenRank() + 1;
 880 
 881                 ContentValues v = new ContentValues();
 882                 v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
 883                 v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
 884                 if (dbInsertAndCheck(this, getWritableDatabase(),
 885                         TABLE_WORKSPACE_SCREENS, null, v) &lt; 0) {
 886                     return false;
 887                 }
 888             }
 889             return true;
 890         }
 891 
 892         private boolean hasScreenId(long screenId) {
 893             SQLiteDatabase db = getWritableDatabase();
 894             Cursor c = db.rawQuery(&quot;SELECT * FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot; WHERE &quot;
 895                     + LauncherSettings.WorkspaceScreens._ID + &quot; = &quot; + screenId, null);
 896             if (c != null) {
 897                 int count = c.getCount();
 898                 c.close();
 899                 return count &gt; 0;
 900             } else {
 901                 return false;
 902             }
 903         }
 904 
 905         private int getMaxScreenRank() {
 906             SQLiteDatabase db = getWritableDatabase();
 907             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens.SCREEN_RANK
 908                     + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);
 909 
 910             // get the result
 911             final int maxRankIndex = 0;
 912             int rank = -1;
 913             if (c != null &amp;&amp; c.moveToNext()) {
 914                 rank = c.getInt(maxRankIndex);
 915             }
 916             if (c != null) {
 917                 c.close();
 918             }
 919 
 920             return rank;
 921         }
 922 
 923         private int loadFavorites(SQLiteDatabase db, AutoInstallsLayout loader) {
 924             ArrayList&lt;Long&gt; screenIds = new ArrayList&lt;Long&gt;();
 925             // TODO: Use multiple loaders with fall-back and transaction.
 926             int count = loader.loadLayout(db, screenIds);
 927 
 928             // Add the screens specified by the items above
 929             Collections.sort(screenIds);
 930             int rank = 0;
 931             ContentValues values = new ContentValues();
 932             for (Long id : screenIds) {
 933                 values.clear();
 934                 values.put(LauncherSettings.WorkspaceScreens._ID, id);
 935                 values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
 936                 if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values) &lt; 0) {
 937                     throw new RuntimeException(&quot;Failed initialize screen table&quot;
 938                             + &quot;from default layout&quot;);
 939                 }
 940                 rank++;
 941             }
 942 
 943             // Ensure that the max ids are initialized
 944             mMaxItemId = initializeMaxItemId(db);
 945             mMaxScreenId = initializeMaxScreenId(db);
 946 
 947             return count;
 948         }
 949 
 950         private void migrateLauncher2Shortcuts(SQLiteDatabase db, Uri uri) {
 951             final ContentResolver resolver = mContext.getContentResolver();
 952             Cursor c = null;
 953             int count = 0;
 954             int curScreen = 0;
 955 
 956             try {
 957                 c = resolver.query(uri, null, null, null, &quot;title ASC&quot;);
 958             } catch (Exception e) {
 959                 // Ignore
 960             }
 961 
 962             // We already have a favorites database in the old provider
 963             if (c != null) {
 964                 try {
 965                     if (c.getCount() &gt; 0) {
 966                         final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
 967                         final int intentIndex
 968                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
 969                         final int titleIndex
 970                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 971                         final int iconTypeIndex
 972                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);
 973                         final int iconIndex
 974                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
 975                         final int iconPackageIndex
 976                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);
 977                         final int iconResourceIndex
 978                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);
 979                         final int containerIndex
 980                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 981                         final int itemTypeIndex
 982                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 983                         final int screenIndex
 984                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 985                         final int cellXIndex
 986                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 987                         final int cellYIndex
 988                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 989                         final int uriIndex
 990                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
 991                         final int displayModeIndex
 992                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE);
 993                         final int profileIndex
 994                                 = c.getColumnIndex(LauncherSettings.Favorites.PROFILE_ID);
 995 
 996                         int i = 0;
 997                         int curX = 0;
 998                         int curY = 0;
 999 
1000                         final LauncherAppState app = LauncherAppState.getInstance();
1001                         final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1002                         final int width = (int) grid.numColumns;
1003                         final int height = (int) grid.numRows;
1004                         final int hotseatWidth = (int) grid.numHotseatIcons;
1005 
1006                         final HashSet&lt;String&gt; seenIntents = new HashSet&lt;String&gt;(c.getCount());
1007 
1008                         final ArrayList&lt;ContentValues&gt; shortcuts = new ArrayList&lt;ContentValues&gt;();
1009                         final ArrayList&lt;ContentValues&gt; folders = new ArrayList&lt;ContentValues&gt;();
1010                         final SparseArray&lt;ContentValues&gt; hotseat = new SparseArray&lt;ContentValues&gt;();
1011 
1012                         while (c.moveToNext()) {
1013                             final int itemType = c.getInt(itemTypeIndex);
1014                             if (itemType != Favorites.ITEM_TYPE_APPLICATION
1015                                     &amp;&amp; itemType != Favorites.ITEM_TYPE_SHORTCUT
1016                                     &amp;&amp; itemType != Favorites.ITEM_TYPE_FOLDER) {
1017                                 continue;
1018                             }
1019 
1020                             final int cellX = c.getInt(cellXIndex);
1021                             final int cellY = c.getInt(cellYIndex);
1022                             final int screen = c.getInt(screenIndex);
1023                             int container = c.getInt(containerIndex);
1024                             final String intentStr = c.getString(intentIndex);
1025 
1026                             UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
1027                             UserHandleCompat userHandle;
1028                             final long userSerialNumber;
1029                             if (profileIndex != -1 &amp;&amp; !c.isNull(profileIndex)) {
1030                                 userSerialNumber = c.getInt(profileIndex);
1031                                 userHandle = userManager.getUserForSerialNumber(userSerialNumber);
1032                             } else {
1033                                 // Default to the serial number of this user, for older
1034                                 // shortcuts.
1035                                 userHandle = UserHandleCompat.myUserHandle();
1036                                 userSerialNumber = userManager.getSerialNumberForUser(userHandle);
1037                             }
1038 
1039                             if (userHandle == null) {
1040                                 Launcher.addDumpLog(TAG, &quot;skipping deleted user&quot;, true);
1041                                 continue;
1042                             }
1043 
1044                             Launcher.addDumpLog(TAG, &quot;migrating \&quot;&quot;
1045                                 + c.getString(titleIndex) + &quot;\&quot; (&quot;
1046                                 + cellX + &quot;,&quot; + cellY + &quot;@&quot;
1047                                 + LauncherSettings.Favorites.containerToString(container)
1048                                 + &quot;/&quot; + screen
1049                                 + &quot;): &quot; + intentStr, true);
1050 
1051                             if (itemType != Favorites.ITEM_TYPE_FOLDER) {
1052 
1053                                 final Intent intent;
1054                                 final ComponentName cn;
1055                                 try {
1056                                     intent = Intent.parseUri(intentStr, 0);
1057                                 } catch (URISyntaxException e) {
1058                                     // bogus intent?
1059                                     Launcher.addDumpLog(TAG,
1060                                             &quot;skipping invalid intent uri&quot;, true);
1061                                     continue;
1062                                 }
1063 
1064                                 cn = intent.getComponent();
1065                                 if (TextUtils.isEmpty(intentStr)) {
1066                                     // no intent? no icon
1067                                     Launcher.addDumpLog(TAG, &quot;skipping empty intent&quot;, true);
1068                                     continue;
1069                                 } else if (cn != null &amp;&amp;
1070                                         !LauncherModel.isValidPackageActivity(mContext, cn,
1071                                                 userHandle)) {
1072                                     // component no longer exists.
1073                                     Launcher.addDumpLog(TAG, &quot;skipping item whose component &quot; +
1074                                             &quot;no longer exists.&quot;, true);
1075                                     continue;
1076                                 } else if (container ==
1077                                         LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1078                                     // Dedupe icons directly on the workspace
1079 
1080                                     // Canonicalize
1081                                     // the Play Store sets the package parameter, but Launcher
1082                                     // does not, so we clear that out to keep them the same.
1083                                     // Also ignore intent flags for the purposes of deduping.
1084                                     intent.setPackage(null);
1085                                     int flags = intent.getFlags();
1086                                     intent.setFlags(0);
1087                                     final String key = intent.toUri(0);
1088                                     intent.setFlags(flags);
1089                                     if (seenIntents.contains(key)) {
1090                                         Launcher.addDumpLog(TAG, &quot;skipping duplicate&quot;, true);
1091                                         continue;
1092                                     } else {
1093                                         seenIntents.add(key);
1094                                     }
1095                                 }
1096                             }
1097 
1098                             ContentValues values = new ContentValues(c.getColumnCount());
1099                             values.put(LauncherSettings.Favorites._ID, c.getInt(idIndex));
1100                             values.put(LauncherSettings.Favorites.INTENT, intentStr);
1101                             values.put(LauncherSettings.Favorites.TITLE, c.getString(titleIndex));
1102                             values.put(LauncherSettings.Favorites.ICON_TYPE,
1103                                     c.getInt(iconTypeIndex));
1104                             values.put(LauncherSettings.Favorites.ICON, c.getBlob(iconIndex));
1105                             values.put(LauncherSettings.Favorites.ICON_PACKAGE,
1106                                     c.getString(iconPackageIndex));
1107                             values.put(LauncherSettings.Favorites.ICON_RESOURCE,
1108                                     c.getString(iconResourceIndex));
1109                             values.put(LauncherSettings.Favorites.ITEM_TYPE, itemType);
1110                             values.put(LauncherSettings.Favorites.APPWIDGET_ID, -1);
1111                             values.put(LauncherSettings.Favorites.URI, c.getString(uriIndex));
1112                             values.put(LauncherSettings.Favorites.DISPLAY_MODE,
1113                                     c.getInt(displayModeIndex));
1114                             values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
1115 
1116                             if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1117                                 hotseat.put(screen, values);
1118                             }
1119 
1120                             if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1121                                 // In a folder or in the hotseat, preserve position
1122                                 values.put(LauncherSettings.Favorites.SCREEN, screen);
1123                                 values.put(LauncherSettings.Favorites.CELLX, cellX);
1124                                 values.put(LauncherSettings.Favorites.CELLY, cellY);
1125                             } else {
1126                                 // For items contained directly on one of the workspace screen,
1127                                 // we&#x27;ll determine their location (screen, x, y) in a second pass.
1128                             }
1129 
1130                             values.put(LauncherSettings.Favorites.CONTAINER, container);
1131 
1132                             if (itemType != Favorites.ITEM_TYPE_FOLDER) {
1133                                 shortcuts.add(values);
1134                             } else {
1135                                 folders.add(values);
1136                             }
1137                         }
1138 
1139                         // Now that we have all the hotseat icons, let&#x27;s go through them left-right
1140                         // and assign valid locations for them in the new hotseat
1141                         final int N = hotseat.size();
1142                         for (int idx=0; idx&lt;N; idx++) {
1143                             int hotseatX = hotseat.keyAt(idx);
1144                             ContentValues values = hotseat.valueAt(idx);
1145 
1146                             if (hotseatX == grid.hotseatAllAppsRank) {
1147                                 // let&#x27;s drop this in the next available hole in the hotseat
1148                                 while (++hotseatX &lt; hotseatWidth) {
1149                                     if (hotseat.get(hotseatX) == null) {
1150                                         // found a spot! move it here
1151                                         values.put(LauncherSettings.Favorites.SCREEN,
1152                                                 hotseatX);
1153                                         break;
1154                                     }
1155                                 }
1156                             }
1157                             if (hotseatX &gt;= hotseatWidth) {
1158                                 // no room for you in the hotseat? it&#x27;s off to the desktop with you
1159                                 values.put(LauncherSettings.Favorites.CONTAINER,
1160                                            Favorites.CONTAINER_DESKTOP);
1161                             }
1162                         }
1163 
1164                         final ArrayList&lt;ContentValues&gt; allItems = new ArrayList&lt;ContentValues&gt;();
1165                         // Folders first
1166                         allItems.addAll(folders);
1167                         // Then shortcuts
1168                         allItems.addAll(shortcuts);
1169 
1170                         // Layout all the folders
1171                         for (ContentValues values: allItems) {
1172                             if (values.getAsInteger(LauncherSettings.Favorites.CONTAINER) !=
1173                                     LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1174                                 // Hotseat items and folder items have already had their
1175                                 // location information set. Nothing to be done here.
1176                                 continue;
1177                             }
1178                             values.put(LauncherSettings.Favorites.SCREEN, curScreen);
1179                             values.put(LauncherSettings.Favorites.CELLX, curX);
1180                             values.put(LauncherSettings.Favorites.CELLY, curY);
1181                             curX = (curX + 1) % width;
1182                             if (curX == 0) {
1183                                 curY = (curY + 1);
1184                             }
1185                             // Leave the last row of icons blank on every screen
1186                             if (curY == height - 1) {
1187                                 curScreen = (int) generateNewScreenId();
1188                                 curY = 0;
1189                             }
1190                         }
1191 
1192                         if (allItems.size() &gt; 0) {
1193                             db.beginTransaction();
1194                             try {
1195                                 for (ContentValues row: allItems) {
1196                                     if (row == null) continue;
1197                                     if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, row)
1198                                             &lt; 0) {
1199                                         return;
1200                                     } else {
1201                                         count++;
1202                                     }
1203                                 }
1204                                 db.setTransactionSuccessful();
1205                             } finally {
1206                                 db.endTransaction();
1207                             }
1208                         }
1209 
1210                         db.beginTransaction();
1211                         try {
1212                             for (i=0; i&lt;=curScreen; i++) {
1213                                 final ContentValues values = new ContentValues();
1214                                 values.put(LauncherSettings.WorkspaceScreens._ID, i);
1215                                 values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1216                                 if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values)
1217                                         &lt; 0) {
1218                                     return;
1219                                 }
1220                             }
1221                             db.setTransactionSuccessful();
1222                         } finally {
1223                             db.endTransaction();
1224                         }
1225 
1226                         updateFolderItemsRank(db, false);
1227                     }
1228                 } finally {
1229                     c.close();
1230                 }
1231             }
1232 
1233             Launcher.addDumpLog(TAG, &quot;migrated &quot; + count + &quot; icons from Launcher2 into &quot;
1234                     + (curScreen+1) + &quot; screens&quot;, true);
1235 
1236             // ensure that new screens are created to hold these icons
1237             setFlagJustLoadedOldDb();
1238 
1239             // Update max IDs; very important since we just grabbed IDs from another database
1240             mMaxItemId = initializeMaxItemId(db);
1241             mMaxScreenId = initializeMaxScreenId(db);
1242             if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId + &quot; mMaxScreenId: &quot; + mMaxScreenId);
1243         }
1244     }
1245 
1246     static class SqlArguments {
1247         public final String table;
1248         public final String where;
1249         public final String[] args;
1250 
1251         SqlArguments(Uri url, String where, String[] args) {
1252             if (url.getPathSegments().size() == 1) {
1253                 this.table = url.getPathSegments().get(0);
1254                 this.where = where;
1255                 this.args = args;
1256             } else if (url.getPathSegments().size() != 2) {
1257                 throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
1258             } else if (!TextUtils.isEmpty(where)) {
1259                 throw new UnsupportedOperationException(&quot;WHERE clause not supported: &quot; + url);
1260             } else {
1261                 this.table = url.getPathSegments().get(0);
1262                 this.where = &quot;_id=&quot; + ContentUris.parseId(url);
1263                 this.args = null;
1264             }
1265         }
1266 
1267         SqlArguments(Uri url) {
1268             if (url.getPathSegments().size() == 1) {
1269                 table = url.getPathSegments().get(0);
1270                 where = null;
1271                 args = null;
1272             } else {
1273                 throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
1274             }
1275         }
1276     }
1277 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.appwidget.AppWidgetHost;
  19 import android.appwidget.AppWidgetManager;
  20 import android.content.ComponentName;
  21 import android.content.ContentProvider;
  22 import android.content.ContentProviderOperation;
  23 import android.content.ContentProviderResult;
  24 import android.content.ContentResolver;
  25 import android.content.ContentUris;
  26 import android.content.ContentValues;
  27 import android.content.Context;
  28 import android.content.Intent;
  29 import android.content.OperationApplicationException;
  30 import android.content.SharedPreferences;
  31 import android.content.res.Resources;
  32 import android.database.Cursor;
  33 import android.database.SQLException;
  34 import android.database.sqlite.SQLiteDatabase;
  35 import android.database.sqlite.SQLiteOpenHelper;
  36 import android.database.sqlite.SQLiteQueryBuilder;
  37 import android.net.Uri;
  38 import android.os.StrictMode;
  39 import android.text.TextUtils;
  40 import android.util.Log;
  41 import android.util.SparseArray;
  42 import com.android.launcher3.AutoInstallsLayout.LayoutParserCallback;
  43 import com.android.launcher3.LauncherSettings.Favorites;
  44 import com.android.launcher3.compat.UserHandleCompat;
  45 import com.android.launcher3.compat.UserManagerCompat;
  46 import com.android.launcher3.config.ProviderConfig;
  47 import java.io.File;
  48 import java.net.URISyntaxException;
  49 import java.util.ArrayList;
  50 import java.util.Collections;
  51 import java.util.HashSet;
  52 
  53 
  54 public class LauncherProvider extends ContentProvider {
  55     private static final String TAG = &quot;Launcher.LauncherProvider&quot;;
  56 
  57     private static final boolean LOGD = false;
  58 
  59     private static final int DATABASE_VERSION = 22;
  60 
  61     static final String OLD_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
  62 
  63     static final String AUTHORITY = ProviderConfig.AUTHORITY;
  64 
  65     static final String TABLE_FAVORITES = &quot;favorites&quot;;
  66 
  67     static final String TABLE_WORKSPACE_SCREENS = &quot;workspaceScreens&quot;;
  68 
  69     static final String PARAMETER_NOTIFY = &quot;notify&quot;;
  70 
  71     static final String EMPTY_DATABASE_CREATED = &quot;EMPTY_DATABASE_CREATED&quot;;
  72 
  73     private static final String URI_PARAM_IS_EXTERNAL_ADD = &quot;isExternalAdd&quot;;
  74 
  75     private LauncherProviderChangeListener mListener;
  76 
  77     /**
  78      * {@link Uri} triggered at any registered {@link android.database.ContentObserver} when
  79      * {@link AppWidgetHost#deleteHost()} is called during database creation.
  80      * Use this to recall {@link AppWidgetHost#startListening()} if needed.
  81      */
  82     static final Uri CONTENT_APPWIDGET_RESET_URI =
  83             Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/appWidgetReset&quot;);
  84 
  85     private DatabaseHelper mOpenHelper;
  86 
  87     @Override
  88     public boolean onCreate() {
  89         final Context context = getContext();
  90         StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();
  91         mOpenHelper = new DatabaseHelper(context);
  92         StrictMode.setThreadPolicy(oldPolicy);
  93         LauncherAppState.setLauncherProvider(this);
  94         return true;
  95     }
  96 
  97     public boolean wasNewDbCreated() {
  98         return mOpenHelper.wasNewDbCreated();
  99     }
 100 
 101     public void setLauncherProviderChangeListener(LauncherProviderChangeListener listener) {
 102         mListener = listener;
 103     }
 104 
 105     @Override
 106     public String getType(Uri uri) {
 107         SqlArguments args = new SqlArguments(uri, null, null);
 108         if (TextUtils.isEmpty(args.where)) {
 109             return &quot;vnd.android.cursor.dir/&quot; + args.table;
 110         } else {
 111             return &quot;vnd.android.cursor.item/&quot; + args.table;
 112         }
 113     }
 114 
 115     @Override
 116     public Cursor query(Uri uri, String[] projection, String selection,
 117             String[] selectionArgs, String sortOrder) {
 118 
 119         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 120         SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
 121         qb.setTables(args.table);
 122 
 123         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 124         Cursor result = qb.query(db, projection, args.where, args.args, null, null, sortOrder);
 125         result.setNotificationUri(getContext().getContentResolver(), uri);
 126 
 127         return result;
 128     }
 129 
 130     private static long dbInsertAndCheck(DatabaseHelper helper,
 131             SQLiteDatabase db, String table, String nullColumnHack, ContentValues values) {
 132         if (values == null) {
 133             throw new RuntimeException(&quot;Error: attempting to insert null values&quot;);
 134         }
 135         if (!values.containsKey(LauncherSettings.ChangeLogColumns._ID)) {
 136             throw new RuntimeException(&quot;Error: attempting to add item without specifying an id&quot;);
 137         }
 138         helper.checkId(table, values);
 139         return db.insert(table, nullColumnHack, values);
 140     }
 141 
 142     @Override
 143     public Uri insert(Uri uri, ContentValues initialValues) {
 144         SqlArguments args = new SqlArguments(uri);
 145         // In very limited cases, we support system|signature permission apps to add to the db
 146         String externalAdd = uri.getQueryParameter(URI_PARAM_IS_EXTERNAL_ADD);
 147         if ((externalAdd != null) &amp;&amp; &quot;true&quot;.equals(externalAdd)) {
 148             if (!mOpenHelper.initializeExternalAdd(initialValues)) {
 149                 return null;
 150             }
 151         }
 152         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 153         addModifiedTime(initialValues);
 154         final long rowId = dbInsertAndCheck(mOpenHelper, db, args.table, null, initialValues);
 155         if (rowId &lt;= 0) {
 156             return null;
 157         }
 158         uri = ContentUris.withAppendedId(uri, rowId);
 159         sendNotify(uri);
 160         return uri;
 161     }
 162 
 163     @Override
 164     public int bulkInsert(Uri uri, ContentValues[] values) {
 165         SqlArguments args = new SqlArguments(uri);
 166         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 167         db.beginTransaction();
 168         try {
 169             int numValues = values.length;
 170             for (int i = 0; i &lt; numValues; i++) {
 171                 addModifiedTime(values[i]);
 172                 if (dbInsertAndCheck(mOpenHelper, db, args.table, null, values[i]) &lt; 0) {
 173                     return 0;
 174                 }
 175             }
 176             db.setTransactionSuccessful();
 177         } finally {
 178             db.endTransaction();
 179         }
 180         sendNotify(uri);
 181         return values.length;
 182     }
 183 
 184     @Override
 185     public ContentProviderResult[] applyBatch(ArrayList&lt;ContentProviderOperation&gt; operations)
 186             throws OperationApplicationException {
 187         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 188         db.beginTransaction();
 189         try {
 190             ContentProviderResult[] result =  super.applyBatch(operations);
 191             db.setTransactionSuccessful();
 192             return result;
 193         } finally {
 194             db.endTransaction();
 195         }
 196     }
 197 
 198     @Override
 199     public int delete(Uri uri, String selection, String[] selectionArgs) {
 200         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 201 
 202         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 203         int count = db.delete(args.table, args.where, args.args);
 204         if (count &gt; 0) sendNotify(uri);
 205 
 206         return count;
 207     }
 208 
 209     @Override
 210     public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
 211         SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 212         addModifiedTime(values);
 213         SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 214         int count = db.update(args.table, values, args.where, args.args);
 215         if (count &gt; 0) {
 216             sendNotify(uri);
 217         }
 218         return count;
 219     }
 220 
 221     private void sendNotify(Uri uri) {
 222         String notify = uri.getQueryParameter(PARAMETER_NOTIFY);
 223         if (notify == null || &quot;true&quot;.equals(notify)) {
 224             getContext().getContentResolver().notifyChange(uri, null);
 225         }
 226 
 227         // always notify the backup agent
 228         LauncherBackupAgentHelper.dataChanged(getContext());
 229         if (mListener != null) {
 230             mListener.onLauncherProviderChange();
 231         }
 232     }
 233 
 234     private static void addModifiedTime(ContentValues values) {
 235         values.put(LauncherSettings.ChangeLogColumns.MODIFIED, System.currentTimeMillis());
 236     }
 237 
 238     public long generateNewItemId() {
 239         return mOpenHelper.generateNewItemId();
 240     }
 241 
 242     public void updateMaxItemId(long id) {
 243         mOpenHelper.updateMaxItemId(id);
 244     }
 245 
 246     public long generateNewScreenId() {
 247         return mOpenHelper.generateNewScreenId();
 248     }
 249 
 250     /**
 251      * Clears all the data for a fresh start.
 252      */
 253     synchronized public void createEmptyDB() {
 254         mOpenHelper.createEmptyDB(mOpenHelper.getWritableDatabase());
 255     }
 256 
 257     public void clearFlagEmptyDbCreated() {
 258         String spKey = LauncherAppState.getSharedPreferencesKey();
 259         getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE)
 260             .edit()
 261             .remove(EMPTY_DATABASE_CREATED)
 262             .commit();
 263     }
 264 
 265     /**
 266      * Loads the default workspace based on the following priority scheme:
 267      *   1) From a package provided by play store
 268      *   2) From a partner configuration APK, already in the system image
 269      *   3) The default configuration for the particular device
 270      */
 271     synchronized public void loadDefaultFavoritesIfNecessary() {
 272         String spKey = LauncherAppState.getSharedPreferencesKey();
 273         SharedPreferences sp = getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE);
 274 
 275         if (sp.getBoolean(EMPTY_DATABASE_CREATED, false)) {
 276             Log.d(TAG, &quot;loading default workspace&quot;);
 277 
 278             AutoInstallsLayout loader = AutoInstallsLayout.get(getContext(),
 279                     mOpenHelper.mAppWidgetHost, mOpenHelper);
 280 
 281             if (loader == null) {
 282                 final Partner partner = Partner.get(getContext().getPackageManager());
 283                 if (partner != null &amp;&amp; partner.hasDefaultLayout()) {
 284                     final Resources partnerRes = partner.getResources();
 285                     int workspaceResId = partnerRes.getIdentifier(Partner.RES_DEFAULT_LAYOUT,
 286                             &quot;xml&quot;, partner.getPackageName());
 287                     if (workspaceResId != 0) {
 288                         loader = new DefaultLayoutParser(getContext(), mOpenHelper.mAppWidgetHost,
 289                                 mOpenHelper, partnerRes, workspaceResId);
 290                     }
 291                 }
 292             }
 293 
 294             final boolean usingExternallyProvidedLayout = loader != null;
 295             if (loader == null) {
 296                 loader = getDefaultLayoutParser();
 297             }
 298             // Populate favorites table with initial favorites
 299             if ((mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(), loader) &lt;= 0)
 300                     &amp;&amp; usingExternallyProvidedLayout) {
 301                 // Unable to load external layout. Cleanup and load the internal layout.
 302                 createEmptyDB();
 303                 mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(),
 304                         getDefaultLayoutParser());
 305             }
 306             clearFlagEmptyDbCreated();
 307         }
 308     }
 309 
 310     private DefaultLayoutParser getDefaultLayoutParser() {
 311         int defaultLayout = LauncherAppState.getInstance()
 312                 .getDynamicGrid().getDeviceProfile().defaultLayoutId;
 313         return new DefaultLayoutParser(getContext(), mOpenHelper.mAppWidgetHost,
 314                 mOpenHelper, getContext().getResources(), defaultLayout);
 315     }
 316 
 317     public void migrateLauncher2Shortcuts() {
 318         mOpenHelper.migrateLauncher2Shortcuts(mOpenHelper.getWritableDatabase(),
 319                 Uri.parse(getContext().getString(R.string.old_launcher_provider_uri)));
 320     }
 321 
 322     public void updateFolderItemsRank() {
 323         mOpenHelper.updateFolderItemsRank(mOpenHelper.getWritableDatabase(), false);
 324     }
 325 
 326     public void deleteDatabase() {
 327         // Are you sure? (y/n)
 328         final SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 329         final File dbFile = new File(db.getPath());
 330         mOpenHelper.close();
 331         if (dbFile.exists()) {
 332             SQLiteDatabase.deleteDatabase(dbFile);
 333         }
 334         mOpenHelper = new DatabaseHelper(getContext());
 335     }
 336 
 337     private static class DatabaseHelper extends SQLiteOpenHelper implements LayoutParserCallback {
 338         private final Context mContext;
 339 
 340         private final AppWidgetHost mAppWidgetHost;
 341 
 342         private long mMaxItemId = -1;
 343 
 344         private long mMaxScreenId = -1;
 345 
 346         private boolean mNewDbCreated = false;
 347 
 348         DatabaseHelper(Context context) {
 349             super(context, LauncherFiles.LAUNCHER_DB, null, DATABASE_VERSION);
 350             mContext = context;
 351             mAppWidgetHost = new AppWidgetHost(context, Launcher.APPWIDGET_HOST_ID);
 352             // In the case where neither onCreate nor onUpgrade gets called, we read the maxId from
 353             // the DB here
 354             if (mMaxItemId == (-1)) {
 355                 mMaxItemId = initializeMaxItemId(getWritableDatabase());
 356             }
 357             if (mMaxScreenId == (-1)) {
 358                 mMaxScreenId = initializeMaxScreenId(getWritableDatabase());
 359             }
 360         }
 361 
 362         public boolean wasNewDbCreated() {
 363             return mNewDbCreated;
 364         }
 365 
 366         /**
 367          * Send notification that we&#x27;ve deleted the {@link AppWidgetHost},
 368          * probably as part of the initial database creation. The receiver may
 369          * want to re-call {@link AppWidgetHost#startListening()} to ensure
 370          * callbacks are correctly set.
 371          */
 372         private void sendAppWidgetResetNotify() {
 373             final ContentResolver resolver = mContext.getContentResolver();
 374             resolver.notifyChange(CONTENT_APPWIDGET_RESET_URI, null);
 375         }
 376 
 377         @Override
 378         public void onCreate(SQLiteDatabase db) {
 379             if (LOGD) Log.d(TAG, &quot;creating new launcher database&quot;);
 380 
 381             mMaxItemId = 1;
 382             mMaxScreenId = 0;
 383             mNewDbCreated = true;
 384 
 385             UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 386             long userSerialNumber = userManager.getSerialNumberForUser(
 387                     UserHandleCompat.myUserHandle());
 388 
 389             db.execSQL(&quot;CREATE TABLE favorites (&quot; +
 390                     &quot;_id INTEGER PRIMARY KEY,&quot; +
 391                     &quot;title TEXT,&quot; +
 392                     &quot;intent TEXT,&quot; +
 393                     &quot;container INTEGER,&quot; +
 394                     &quot;screen INTEGER,&quot; +
 395                     &quot;cellX INTEGER,&quot; +
 396                     &quot;cellY INTEGER,&quot; +
 397                     &quot;spanX INTEGER,&quot; +
 398                     &quot;spanY INTEGER,&quot; +
 399                     &quot;itemType INTEGER,&quot; +
 400                     &quot;appWidgetId INTEGER NOT NULL DEFAULT -1,&quot; +
 401                     &quot;isShortcut INTEGER,&quot; +
 402                     &quot;iconType INTEGER,&quot; +
 403                     &quot;iconPackage TEXT,&quot; +
 404                     &quot;iconResource TEXT,&quot; +
 405                     &quot;icon BLOB,&quot; +
 406                     &quot;uri TEXT,&quot; +
 407                     &quot;displayMode INTEGER,&quot; +
 408                     &quot;appWidgetProvider TEXT,&quot; +
 409                     &quot;modified INTEGER NOT NULL DEFAULT 0,&quot; +
 410                     &quot;restored INTEGER NOT NULL DEFAULT 0,&quot; +
 411                     &quot;profileId INTEGER DEFAULT &quot; + userSerialNumber + &quot;,&quot; +
 412                     &quot;rank INTEGER NOT NULL DEFAULT 0&quot; +
 413                     &quot;);&quot;);
 414             addWorkspacesTable(db);
 415 
 416             // Database was just created, so wipe any previous widgets
 417             if (mAppWidgetHost != null) {
 418                 mAppWidgetHost.deleteHost();
 419                 sendAppWidgetResetNotify();
 420             }
 421 
 422             // Fresh and clean launcher DB.
 423             mMaxItemId = initializeMaxItemId(db);
 424             setFlagEmptyDbCreated();
 425         }
 426 
 427         private void addWorkspacesTable(SQLiteDatabase db) {
<abbr title=" 428             db.execSQL(((((((((&quot;CREATE TABLE &quot; + TABLE_WORKSPACE_SCREENS) + &quot; (&quot;) + LauncherSettings.WorkspaceScreens._ID) + &quot; INTEGER PRIMARY KEY,&quot;) + LauncherSettings.WorkspaceScreens.SCREEN_RANK) + &quot; INTEGER,&quot;) + LauncherSettings.ChangeLogColumns.MODIFIED) + &quot; INTEGER NOT NULL DEFAULT 0&quot;) + &quot;);&quot;);"> 428             db.execSQL(((((((((&quot;CREATE TABLE &quot; + TABLE_WORKSPACE_SCREENS) + &quot; (&quot;) + LauncherSettings.Work</abbr>
 429         }
 430 
 431         private void removeOrphanedItems(SQLiteDatabase db) {
 432             // Delete items directly on the workspace who&#x27;s screen id doesn&#x27;t exist
 433             //  &quot;DELETE FROM favorites WHERE screen NOT IN (SELECT _id FROM workspaceScreens)
 434             //   AND container = -100&quot;
 435             String removeOrphanedDesktopItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +
 436                     &quot; WHERE &quot; +
 437                     LauncherSettings.Favorites.SCREEN + &quot; NOT IN (SELECT &quot; +
 438                     LauncherSettings.WorkspaceScreens._ID + &quot; FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot;)&quot; +
 439                     &quot; AND &quot; +
 440                     LauncherSettings.Favorites.CONTAINER + &quot; = &quot; +
 441                     LauncherSettings.Favorites.CONTAINER_DESKTOP;
 442             db.execSQL(removeOrphanedDesktopItems);
 443 
 444             // Delete items contained in folders which no longer exist (after above statement)
 445             //  &quot;DELETE FROM favorites  WHERE container &lt;&gt; -100 AND container &lt;&gt; -101 AND container
 446             //   NOT IN (SELECT _id FROM favorites WHERE itemType = 2)&quot;
 447             String removeOrphanedFolderItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +
 448                     &quot; WHERE &quot; +
 449                     LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +
 450                     LauncherSettings.Favorites.CONTAINER_DESKTOP +
 451                     &quot; AND &quot;
 452                     + LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +
 453                     LauncherSettings.Favorites.CONTAINER_HOTSEAT +
 454                     &quot; AND &quot;
 455                     + LauncherSettings.Favorites.CONTAINER + &quot; NOT IN (SELECT &quot; +
 456                     LauncherSettings.Favorites._ID + &quot; FROM &quot; + TABLE_FAVORITES +
 457                     &quot; WHERE &quot; + LauncherSettings.Favorites.ITEM_TYPE + &quot; = &quot; +
 458                     LauncherSettings.Favorites.ITEM_TYPE_FOLDER + &quot;)&quot;;
 459             db.execSQL(removeOrphanedFolderItems);
 460         }
 461 
 462         private void setFlagJustLoadedOldDb() {
 463             String spKey = LauncherAppState.getSharedPreferencesKey();
 464             SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 465             sp.edit().putBoolean(EMPTY_DATABASE_CREATED, false).commit();
 466         }
 467 
 468         private void setFlagEmptyDbCreated() {
 469             String spKey = LauncherAppState.getSharedPreferencesKey();
 470             SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 471             sp.edit().putBoolean(EMPTY_DATABASE_CREATED, true).commit();
 472         }
 473 
 474         @Override
 475         public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 476             if (LOGD) {
 477                 Log.d(TAG, &quot;onUpgrade triggered: &quot; + oldVersion);
 478             }
 479             switch (oldVersion) {
 480                 // The version cannot be lower that 12, as Launcher3 never supported a lower
 481                 // version of the DB.
 482                 case 12 :
 483                     {
 484                         // With the new shrink-wrapped and re-orderable workspaces, it makes sense
 485                         // to persist workspace screens and their relative order.
 486                         mMaxScreenId = 0;
 487                         addWorkspacesTable(db);
 488                     }
 489                 case 13 :
 490                     {
 491                         db.beginTransaction();
 492                         try {
 493                             // Insert new column for holding widget provider name
 494                             db.execSQL(&quot;ALTER TABLE favorites &quot; + &quot;ADD COLUMN appWidgetProvider TEXT;&quot;);
 495                             db.setTransactionSuccessful();
 496                         } catch (SQLException ex) {
 497                             Log.e(TAG, ex.getMessage(), ex);
 498                             // Old version remains, which means we wipe old data
 499                             break;
 500                         } finally {
 501                             db.endTransaction();
 502                         }
 503                     }
 504                 case 14 :
 505                     {
 506                         db.beginTransaction();
 507                         try {
 508                             // Insert new column for holding update timestamp
<abbr title=" 509                             db.execSQL(&quot;ALTER TABLE favorites &quot; + &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);"> 509                             db.execSQL(&quot;ALTER TABLE favorites &quot; + &quot;ADD COLUMN modified INTEGER NOT NULL D</abbr>
<abbr title=" 510                             db.execSQL(&quot;ALTER TABLE workspaceScreens &quot; + &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);"> 510                             db.execSQL(&quot;ALTER TABLE workspaceScreens &quot; + &quot;ADD COLUMN modified INTEGER NOT</abbr>
 511                             db.setTransactionSuccessful();
 512                         } catch (SQLException ex) {
 513                             Log.e(TAG, ex.getMessage(), ex);
 514                             // Old version remains, which means we wipe old data
 515                             break;
 516                         } finally {
 517                             db.endTransaction();
 518                         }
 519                     }
 520                 case 15 :
 521                     {
 522                         db.beginTransaction();
 523                         try {
 524                             // Insert new column for holding restore status
<abbr title=" 525                             db.execSQL(&quot;ALTER TABLE favorites &quot; + &quot;ADD COLUMN restored INTEGER NOT NULL DEFAULT 0;&quot;);"> 525                             db.execSQL(&quot;ALTER TABLE favorites &quot; + &quot;ADD COLUMN restored INTEGER NOT NULL D</abbr>
 526                             db.setTransactionSuccessful();
 527                         } catch (SQLException ex) {
 528                             Log.e(TAG, ex.getMessage(), ex);
 529                             // Old version remains, which means we wipe old data
 530                             break;
 531                         } finally {
 532                             db.endTransaction();
 533                         }
 534                     }
 535                 case 16 :
 536                     {
 537                         // We use the db version upgrade here to identify users who may not have seen
 538                         // clings yet (because they weren&#x27;t available), but for whom the clings are now
 539                         // available (tablet users). Because one of the possible cling flows (migration)
<abbr title=" 540                         // is very destructive (wipes out workspaces), we want to prevent this from showing"> 540                         // is very destructive (wipes out workspaces), we want to prevent this from showi</abbr>
 541                         // until clear data. We do so by marking that the clings have been shown.
 542                         LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);
 543                     }
 544                 case 17 :
 545                     {
 546                         // No-op
 547                     }
 548                 case 18 :
 549                     {
 550                         // Due to a data loss bug, some users may have items associated with screen ids
 551                         // which no longer exist. Since this can cause other problems, and since the user
<abbr title=" 552                         // will never see these items anyway, we use database upgrade as an opportunity to"> 552                         // will never see these items anyway, we use database upgrade as an opportunity t</abbr>
 553                         // clean things up.
 554                         removeOrphanedItems(db);
 555                     }
 556                 case 19 :
 557                     {
 558                 // Add userId column
 559                         if (!addProfileColumn(db)) {
 560                             // Old version remains, which means we wipe old data
 561                             break;
 562                         }
 563                     }
 564                 case 20 :
 565                     if (!updateFolderItemsRank(db, true)) {
 566                         break;
 567                     }
 568                 case 21 :
 569                     {
 570                         // DB Upgraded successfully
 571                         return;
 572                     }
 573             }
 574             // DB was not upgraded
 575             Log.w(TAG, &quot;Destroying all old data.&quot;);
 576             createEmptyDB(db);
 577         }
 578 
 579         @Override
 580         public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 581             // This shouldn&#x27;t happen -- throw our hands up in the air and start over.
 582             Log.w(TAG, &quot;Database version downgrade from: &quot; + oldVersion + &quot; to &quot; + newVersion +
 583                     &quot;. Wiping databse.&quot;);
 584             createEmptyDB(db);
 585         }
 586 
 587         /**
 588          * Clears all the data for a fresh start.
 589          */
 590         public void createEmptyDB(SQLiteDatabase db) {
 591             db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_FAVORITES);
 592             db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
 593             onCreate(db);
 594         }
 595 
 596         /**
 597          * Recreates workspace table and migrates data to the new table.
 598          */
 599         public boolean recreateWorkspaceTable(SQLiteDatabase db) {
 600             db.beginTransaction();
 601             try {
 602                 Cursor c = db.query(TABLE_WORKSPACE_SCREENS,
 603                         new String[] {LauncherSettings.WorkspaceScreens._ID},
 604                         null, null, null, null,
 605                         LauncherSettings.WorkspaceScreens.SCREEN_RANK);
 606                 ArrayList&lt;Long&gt; sortedIDs = new ArrayList&lt;Long&gt;();
 607                 long maxId = 0;
 608                 try {
 609                     while (c.moveToNext()) {
 610                         Long id = c.getLong(0);
 611                         if (!sortedIDs.contains(id)) {
 612                             sortedIDs.add(id);
 613                             maxId = Math.max(maxId, id);
 614                         }
 615                     }
 616                 } finally {
 617                     c.close();
 618                 }
 619 
 620                 db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
 621                 addWorkspacesTable(db);
 622 
 623                 // Add all screen ids back
 624                 int total = sortedIDs.size();
 625                 for (int i = 0; i &lt; total; i++) {
 626                     ContentValues values = new ContentValues();
 627                     values.put(LauncherSettings.WorkspaceScreens._ID, sortedIDs.get(i));
 628                     values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
 629                     addModifiedTime(values);
 630                     db.insertOrThrow(TABLE_WORKSPACE_SCREENS, null, values);
 631                 }
 632                 db.setTransactionSuccessful();
 633                 mMaxScreenId = maxId;
 634             } catch (SQLException ex) {
 635                 // Old version remains, which means we wipe old data
 636                 Log.e(TAG, ex.getMessage(), ex);
 637                 return false;
 638             } finally {
 639                 db.endTransaction();
 640             }
 641             return true;
 642         }
 643 
 644         private boolean updateFolderItemsRank(SQLiteDatabase db, boolean addRankColumn) {
 645             db.beginTransaction();
 646             try {
 647                 if (addRankColumn) {
 648                     // Insert new column for holding rank
 649                     db.execSQL(&quot;ALTER TABLE favorites ADD COLUMN rank INTEGER NOT NULL DEFAULT 0;&quot;);
 650                 }
 651 
 652                 // Get a map for folder ID to folder width
 653                 Cursor c = db.rawQuery(&quot;SELECT container, MAX(cellX) FROM favorites&quot;
 654                         + &quot; WHERE container IN (SELECT _id FROM favorites WHERE itemType = ?)&quot;
 655                         + &quot; GROUP BY container;&quot;,
 656                         new String[] {Integer.toString(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)});
 657 
 658                 while (c.moveToNext()) {
 659                     db.execSQL(&quot;UPDATE favorites SET rank=cellX+(cellY*?) WHERE &quot;
 660                             + &quot;container=? AND cellX IS NOT NULL AND cellY IS NOT NULL;&quot;,
 661                             new Object[] {c.getLong(1) + 1, c.getLong(0)});
 662                 }
 663 
 664                 c.close();
 665                 db.setTransactionSuccessful();
 666             } catch (SQLException ex) {
 667                 // Old version remains, which means we wipe old data
 668                 Log.e(TAG, ex.getMessage(), ex);
 669                 return false;
 670             } finally {
 671                 db.endTransaction();
 672             }
 673             return true;
 674         }
 675 
 676         private boolean addProfileColumn(SQLiteDatabase db) {
 677             db.beginTransaction();
 678             try {
 679                 UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 680                 // Default to the serial number of this user, for older
 681                 // shortcuts.
 682                 long userSerialNumber = userManager.getSerialNumberForUser(
 683                         UserHandleCompat.myUserHandle());
 684                 // Insert new column for holding user serial number
 685                 db.execSQL(&quot;ALTER TABLE favorites &quot; +
 686                         &quot;ADD COLUMN profileId INTEGER DEFAULT &quot;
 687                                         + userSerialNumber + &quot;;&quot;);
 688                 db.setTransactionSuccessful();
 689             } catch (SQLException ex) {
 690                 // Old version remains, which means we wipe old data
 691                 Log.e(TAG, ex.getMessage(), ex);
 692                 return false;
 693             } finally {
 694                 db.endTransaction();
 695             }
 696             return true;
 697         }
 698 
 699         // Generates a new ID to use for an object in your database. This method should be only
 700         // called from the main UI thread. As an exception, we do call it when we call the
 701         // constructor from the worker thread; however, this doesn&#x27;t extend until after the
 702         // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
 703         // after that point
 704         @Override
 705         public long generateNewItemId() {
 706             if (mMaxItemId &lt; 0) {
 707                 throw new RuntimeException(&quot;Error: max item id was not initialized&quot;);
 708             }
 709             mMaxItemId += 1;
 710             return mMaxItemId;
 711         }
 712 
 713         @Override
 714         public long insertAndCheck(SQLiteDatabase db, ContentValues values) {
 715             return dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values);
 716         }
 717 
 718         public void updateMaxItemId(long id) {
 719             mMaxItemId = id + 1;
 720         }
 721 
 722         public void checkId(String table, ContentValues values) {
 723             long id = values.getAsLong(LauncherSettings.BaseLauncherColumns._ID);
 724             if (table == LauncherProvider.TABLE_WORKSPACE_SCREENS) {
 725                 mMaxScreenId = Math.max(id, mMaxScreenId);
 726             }  else {
 727                 mMaxItemId = Math.max(id, mMaxItemId);
 728             }
 729         }
 730 
 731         private long initializeMaxItemId(SQLiteDatabase db) {
 732             Cursor c = db.rawQuery(&quot;SELECT MAX(_id) FROM favorites&quot;, null);
 733 
 734             // get the result
 735             final int maxIdIndex = 0;
 736             long id = -1;
 737             if (c != null &amp;&amp; c.moveToNext()) {
 738                 id = c.getLong(maxIdIndex);
 739             }
 740             if (c != null) {
 741                 c.close();
 742             }
 743 
 744             if (id == -1) {
 745                 throw new RuntimeException(&quot;Error: could not query max item id&quot;);
 746             }
 747 
 748             return id;
 749         }
 750 
 751         // Generates a new ID to use for an workspace screen in your database. This method
 752         // should be only called from the main UI thread. As an exception, we do call it when we
 753         // call the constructor from the worker thread; however, this doesn&#x27;t extend until after the
 754         // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
 755         // after that point
 756         public long generateNewScreenId() {
 757             if (mMaxScreenId &lt; 0) {
 758                 throw new RuntimeException(&quot;Error: max screen id was not initialized&quot;);
 759             }
 760             mMaxScreenId += 1;
 761             // Log to disk
 762             Launcher.addDumpLog(TAG, &quot;11683562 - generateNewScreenId(): &quot; + mMaxScreenId, true);
 763             return mMaxScreenId;
 764         }
 765 
 766         private long initializeMaxScreenId(SQLiteDatabase db) {
<abbr title=" 767             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);"> 767             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TA</abbr>
 768 
 769             // get the result
 770             final int maxIdIndex = 0;
 771             long id = -1;
 772             if (c != null &amp;&amp; c.moveToNext()) {
 773                 id = c.getLong(maxIdIndex);
 774             }
 775             if (c != null) {
 776                 c.close();
 777             }
 778 
 779             if (id == -1) {
 780                 throw new RuntimeException(&quot;Error: could not query max screen id&quot;);
 781             }
 782 
 783             // Log to disk
 784             Launcher.addDumpLog(TAG, &quot;11683562 - initializeMaxScreenId(): &quot; + id, true);
 785             return id;
 786         }
 787 
 788         private boolean initializeExternalAdd(ContentValues values) {
 789             // 1. Ensure that externally added items have a valid item id
 790             long id = generateNewItemId();
 791             values.put(LauncherSettings.Favorites._ID, id);
 792 
 793             // 2. In the case of an app widget, and if no app widget id is specified, we
 794             // attempt allocate and bind the widget.
 795             Integer itemType = values.getAsInteger(LauncherSettings.Favorites.ITEM_TYPE);
 796             if (itemType != null &amp;&amp;
 797                     itemType.intValue() == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;
 798                     !values.containsKey(LauncherSettings.Favorites.APPWIDGET_ID)) {
 799 
 800                 final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
 801                 ComponentName cn = ComponentName.unflattenFromString(
 802                         values.getAsString(Favorites.APPWIDGET_PROVIDER));
 803 
 804                 if (cn != null) {
 805                     try {
 806                         int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
 807                         values.put(LauncherSettings.Favorites.APPWIDGET_ID, appWidgetId);
 808                         if (!appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,cn)) {
 809                             return false;
 810                         }
 811                     } catch (RuntimeException e) {
 812                         Log.e(TAG, &quot;Failed to initialize external widget&quot;, e);
 813                         return false;
 814                     }
 815                 } else {
 816                     return false;
 817                 }
 818             }
 819 
 820             // Add screen id if not present
 821             long screenId = values.getAsLong(LauncherSettings.Favorites.SCREEN);
 822             if (!addScreenIdIfNecessary(screenId)) {
 823                 return false;
 824             }
 825             return true;
 826         }
 827 
 828         // Returns true of screen id exists, or if successfully added
 829         private boolean addScreenIdIfNecessary(long screenId) {
 830             if (!hasScreenId(screenId)) {
 831                 int rank = getMaxScreenRank() + 1;
 832 
 833                 ContentValues v = new ContentValues();
 834                 v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
 835                 v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
 836                 if (dbInsertAndCheck(this, getWritableDatabase(),
 837                         TABLE_WORKSPACE_SCREENS, null, v) &lt; 0) {
 838                     return false;
 839                 }
 840             }
 841             return true;
 842         }
 843 
 844         private boolean hasScreenId(long screenId) {
 845             SQLiteDatabase db = getWritableDatabase();
 846             Cursor c = db.rawQuery(&quot;SELECT * FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot; WHERE &quot;
 847                     + LauncherSettings.WorkspaceScreens._ID + &quot; = &quot; + screenId, null);
 848             if (c != null) {
 849                 int count = c.getCount();
 850                 c.close();
 851                 return count &gt; 0;
 852             } else {
 853                 return false;
 854             }
 855         }
 856 
 857         private int getMaxScreenRank() {
 858             SQLiteDatabase db = getWritableDatabase();
 859             Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens.SCREEN_RANK
 860                     + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);
 861 
 862             // get the result
 863             final int maxRankIndex = 0;
 864             int rank = -1;
 865             if (c != null &amp;&amp; c.moveToNext()) {
 866                 rank = c.getInt(maxRankIndex);
 867             }
 868             if (c != null) {
 869                 c.close();
 870             }
 871 
 872             return rank;
 873         }
 874 
 875         private int loadFavorites(SQLiteDatabase db, AutoInstallsLayout loader) {
 876             ArrayList&lt;Long&gt; screenIds = new ArrayList&lt;Long&gt;();
 877             // TODO: Use multiple loaders with fall-back and transaction.
 878             int count = loader.loadLayout(db, screenIds);
 879 
 880             // Add the screens specified by the items above
 881             Collections.sort(screenIds);
 882             int rank = 0;
 883             ContentValues values = new ContentValues();
 884             for (Long id : screenIds) {
 885                 values.clear();
 886                 values.put(LauncherSettings.WorkspaceScreens._ID, id);
 887                 values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
 888                 if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values) &lt; 0) {
 889                     throw new RuntimeException(&quot;Failed initialize screen table&quot;
 890                             + &quot;from default layout&quot;);
 891                 }
 892                 rank++;
 893             }
 894 
 895             // Ensure that the max ids are initialized
 896             mMaxItemId = initializeMaxItemId(db);
 897             mMaxScreenId = initializeMaxScreenId(db);
 898 
 899             return count;
 900         }
 901 
 902         private void migrateLauncher2Shortcuts(SQLiteDatabase db, Uri uri) {
 903             final ContentResolver resolver = mContext.getContentResolver();
 904             Cursor c = null;
 905             int count = 0;
 906             int curScreen = 0;
 907 
 908             try {
 909                 c = resolver.query(uri, null, null, null, &quot;title ASC&quot;);
 910             } catch (Exception e) {
 911                 // Ignore
 912             }
 913 
 914             // We already have a favorites database in the old provider
 915             if (c != null) {
 916                 try {
 917                     if (c.getCount() &gt; 0) {
 918                         final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
 919                         final int intentIndex
 920                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
 921                         final int titleIndex
 922                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 923                         final int iconTypeIndex
 924                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);
 925                         final int iconIndex
 926                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
 927                         final int iconPackageIndex
 928                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);
 929                         final int iconResourceIndex
 930                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);
 931                         final int containerIndex
 932                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 933                         final int itemTypeIndex
 934                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 935                         final int screenIndex
 936                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 937                         final int cellXIndex
 938                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 939                         final int cellYIndex
 940                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 941                         final int uriIndex
 942                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
 943                         final int displayModeIndex
 944                                 = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE);
 945                         final int profileIndex
 946                                 = c.getColumnIndex(LauncherSettings.Favorites.PROFILE_ID);
 947 
 948                         int i = 0;
 949                         int curX = 0;
 950                         int curY = 0;
 951 
 952                         final LauncherAppState app = LauncherAppState.getInstance();
 953                         final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 954                         final int width = (int) grid.numColumns;
 955                         final int height = (int) grid.numRows;
 956                         final int hotseatWidth = (int) grid.numHotseatIcons;
 957 
 958                         final HashSet&lt;String&gt; seenIntents = new HashSet&lt;String&gt;(c.getCount());
 959 
 960                         final ArrayList&lt;ContentValues&gt; shortcuts = new ArrayList&lt;ContentValues&gt;();
 961                         final ArrayList&lt;ContentValues&gt; folders = new ArrayList&lt;ContentValues&gt;();
 962                         final SparseArray&lt;ContentValues&gt; hotseat = new SparseArray&lt;ContentValues&gt;();
 963 
 964                         while (c.moveToNext()) {
 965                             final int itemType = c.getInt(itemTypeIndex);
 966                             if (itemType != Favorites.ITEM_TYPE_APPLICATION
 967                                     &amp;&amp; itemType != Favorites.ITEM_TYPE_SHORTCUT
 968                                     &amp;&amp; itemType != Favorites.ITEM_TYPE_FOLDER) {
 969                                 continue;
 970                             }
 971 
 972                             final int cellX = c.getInt(cellXIndex);
 973                             final int cellY = c.getInt(cellYIndex);
 974                             final int screen = c.getInt(screenIndex);
 975                             int container = c.getInt(containerIndex);
 976                             final String intentStr = c.getString(intentIndex);
 977 
 978                             UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 979                             UserHandleCompat userHandle;
 980                             final long userSerialNumber;
 981                             if (profileIndex != -1 &amp;&amp; !c.isNull(profileIndex)) {
 982                                 userSerialNumber = c.getInt(profileIndex);
 983                                 userHandle = userManager.getUserForSerialNumber(userSerialNumber);
 984                             } else {
 985                                 // Default to the serial number of this user, for older
 986                                 // shortcuts.
 987                                 userHandle = UserHandleCompat.myUserHandle();
 988                                 userSerialNumber = userManager.getSerialNumberForUser(userHandle);
 989                             }
 990 
 991                             if (userHandle == null) {
 992                                 Launcher.addDumpLog(TAG, &quot;skipping deleted user&quot;, true);
 993                                 continue;
 994                             }
 995 
 996                             Launcher.addDumpLog(TAG, &quot;migrating \&quot;&quot;
 997                                 + c.getString(titleIndex) + &quot;\&quot; (&quot;
 998                                 + cellX + &quot;,&quot; + cellY + &quot;@&quot;
 999                                 + LauncherSettings.Favorites.containerToString(container)
1000                                 + &quot;/&quot; + screen
1001                                 + &quot;): &quot; + intentStr, true);
1002 
1003                             if (itemType != Favorites.ITEM_TYPE_FOLDER) {
1004 
1005                                 final Intent intent;
1006                                 final ComponentName cn;
1007                                 try {
1008                                     intent = Intent.parseUri(intentStr, 0);
1009                                 } catch (URISyntaxException e) {
1010                                     // bogus intent?
1011                                     Launcher.addDumpLog(TAG,
1012                                             &quot;skipping invalid intent uri&quot;, true);
1013                                     continue;
1014                                 }
1015 
1016                                 cn = intent.getComponent();
1017                                 if (TextUtils.isEmpty(intentStr)) {
1018                                     // no intent? no icon
1019                                     Launcher.addDumpLog(TAG, &quot;skipping empty intent&quot;, true);
1020                                     continue;
1021                                 } else if (cn != null &amp;&amp;
1022                                         !LauncherModel.isValidPackageActivity(mContext, cn,
1023                                                 userHandle)) {
1024                                     // component no longer exists.
1025                                     Launcher.addDumpLog(TAG, &quot;skipping item whose component &quot; +
1026                                             &quot;no longer exists.&quot;, true);
1027                                     continue;
1028                                 } else if (container ==
1029                                         LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1030                                     // Dedupe icons directly on the workspace
1031 
1032                                     // Canonicalize
1033                                     // the Play Store sets the package parameter, but Launcher
1034                                     // does not, so we clear that out to keep them the same.
1035                                     // Also ignore intent flags for the purposes of deduping.
1036                                     intent.setPackage(null);
1037                                     int flags = intent.getFlags();
1038                                     intent.setFlags(0);
1039                                     final String key = intent.toUri(0);
1040                                     intent.setFlags(flags);
1041                                     if (seenIntents.contains(key)) {
1042                                         Launcher.addDumpLog(TAG, &quot;skipping duplicate&quot;, true);
1043                                         continue;
1044                                     } else {
1045                                         seenIntents.add(key);
1046                                     }
1047                                 }
1048                             }
1049 
1050                             ContentValues values = new ContentValues(c.getColumnCount());
1051                             values.put(LauncherSettings.Favorites._ID, c.getInt(idIndex));
1052                             values.put(LauncherSettings.Favorites.INTENT, intentStr);
1053                             values.put(LauncherSettings.Favorites.TITLE, c.getString(titleIndex));
1054                             values.put(LauncherSettings.Favorites.ICON_TYPE,
1055                                     c.getInt(iconTypeIndex));
1056                             values.put(LauncherSettings.Favorites.ICON, c.getBlob(iconIndex));
1057                             values.put(LauncherSettings.Favorites.ICON_PACKAGE,
1058                                     c.getString(iconPackageIndex));
1059                             values.put(LauncherSettings.Favorites.ICON_RESOURCE,
1060                                     c.getString(iconResourceIndex));
1061                             values.put(LauncherSettings.Favorites.ITEM_TYPE, itemType);
1062                             values.put(LauncherSettings.Favorites.APPWIDGET_ID, -1);
1063                             values.put(LauncherSettings.Favorites.URI, c.getString(uriIndex));
1064                             values.put(LauncherSettings.Favorites.DISPLAY_MODE,
1065                                     c.getInt(displayModeIndex));
1066                             values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
1067 
1068                             if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1069                                 hotseat.put(screen, values);
1070                             }
1071 
1072                             if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1073                                 // In a folder or in the hotseat, preserve position
1074                                 values.put(LauncherSettings.Favorites.SCREEN, screen);
1075                                 values.put(LauncherSettings.Favorites.CELLX, cellX);
1076                                 values.put(LauncherSettings.Favorites.CELLY, cellY);
1077                             } else {
1078                                 // For items contained directly on one of the workspace screen,
1079                                 // we&#x27;ll determine their location (screen, x, y) in a second pass.
1080                             }
1081 
1082                             values.put(LauncherSettings.Favorites.CONTAINER, container);
1083 
1084                             if (itemType != Favorites.ITEM_TYPE_FOLDER) {
1085                                 shortcuts.add(values);
1086                             } else {
1087                                 folders.add(values);
1088                             }
1089                         }
1090 
1091                         // Now that we have all the hotseat icons, let&#x27;s go through them left-right
1092                         // and assign valid locations for them in the new hotseat
1093                         final int N = hotseat.size();
1094                         for (int idx=0; idx&lt;N; idx++) {
1095                             int hotseatX = hotseat.keyAt(idx);
1096                             ContentValues values = hotseat.valueAt(idx);
1097 
1098                             if (hotseatX == grid.hotseatAllAppsRank) {
1099                                 // let&#x27;s drop this in the next available hole in the hotseat
1100                                 while (++hotseatX &lt; hotseatWidth) {
1101                                     if (hotseat.get(hotseatX) == null) {
1102                                         // found a spot! move it here
1103                                         values.put(LauncherSettings.Favorites.SCREEN,
1104                                                 hotseatX);
1105                                         break;
1106                                     }
1107                                 }
1108                             }
1109                             if (hotseatX &gt;= hotseatWidth) {
1110                                 // no room for you in the hotseat? it&#x27;s off to the desktop with you
1111                                 values.put(LauncherSettings.Favorites.CONTAINER,
1112                                            Favorites.CONTAINER_DESKTOP);
1113                             }
1114                         }
1115 
1116                         final ArrayList&lt;ContentValues&gt; allItems = new ArrayList&lt;ContentValues&gt;();
1117                         // Folders first
1118                         allItems.addAll(folders);
1119                         // Then shortcuts
1120                         allItems.addAll(shortcuts);
1121 
1122                         // Layout all the folders
1123                         for (ContentValues values: allItems) {
1124                             if (values.getAsInteger(LauncherSettings.Favorites.CONTAINER) !=
1125                                     LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1126                                 // Hotseat items and folder items have already had their
1127                                 // location information set. Nothing to be done here.
1128                                 continue;
1129                             }
1130                             values.put(LauncherSettings.Favorites.SCREEN, curScreen);
1131                             values.put(LauncherSettings.Favorites.CELLX, curX);
1132                             values.put(LauncherSettings.Favorites.CELLY, curY);
1133                             curX = (curX + 1) % width;
1134                             if (curX == 0) {
1135                                 curY = (curY + 1);
1136                             }
1137                             // Leave the last row of icons blank on every screen
1138                             if (curY == height - 1) {
1139                                 curScreen = (int) generateNewScreenId();
1140                                 curY = 0;
1141                             }
1142                         }
1143 
1144                         if (allItems.size() &gt; 0) {
1145                             db.beginTransaction();
1146                             try {
1147                                 for (ContentValues row: allItems) {
1148                                     if (row == null) continue;
1149                                     if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, row)
1150                                             &lt; 0) {
1151                                         return;
1152                                     } else {
1153                                         count++;
1154                                     }
1155                                 }
1156                                 db.setTransactionSuccessful();
1157                             } finally {
1158                                 db.endTransaction();
1159                             }
1160                         }
1161 
1162                         db.beginTransaction();
1163                         try {
1164                             for (i=0; i&lt;=curScreen; i++) {
1165                                 final ContentValues values = new ContentValues();
1166                                 values.put(LauncherSettings.WorkspaceScreens._ID, i);
1167                                 values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1168                                 if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values)
1169                                         &lt; 0) {
1170                                     return;
1171                                 }
1172                             }
1173                             db.setTransactionSuccessful();
1174                         } finally {
1175                             db.endTransaction();
1176                         }
1177 
1178                         updateFolderItemsRank(db, false);
1179                     }
1180                 } finally {
1181                     c.close();
1182                 }
1183             }
1184 
1185             Launcher.addDumpLog(TAG, &quot;migrated &quot; + count + &quot; icons from Launcher2 into &quot;
1186                     + (curScreen+1) + &quot; screens&quot;, true);
1187 
1188             // ensure that new screens are created to hold these icons
1189             setFlagJustLoadedOldDb();
1190 
1191             // Update max IDs; very important since we just grabbed IDs from another database
1192             mMaxItemId = initializeMaxItemId(db);
1193             mMaxScreenId = initializeMaxScreenId(db);
1194             if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId + &quot; mMaxScreenId: &quot; + mMaxScreenId);
1195         }
1196     }
1197 
1198     static class SqlArguments {
1199         public final String table;
1200 
1201         public final String where;
1202 
1203         public final String[] args;
1204 
1205         SqlArguments(Uri url, String where, String[] args) {
1206             if (url.getPathSegments().size() == 1) {
1207                 this.table = url.getPathSegments().get(0);
1208                 this.where = where;
1209                 this.args = args;
1210             } else if (url.getPathSegments().size() != 2) {
1211                 throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
1212             } else if (!TextUtils.isEmpty(where)) {
1213                 throw new UnsupportedOperationException(&quot;WHERE clause not supported: &quot; + url);
1214             } else {
1215                 this.table = url.getPathSegments().get(0);
1216                 this.where = &quot;_id=&quot; + ContentUris.parseId(url);
1217                 this.args = null;
1218             }
1219         }
1220 
1221         SqlArguments(Uri url) {
1222             if (url.getPathSegments().size() == 1) {
1223                 table = url.getPathSegments().get(0);
1224                 where = null;
1225                 args = null;
1226             } else {
1227                 throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
1228             }
1229         }
1230     }
1231 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.appwidget.AppWidgetHost;
  20  import android.appwidget.AppWidgetManager;
  21  import android.content.ComponentName;
  22  import android.content.ContentProvider;
  23  import android.content.ContentProviderOperation;
  24  import android.content.ContentProviderResult;
  25  import android.content.ContentResolver;
  26  import android.content.ContentUris;
  27  import android.content.ContentValues;
  28  import android.content.Context;
  29  import android.content.Intent;
  30  import android.content.OperationApplicationException;
  31  import android.content.SharedPreferences;
  32  import android.content.res.Resources;
  33  import android.database.Cursor;
  34  import android.database.SQLException;
  35  import android.database.sqlite.SQLiteDatabase;
  36  import android.database.sqlite.SQLiteOpenHelper;
  37  import android.database.sqlite.SQLiteQueryBuilder;
  38  import android.net.Uri;
  39  import android.os.StrictMode;
  40  import android.text.TextUtils;
  41  import android.util.Log;
  42  import android.util.SparseArray;
  43  
  44  import com.android.launcher3.AutoInstallsLayout.LayoutParserCallback;
  45  import com.android.launcher3.LauncherSettings.Favorites;
  46  import com.android.launcher3.compat.UserHandleCompat;
  47  import com.android.launcher3.compat.UserManagerCompat;
  48  import com.android.launcher3.config.ProviderConfig;
  49  
  50  import java.io.File;
  51  import java.net.URISyntaxException;
  52  import java.util.ArrayList;
  53  import java.util.Collections;
  54  import java.util.HashSet;
  55  
  56  public class LauncherProvider extends ContentProvider {
  57      private static final String TAG = &quot;Launcher.LauncherProvider&quot;;
  58      private static final boolean LOGD = false;
  59  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  60 -    private static final int MIN_DATABASE_VERSION = 12;</span>
  61      private static final int DATABASE_VERSION = 21;

  62  
  63      static final String OLD_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
  64      static final String AUTHORITY = ProviderConfig.AUTHORITY;
  65  
  66      static final String TABLE_FAVORITES = &quot;favorites&quot;;
  67      static final String TABLE_WORKSPACE_SCREENS = &quot;workspaceScreens&quot;;
  68      static final String PARAMETER_NOTIFY = &quot;notify&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  69 -    static final String UPGRADED_FROM_OLD_DATABASE = &quot;UPGRADED_FROM_OLD_DATABASE&quot;;</span>
  70      static final String EMPTY_DATABASE_CREATED = &quot;EMPTY_DATABASE_CREATED&quot;;
  71  
  72      private static final String URI_PARAM_IS_EXTERNAL_ADD = &quot;isExternalAdd&quot;;
  73  
  74      private LauncherProviderChangeListener mListener;
  75  
  76      /**
  77       * {@link Uri} triggered at any registered {@link android.database.ContentObserver} when
  78       * {@link AppWidgetHost#deleteHost()} is called during database creation.
  79       * Use this to recall {@link AppWidgetHost#startListening()} if needed.
  80       */
  81      static final Uri CONTENT_APPWIDGET_RESET_URI =
  82              Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/appWidgetReset&quot;);
  83  
  84      private DatabaseHelper mOpenHelper;
  85  
  86      @Override
  87      public boolean onCreate() {
  88          final Context context = getContext();
  89          StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();
  90          mOpenHelper = new DatabaseHelper(context);
  91          StrictMode.setThreadPolicy(oldPolicy);
  92          LauncherAppState.setLauncherProvider(this);
  93          return true;
  94      }
  95  
  96      public boolean wasNewDbCreated() {
  97          return mOpenHelper.wasNewDbCreated();
  98      }
  99  
 100      public void setLauncherProviderChangeListener(LauncherProviderChangeListener listener) {
 101          mListener = listener;
 102      }
 103  
 104      @Override
 105      public String getType(Uri uri) {
 106          SqlArguments args = new SqlArguments(uri, null, null);
 107          if (TextUtils.isEmpty(args.where)) {
 108              return &quot;vnd.android.cursor.dir/&quot; + args.table;
 109          } else {
 110              return &quot;vnd.android.cursor.item/&quot; + args.table;
 111          }
 112      }
 113  
 114      @Override
 115      public Cursor query(Uri uri, String[] projection, String selection,
 116              String[] selectionArgs, String sortOrder) {
 117  
 118          SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 119          SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
 120          qb.setTables(args.table);
 121  
 122          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 123          Cursor result = qb.query(db, projection, args.where, args.args, null, null, sortOrder);
 124          result.setNotificationUri(getContext().getContentResolver(), uri);
 125  
 126          return result;
 127      }
 128  
 129      private static long dbInsertAndCheck(DatabaseHelper helper,
 130              SQLiteDatabase db, String table, String nullColumnHack, ContentValues values) {
 131          if (values == null) {
 132              throw new RuntimeException(&quot;Error: attempting to insert null values&quot;);
 133          }
 134          if (!values.containsKey(LauncherSettings.ChangeLogColumns._ID)) {
 135              throw new RuntimeException(&quot;Error: attempting to add item without specifying an id&quot;);
 136          }
 137          helper.checkId(table, values);
 138          return db.insert(table, nullColumnHack, values);
 139      }
 140  
 141      @Override
 142      public Uri insert(Uri uri, ContentValues initialValues) {
 143          SqlArguments args = new SqlArguments(uri);
 144  
 145          // In very limited cases, we support system|signature permission apps to add to the db
 146          String externalAdd = uri.getQueryParameter(URI_PARAM_IS_EXTERNAL_ADD);
 147          if (externalAdd != null &amp;&amp; &quot;true&quot;.equals(externalAdd)) {
 148              if (!mOpenHelper.initializeExternalAdd(initialValues)) {
 149                  return null;
 150              }
 151          }
 152  
 153          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 154          addModifiedTime(initialValues);
 155          final long rowId = dbInsertAndCheck(mOpenHelper, db, args.table, null, initialValues);
 156          if (rowId &lt;= 0) return null;
 157  
 158          uri = ContentUris.withAppendedId(uri, rowId);
 159          sendNotify(uri);
 160  
 161          return uri;
 162      }
 163  
 164  
 165      @Override
 166      public int bulkInsert(Uri uri, ContentValues[] values) {
 167          SqlArguments args = new SqlArguments(uri);
 168  
 169          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 170          db.beginTransaction();
 171          try {
 172              int numValues = values.length;
 173              for (int i = 0; i &lt; numValues; i++) {
 174                  addModifiedTime(values[i]);
 175                  if (dbInsertAndCheck(mOpenHelper, db, args.table, null, values[i]) &lt; 0) {
 176                      return 0;
 177                  }
 178              }
 179              db.setTransactionSuccessful();
 180          } finally {
 181              db.endTransaction();
 182          }
 183  
 184          sendNotify(uri);
 185          return values.length;
 186      }
 187  
 188      @Override
 189      public ContentProviderResult[] applyBatch(ArrayList&lt;ContentProviderOperation&gt; operations)
 190              throws OperationApplicationException {
 191          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 192          db.beginTransaction();
 193          try {
 194              ContentProviderResult[] result =  super.applyBatch(operations);
 195              db.setTransactionSuccessful();
 196              return result;
 197          } finally {
 198              db.endTransaction();
 199          }
 200      }
 201  
 202      @Override
 203      public int delete(Uri uri, String selection, String[] selectionArgs) {
 204          SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 205  
 206          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 207          int count = db.delete(args.table, args.where, args.args);
 208          if (count &gt; 0) sendNotify(uri);
 209  
 210          return count;
 211      }
 212  
 213      @Override
 214      public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
 215          SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 216  
 217          addModifiedTime(values);
 218          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 219          int count = db.update(args.table, values, args.where, args.args);
 220          if (count &gt; 0) sendNotify(uri);
 221  
 222          return count;
 223      }
 224  
 225      private void sendNotify(Uri uri) {
 226          String notify = uri.getQueryParameter(PARAMETER_NOTIFY);
 227          if (notify == null || &quot;true&quot;.equals(notify)) {
 228              getContext().getContentResolver().notifyChange(uri, null);
 229          }
 230  
 231          // always notify the backup agent
 232          LauncherBackupAgentHelper.dataChanged(getContext());
 233          if (mListener != null) {
 234              mListener.onLauncherProviderChange();
 235          }
 236      }
 237  
 238      private void addModifiedTime(ContentValues values) {

 239          values.put(LauncherSettings.ChangeLogColumns.MODIFIED, System.currentTimeMillis());
 240      }
 241  
 242      public long generateNewItemId() {
 243          return mOpenHelper.generateNewItemId();
 244      }
 245  
 246      public void updateMaxItemId(long id) {
 247          mOpenHelper.updateMaxItemId(id);
 248      }
 249  
 250      public long generateNewScreenId() {
 251          return mOpenHelper.generateNewScreenId();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 252 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 253 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 254 -    // This is only required one time while loading the workspace during the</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 255 -    // upgrade path, and should never be called from anywhere else.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 256 -    public void updateMaxScreenId(long maxScreenId) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 257 -        mOpenHelper.updateMaxScreenId(maxScreenId);</span>
 258      }
 259  
 260      /**
 261       * Clears all the data for a fresh start.
 262       */
 263      synchronized public void createEmptyDB() {
 264          mOpenHelper.createEmptyDB(mOpenHelper.getWritableDatabase());
 265      }
 266  
 267      public void clearFlagEmptyDbCreated() {
 268          String spKey = LauncherAppState.getSharedPreferencesKey();
 269          getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE)
 270              .edit()
 271              .remove(EMPTY_DATABASE_CREATED)
 272              .commit();
 273      }
 274  
 275      /**
 276       * Loads the default workspace based on the following priority scheme:
 277       *   1) From a package provided by play store
 278       *   2) From a partner configuration APK, already in the system image
 279       *   3) The default configuration for the particular device
 280       */
 281      synchronized public void loadDefaultFavoritesIfNecessary() {
 282          String spKey = LauncherAppState.getSharedPreferencesKey();
 283          SharedPreferences sp = getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE);
 284  
 285          if (sp.getBoolean(EMPTY_DATABASE_CREATED, false)) {
 286              Log.d(TAG, &quot;loading default workspace&quot;);
 287  
 288              AutoInstallsLayout loader = AutoInstallsLayout.get(getContext(),
 289                      mOpenHelper.mAppWidgetHost, mOpenHelper);
 290  
 291              if (loader == null) {
 292                  final Partner partner = Partner.get(getContext().getPackageManager());
 293                  if (partner != null &amp;&amp; partner.hasDefaultLayout()) {
 294                      final Resources partnerRes = partner.getResources();
 295                      int workspaceResId = partnerRes.getIdentifier(Partner.RES_DEFAULT_LAYOUT,
 296                              &quot;xml&quot;, partner.getPackageName());
 297                      if (workspaceResId != 0) {
 298                          loader = new DefaultLayoutParser(getContext(), mOpenHelper.mAppWidgetHost,
 299                                  mOpenHelper, partnerRes, workspaceResId);
 300                      }
 301                  }
 302              }
 303  
 304              final boolean usingExternallyProvidedLayout = loader != null;
 305              if (loader == null) {
 306                  loader = getDefaultLayoutParser();
 307              }
 308              // Populate favorites table with initial favorites
 309              if ((mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(), loader) &lt;= 0)
 310                      &amp;&amp; usingExternallyProvidedLayout) {
 311                  // Unable to load external layout. Cleanup and load the internal layout.
 312                  createEmptyDB();
 313                  mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(),
 314                          getDefaultLayoutParser());
 315              }
 316              clearFlagEmptyDbCreated();
 317          }
 318      }
 319  
 320      private DefaultLayoutParser getDefaultLayoutParser() {
 321          int defaultLayout = LauncherAppState.getInstance()
 322                  .getDynamicGrid().getDeviceProfile().defaultLayoutId;
 323          return new DefaultLayoutParser(getContext(), mOpenHelper.mAppWidgetHost,
 324                  mOpenHelper, getContext().getResources(), defaultLayout);
 325      }
 326  
 327      public void migrateLauncher2Shortcuts() {
 328          mOpenHelper.migrateLauncher2Shortcuts(mOpenHelper.getWritableDatabase(),
 329                  Uri.parse(getContext().getString(R.string.old_launcher_provider_uri)));
 330      }
 331  
 332      public void updateFolderItemsRank() {
 333          mOpenHelper.updateFolderItemsRank(mOpenHelper.getWritableDatabase(), false);
 334      }
 335  
 336      public void deleteDatabase() {
 337          // Are you sure? (y/n)
 338          final SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 339          final File dbFile = new File(db.getPath());
 340          mOpenHelper.close();
 341          if (dbFile.exists()) {
 342              SQLiteDatabase.deleteDatabase(dbFile);
 343          }
 344          mOpenHelper = new DatabaseHelper(getContext());
 345      }
 346  
 347      private static class DatabaseHelper extends SQLiteOpenHelper implements LayoutParserCallback {
 348          private final Context mContext;
 349          private final AppWidgetHost mAppWidgetHost;
 350          private long mMaxItemId = -1;
 351          private long mMaxScreenId = -1;
 352  
 353          private boolean mNewDbCreated = false;
 354  
 355          DatabaseHelper(Context context) {
 356              super(context, LauncherFiles.LAUNCHER_DB, null, DATABASE_VERSION);
 357              mContext = context;
 358              mAppWidgetHost = new AppWidgetHost(context, Launcher.APPWIDGET_HOST_ID);
 359  
 360              // In the case where neither onCreate nor onUpgrade gets called, we read the maxId from
 361              // the DB here
 362              if (mMaxItemId == -1) {
 363                  mMaxItemId = initializeMaxItemId(getWritableDatabase());
 364              }
 365              if (mMaxScreenId == -1) {
 366                  mMaxScreenId = initializeMaxScreenId(getWritableDatabase());
 367              }
 368          }
 369  
 370          public boolean wasNewDbCreated() {
 371              return mNewDbCreated;
 372          }
 373  
 374          /**
 375           * Send notification that we&#x27;ve deleted the {@link AppWidgetHost},
 376           * probably as part of the initial database creation. The receiver may
 377           * want to re-call {@link AppWidgetHost#startListening()} to ensure
 378           * callbacks are correctly set.
 379           */
 380          private void sendAppWidgetResetNotify() {
 381              final ContentResolver resolver = mContext.getContentResolver();
 382              resolver.notifyChange(CONTENT_APPWIDGET_RESET_URI, null);
 383          }
 384  
 385          @Override
 386          public void onCreate(SQLiteDatabase db) {
 387              if (LOGD) Log.d(TAG, &quot;creating new launcher database&quot;);
 388  
 389              mMaxItemId = 1;
 390              mMaxScreenId = 0;
 391              mNewDbCreated = true;
 392  
 393              UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 394              long userSerialNumber = userManager.getSerialNumberForUser(
 395                      UserHandleCompat.myUserHandle());
 396  
 397              db.execSQL(&quot;CREATE TABLE favorites (&quot; +
 398                      &quot;_id INTEGER PRIMARY KEY,&quot; +
 399                      &quot;title TEXT,&quot; +
 400                      &quot;intent TEXT,&quot; +
 401                      &quot;container INTEGER,&quot; +
 402                      &quot;screen INTEGER,&quot; +
 403                      &quot;cellX INTEGER,&quot; +
 404                      &quot;cellY INTEGER,&quot; +
 405                      &quot;spanX INTEGER,&quot; +
 406                      &quot;spanY INTEGER,&quot; +
 407                      &quot;itemType INTEGER,&quot; +
 408                      &quot;appWidgetId INTEGER NOT NULL DEFAULT -1,&quot; +
 409                      &quot;isShortcut INTEGER,&quot; +
 410                      &quot;iconType INTEGER,&quot; +
 411                      &quot;iconPackage TEXT,&quot; +
 412                      &quot;iconResource TEXT,&quot; +
 413                      &quot;icon BLOB,&quot; +
 414                      &quot;uri TEXT,&quot; +
 415                      &quot;displayMode INTEGER,&quot; +
 416                      &quot;appWidgetProvider TEXT,&quot; +
 417                      &quot;modified INTEGER NOT NULL DEFAULT 0,&quot; +
 418                      &quot;restored INTEGER NOT NULL DEFAULT 0,&quot; +
 419                      &quot;profileId INTEGER DEFAULT &quot; + userSerialNumber + &quot;,&quot; +
 420                      &quot;rank INTEGER NOT NULL DEFAULT 0&quot; +
 421                      &quot;);&quot;);
 422              addWorkspacesTable(db);
 423  
 424              // Database was just created, so wipe any previous widgets
 425              if (mAppWidgetHost != null) {
 426                  mAppWidgetHost.deleteHost();
 427                  sendAppWidgetResetNotify();
 428              }
 429  
 430              // Fresh and clean launcher DB.
 431              mMaxItemId = initializeMaxItemId(db);
 432              setFlagEmptyDbCreated();
 433          }
 434  
 435          private void addWorkspacesTable(SQLiteDatabase db) {
 436              db.execSQL(&quot;CREATE TABLE &quot; + TABLE_WORKSPACE_SCREENS + &quot; (&quot; +
 437                      LauncherSettings.WorkspaceScreens._ID + &quot; INTEGER,&quot; +

 438                      LauncherSettings.WorkspaceScreens.SCREEN_RANK + &quot; INTEGER,&quot; +
 439                      LauncherSettings.ChangeLogColumns.MODIFIED + &quot; INTEGER NOT NULL DEFAULT 0&quot; +
 440                      &quot;);&quot;);
 441          }
 442  
 443          private void removeOrphanedItems(SQLiteDatabase db) {
 444              // Delete items directly on the workspace who&#x27;s screen id doesn&#x27;t exist
 445              //  &quot;DELETE FROM favorites WHERE screen NOT IN (SELECT _id FROM workspaceScreens)
 446              //   AND container = -100&quot;
 447              String removeOrphanedDesktopItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +
 448                      &quot; WHERE &quot; +
 449                      LauncherSettings.Favorites.SCREEN + &quot; NOT IN (SELECT &quot; +
 450                      LauncherSettings.WorkspaceScreens._ID + &quot; FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot;)&quot; +
 451                      &quot; AND &quot; +
 452                      LauncherSettings.Favorites.CONTAINER + &quot; = &quot; +
 453                      LauncherSettings.Favorites.CONTAINER_DESKTOP;
 454              db.execSQL(removeOrphanedDesktopItems);
 455  
 456              // Delete items contained in folders which no longer exist (after above statement)
 457              //  &quot;DELETE FROM favorites  WHERE container &lt;&gt; -100 AND container &lt;&gt; -101 AND container
 458              //   NOT IN (SELECT _id FROM favorites WHERE itemType = 2)&quot;
 459              String removeOrphanedFolderItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +
 460                      &quot; WHERE &quot; +
 461                      LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +
 462                      LauncherSettings.Favorites.CONTAINER_DESKTOP +
 463                      &quot; AND &quot;
 464                      + LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +
 465                      LauncherSettings.Favorites.CONTAINER_HOTSEAT +
 466                      &quot; AND &quot;
 467                      + LauncherSettings.Favorites.CONTAINER + &quot; NOT IN (SELECT &quot; +
 468                      LauncherSettings.Favorites._ID + &quot; FROM &quot; + TABLE_FAVORITES +
 469                      &quot; WHERE &quot; + LauncherSettings.Favorites.ITEM_TYPE + &quot; = &quot; +
 470                      LauncherSettings.Favorites.ITEM_TYPE_FOLDER + &quot;)&quot;;
 471              db.execSQL(removeOrphanedFolderItems);
 472          }
 473  
 474          private void setFlagJustLoadedOldDb() {
 475              String spKey = LauncherAppState.getSharedPreferencesKey();
 476              SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 477 -            SharedPreferences.Editor editor = sp.edit();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 478 -            editor.putBoolean(UPGRADED_FROM_OLD_DATABASE, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 479 -            editor.putBoolean(EMPTY_DATABASE_CREATED, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 480 -            editor.commit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 481 +            sp.edit().putBoolean(EMPTY_DATABASE_CREATED, false).commit();</span>
 482          }
 483  
 484          private void setFlagEmptyDbCreated() {
 485              String spKey = LauncherAppState.getSharedPreferencesKey();
 486              SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 487 -            SharedPreferences.Editor editor = sp.edit();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 488 -            editor.putBoolean(EMPTY_DATABASE_CREATED, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 489 -            editor.putBoolean(UPGRADED_FROM_OLD_DATABASE, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 490 -            editor.commit();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 491 +            sp.edit().putBoolean(EMPTY_DATABASE_CREATED, true).commit();</span>
 492          }
 493  
 494          @Override
 495          public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 496              if (LOGD) Log.d(TAG, &quot;onUpgrade triggered: &quot; + oldVersion);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 497 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 498 -            int version = oldVersion;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 499 -            if (version &lt; MIN_DATABASE_VERSION) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 500 -                // The version cannot be lower that this, as Launcher3 never supported a lower</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 501 +            switch (oldVersion) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 502 +                // The version cannot be lower that 12, as Launcher3 never supported a lower</span>
 503                  // version of the DB.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 504 -                createEmptyDB(db);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 505 -                version = DATABASE_VERSION;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 506 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 507 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 508 -            if (version &lt; 13) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 509 -                // With the new shrink-wrapped and re-orderable workspaces, it makes sense</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 510 -                // to persist workspace screens and their relative order.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 511 -                mMaxScreenId = 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 512 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 513 -                addWorkspacesTable(db);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 514 -                version = 13;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 515 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 516 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 517 -            if (version &lt; 14) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 518 -                db.beginTransaction();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 519 -                try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 520 -                    // Insert new column for holding widget provider name</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 521 -                    db.execSQL(&quot;ALTER TABLE favorites &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 522 -                            &quot;ADD COLUMN appWidgetProvider TEXT;&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 523 -                    db.setTransactionSuccessful();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 524 -                    version = 14;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 525 -                } catch (SQLException ex) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 526 -                    // Old version remains, which means we wipe old data</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 527 -                    Log.e(TAG, ex.getMessage(), ex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 528 -                } finally {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 529 -                    db.endTransaction();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 530 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 531 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 532 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 533 -            if (version &lt; 15) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 534 -                db.beginTransaction();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 535 -                try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 536 -                    // Insert new column for holding update timestamp</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 537 -                    db.execSQL(&quot;ALTER TABLE favorites &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 538 -                            &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 539 -                    db.execSQL(&quot;ALTER TABLE workspaceScreens &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 540 -                            &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 541 -                    db.setTransactionSuccessful();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 542 -                    version = 15;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 543 -                } catch (SQLException ex) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 544 -                    // Old version remains, which means we wipe old data</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 545 -                    Log.e(TAG, ex.getMessage(), ex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 546 -                } finally {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 547 -                    db.endTransaction();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 548 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 549 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 550 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 551 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 552 -            if (version &lt; 16) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 553 -                db.beginTransaction();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 554 -                try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 555 -                    // Insert new column for holding restore status</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 556 -                    db.execSQL(&quot;ALTER TABLE favorites &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 557 -                            &quot;ADD COLUMN restored INTEGER NOT NULL DEFAULT 0;&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 558 -                    db.setTransactionSuccessful();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 559 -                    version = 16;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 560 -                } catch (SQLException ex) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 561 -                    // Old version remains, which means we wipe old data</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 562 -                    Log.e(TAG, ex.getMessage(), ex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 563 -                } finally {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -                    db.endTransaction();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 565 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 566 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 567 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 568 -            if (version &lt; 17) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 569 -                // We use the db version upgrade here to identify users who may not have seen</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 570 -                // clings yet (because they weren&#x27;t available), but for whom the clings are now</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 571 -                // available (tablet users). Because one of the possible cling flows (migration)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 572 -                // is very destructive (wipes out workspaces), we want to prevent this from showing</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 573 -                // until clear data. We do so by marking that the clings have been shown.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 574 -                LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 575 -                version = 17;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 576 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 577 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 578 -            if (version &lt; 18) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 579 -                // No-op</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 580 -                version = 18;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 581 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 582 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 583 -            if (version &lt; 19) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 584 -                // Due to a data loss bug, some users may have items associated with screen ids</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 585 -                // which no longer exist. Since this can cause other problems, and since the user</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 586 -                // will never see these items anyway, we use database upgrade as an opportunity to</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 587 -                // clean things up.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 588 -                removeOrphanedItems(db);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 589 -                version = 19;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 590 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 591 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 592 -            if (version &lt; 20) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 593 -                // Add userId column</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 594 -                if (addProfileColumn(db)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 595 -                    version = 20;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 596 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 597 -                // else old version remains, which means we wipe old data</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 598 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 599 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 600 -            if (version &lt; 21) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 601 -                if (updateFolderItemsRank(db, true)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 602 -                    version  = 21;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 603 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 604 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 605 -</span>







<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 606 -            if (version != DATABASE_VERSION) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 607 -                Log.w(TAG, &quot;Destroying all old data.&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 608 -                createEmptyDB(db);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 609 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 610 +                case 12: {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 611 +                    // With the new shrink-wrapped and re-orderable workspaces, it makes sense</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 612 +                    // to persist workspace screens and their relative order.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 613 +                    mMaxScreenId = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 614 +                    addWorkspacesTable(db);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 615 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 616 +                case 13: {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 617 +                    db.beginTransaction();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 618 +                    try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 619 +                        // Insert new column for holding widget provider name</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 620 +                        db.execSQL(&quot;ALTER TABLE favorites &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 621 +                                &quot;ADD COLUMN appWidgetProvider TEXT;&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 622 +                        db.setTransactionSuccessful();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 623 +                    } catch (SQLException ex) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 624 +                        Log.e(TAG, ex.getMessage(), ex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 625 +                        // Old version remains, which means we wipe old data</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 626 +                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 627 +                    } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 628 +                        db.endTransaction();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 629 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 630 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 631 +                case 14: {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 632 +                    db.beginTransaction();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 633 +                    try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 634 +                        // Insert new column for holding update timestamp</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 635 +                        db.execSQL(&quot;ALTER TABLE favorites &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 636 +                                &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 637 +                        db.execSQL(&quot;ALTER TABLE workspaceScreens &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 638 +                                &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 639 +                        db.setTransactionSuccessful();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 640 +                    } catch (SQLException ex) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 641 +                        Log.e(TAG, ex.getMessage(), ex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 642 +                        // Old version remains, which means we wipe old data</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 643 +                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 644 +                    } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 645 +                        db.endTransaction();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 646 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 647 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 648 +                case 15: {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 649 +                    db.beginTransaction();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 650 +                    try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 651 +                        // Insert new column for holding restore status</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 652 +                        db.execSQL(&quot;ALTER TABLE favorites &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 653 +                                &quot;ADD COLUMN restored INTEGER NOT NULL DEFAULT 0;&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 654 +                        db.setTransactionSuccessful();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 655 +                    } catch (SQLException ex) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 656 +                        Log.e(TAG, ex.getMessage(), ex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 657 +                        // Old version remains, which means we wipe old data</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 658 +                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 659 +                    } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 660 +                        db.endTransaction();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 661 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 662 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 663 +                case 16: {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 664 +                    // We use the db version upgrade here to identify users who may not have seen</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 665 +                    // clings yet (because they weren&#x27;t available), but for whom the clings are now</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 666 +                    // available (tablet users). Because one of the possible cling flows (migration)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 667 +                    // is very destructive (wipes out workspaces), we want to prevent this from showing</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 668 +                    // until clear data. We do so by marking that the clings have been shown.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 669 +                    LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 670 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 671 +                case 17: {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 672 +                    // No-op</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 673 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 674 +                case 18: {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 675 +                    // Due to a data loss bug, some users may have items associated with screen ids</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 676 +                    // which no longer exist. Since this can cause other problems, and since the user</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 677 +                    // will never see these items anyway, we use database upgrade as an opportunity to</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 678 +                    // clean things up.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 679 +                    removeOrphanedItems(db);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 680 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 681 +                case 19: {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 682 +                    // Add userId column</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 683 +                    if (!addProfileColumn(db)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 684 +                        // Old version remains, which means we wipe old data</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 685 +                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 686 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 687 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 688 +                case 20:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 689 +                    if (!updateFolderItemsRank(db, true)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 690 +                        break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 691 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 692 +                case 21: {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 693 +                    // DB Upgraded successfully</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 694 +                    return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 695 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 696 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 697 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 698 +            // DB was not upgraded</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 699 +            Log.w(TAG, &quot;Destroying all old data.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 700 +            createEmptyDB(db);</span>
 701          }
 702  
 703          @Override
 704          public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 705              // This shouldn&#x27;t happen -- throw our hands up in the air and start over.
 706              Log.w(TAG, &quot;Database version downgrade from: &quot; + oldVersion + &quot; to &quot; + newVersion +
 707                      &quot;. Wiping databse.&quot;);
 708              createEmptyDB(db);
 709          }
 710  
 711  
 712          /**
 713           * Clears all the data for a fresh start.
 714           */
 715          public void createEmptyDB(SQLiteDatabase db) {
 716              db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_FAVORITES);
 717              db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
 718              onCreate(db);
















































 719          }
 720  
 721          private boolean updateFolderItemsRank(SQLiteDatabase db, boolean addRankColumn) {
 722              db.beginTransaction();
 723              try {
 724                  if (addRankColumn) {
 725                      // Insert new column for holding rank
 726                      db.execSQL(&quot;ALTER TABLE favorites ADD COLUMN rank INTEGER NOT NULL DEFAULT 0;&quot;);
 727                  }
 728  
 729                  // Get a map for folder ID to folder width
 730                  Cursor c = db.rawQuery(&quot;SELECT container, MAX(cellX) FROM favorites&quot;
 731                          + &quot; WHERE container IN (SELECT _id FROM favorites WHERE itemType = ?)&quot;
 732                          + &quot; GROUP BY container;&quot;,
 733                          new String[] {Integer.toString(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)});
 734  
 735                  while (c.moveToNext()) {
 736                      db.execSQL(&quot;UPDATE favorites SET rank=cellX+(cellY*?) WHERE &quot;
 737                              + &quot;container=? AND cellX IS NOT NULL AND cellY IS NOT NULL;&quot;,
 738                              new Object[] {c.getLong(1) + 1, c.getLong(0)});
 739                  }
 740  
 741                  c.close();
 742                  db.setTransactionSuccessful();
 743              } catch (SQLException ex) {
 744                  // Old version remains, which means we wipe old data
 745                  Log.e(TAG, ex.getMessage(), ex);
 746                  return false;
 747              } finally {
 748                  db.endTransaction();
 749              }
 750              return true;
 751          }
 752  
 753          private boolean addProfileColumn(SQLiteDatabase db) {
 754              db.beginTransaction();
 755              try {
 756                  UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 757                  // Default to the serial number of this user, for older
 758                  // shortcuts.
 759                  long userSerialNumber = userManager.getSerialNumberForUser(
 760                          UserHandleCompat.myUserHandle());
 761                  // Insert new column for holding user serial number
 762                  db.execSQL(&quot;ALTER TABLE favorites &quot; +
 763                          &quot;ADD COLUMN profileId INTEGER DEFAULT &quot;
 764                                          + userSerialNumber + &quot;;&quot;);
 765                  db.setTransactionSuccessful();
 766              } catch (SQLException ex) {
 767                  // Old version remains, which means we wipe old data
 768                  Log.e(TAG, ex.getMessage(), ex);
 769                  return false;
 770              } finally {
 771                  db.endTransaction();
 772              }
 773              return true;
 774          }
 775  
 776          // Generates a new ID to use for an object in your database. This method should be only
 777          // called from the main UI thread. As an exception, we do call it when we call the
 778          // constructor from the worker thread; however, this doesn&#x27;t extend until after the
 779          // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
 780          // after that point
 781          @Override
 782          public long generateNewItemId() {
 783              if (mMaxItemId &lt; 0) {
 784                  throw new RuntimeException(&quot;Error: max item id was not initialized&quot;);
 785              }
 786              mMaxItemId += 1;
 787              return mMaxItemId;
 788          }
 789  
 790          @Override
 791          public long insertAndCheck(SQLiteDatabase db, ContentValues values) {
 792              return dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values);
 793          }
 794  
 795          public void updateMaxItemId(long id) {
 796              mMaxItemId = id + 1;
 797          }
 798  
 799          public void checkId(String table, ContentValues values) {
 800              long id = values.getAsLong(LauncherSettings.BaseLauncherColumns._ID);
 801              if (table == LauncherProvider.TABLE_WORKSPACE_SCREENS) {
 802                  mMaxScreenId = Math.max(id, mMaxScreenId);
 803              }  else {
 804                  mMaxItemId = Math.max(id, mMaxItemId);
 805              }
 806          }
 807  
 808          private long initializeMaxItemId(SQLiteDatabase db) {
 809              Cursor c = db.rawQuery(&quot;SELECT MAX(_id) FROM favorites&quot;, null);
 810  
 811              // get the result
 812              final int maxIdIndex = 0;
 813              long id = -1;
 814              if (c != null &amp;&amp; c.moveToNext()) {
 815                  id = c.getLong(maxIdIndex);
 816              }
 817              if (c != null) {
 818                  c.close();
 819              }
 820  
 821              if (id == -1) {
 822                  throw new RuntimeException(&quot;Error: could not query max item id&quot;);
 823              }
 824  
 825              return id;
 826          }
 827  
 828          // Generates a new ID to use for an workspace screen in your database. This method
 829          // should be only called from the main UI thread. As an exception, we do call it when we
 830          // call the constructor from the worker thread; however, this doesn&#x27;t extend until after the
 831          // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
 832          // after that point
 833          public long generateNewScreenId() {
 834              if (mMaxScreenId &lt; 0) {
 835                  throw new RuntimeException(&quot;Error: max screen id was not initialized&quot;);
 836              }
 837              mMaxScreenId += 1;
 838              // Log to disk
 839              Launcher.addDumpLog(TAG, &quot;11683562 - generateNewScreenId(): &quot; + mMaxScreenId, true);
 840              return mMaxScreenId;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 841 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 842 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 843 -        public void updateMaxScreenId(long maxScreenId) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 844 -            // Log to disk</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 845 -            Launcher.addDumpLog(TAG, &quot;11683562 - updateMaxScreenId(): &quot; + maxScreenId, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 846 -            mMaxScreenId = maxScreenId;</span>
 847          }
 848  
 849          private long initializeMaxScreenId(SQLiteDatabase db) {
<abbr title=" 850              Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);"> 850              Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TABLE_WORKS</abbr>
 851  
 852              // get the result
 853              final int maxIdIndex = 0;
 854              long id = -1;
 855              if (c != null &amp;&amp; c.moveToNext()) {
 856                  id = c.getLong(maxIdIndex);
 857              }
 858              if (c != null) {
 859                  c.close();
 860              }
 861  
 862              if (id == -1) {
 863                  throw new RuntimeException(&quot;Error: could not query max screen id&quot;);
 864              }
 865  
 866              // Log to disk
 867              Launcher.addDumpLog(TAG, &quot;11683562 - initializeMaxScreenId(): &quot; + id, true);
 868              return id;
 869          }
 870  
 871          private boolean initializeExternalAdd(ContentValues values) {
 872              // 1. Ensure that externally added items have a valid item id
 873              long id = generateNewItemId();
 874              values.put(LauncherSettings.Favorites._ID, id);
 875  
 876              // 2. In the case of an app widget, and if no app widget id is specified, we
 877              // attempt allocate and bind the widget.
 878              Integer itemType = values.getAsInteger(LauncherSettings.Favorites.ITEM_TYPE);
 879              if (itemType != null &amp;&amp;
 880                      itemType.intValue() == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;
 881                      !values.containsKey(LauncherSettings.Favorites.APPWIDGET_ID)) {
 882  
 883                  final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
 884                  ComponentName cn = ComponentName.unflattenFromString(
 885                          values.getAsString(Favorites.APPWIDGET_PROVIDER));
 886  
 887                  if (cn != null) {
 888                      try {
 889                          int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
 890                          values.put(LauncherSettings.Favorites.APPWIDGET_ID, appWidgetId);
 891                          if (!appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,cn)) {
 892                              return false;
 893                          }
 894                      } catch (RuntimeException e) {
 895                          Log.e(TAG, &quot;Failed to initialize external widget&quot;, e);
 896                          return false;
 897                      }
 898                  } else {
 899                      return false;
 900                  }
 901              }
 902  
 903              // Add screen id if not present
 904              long screenId = values.getAsLong(LauncherSettings.Favorites.SCREEN);
 905              if (!addScreenIdIfNecessary(screenId)) {
 906                  return false;
 907              }
 908              return true;
 909          }
 910  
 911          // Returns true of screen id exists, or if successfully added
 912          private boolean addScreenIdIfNecessary(long screenId) {
 913              if (!hasScreenId(screenId)) {
 914                  int rank = getMaxScreenRank() + 1;
 915  
 916                  ContentValues v = new ContentValues();
 917                  v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
 918                  v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
 919                  if (dbInsertAndCheck(this, getWritableDatabase(),
 920                          TABLE_WORKSPACE_SCREENS, null, v) &lt; 0) {
 921                      return false;
 922                  }
 923              }
 924              return true;
 925          }
 926  
 927          private boolean hasScreenId(long screenId) {
 928              SQLiteDatabase db = getWritableDatabase();
 929              Cursor c = db.rawQuery(&quot;SELECT * FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot; WHERE &quot;
 930                      + LauncherSettings.WorkspaceScreens._ID + &quot; = &quot; + screenId, null);
 931              if (c != null) {
 932                  int count = c.getCount();
 933                  c.close();
 934                  return count &gt; 0;
 935              } else {
 936                  return false;
 937              }
 938          }
 939  
 940          private int getMaxScreenRank() {
 941              SQLiteDatabase db = getWritableDatabase();
 942              Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens.SCREEN_RANK
 943                      + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);
 944  
 945              // get the result
 946              final int maxRankIndex = 0;
 947              int rank = -1;
 948              if (c != null &amp;&amp; c.moveToNext()) {
 949                  rank = c.getInt(maxRankIndex);
 950              }
 951              if (c != null) {
 952                  c.close();
 953              }
 954  
 955              return rank;
 956          }
 957  
 958          private int loadFavorites(SQLiteDatabase db, AutoInstallsLayout loader) {
 959              ArrayList&lt;Long&gt; screenIds = new ArrayList&lt;Long&gt;();
 960              // TODO: Use multiple loaders with fall-back and transaction.
 961              int count = loader.loadLayout(db, screenIds);
 962  
 963              // Add the screens specified by the items above
 964              Collections.sort(screenIds);
 965              int rank = 0;
 966              ContentValues values = new ContentValues();
 967              for (Long id : screenIds) {
 968                  values.clear();
 969                  values.put(LauncherSettings.WorkspaceScreens._ID, id);
 970                  values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
 971                  if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values) &lt; 0) {
 972                      throw new RuntimeException(&quot;Failed initialize screen table&quot;
 973                              + &quot;from default layout&quot;);
 974                  }
 975                  rank++;
 976              }
 977  
 978              // Ensure that the max ids are initialized
 979              mMaxItemId = initializeMaxItemId(db);
 980              mMaxScreenId = initializeMaxScreenId(db);
 981  
 982              return count;
 983          }
 984  
 985          private void migrateLauncher2Shortcuts(SQLiteDatabase db, Uri uri) {
 986              final ContentResolver resolver = mContext.getContentResolver();
 987              Cursor c = null;
 988              int count = 0;
 989              int curScreen = 0;
 990  
 991              try {
 992                  c = resolver.query(uri, null, null, null, &quot;title ASC&quot;);
 993              } catch (Exception e) {
 994                  // Ignore
 995              }
 996  
 997              // We already have a favorites database in the old provider
 998              if (c != null) {
 999                  try {
1000                      if (c.getCount() &gt; 0) {
1001                          final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1002                          final int intentIndex
1003                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
1004                          final int titleIndex
1005                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
1006                          final int iconTypeIndex
1007                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);
1008                          final int iconIndex
1009                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1010                          final int iconPackageIndex
1011                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);
1012                          final int iconResourceIndex
1013                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);
1014                          final int containerIndex
1015                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
1016                          final int itemTypeIndex
1017                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
1018                          final int screenIndex
1019                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1020                          final int cellXIndex
1021                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1022                          final int cellYIndex
1023                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1024                          final int uriIndex
1025                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1026                          final int displayModeIndex
1027                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE);
1028                          final int profileIndex
1029                                  = c.getColumnIndex(LauncherSettings.Favorites.PROFILE_ID);
1030  
1031                          int i = 0;
1032                          int curX = 0;
1033                          int curY = 0;
1034  
1035                          final LauncherAppState app = LauncherAppState.getInstance();
1036                          final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1037                          final int width = (int) grid.numColumns;
1038                          final int height = (int) grid.numRows;
1039                          final int hotseatWidth = (int) grid.numHotseatIcons;
1040  
1041                          final HashSet&lt;String&gt; seenIntents = new HashSet&lt;String&gt;(c.getCount());
1042  
1043                          final ArrayList&lt;ContentValues&gt; shortcuts = new ArrayList&lt;ContentValues&gt;();
1044                          final ArrayList&lt;ContentValues&gt; folders = new ArrayList&lt;ContentValues&gt;();
1045                          final SparseArray&lt;ContentValues&gt; hotseat = new SparseArray&lt;ContentValues&gt;();
1046  
1047                          while (c.moveToNext()) {
1048                              final int itemType = c.getInt(itemTypeIndex);
1049                              if (itemType != Favorites.ITEM_TYPE_APPLICATION
1050                                      &amp;&amp; itemType != Favorites.ITEM_TYPE_SHORTCUT
1051                                      &amp;&amp; itemType != Favorites.ITEM_TYPE_FOLDER) {
1052                                  continue;
1053                              }
1054  
1055                              final int cellX = c.getInt(cellXIndex);
1056                              final int cellY = c.getInt(cellYIndex);
1057                              final int screen = c.getInt(screenIndex);
1058                              int container = c.getInt(containerIndex);
1059                              final String intentStr = c.getString(intentIndex);
1060  
1061                              UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
1062                              UserHandleCompat userHandle;
1063                              final long userSerialNumber;
1064                              if (profileIndex != -1 &amp;&amp; !c.isNull(profileIndex)) {
1065                                  userSerialNumber = c.getInt(profileIndex);
1066                                  userHandle = userManager.getUserForSerialNumber(userSerialNumber);
1067                              } else {
1068                                  // Default to the serial number of this user, for older
1069                                  // shortcuts.
1070                                  userHandle = UserHandleCompat.myUserHandle();
1071                                  userSerialNumber = userManager.getSerialNumberForUser(userHandle);
1072                              }
1073  
1074                              if (userHandle == null) {
1075                                  Launcher.addDumpLog(TAG, &quot;skipping deleted user&quot;, true);
1076                                  continue;
1077                              }
1078  
1079                              Launcher.addDumpLog(TAG, &quot;migrating \&quot;&quot;
1080                                  + c.getString(titleIndex) + &quot;\&quot; (&quot;
1081                                  + cellX + &quot;,&quot; + cellY + &quot;@&quot;
1082                                  + LauncherSettings.Favorites.containerToString(container)
1083                                  + &quot;/&quot; + screen
1084                                  + &quot;): &quot; + intentStr, true);
1085  
1086                              if (itemType != Favorites.ITEM_TYPE_FOLDER) {
1087  
1088                                  final Intent intent;
1089                                  final ComponentName cn;
1090                                  try {
1091                                      intent = Intent.parseUri(intentStr, 0);
1092                                  } catch (URISyntaxException e) {
1093                                      // bogus intent?
1094                                      Launcher.addDumpLog(TAG,
1095                                              &quot;skipping invalid intent uri&quot;, true);
1096                                      continue;
1097                                  }
1098  
1099                                  cn = intent.getComponent();
1100                                  if (TextUtils.isEmpty(intentStr)) {
1101                                      // no intent? no icon
1102                                      Launcher.addDumpLog(TAG, &quot;skipping empty intent&quot;, true);
1103                                      continue;
1104                                  } else if (cn != null &amp;&amp;
1105                                          !LauncherModel.isValidPackageActivity(mContext, cn,
1106                                                  userHandle)) {
1107                                      // component no longer exists.
1108                                      Launcher.addDumpLog(TAG, &quot;skipping item whose component &quot; +
1109                                              &quot;no longer exists.&quot;, true);
1110                                      continue;
1111                                  } else if (container ==
1112                                          LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1113                                      // Dedupe icons directly on the workspace
1114  
1115                                      // Canonicalize
1116                                      // the Play Store sets the package parameter, but Launcher
1117                                      // does not, so we clear that out to keep them the same.
1118                                      // Also ignore intent flags for the purposes of deduping.
1119                                      intent.setPackage(null);
1120                                      int flags = intent.getFlags();
1121                                      intent.setFlags(0);
1122                                      final String key = intent.toUri(0);
1123                                      intent.setFlags(flags);
1124                                      if (seenIntents.contains(key)) {
1125                                          Launcher.addDumpLog(TAG, &quot;skipping duplicate&quot;, true);
1126                                          continue;
1127                                      } else {
1128                                          seenIntents.add(key);
1129                                      }
1130                                  }
1131                              }
1132  
1133                              ContentValues values = new ContentValues(c.getColumnCount());
1134                              values.put(LauncherSettings.Favorites._ID, c.getInt(idIndex));
1135                              values.put(LauncherSettings.Favorites.INTENT, intentStr);
1136                              values.put(LauncherSettings.Favorites.TITLE, c.getString(titleIndex));
1137                              values.put(LauncherSettings.Favorites.ICON_TYPE,
1138                                      c.getInt(iconTypeIndex));
1139                              values.put(LauncherSettings.Favorites.ICON, c.getBlob(iconIndex));
1140                              values.put(LauncherSettings.Favorites.ICON_PACKAGE,
1141                                      c.getString(iconPackageIndex));
1142                              values.put(LauncherSettings.Favorites.ICON_RESOURCE,
1143                                      c.getString(iconResourceIndex));
1144                              values.put(LauncherSettings.Favorites.ITEM_TYPE, itemType);
1145                              values.put(LauncherSettings.Favorites.APPWIDGET_ID, -1);
1146                              values.put(LauncherSettings.Favorites.URI, c.getString(uriIndex));
1147                              values.put(LauncherSettings.Favorites.DISPLAY_MODE,
1148                                      c.getInt(displayModeIndex));
1149                              values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
1150  
1151                              if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1152                                  hotseat.put(screen, values);
1153                              }
1154  
1155                              if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1156                                  // In a folder or in the hotseat, preserve position
1157                                  values.put(LauncherSettings.Favorites.SCREEN, screen);
1158                                  values.put(LauncherSettings.Favorites.CELLX, cellX);
1159                                  values.put(LauncherSettings.Favorites.CELLY, cellY);
1160                              } else {
1161                                  // For items contained directly on one of the workspace screen,
1162                                  // we&#x27;ll determine their location (screen, x, y) in a second pass.
1163                              }
1164  
1165                              values.put(LauncherSettings.Favorites.CONTAINER, container);
1166  
1167                              if (itemType != Favorites.ITEM_TYPE_FOLDER) {
1168                                  shortcuts.add(values);
1169                              } else {
1170                                  folders.add(values);
1171                              }
1172                          }
1173  
1174                          // Now that we have all the hotseat icons, let&#x27;s go through them left-right
1175                          // and assign valid locations for them in the new hotseat
1176                          final int N = hotseat.size();
1177                          for (int idx=0; idx&lt;N; idx++) {
1178                              int hotseatX = hotseat.keyAt(idx);
1179                              ContentValues values = hotseat.valueAt(idx);
1180  
1181                              if (hotseatX == grid.hotseatAllAppsRank) {
1182                                  // let&#x27;s drop this in the next available hole in the hotseat
1183                                  while (++hotseatX &lt; hotseatWidth) {
1184                                      if (hotseat.get(hotseatX) == null) {
1185                                          // found a spot! move it here
1186                                          values.put(LauncherSettings.Favorites.SCREEN,
1187                                                  hotseatX);
1188                                          break;
1189                                      }
1190                                  }
1191                              }
1192                              if (hotseatX &gt;= hotseatWidth) {
1193                                  // no room for you in the hotseat? it&#x27;s off to the desktop with you
1194                                  values.put(LauncherSettings.Favorites.CONTAINER,
1195                                             Favorites.CONTAINER_DESKTOP);
1196                              }
1197                          }
1198  
1199                          final ArrayList&lt;ContentValues&gt; allItems = new ArrayList&lt;ContentValues&gt;();
1200                          // Folders first
1201                          allItems.addAll(folders);
1202                          // Then shortcuts
1203                          allItems.addAll(shortcuts);
1204  
1205                          // Layout all the folders
1206                          for (ContentValues values: allItems) {
1207                              if (values.getAsInteger(LauncherSettings.Favorites.CONTAINER) !=
1208                                      LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1209                                  // Hotseat items and folder items have already had their
1210                                  // location information set. Nothing to be done here.
1211                                  continue;
1212                              }
1213                              values.put(LauncherSettings.Favorites.SCREEN, curScreen);
1214                              values.put(LauncherSettings.Favorites.CELLX, curX);
1215                              values.put(LauncherSettings.Favorites.CELLY, curY);
1216                              curX = (curX + 1) % width;
1217                              if (curX == 0) {
1218                                  curY = (curY + 1);
1219                              }
1220                              // Leave the last row of icons blank on every screen
1221                              if (curY == height - 1) {
1222                                  curScreen = (int) generateNewScreenId();
1223                                  curY = 0;
1224                              }
1225                          }
1226  
1227                          if (allItems.size() &gt; 0) {
1228                              db.beginTransaction();
1229                              try {
1230                                  for (ContentValues row: allItems) {
1231                                      if (row == null) continue;
1232                                      if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, row)
1233                                              &lt; 0) {
1234                                          return;
1235                                      } else {
1236                                          count++;
1237                                      }
1238                                  }
1239                                  db.setTransactionSuccessful();
1240                              } finally {
1241                                  db.endTransaction();
1242                              }
1243                          }
1244  
1245                          db.beginTransaction();
1246                          try {
1247                              for (i=0; i&lt;=curScreen; i++) {
1248                                  final ContentValues values = new ContentValues();
1249                                  values.put(LauncherSettings.WorkspaceScreens._ID, i);
1250                                  values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1251                                  if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values)
1252                                          &lt; 0) {
1253                                      return;
1254                                  }
1255                              }
1256                              db.setTransactionSuccessful();
1257                          } finally {
1258                              db.endTransaction();
1259                          }
1260  
1261                          updateFolderItemsRank(db, false);
1262                      }
1263                  } finally {
1264                      c.close();
1265                  }
1266              }
1267  
1268              Launcher.addDumpLog(TAG, &quot;migrated &quot; + count + &quot; icons from Launcher2 into &quot;
1269                      + (curScreen+1) + &quot; screens&quot;, true);
1270  
1271              // ensure that new screens are created to hold these icons
1272              setFlagJustLoadedOldDb();
1273  
1274              // Update max IDs; very important since we just grabbed IDs from another database
1275              mMaxItemId = initializeMaxItemId(db);
1276              mMaxScreenId = initializeMaxScreenId(db);
1277              if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId + &quot; mMaxScreenId: &quot; + mMaxScreenId);
1278          }
1279      }
1280  
1281      static class SqlArguments {
1282          public final String table;
1283          public final String where;
1284          public final String[] args;
1285  
1286          SqlArguments(Uri url, String where, String[] args) {
1287              if (url.getPathSegments().size() == 1) {
1288                  this.table = url.getPathSegments().get(0);
1289                  this.where = where;
1290                  this.args = args;
1291              } else if (url.getPathSegments().size() != 2) {
1292                  throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
1293              } else if (!TextUtils.isEmpty(where)) {
1294                  throw new UnsupportedOperationException(&quot;WHERE clause not supported: &quot; + url);
1295              } else {
1296                  this.table = url.getPathSegments().get(0);
1297                  this.where = &quot;_id=&quot; + ContentUris.parseId(url);
1298                  this.args = null;
1299              }
1300          }
1301  
1302          SqlArguments(Uri url) {
1303              if (url.getPathSegments().size() == 1) {
1304                  table = url.getPathSegments().get(0);
1305                  where = null;
1306                  args = null;
1307              } else {
1308                  throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
1309              }
1310          }
1311      }
1312  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.appwidget.AppWidgetHost;
  20  import android.appwidget.AppWidgetManager;
  21  import android.content.ComponentName;
  22  import android.content.ContentProvider;
  23  import android.content.ContentProviderOperation;
  24  import android.content.ContentProviderResult;
  25  import android.content.ContentResolver;
  26  import android.content.ContentUris;
  27  import android.content.ContentValues;
  28  import android.content.Context;
  29  import android.content.Intent;
  30  import android.content.OperationApplicationException;
  31  import android.content.SharedPreferences;
  32  import android.content.res.Resources;
  33  import android.database.Cursor;
  34  import android.database.SQLException;
  35  import android.database.sqlite.SQLiteDatabase;
  36  import android.database.sqlite.SQLiteOpenHelper;
  37  import android.database.sqlite.SQLiteQueryBuilder;
  38  import android.net.Uri;
  39  import android.os.StrictMode;
  40  import android.text.TextUtils;
  41  import android.util.Log;
  42  import android.util.SparseArray;
  43  
  44  import com.android.launcher3.AutoInstallsLayout.LayoutParserCallback;
  45  import com.android.launcher3.LauncherSettings.Favorites;
  46  import com.android.launcher3.compat.UserHandleCompat;
  47  import com.android.launcher3.compat.UserManagerCompat;
  48  import com.android.launcher3.config.ProviderConfig;
  49  
  50  import java.io.File;
  51  import java.net.URISyntaxException;
  52  import java.util.ArrayList;
  53  import java.util.Collections;
  54  import java.util.HashSet;
  55  
  56  public class LauncherProvider extends ContentProvider {
  57      private static final String TAG = &quot;Launcher.LauncherProvider&quot;;
  58      private static final boolean LOGD = false;
  59  
  60      private static final int MIN_DATABASE_VERSION = 12;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  61 -    private static final int DATABASE_VERSION = 21;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +    private static final int DATABASE_VERSION = 22;</span>
  63  
  64      static final String OLD_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
  65      static final String AUTHORITY = ProviderConfig.AUTHORITY;
  66  
  67      static final String TABLE_FAVORITES = &quot;favorites&quot;;
  68      static final String TABLE_WORKSPACE_SCREENS = &quot;workspaceScreens&quot;;
  69      static final String PARAMETER_NOTIFY = &quot;notify&quot;;
  70      static final String UPGRADED_FROM_OLD_DATABASE = &quot;UPGRADED_FROM_OLD_DATABASE&quot;;
  71      static final String EMPTY_DATABASE_CREATED = &quot;EMPTY_DATABASE_CREATED&quot;;
  72  
  73      private static final String URI_PARAM_IS_EXTERNAL_ADD = &quot;isExternalAdd&quot;;
  74  
  75      private LauncherProviderChangeListener mListener;
  76  
  77      /**
  78       * {@link Uri} triggered at any registered {@link android.database.ContentObserver} when
  79       * {@link AppWidgetHost#deleteHost()} is called during database creation.
  80       * Use this to recall {@link AppWidgetHost#startListening()} if needed.
  81       */
  82      static final Uri CONTENT_APPWIDGET_RESET_URI =
  83              Uri.parse(&quot;content://&quot; + AUTHORITY + &quot;/appWidgetReset&quot;);
  84  
  85      private DatabaseHelper mOpenHelper;
  86  
  87      @Override
  88      public boolean onCreate() {
  89          final Context context = getContext();
  90          StrictMode.ThreadPolicy oldPolicy = StrictMode.allowThreadDiskWrites();
  91          mOpenHelper = new DatabaseHelper(context);
  92          StrictMode.setThreadPolicy(oldPolicy);
  93          LauncherAppState.setLauncherProvider(this);
  94          return true;
  95      }
  96  
  97      public boolean wasNewDbCreated() {
  98          return mOpenHelper.wasNewDbCreated();
  99      }
 100  
 101      public void setLauncherProviderChangeListener(LauncherProviderChangeListener listener) {
 102          mListener = listener;
 103      }
 104  
 105      @Override
 106      public String getType(Uri uri) {
 107          SqlArguments args = new SqlArguments(uri, null, null);
 108          if (TextUtils.isEmpty(args.where)) {
 109              return &quot;vnd.android.cursor.dir/&quot; + args.table;
 110          } else {
 111              return &quot;vnd.android.cursor.item/&quot; + args.table;
 112          }
 113      }
 114  
 115      @Override
 116      public Cursor query(Uri uri, String[] projection, String selection,
 117              String[] selectionArgs, String sortOrder) {
 118  
 119          SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 120          SQLiteQueryBuilder qb = new SQLiteQueryBuilder();
 121          qb.setTables(args.table);
 122  
 123          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 124          Cursor result = qb.query(db, projection, args.where, args.args, null, null, sortOrder);
 125          result.setNotificationUri(getContext().getContentResolver(), uri);
 126  
 127          return result;
 128      }
 129  
 130      private static long dbInsertAndCheck(DatabaseHelper helper,
 131              SQLiteDatabase db, String table, String nullColumnHack, ContentValues values) {
 132          if (values == null) {
 133              throw new RuntimeException(&quot;Error: attempting to insert null values&quot;);
 134          }
 135          if (!values.containsKey(LauncherSettings.ChangeLogColumns._ID)) {
 136              throw new RuntimeException(&quot;Error: attempting to add item without specifying an id&quot;);
 137          }
 138          helper.checkId(table, values);
 139          return db.insert(table, nullColumnHack, values);
 140      }
 141  
 142      @Override
 143      public Uri insert(Uri uri, ContentValues initialValues) {
 144          SqlArguments args = new SqlArguments(uri);
 145  
 146          // In very limited cases, we support system|signature permission apps to add to the db
 147          String externalAdd = uri.getQueryParameter(URI_PARAM_IS_EXTERNAL_ADD);
 148          if (externalAdd != null &amp;&amp; &quot;true&quot;.equals(externalAdd)) {
 149              if (!mOpenHelper.initializeExternalAdd(initialValues)) {
 150                  return null;
 151              }
 152          }
 153  
 154          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 155          addModifiedTime(initialValues);
 156          final long rowId = dbInsertAndCheck(mOpenHelper, db, args.table, null, initialValues);
 157          if (rowId &lt;= 0) return null;
 158  
 159          uri = ContentUris.withAppendedId(uri, rowId);
 160          sendNotify(uri);
 161  
 162          return uri;
 163      }
 164  
 165  
 166      @Override
 167      public int bulkInsert(Uri uri, ContentValues[] values) {
 168          SqlArguments args = new SqlArguments(uri);
 169  
 170          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 171          db.beginTransaction();
 172          try {
 173              int numValues = values.length;
 174              for (int i = 0; i &lt; numValues; i++) {
 175                  addModifiedTime(values[i]);
 176                  if (dbInsertAndCheck(mOpenHelper, db, args.table, null, values[i]) &lt; 0) {
 177                      return 0;
 178                  }
 179              }
 180              db.setTransactionSuccessful();
 181          } finally {
 182              db.endTransaction();
 183          }
 184  
 185          sendNotify(uri);
 186          return values.length;
 187      }
 188  
 189      @Override
 190      public ContentProviderResult[] applyBatch(ArrayList&lt;ContentProviderOperation&gt; operations)
 191              throws OperationApplicationException {
 192          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 193          db.beginTransaction();
 194          try {
 195              ContentProviderResult[] result =  super.applyBatch(operations);
 196              db.setTransactionSuccessful();
 197              return result;
 198          } finally {
 199              db.endTransaction();
 200          }
 201      }
 202  
 203      @Override
 204      public int delete(Uri uri, String selection, String[] selectionArgs) {
 205          SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 206  
 207          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 208          int count = db.delete(args.table, args.where, args.args);
 209          if (count &gt; 0) sendNotify(uri);
 210  
 211          return count;
 212      }
 213  
 214      @Override
 215      public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
 216          SqlArguments args = new SqlArguments(uri, selection, selectionArgs);
 217  
 218          addModifiedTime(values);
 219          SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 220          int count = db.update(args.table, values, args.where, args.args);
 221          if (count &gt; 0) sendNotify(uri);
 222  
 223          return count;
 224      }
 225  
 226      private void sendNotify(Uri uri) {
 227          String notify = uri.getQueryParameter(PARAMETER_NOTIFY);
 228          if (notify == null || &quot;true&quot;.equals(notify)) {
 229              getContext().getContentResolver().notifyChange(uri, null);
 230          }
 231  
 232          // always notify the backup agent
 233          LauncherBackupAgentHelper.dataChanged(getContext());
 234          if (mListener != null) {
 235              mListener.onLauncherProviderChange();
 236          }
 237      }
 238  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 239 -    private void addModifiedTime(ContentValues values) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +    private static void addModifiedTime(ContentValues values) {</span>
 241          values.put(LauncherSettings.ChangeLogColumns.MODIFIED, System.currentTimeMillis());
 242      }
 243  
 244      public long generateNewItemId() {
 245          return mOpenHelper.generateNewItemId();
 246      }
 247  
 248      public void updateMaxItemId(long id) {
 249          mOpenHelper.updateMaxItemId(id);
 250      }
 251  
 252      public long generateNewScreenId() {
 253          return mOpenHelper.generateNewScreenId();
 254      }
 255  
 256      // This is only required one time while loading the workspace during the
 257      // upgrade path, and should never be called from anywhere else.
 258      public void updateMaxScreenId(long maxScreenId) {
 259          mOpenHelper.updateMaxScreenId(maxScreenId);
 260      }
 261  
 262      /**
 263       * Clears all the data for a fresh start.
 264       */
 265      synchronized public void createEmptyDB() {
 266          mOpenHelper.createEmptyDB(mOpenHelper.getWritableDatabase());
 267      }
 268  
 269      public void clearFlagEmptyDbCreated() {
 270          String spKey = LauncherAppState.getSharedPreferencesKey();
 271          getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE)
 272              .edit()
 273              .remove(EMPTY_DATABASE_CREATED)
 274              .commit();
 275      }
 276  
 277      /**
 278       * Loads the default workspace based on the following priority scheme:
 279       *   1) From a package provided by play store
 280       *   2) From a partner configuration APK, already in the system image
 281       *   3) The default configuration for the particular device
 282       */
 283      synchronized public void loadDefaultFavoritesIfNecessary() {
 284          String spKey = LauncherAppState.getSharedPreferencesKey();
 285          SharedPreferences sp = getContext().getSharedPreferences(spKey, Context.MODE_PRIVATE);
 286  
 287          if (sp.getBoolean(EMPTY_DATABASE_CREATED, false)) {
 288              Log.d(TAG, &quot;loading default workspace&quot;);
 289  
 290              AutoInstallsLayout loader = AutoInstallsLayout.get(getContext(),
 291                      mOpenHelper.mAppWidgetHost, mOpenHelper);
 292  
 293              if (loader == null) {
 294                  final Partner partner = Partner.get(getContext().getPackageManager());
 295                  if (partner != null &amp;&amp; partner.hasDefaultLayout()) {
 296                      final Resources partnerRes = partner.getResources();
 297                      int workspaceResId = partnerRes.getIdentifier(Partner.RES_DEFAULT_LAYOUT,
 298                              &quot;xml&quot;, partner.getPackageName());
 299                      if (workspaceResId != 0) {
 300                          loader = new DefaultLayoutParser(getContext(), mOpenHelper.mAppWidgetHost,
 301                                  mOpenHelper, partnerRes, workspaceResId);
 302                      }
 303                  }
 304              }
 305  
 306              final boolean usingExternallyProvidedLayout = loader != null;
 307              if (loader == null) {
 308                  loader = getDefaultLayoutParser();
 309              }
 310              // Populate favorites table with initial favorites
 311              if ((mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(), loader) &lt;= 0)
 312                      &amp;&amp; usingExternallyProvidedLayout) {
 313                  // Unable to load external layout. Cleanup and load the internal layout.
 314                  createEmptyDB();
 315                  mOpenHelper.loadFavorites(mOpenHelper.getWritableDatabase(),
 316                          getDefaultLayoutParser());
 317              }
 318              clearFlagEmptyDbCreated();
 319          }
 320      }
 321  
 322      private DefaultLayoutParser getDefaultLayoutParser() {
 323          int defaultLayout = LauncherAppState.getInstance()
 324                  .getDynamicGrid().getDeviceProfile().defaultLayoutId;
 325          return new DefaultLayoutParser(getContext(), mOpenHelper.mAppWidgetHost,
 326                  mOpenHelper, getContext().getResources(), defaultLayout);
 327      }
 328  
 329      public void migrateLauncher2Shortcuts() {
 330          mOpenHelper.migrateLauncher2Shortcuts(mOpenHelper.getWritableDatabase(),
 331                  Uri.parse(getContext().getString(R.string.old_launcher_provider_uri)));
 332      }
 333  
 334      public void updateFolderItemsRank() {
 335          mOpenHelper.updateFolderItemsRank(mOpenHelper.getWritableDatabase(), false);
 336      }
 337  
 338      public void deleteDatabase() {
 339          // Are you sure? (y/n)
 340          final SQLiteDatabase db = mOpenHelper.getWritableDatabase();
 341          final File dbFile = new File(db.getPath());
 342          mOpenHelper.close();
 343          if (dbFile.exists()) {
 344              SQLiteDatabase.deleteDatabase(dbFile);
 345          }
 346          mOpenHelper = new DatabaseHelper(getContext());
 347      }
 348  
 349      private static class DatabaseHelper extends SQLiteOpenHelper implements LayoutParserCallback {
 350          private final Context mContext;
 351          private final AppWidgetHost mAppWidgetHost;
 352          private long mMaxItemId = -1;
 353          private long mMaxScreenId = -1;
 354  
 355          private boolean mNewDbCreated = false;
 356  
 357          DatabaseHelper(Context context) {
 358              super(context, LauncherFiles.LAUNCHER_DB, null, DATABASE_VERSION);
 359              mContext = context;
 360              mAppWidgetHost = new AppWidgetHost(context, Launcher.APPWIDGET_HOST_ID);
 361  
 362              // In the case where neither onCreate nor onUpgrade gets called, we read the maxId from
 363              // the DB here
 364              if (mMaxItemId == -1) {
 365                  mMaxItemId = initializeMaxItemId(getWritableDatabase());
 366              }
 367              if (mMaxScreenId == -1) {
 368                  mMaxScreenId = initializeMaxScreenId(getWritableDatabase());
 369              }
 370          }
 371  
 372          public boolean wasNewDbCreated() {
 373              return mNewDbCreated;
 374          }
 375  
 376          /**
 377           * Send notification that we&#x27;ve deleted the {@link AppWidgetHost},
 378           * probably as part of the initial database creation. The receiver may
 379           * want to re-call {@link AppWidgetHost#startListening()} to ensure
 380           * callbacks are correctly set.
 381           */
 382          private void sendAppWidgetResetNotify() {
 383              final ContentResolver resolver = mContext.getContentResolver();
 384              resolver.notifyChange(CONTENT_APPWIDGET_RESET_URI, null);
 385          }
 386  
 387          @Override
 388          public void onCreate(SQLiteDatabase db) {
 389              if (LOGD) Log.d(TAG, &quot;creating new launcher database&quot;);
 390  
 391              mMaxItemId = 1;
 392              mMaxScreenId = 0;
 393              mNewDbCreated = true;
 394  
 395              UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 396              long userSerialNumber = userManager.getSerialNumberForUser(
 397                      UserHandleCompat.myUserHandle());
 398  
 399              db.execSQL(&quot;CREATE TABLE favorites (&quot; +
 400                      &quot;_id INTEGER PRIMARY KEY,&quot; +
 401                      &quot;title TEXT,&quot; +
 402                      &quot;intent TEXT,&quot; +
 403                      &quot;container INTEGER,&quot; +
 404                      &quot;screen INTEGER,&quot; +
 405                      &quot;cellX INTEGER,&quot; +
 406                      &quot;cellY INTEGER,&quot; +
 407                      &quot;spanX INTEGER,&quot; +
 408                      &quot;spanY INTEGER,&quot; +
 409                      &quot;itemType INTEGER,&quot; +
 410                      &quot;appWidgetId INTEGER NOT NULL DEFAULT -1,&quot; +
 411                      &quot;isShortcut INTEGER,&quot; +
 412                      &quot;iconType INTEGER,&quot; +
 413                      &quot;iconPackage TEXT,&quot; +
 414                      &quot;iconResource TEXT,&quot; +
 415                      &quot;icon BLOB,&quot; +
 416                      &quot;uri TEXT,&quot; +
 417                      &quot;displayMode INTEGER,&quot; +
 418                      &quot;appWidgetProvider TEXT,&quot; +
 419                      &quot;modified INTEGER NOT NULL DEFAULT 0,&quot; +
 420                      &quot;restored INTEGER NOT NULL DEFAULT 0,&quot; +
 421                      &quot;profileId INTEGER DEFAULT &quot; + userSerialNumber + &quot;,&quot; +
 422                      &quot;rank INTEGER NOT NULL DEFAULT 0&quot; +
 423                      &quot;);&quot;);
 424              addWorkspacesTable(db);
 425  
 426              // Database was just created, so wipe any previous widgets
 427              if (mAppWidgetHost != null) {
 428                  mAppWidgetHost.deleteHost();
 429                  sendAppWidgetResetNotify();
 430              }
 431  
 432              // Fresh and clean launcher DB.
 433              mMaxItemId = initializeMaxItemId(db);
 434              setFlagEmptyDbCreated();
 435          }
 436  
 437          private void addWorkspacesTable(SQLiteDatabase db) {
 438              db.execSQL(&quot;CREATE TABLE &quot; + TABLE_WORKSPACE_SCREENS + &quot; (&quot; +
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 439 -                    LauncherSettings.WorkspaceScreens._ID + &quot; INTEGER,&quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 440 +                    LauncherSettings.WorkspaceScreens._ID + &quot; INTEGER PRIMARY KEY,&quot; +</span>
 441                      LauncherSettings.WorkspaceScreens.SCREEN_RANK + &quot; INTEGER,&quot; +
 442                      LauncherSettings.ChangeLogColumns.MODIFIED + &quot; INTEGER NOT NULL DEFAULT 0&quot; +
 443                      &quot;);&quot;);
 444          }
 445  
 446          private void removeOrphanedItems(SQLiteDatabase db) {
 447              // Delete items directly on the workspace who&#x27;s screen id doesn&#x27;t exist
 448              //  &quot;DELETE FROM favorites WHERE screen NOT IN (SELECT _id FROM workspaceScreens)
 449              //   AND container = -100&quot;
 450              String removeOrphanedDesktopItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +
 451                      &quot; WHERE &quot; +
 452                      LauncherSettings.Favorites.SCREEN + &quot; NOT IN (SELECT &quot; +
 453                      LauncherSettings.WorkspaceScreens._ID + &quot; FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot;)&quot; +
 454                      &quot; AND &quot; +
 455                      LauncherSettings.Favorites.CONTAINER + &quot; = &quot; +
 456                      LauncherSettings.Favorites.CONTAINER_DESKTOP;
 457              db.execSQL(removeOrphanedDesktopItems);
 458  
 459              // Delete items contained in folders which no longer exist (after above statement)
 460              //  &quot;DELETE FROM favorites  WHERE container &lt;&gt; -100 AND container &lt;&gt; -101 AND container
 461              //   NOT IN (SELECT _id FROM favorites WHERE itemType = 2)&quot;
 462              String removeOrphanedFolderItems = &quot;DELETE FROM &quot; + TABLE_FAVORITES +
 463                      &quot; WHERE &quot; +
 464                      LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +
 465                      LauncherSettings.Favorites.CONTAINER_DESKTOP +
 466                      &quot; AND &quot;
 467                      + LauncherSettings.Favorites.CONTAINER + &quot; &lt;&gt; &quot; +
 468                      LauncherSettings.Favorites.CONTAINER_HOTSEAT +
 469                      &quot; AND &quot;
 470                      + LauncherSettings.Favorites.CONTAINER + &quot; NOT IN (SELECT &quot; +
 471                      LauncherSettings.Favorites._ID + &quot; FROM &quot; + TABLE_FAVORITES +
 472                      &quot; WHERE &quot; + LauncherSettings.Favorites.ITEM_TYPE + &quot; = &quot; +
 473                      LauncherSettings.Favorites.ITEM_TYPE_FOLDER + &quot;)&quot;;
 474              db.execSQL(removeOrphanedFolderItems);
 475          }
 476  
 477          private void setFlagJustLoadedOldDb() {
 478              String spKey = LauncherAppState.getSharedPreferencesKey();
 479              SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 480              SharedPreferences.Editor editor = sp.edit();
 481              editor.putBoolean(UPGRADED_FROM_OLD_DATABASE, true);
 482              editor.putBoolean(EMPTY_DATABASE_CREATED, false);
 483              editor.commit();

 484          }
 485  
 486          private void setFlagEmptyDbCreated() {
 487              String spKey = LauncherAppState.getSharedPreferencesKey();
 488              SharedPreferences sp = mContext.getSharedPreferences(spKey, Context.MODE_PRIVATE);
 489              SharedPreferences.Editor editor = sp.edit();
 490              editor.putBoolean(EMPTY_DATABASE_CREATED, true);
 491              editor.putBoolean(UPGRADED_FROM_OLD_DATABASE, false);
 492              editor.commit();

 493          }
 494  
 495          @Override
 496          public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 497              if (LOGD) Log.d(TAG, &quot;onUpgrade triggered: &quot; + oldVersion);
 498  
 499              int version = oldVersion;
 500              if (version &lt; MIN_DATABASE_VERSION) {
 501                  // The version cannot be lower that this, as Launcher3 never supported a lower


 502                  // version of the DB.
 503                  createEmptyDB(db);
 504                  version = DATABASE_VERSION;
 505              }
 506  
 507              if (version &lt; 13) {
 508                  // With the new shrink-wrapped and re-orderable workspaces, it makes sense
 509                  // to persist workspace screens and their relative order.
 510                  mMaxScreenId = 0;
 511  
 512                  addWorkspacesTable(db);
 513                  version = 13;
 514              }
 515  
 516              if (version &lt; 14) {
 517                  db.beginTransaction();
 518                  try {
 519                      // Insert new column for holding widget provider name
 520                      db.execSQL(&quot;ALTER TABLE favorites &quot; +
 521                              &quot;ADD COLUMN appWidgetProvider TEXT;&quot;);
 522                      db.setTransactionSuccessful();
 523                      version = 14;
 524                  } catch (SQLException ex) {
 525                      // Old version remains, which means we wipe old data
 526                      Log.e(TAG, ex.getMessage(), ex);
 527                  } finally {
 528                      db.endTransaction();
 529                  }
 530              }
 531  
 532              if (version &lt; 15) {
 533                  db.beginTransaction();
 534                  try {
 535                      // Insert new column for holding update timestamp
 536                      db.execSQL(&quot;ALTER TABLE favorites &quot; +
 537                              &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);
 538                      db.execSQL(&quot;ALTER TABLE workspaceScreens &quot; +
 539                              &quot;ADD COLUMN modified INTEGER NOT NULL DEFAULT 0;&quot;);
 540                      db.setTransactionSuccessful();
 541                      version = 15;
 542                  } catch (SQLException ex) {
 543                      // Old version remains, which means we wipe old data
 544                      Log.e(TAG, ex.getMessage(), ex);
 545                  } finally {
 546                      db.endTransaction();
 547                  }
 548              }
 549  
 550  
 551              if (version &lt; 16) {
 552                  db.beginTransaction();
 553                  try {
 554                      // Insert new column for holding restore status
 555                      db.execSQL(&quot;ALTER TABLE favorites &quot; +
 556                              &quot;ADD COLUMN restored INTEGER NOT NULL DEFAULT 0;&quot;);
 557                      db.setTransactionSuccessful();
 558                      version = 16;
 559                  } catch (SQLException ex) {
 560                      // Old version remains, which means we wipe old data
 561                      Log.e(TAG, ex.getMessage(), ex);
 562                  } finally {
 563                      db.endTransaction();
 564                  }
 565              }
 566  
 567              if (version &lt; 17) {
 568                  // We use the db version upgrade here to identify users who may not have seen
 569                  // clings yet (because they weren&#x27;t available), but for whom the clings are now
 570                  // available (tablet users). Because one of the possible cling flows (migration)
 571                  // is very destructive (wipes out workspaces), we want to prevent this from showing
 572                  // until clear data. We do so by marking that the clings have been shown.
 573                  LauncherClings.synchonouslyMarkFirstRunClingDismissed(mContext);
 574                  version = 17;
 575              }
 576  
 577              if (version &lt; 18) {
 578                  // No-op
 579                  version = 18;
 580              }
 581  
 582              if (version &lt; 19) {
 583                  // Due to a data loss bug, some users may have items associated with screen ids
 584                  // which no longer exist. Since this can cause other problems, and since the user
 585                  // will never see these items anyway, we use database upgrade as an opportunity to
 586                  // clean things up.
 587                  removeOrphanedItems(db);
 588                  version = 19;
 589              }
 590  
 591              if (version &lt; 20) {
 592                  // Add userId column
 593                  if (addProfileColumn(db)) {
 594                      version = 20;
 595                  }
 596                  // else old version remains, which means we wipe old data
 597              }
 598  
 599              if (version &lt; 21) {
 600                  if (updateFolderItemsRank(db, true)) {
 601                      version  = 21;
 602                  }
 603              }
 604  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 605 +            if (version == 21) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 606 +                // Recreate workspace table with screen id a primary key</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 607 +                if (recreateWorkspaceTable(db)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 608 +                    version = 22;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 609 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 610 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 611 +</span>
 612              if (version != DATABASE_VERSION) {
 613                  Log.w(TAG, &quot;Destroying all old data.&quot;);
 614                  createEmptyDB(db);
 615              }



























































































 616          }
 617  
 618          @Override
 619          public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
 620              // This shouldn&#x27;t happen -- throw our hands up in the air and start over.
 621              Log.w(TAG, &quot;Database version downgrade from: &quot; + oldVersion + &quot; to &quot; + newVersion +
 622                      &quot;. Wiping databse.&quot;);
 623              createEmptyDB(db);
 624          }
 625  
 626  
 627          /**
 628           * Clears all the data for a fresh start.
 629           */
 630          public void createEmptyDB(SQLiteDatabase db) {
 631              db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_FAVORITES);
 632              db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);
 633              onCreate(db);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 634 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 635 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 636 +        /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 637 +         * Recreates workspace table and migrates data to the new table.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 638 +         */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 639 +        public boolean recreateWorkspaceTable(SQLiteDatabase db) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 640 +            db.beginTransaction();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 641 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 642 +                Cursor c = db.query(TABLE_WORKSPACE_SCREENS,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 643 +                        new String[] {LauncherSettings.WorkspaceScreens._ID},</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 644 +                        null, null, null, null,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 645 +                        LauncherSettings.WorkspaceScreens.SCREEN_RANK);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 646 +                ArrayList&lt;Long&gt; sortedIDs = new ArrayList&lt;Long&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 647 +                long maxId = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 648 +                try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 649 +                    while (c.moveToNext()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 650 +                        Long id = c.getLong(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 651 +                        if (!sortedIDs.contains(id)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 652 +                            sortedIDs.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 653 +                            maxId = Math.max(maxId, id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 654 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 655 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 656 +                } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 657 +                    c.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 658 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 659 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 660 +                db.execSQL(&quot;DROP TABLE IF EXISTS &quot; + TABLE_WORKSPACE_SCREENS);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 661 +                addWorkspacesTable(db);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 662 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 663 +                // Add all screen ids back</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 664 +                int total = sortedIDs.size();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 665 +                for (int i = 0; i &lt; total; i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 666 +                    ContentValues values = new ContentValues();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 667 +                    values.put(LauncherSettings.WorkspaceScreens._ID, sortedIDs.get(i));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 668 +                    values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 669 +                    addModifiedTime(values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 670 +                    db.insertOrThrow(TABLE_WORKSPACE_SCREENS, null, values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 671 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 672 +                db.setTransactionSuccessful();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 673 +                mMaxScreenId = maxId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 674 +            } catch (SQLException ex) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 675 +                // Old version remains, which means we wipe old data</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 676 +                Log.e(TAG, ex.getMessage(), ex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 677 +                return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 678 +            } finally {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 679 +                db.endTransaction();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 680 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 681 +            return true;</span>
 682          }
 683  
 684          private boolean updateFolderItemsRank(SQLiteDatabase db, boolean addRankColumn) {
 685              db.beginTransaction();
 686              try {
 687                  if (addRankColumn) {
 688                      // Insert new column for holding rank
 689                      db.execSQL(&quot;ALTER TABLE favorites ADD COLUMN rank INTEGER NOT NULL DEFAULT 0;&quot;);
 690                  }
 691  
 692                  // Get a map for folder ID to folder width
 693                  Cursor c = db.rawQuery(&quot;SELECT container, MAX(cellX) FROM favorites&quot;
 694                          + &quot; WHERE container IN (SELECT _id FROM favorites WHERE itemType = ?)&quot;
 695                          + &quot; GROUP BY container;&quot;,
 696                          new String[] {Integer.toString(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)});
 697  
 698                  while (c.moveToNext()) {
 699                      db.execSQL(&quot;UPDATE favorites SET rank=cellX+(cellY*?) WHERE &quot;
 700                              + &quot;container=? AND cellX IS NOT NULL AND cellY IS NOT NULL;&quot;,
 701                              new Object[] {c.getLong(1) + 1, c.getLong(0)});
 702                  }
 703  
 704                  c.close();
 705                  db.setTransactionSuccessful();
 706              } catch (SQLException ex) {
 707                  // Old version remains, which means we wipe old data
 708                  Log.e(TAG, ex.getMessage(), ex);
 709                  return false;
 710              } finally {
 711                  db.endTransaction();
 712              }
 713              return true;
 714          }
 715  
 716          private boolean addProfileColumn(SQLiteDatabase db) {
 717              db.beginTransaction();
 718              try {
 719                  UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
 720                  // Default to the serial number of this user, for older
 721                  // shortcuts.
 722                  long userSerialNumber = userManager.getSerialNumberForUser(
 723                          UserHandleCompat.myUserHandle());
 724                  // Insert new column for holding user serial number
 725                  db.execSQL(&quot;ALTER TABLE favorites &quot; +
 726                          &quot;ADD COLUMN profileId INTEGER DEFAULT &quot;
 727                                          + userSerialNumber + &quot;;&quot;);
 728                  db.setTransactionSuccessful();
 729              } catch (SQLException ex) {
 730                  // Old version remains, which means we wipe old data
 731                  Log.e(TAG, ex.getMessage(), ex);
 732                  return false;
 733              } finally {
 734                  db.endTransaction();
 735              }
 736              return true;
 737          }
 738  
 739          // Generates a new ID to use for an object in your database. This method should be only
 740          // called from the main UI thread. As an exception, we do call it when we call the
 741          // constructor from the worker thread; however, this doesn&#x27;t extend until after the
 742          // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
 743          // after that point
 744          @Override
 745          public long generateNewItemId() {
 746              if (mMaxItemId &lt; 0) {
 747                  throw new RuntimeException(&quot;Error: max item id was not initialized&quot;);
 748              }
 749              mMaxItemId += 1;
 750              return mMaxItemId;
 751          }
 752  
 753          @Override
 754          public long insertAndCheck(SQLiteDatabase db, ContentValues values) {
 755              return dbInsertAndCheck(this, db, TABLE_FAVORITES, null, values);
 756          }
 757  
 758          public void updateMaxItemId(long id) {
 759              mMaxItemId = id + 1;
 760          }
 761  
 762          public void checkId(String table, ContentValues values) {
 763              long id = values.getAsLong(LauncherSettings.BaseLauncherColumns._ID);
 764              if (table == LauncherProvider.TABLE_WORKSPACE_SCREENS) {
 765                  mMaxScreenId = Math.max(id, mMaxScreenId);
 766              }  else {
 767                  mMaxItemId = Math.max(id, mMaxItemId);
 768              }
 769          }
 770  
 771          private long initializeMaxItemId(SQLiteDatabase db) {
 772              Cursor c = db.rawQuery(&quot;SELECT MAX(_id) FROM favorites&quot;, null);
 773  
 774              // get the result
 775              final int maxIdIndex = 0;
 776              long id = -1;
 777              if (c != null &amp;&amp; c.moveToNext()) {
 778                  id = c.getLong(maxIdIndex);
 779              }
 780              if (c != null) {
 781                  c.close();
 782              }
 783  
 784              if (id == -1) {
 785                  throw new RuntimeException(&quot;Error: could not query max item id&quot;);
 786              }
 787  
 788              return id;
 789          }
 790  
 791          // Generates a new ID to use for an workspace screen in your database. This method
 792          // should be only called from the main UI thread. As an exception, we do call it when we
 793          // call the constructor from the worker thread; however, this doesn&#x27;t extend until after the
 794          // constructor is called, and we only pass a reference to LauncherProvider to LauncherApp
 795          // after that point
 796          public long generateNewScreenId() {
 797              if (mMaxScreenId &lt; 0) {
 798                  throw new RuntimeException(&quot;Error: max screen id was not initialized&quot;);
 799              }
 800              mMaxScreenId += 1;
 801              // Log to disk
 802              Launcher.addDumpLog(TAG, &quot;11683562 - generateNewScreenId(): &quot; + mMaxScreenId, true);
 803              return mMaxScreenId;
 804          }
 805  
 806          public void updateMaxScreenId(long maxScreenId) {
 807              // Log to disk
 808              Launcher.addDumpLog(TAG, &quot;11683562 - updateMaxScreenId(): &quot; + maxScreenId, true);
 809              mMaxScreenId = maxScreenId;
 810          }
 811  
 812          private long initializeMaxScreenId(SQLiteDatabase db) {
<abbr title=" 813              Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);"> 813              Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens._ID + &quot;) FROM &quot; + TABLE_WORKS</abbr>
 814  
 815              // get the result
 816              final int maxIdIndex = 0;
 817              long id = -1;
 818              if (c != null &amp;&amp; c.moveToNext()) {
 819                  id = c.getLong(maxIdIndex);
 820              }
 821              if (c != null) {
 822                  c.close();
 823              }
 824  
 825              if (id == -1) {
 826                  throw new RuntimeException(&quot;Error: could not query max screen id&quot;);
 827              }
 828  
 829              // Log to disk
 830              Launcher.addDumpLog(TAG, &quot;11683562 - initializeMaxScreenId(): &quot; + id, true);
 831              return id;
 832          }
 833  
 834          private boolean initializeExternalAdd(ContentValues values) {
 835              // 1. Ensure that externally added items have a valid item id
 836              long id = generateNewItemId();
 837              values.put(LauncherSettings.Favorites._ID, id);
 838  
 839              // 2. In the case of an app widget, and if no app widget id is specified, we
 840              // attempt allocate and bind the widget.
 841              Integer itemType = values.getAsInteger(LauncherSettings.Favorites.ITEM_TYPE);
 842              if (itemType != null &amp;&amp;
 843                      itemType.intValue() == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;
 844                      !values.containsKey(LauncherSettings.Favorites.APPWIDGET_ID)) {
 845  
 846                  final AppWidgetManager appWidgetManager = AppWidgetManager.getInstance(mContext);
 847                  ComponentName cn = ComponentName.unflattenFromString(
 848                          values.getAsString(Favorites.APPWIDGET_PROVIDER));
 849  
 850                  if (cn != null) {
 851                      try {
 852                          int appWidgetId = mAppWidgetHost.allocateAppWidgetId();
 853                          values.put(LauncherSettings.Favorites.APPWIDGET_ID, appWidgetId);
 854                          if (!appWidgetManager.bindAppWidgetIdIfAllowed(appWidgetId,cn)) {
 855                              return false;
 856                          }
 857                      } catch (RuntimeException e) {
 858                          Log.e(TAG, &quot;Failed to initialize external widget&quot;, e);
 859                          return false;
 860                      }
 861                  } else {
 862                      return false;
 863                  }
 864              }
 865  
 866              // Add screen id if not present
 867              long screenId = values.getAsLong(LauncherSettings.Favorites.SCREEN);
 868              if (!addScreenIdIfNecessary(screenId)) {
 869                  return false;
 870              }
 871              return true;
 872          }
 873  
 874          // Returns true of screen id exists, or if successfully added
 875          private boolean addScreenIdIfNecessary(long screenId) {
 876              if (!hasScreenId(screenId)) {
 877                  int rank = getMaxScreenRank() + 1;
 878  
 879                  ContentValues v = new ContentValues();
 880                  v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
 881                  v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
 882                  if (dbInsertAndCheck(this, getWritableDatabase(),
 883                          TABLE_WORKSPACE_SCREENS, null, v) &lt; 0) {
 884                      return false;
 885                  }
 886              }
 887              return true;
 888          }
 889  
 890          private boolean hasScreenId(long screenId) {
 891              SQLiteDatabase db = getWritableDatabase();
 892              Cursor c = db.rawQuery(&quot;SELECT * FROM &quot; + TABLE_WORKSPACE_SCREENS + &quot; WHERE &quot;
 893                      + LauncherSettings.WorkspaceScreens._ID + &quot; = &quot; + screenId, null);
 894              if (c != null) {
 895                  int count = c.getCount();
 896                  c.close();
 897                  return count &gt; 0;
 898              } else {
 899                  return false;
 900              }
 901          }
 902  
 903          private int getMaxScreenRank() {
 904              SQLiteDatabase db = getWritableDatabase();
 905              Cursor c = db.rawQuery(&quot;SELECT MAX(&quot; + LauncherSettings.WorkspaceScreens.SCREEN_RANK
 906                      + &quot;) FROM &quot; + TABLE_WORKSPACE_SCREENS, null);
 907  
 908              // get the result
 909              final int maxRankIndex = 0;
 910              int rank = -1;
 911              if (c != null &amp;&amp; c.moveToNext()) {
 912                  rank = c.getInt(maxRankIndex);
 913              }
 914              if (c != null) {
 915                  c.close();
 916              }
 917  
 918              return rank;
 919          }
 920  
 921          private int loadFavorites(SQLiteDatabase db, AutoInstallsLayout loader) {
 922              ArrayList&lt;Long&gt; screenIds = new ArrayList&lt;Long&gt;();
 923              // TODO: Use multiple loaders with fall-back and transaction.
 924              int count = loader.loadLayout(db, screenIds);
 925  
 926              // Add the screens specified by the items above
 927              Collections.sort(screenIds);
 928              int rank = 0;
 929              ContentValues values = new ContentValues();
 930              for (Long id : screenIds) {
 931                  values.clear();
 932                  values.put(LauncherSettings.WorkspaceScreens._ID, id);
 933                  values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, rank);
 934                  if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values) &lt; 0) {
 935                      throw new RuntimeException(&quot;Failed initialize screen table&quot;
 936                              + &quot;from default layout&quot;);
 937                  }
 938                  rank++;
 939              }
 940  
 941              // Ensure that the max ids are initialized
 942              mMaxItemId = initializeMaxItemId(db);
 943              mMaxScreenId = initializeMaxScreenId(db);
 944  
 945              return count;
 946          }
 947  
 948          private void migrateLauncher2Shortcuts(SQLiteDatabase db, Uri uri) {
 949              final ContentResolver resolver = mContext.getContentResolver();
 950              Cursor c = null;
 951              int count = 0;
 952              int curScreen = 0;
 953  
 954              try {
 955                  c = resolver.query(uri, null, null, null, &quot;title ASC&quot;);
 956              } catch (Exception e) {
 957                  // Ignore
 958              }
 959  
 960              // We already have a favorites database in the old provider
 961              if (c != null) {
 962                  try {
 963                      if (c.getCount() &gt; 0) {
 964                          final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
 965                          final int intentIndex
 966                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
 967                          final int titleIndex
 968                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 969                          final int iconTypeIndex
 970                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);
 971                          final int iconIndex
 972                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
 973                          final int iconPackageIndex
 974                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);
 975                          final int iconResourceIndex
 976                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);
 977                          final int containerIndex
 978                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 979                          final int itemTypeIndex
 980                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 981                          final int screenIndex
 982                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 983                          final int cellXIndex
 984                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 985                          final int cellYIndex
 986                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 987                          final int uriIndex
 988                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
 989                          final int displayModeIndex
 990                                  = c.getColumnIndexOrThrow(LauncherSettings.Favorites.DISPLAY_MODE);
 991                          final int profileIndex
 992                                  = c.getColumnIndex(LauncherSettings.Favorites.PROFILE_ID);
 993  
 994                          int i = 0;
 995                          int curX = 0;
 996                          int curY = 0;
 997  
 998                          final LauncherAppState app = LauncherAppState.getInstance();
 999                          final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1000                          final int width = (int) grid.numColumns;
1001                          final int height = (int) grid.numRows;
1002                          final int hotseatWidth = (int) grid.numHotseatIcons;
1003  
1004                          final HashSet&lt;String&gt; seenIntents = new HashSet&lt;String&gt;(c.getCount());
1005  
1006                          final ArrayList&lt;ContentValues&gt; shortcuts = new ArrayList&lt;ContentValues&gt;();
1007                          final ArrayList&lt;ContentValues&gt; folders = new ArrayList&lt;ContentValues&gt;();
1008                          final SparseArray&lt;ContentValues&gt; hotseat = new SparseArray&lt;ContentValues&gt;();
1009  
1010                          while (c.moveToNext()) {
1011                              final int itemType = c.getInt(itemTypeIndex);
1012                              if (itemType != Favorites.ITEM_TYPE_APPLICATION
1013                                      &amp;&amp; itemType != Favorites.ITEM_TYPE_SHORTCUT
1014                                      &amp;&amp; itemType != Favorites.ITEM_TYPE_FOLDER) {
1015                                  continue;
1016                              }
1017  
1018                              final int cellX = c.getInt(cellXIndex);
1019                              final int cellY = c.getInt(cellYIndex);
1020                              final int screen = c.getInt(screenIndex);
1021                              int container = c.getInt(containerIndex);
1022                              final String intentStr = c.getString(intentIndex);
1023  
1024                              UserManagerCompat userManager = UserManagerCompat.getInstance(mContext);
1025                              UserHandleCompat userHandle;
1026                              final long userSerialNumber;
1027                              if (profileIndex != -1 &amp;&amp; !c.isNull(profileIndex)) {
1028                                  userSerialNumber = c.getInt(profileIndex);
1029                                  userHandle = userManager.getUserForSerialNumber(userSerialNumber);
1030                              } else {
1031                                  // Default to the serial number of this user, for older
1032                                  // shortcuts.
1033                                  userHandle = UserHandleCompat.myUserHandle();
1034                                  userSerialNumber = userManager.getSerialNumberForUser(userHandle);
1035                              }
1036  
1037                              if (userHandle == null) {
1038                                  Launcher.addDumpLog(TAG, &quot;skipping deleted user&quot;, true);
1039                                  continue;
1040                              }
1041  
1042                              Launcher.addDumpLog(TAG, &quot;migrating \&quot;&quot;
1043                                  + c.getString(titleIndex) + &quot;\&quot; (&quot;
1044                                  + cellX + &quot;,&quot; + cellY + &quot;@&quot;
1045                                  + LauncherSettings.Favorites.containerToString(container)
1046                                  + &quot;/&quot; + screen
1047                                  + &quot;): &quot; + intentStr, true);
1048  
1049                              if (itemType != Favorites.ITEM_TYPE_FOLDER) {
1050  
1051                                  final Intent intent;
1052                                  final ComponentName cn;
1053                                  try {
1054                                      intent = Intent.parseUri(intentStr, 0);
1055                                  } catch (URISyntaxException e) {
1056                                      // bogus intent?
1057                                      Launcher.addDumpLog(TAG,
1058                                              &quot;skipping invalid intent uri&quot;, true);
1059                                      continue;
1060                                  }
1061  
1062                                  cn = intent.getComponent();
1063                                  if (TextUtils.isEmpty(intentStr)) {
1064                                      // no intent? no icon
1065                                      Launcher.addDumpLog(TAG, &quot;skipping empty intent&quot;, true);
1066                                      continue;
1067                                  } else if (cn != null &amp;&amp;
1068                                          !LauncherModel.isValidPackageActivity(mContext, cn,
1069                                                  userHandle)) {
1070                                      // component no longer exists.
1071                                      Launcher.addDumpLog(TAG, &quot;skipping item whose component &quot; +
1072                                              &quot;no longer exists.&quot;, true);
1073                                      continue;
1074                                  } else if (container ==
1075                                          LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1076                                      // Dedupe icons directly on the workspace
1077  
1078                                      // Canonicalize
1079                                      // the Play Store sets the package parameter, but Launcher
1080                                      // does not, so we clear that out to keep them the same.
1081                                      // Also ignore intent flags for the purposes of deduping.
1082                                      intent.setPackage(null);
1083                                      int flags = intent.getFlags();
1084                                      intent.setFlags(0);
1085                                      final String key = intent.toUri(0);
1086                                      intent.setFlags(flags);
1087                                      if (seenIntents.contains(key)) {
1088                                          Launcher.addDumpLog(TAG, &quot;skipping duplicate&quot;, true);
1089                                          continue;
1090                                      } else {
1091                                          seenIntents.add(key);
1092                                      }
1093                                  }
1094                              }
1095  
1096                              ContentValues values = new ContentValues(c.getColumnCount());
1097                              values.put(LauncherSettings.Favorites._ID, c.getInt(idIndex));
1098                              values.put(LauncherSettings.Favorites.INTENT, intentStr);
1099                              values.put(LauncherSettings.Favorites.TITLE, c.getString(titleIndex));
1100                              values.put(LauncherSettings.Favorites.ICON_TYPE,
1101                                      c.getInt(iconTypeIndex));
1102                              values.put(LauncherSettings.Favorites.ICON, c.getBlob(iconIndex));
1103                              values.put(LauncherSettings.Favorites.ICON_PACKAGE,
1104                                      c.getString(iconPackageIndex));
1105                              values.put(LauncherSettings.Favorites.ICON_RESOURCE,
1106                                      c.getString(iconResourceIndex));
1107                              values.put(LauncherSettings.Favorites.ITEM_TYPE, itemType);
1108                              values.put(LauncherSettings.Favorites.APPWIDGET_ID, -1);
1109                              values.put(LauncherSettings.Favorites.URI, c.getString(uriIndex));
1110                              values.put(LauncherSettings.Favorites.DISPLAY_MODE,
1111                                      c.getInt(displayModeIndex));
1112                              values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
1113  
1114                              if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1115                                  hotseat.put(screen, values);
1116                              }
1117  
1118                              if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1119                                  // In a folder or in the hotseat, preserve position
1120                                  values.put(LauncherSettings.Favorites.SCREEN, screen);
1121                                  values.put(LauncherSettings.Favorites.CELLX, cellX);
1122                                  values.put(LauncherSettings.Favorites.CELLY, cellY);
1123                              } else {
1124                                  // For items contained directly on one of the workspace screen,
1125                                  // we&#x27;ll determine their location (screen, x, y) in a second pass.
1126                              }
1127  
1128                              values.put(LauncherSettings.Favorites.CONTAINER, container);
1129  
1130                              if (itemType != Favorites.ITEM_TYPE_FOLDER) {
1131                                  shortcuts.add(values);
1132                              } else {
1133                                  folders.add(values);
1134                              }
1135                          }
1136  
1137                          // Now that we have all the hotseat icons, let&#x27;s go through them left-right
1138                          // and assign valid locations for them in the new hotseat
1139                          final int N = hotseat.size();
1140                          for (int idx=0; idx&lt;N; idx++) {
1141                              int hotseatX = hotseat.keyAt(idx);
1142                              ContentValues values = hotseat.valueAt(idx);
1143  
1144                              if (hotseatX == grid.hotseatAllAppsRank) {
1145                                  // let&#x27;s drop this in the next available hole in the hotseat
1146                                  while (++hotseatX &lt; hotseatWidth) {
1147                                      if (hotseat.get(hotseatX) == null) {
1148                                          // found a spot! move it here
1149                                          values.put(LauncherSettings.Favorites.SCREEN,
1150                                                  hotseatX);
1151                                          break;
1152                                      }
1153                                  }
1154                              }
1155                              if (hotseatX &gt;= hotseatWidth) {
1156                                  // no room for you in the hotseat? it&#x27;s off to the desktop with you
1157                                  values.put(LauncherSettings.Favorites.CONTAINER,
1158                                             Favorites.CONTAINER_DESKTOP);
1159                              }
1160                          }
1161  
1162                          final ArrayList&lt;ContentValues&gt; allItems = new ArrayList&lt;ContentValues&gt;();
1163                          // Folders first
1164                          allItems.addAll(folders);
1165                          // Then shortcuts
1166                          allItems.addAll(shortcuts);
1167  
1168                          // Layout all the folders
1169                          for (ContentValues values: allItems) {
1170                              if (values.getAsInteger(LauncherSettings.Favorites.CONTAINER) !=
1171                                      LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1172                                  // Hotseat items and folder items have already had their
1173                                  // location information set. Nothing to be done here.
1174                                  continue;
1175                              }
1176                              values.put(LauncherSettings.Favorites.SCREEN, curScreen);
1177                              values.put(LauncherSettings.Favorites.CELLX, curX);
1178                              values.put(LauncherSettings.Favorites.CELLY, curY);
1179                              curX = (curX + 1) % width;
1180                              if (curX == 0) {
1181                                  curY = (curY + 1);
1182                              }
1183                              // Leave the last row of icons blank on every screen
1184                              if (curY == height - 1) {
1185                                  curScreen = (int) generateNewScreenId();
1186                                  curY = 0;
1187                              }
1188                          }
1189  
1190                          if (allItems.size() &gt; 0) {
1191                              db.beginTransaction();
1192                              try {
1193                                  for (ContentValues row: allItems) {
1194                                      if (row == null) continue;
1195                                      if (dbInsertAndCheck(this, db, TABLE_FAVORITES, null, row)
1196                                              &lt; 0) {
1197                                          return;
1198                                      } else {
1199                                          count++;
1200                                      }
1201                                  }
1202                                  db.setTransactionSuccessful();
1203                              } finally {
1204                                  db.endTransaction();
1205                              }
1206                          }
1207  
1208                          db.beginTransaction();
1209                          try {
1210                              for (i=0; i&lt;=curScreen; i++) {
1211                                  final ContentValues values = new ContentValues();
1212                                  values.put(LauncherSettings.WorkspaceScreens._ID, i);
1213                                  values.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1214                                  if (dbInsertAndCheck(this, db, TABLE_WORKSPACE_SCREENS, null, values)
1215                                          &lt; 0) {
1216                                      return;
1217                                  }
1218                              }
1219                              db.setTransactionSuccessful();
1220                          } finally {
1221                              db.endTransaction();
1222                          }
1223  
1224                          updateFolderItemsRank(db, false);
1225                      }
1226                  } finally {
1227                      c.close();
1228                  }
1229              }
1230  
1231              Launcher.addDumpLog(TAG, &quot;migrated &quot; + count + &quot; icons from Launcher2 into &quot;
1232                      + (curScreen+1) + &quot; screens&quot;, true);
1233  
1234              // ensure that new screens are created to hold these icons
1235              setFlagJustLoadedOldDb();
1236  
1237              // Update max IDs; very important since we just grabbed IDs from another database
1238              mMaxItemId = initializeMaxItemId(db);
1239              mMaxScreenId = initializeMaxScreenId(db);
1240              if (LOGD) Log.d(TAG, &quot;mMaxItemId: &quot; + mMaxItemId + &quot; mMaxScreenId: &quot; + mMaxScreenId);
1241          }
1242      }
1243  
1244      static class SqlArguments {
1245          public final String table;
1246          public final String where;
1247          public final String[] args;
1248  
1249          SqlArguments(Uri url, String where, String[] args) {
1250              if (url.getPathSegments().size() == 1) {
1251                  this.table = url.getPathSegments().get(0);
1252                  this.where = where;
1253                  this.args = args;
1254              } else if (url.getPathSegments().size() != 2) {
1255                  throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
1256              } else if (!TextUtils.isEmpty(where)) {
1257                  throw new UnsupportedOperationException(&quot;WHERE clause not supported: &quot; + url);
1258              } else {
1259                  this.table = url.getPathSegments().get(0);
1260                  this.where = &quot;_id=&quot; + ContentUris.parseId(url);
1261                  this.args = null;
1262              }
1263          }
1264  
1265          SqlArguments(Uri url) {
1266              if (url.getPathSegments().size() == 1) {
1267                  table = url.getPathSegments().get(0);
1268                  where = null;
1269                  args = null;
1270              } else {
1271                  throw new IllegalArgumentException(&quot;Invalid URI: &quot; + url);
1272              }
1273          }
1274      }
1275  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            