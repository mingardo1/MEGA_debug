<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>372</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    372
                    <a href="371.html">prev</a>
                    <a href="373.html">next</a>
                    <a href="372_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_7118d9dd17f51d998440f257935d6670c927383f_src/com/android/launcher3/LauncherModel.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;7118d9dd17f51d998440f257935d6670c927383f:src/com/android/launcher3/LauncherModel.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;7118d9dd17f51d998440f257935d6670c927383f^1:src/com/android/launcher3/LauncherModel.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;7118d9dd17f51d998440f257935d6670c927383f^2:src/com/android/launcher3/LauncherModel.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;58dcef7b28ec0bbc8e097b2cd45a6c6542a4cdef:src/com/android/launcher3/LauncherModel.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b], [b], [b]], subset: [[b], [b], [b], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetManager;
  21 import android.appwidget.AppWidgetProviderInfo;
  22 import android.content.BroadcastReceiver;
  23 import android.content.ComponentName;
  24 import android.content.ContentProviderClient;
  25 import android.content.ContentProviderOperation;
  26 import android.content.ContentResolver;
  27 import android.content.ContentValues;
  28 import android.content.Context;
  29 import android.content.Intent;
  30 import android.content.Intent.ShortcutIconResource;
  31 import android.content.IntentFilter;
  32 import android.content.SharedPreferences;
  33 import android.content.pm.PackageManager;
  34 import android.content.pm.ProviderInfo;
  35 import android.content.pm.ResolveInfo;
  36 import android.content.res.Configuration;
  37 import android.content.res.Resources;
  38 import android.database.Cursor;
  39 import android.graphics.Bitmap;
  40 import android.graphics.BitmapFactory;
  41 import android.net.Uri;
  42 import android.os.Environment;
  43 import android.os.Handler;
  44 import android.os.HandlerThread;
  45 import android.os.Parcelable;
  46 import android.os.Process;
  47 import android.os.RemoteException;
  48 import android.os.SystemClock;
  49 import android.provider.BaseColumns;
  50 import android.text.TextUtils;
  51 import android.util.Log;
  52 import android.util.Pair;
  53 
  54 import com.android.launcher3.compat.AppWidgetManagerCompat;
  55 import com.android.launcher3.compat.LauncherActivityInfoCompat;
  56 import com.android.launcher3.compat.LauncherAppsCompat;
  57 import com.android.launcher3.compat.PackageInstallerCompat;
  58 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  59 import com.android.launcher3.compat.UserHandleCompat;
  60 import com.android.launcher3.compat.UserManagerCompat;
  61 
  62 import java.lang.ref.WeakReference;
  63 import java.net.URISyntaxException;
  64 import java.security.InvalidParameterException;
  65 import java.text.Collator;
  66 import java.util.ArrayList;
  67 import java.util.Arrays;
  68 import java.util.Collection;
  69 import java.util.Collections;
  70 import java.util.Comparator;
  71 import java.util.HashMap;
  72 import java.util.HashSet;
  73 import java.util.Iterator;
  74 import java.util.List;
  75 import java.util.Map.Entry;
  76 import java.util.Set;
  77 import java.util.TreeMap;
  78 import java.util.concurrent.atomic.AtomicBoolean;
  79 
  80 /**
  81  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  82  * LauncherModel object held in a static. Also provide APIs for updating the database state
  83  * for the Launcher.
  84  */
  85 public class LauncherModel extends BroadcastReceiver
  86         implements LauncherAppsCompat.OnAppsChangedCallbackCompat {
  87     static final boolean DEBUG_LOADERS = false;
  88     private static final boolean DEBUG_RECEIVER = false;
  89     private static final boolean REMOVE_UNRESTORED_ICONS = true;
  90 
  91     static final String TAG = &quot;Launcher.Model&quot;;
  92 
  93     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  94     // false = strew non-workspace apps across the workspace on upgrade
  95     public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  96     public static final int LOADER_FLAG_NONE = 0;
  97     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  98     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  99 
 100     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 101     private static final long INVALID_SCREEN_ID = -1L;
 102 
 103     private final boolean mAppsCanBeOnRemoveableStorage;
 104     private final boolean mOldContentProviderExists;
 105 
 106     private final LauncherAppState mApp;
 107     private final Object mLock = new Object();
 108     private DeferredHandler mHandler = new DeferredHandler();
 109     private LoaderTask mLoaderTask;
 110     private boolean mIsLoaderTaskRunning;
 111     private volatile boolean mFlushingWorkerThread;
 112 
 113     // Specific runnable types that are run on the main thread deferred handler, this allows us to
 114     // clear all queued binding runnables when the Launcher activity is destroyed.
 115     private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 116     private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
 117 
 118     private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 119 
 120     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 121     static {
 122         sWorkerThread.start();
 123     }
 124     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 125 
 126     // We start off with everything not loaded.  After that, we assume that
 127     // our monitoring of the package manager provides all updates and we never
 128     // need to do a requery.  These are only ever touched from the loader thread.
 129     private boolean mWorkspaceLoaded;
 130     private boolean mAllAppsLoaded;
 131 
 132     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 133     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 134     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 135     // a normal load, we also clear this set of Runnables.
 136     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 137 
 138     private WeakReference&lt;Callbacks&gt; mCallbacks;
 139 
 140     // &lt; only access in worker thread &gt;
 141     AllAppsList mBgAllAppsList;
 142 
 143     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 144     // other locks, this one can generally be held long-term because we never expect any of these
 145     // static data structures to be referenced outside of the worker thread except on the first
 146     // load after configuration change.
 147     static final Object sBgLock = new Object();
 148 
 149     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 150     // LauncherModel to their ids
 151     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 152 
 153     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 154     //       created by LauncherModel that are directly on the home screen (however, no widgets or
 155     //       shortcuts within folders).
 156     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 157 
 158     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 159     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 160         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 161 
 162     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 163     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 164 
 165     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 166     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 167 
 168     // sBgWorkspaceScreens is the ordered set of workspace screens.
 169     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 170 
 171     // sPendingPackages is a set of packages which could be on sdcard and are not available yet
 172     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages =
 173             new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();
 174 
 175     // &lt;/ only access in worker thread &gt;
 176 
 177     private IconCache mIconCache;
 178 
 179     protected int mPreviousConfigMcc;
 180 
 181     private final LauncherAppsCompat mLauncherApps;
 182     private final UserManagerCompat mUserManager;
 183 
 184     public interface Callbacks {
 185         public boolean setLoadOnResume();
 186         public int getCurrentWorkspaceScreen();
 187         public void startBinding();
 188         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 189                               boolean forceAnimateIcons);
 190         public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 191         public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 192         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 193         public void finishBindingItems(boolean upgradePath);
 194         public void bindAppWidget(LauncherAppWidgetInfo info);
 195         public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 196         public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 197                                   ArrayList&lt;ItemInfo&gt; addNotAnimated,
 198                                   ArrayList&lt;ItemInfo&gt; addAnimated,
 199                                   ArrayList&lt;AppInfo&gt; addedApps);
 200         public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 201         public void bindAppsRestored(ArrayList&lt;AppInfo&gt; apps);
 202         public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);
 203         public void updatePackageBadge(String packageName);
 204         public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 205                         ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user);
 206         public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 207         public void bindSearchablesChanged();
 208         public boolean isAllAppsButtonRank(int rank);
 209         public void onPageBoundSynchronously(int page);
 210         public void dumpLogsToLocalData();
 211     }
 212 
 213     public interface ItemInfoFilter {
 214         public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 215     }
 216 
 217     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 218         Context context = app.getContext();
 219 
 220         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 221         String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 222         // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 223         // resource string.
 224         String redirectAuthority = Uri.parse(oldProvider).getAuthority();
 225         ProviderInfo providerInfo =
 226                 context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);
 227         ProviderInfo redirectProvider =
 228                 context.getPackageManager().resolveContentProvider(redirectAuthority, 0);
 229 
 230         Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 231         mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 232 
 233         if (mOldContentProviderExists) {
 234             Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 235         } else {
 236             Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 237         }
 238 
 239         mApp = app;
 240         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 241         mIconCache = iconCache;
 242 
 243         final Resources res = context.getResources();
 244         Configuration config = res.getConfiguration();
 245         mPreviousConfigMcc = config.mcc;
 246         mLauncherApps = LauncherAppsCompat.getInstance(context);
 247         mUserManager = UserManagerCompat.getInstance(context);
 248     }
 249 
 250     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 251      * posted on the main thread handler. */
 252     private void runOnMainThread(Runnable r) {
 253         runOnMainThread(r, 0);
 254     }
 255     private void runOnMainThread(Runnable r, int type) {
 256         if (sWorkerThread.getThreadId() == Process.myTid()) {
 257             // If we are on the worker thread, post onto the main handler
 258             mHandler.post(r);
 259         } else {
 260             r.run();
 261         }
 262     }
 263 
 264     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 265      * posted on the worker thread handler. */
 266     private static void runOnWorkerThread(Runnable r) {
 267         if (sWorkerThread.getThreadId() == Process.myTid()) {
 268             r.run();
 269         } else {
 270             // If we are not on the worker thread, then post to the worker handler
 271             sWorker.post(r);
 272         }
 273     }
 274 
 275     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 276         return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 277     }
 278 
 279     static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 280                                  long screen) {
 281         LauncherAppState app = LauncherAppState.getInstance();
 282         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 283         final int xCount = (int) grid.numColumns;
 284         final int yCount = (int) grid.numRows;
 285         boolean[][] occupied = new boolean[xCount][yCount];
 286 
 287         int cellX, cellY, spanX, spanY;
 288         for (int i = 0; i &lt; items.size(); ++i) {
 289             final ItemInfo item = items.get(i);
 290             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 291                 if (item.screenId == screen) {
 292                     cellX = item.cellX;
 293                     cellY = item.cellY;
 294                     spanX = item.spanX;
 295                     spanY = item.spanY;
 296                     for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 297                         for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 298                             occupied[x][y] = true;
 299                         }
 300                     }
 301                 }
 302             }
 303         }
 304 
 305         return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 306     }
 307     static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 308                                                         Intent launchIntent,
 309                                                         int firstScreenIndex,
 310                                                         ArrayList&lt;Long&gt; workspaceScreens) {
 311         // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 312         LauncherAppState app = LauncherAppState.getInstance();
 313         LauncherModel model = app.getModel();
 314         boolean found = false;
 315         synchronized (app) {
 316             if (sWorkerThread.getThreadId() != Process.myTid()) {
 317                 // Flush the LauncherModel worker thread, so that if we just did another
 318                 // processInstallShortcut, we give it time for its shortcut to get added to the
 319                 // database (getItemsInLocalCoordinates reads the database)
 320                 model.flushWorkerThread();
 321             }
 322             final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 323 
 324             // Try adding to the workspace screens incrementally, starting at the default or center
 325             // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 326             firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 327             int count = workspaceScreens.size();
 328             for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 329                 int[] tmpCoordinates = new int[2];
 330                 if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 331                         workspaceScreens.get(screen))) {
 332                     // Update the Launcher db
 333                     return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 334                 }
 335             }
 336         }
 337         return null;
 338     }
 339 
 340 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 341     public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 342         // Process the updated package state</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 343         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 344             public void run() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 345                 Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 346                 if (callbacks != null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 347                     callbacks.updatePackageState(installInfo);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 348                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 349             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 350         };</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 351         mHandler.post(r);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 352     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 353 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 354     public void updatePackageBadge(final String packageName) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 355         // Process the updated package badge</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 356         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 357             public void run() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 358                 Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 359                 if (callbacks != null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 360                     callbacks.updatePackageBadge(packageName);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 361                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 362             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 363         };</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 364         mHandler.post(r);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 365     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 366 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 367     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 368         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 369 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 370         if (allAppsApps == null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 371             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 372         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 373         if (allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 374             return;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 375         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 376 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 377         final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 378         Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 379         while (iter.hasNext()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 380             ItemInfo a = iter.next();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 381             if (LauncherModel.appWasPromise(ctx, a.getIntent(), a.user)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 382                 restoredAppsFinal.add((AppInfo) a);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 383             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 384         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 385 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 386         // Process the newly added applications and add them to the database first</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 387         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 388             public void run() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 389                 runOnMainThread(new Runnable() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 390                     public void run() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 391                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 392                         if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 393                             if (!restoredAppsFinal.isEmpty()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 394                                 for (AppInfo info : restoredAppsFinal) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 395                                     final Intent intent = info.getIntent();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 396                                     if (intent != null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 397                                         mIconCache.deletePreloadedIcon(intent.getComponent(),</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 398                                                 info.user);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 399                                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 400                                 }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 401                                 callbacks.bindAppsUpdated(restoredAppsFinal);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 402                             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 403                             callbacks.bindAppsAdded(null, null, null, allAppsApps);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 404                         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 405                     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 406                 });</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 407             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 408         };</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 409         runOnWorkerThread(r);</span>
 410 ||||||| GitAnalyzerPlus_base
 411 &lt;&lt;&lt;&lt;&lt;&lt;&lt; OURS
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 412     public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 413                                     final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 414         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 415         addAndBindAddedApps(context, workspaceApps, cb, allAppsApps);</span>
 416 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 417     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 418         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 419 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 420         if (allAppsApps == null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 421             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 422         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 423         if (allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 424             return;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 425         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 426 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 427         final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 428         Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 429         while (iter.hasNext()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 430             ItemInfo a = iter.next();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 431             if (LauncherModel.appWasRestored(ctx, a.getIntent())) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 432                 restoredAppsFinal.add((AppInfo) a);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 433             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 434         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 435 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 436         // Process the newly added applications and add them to the database first</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 437         Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 438             public void run() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 439                 runOnMainThread(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 440                     public void run() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 441                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 442                         if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 443                             if (!restoredAppsFinal.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 444                                 for (AppInfo info : restoredAppsFinal) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 445                                     final Intent intent = info.getIntent();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 446                                     if (intent != null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 447                                         mIconCache.deletePreloadedIcon(intent.getComponent());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 448                                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 449                                 }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 450                                 callbacks.bindAppsUpdated(restoredAppsFinal);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 451                             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 452                             callbacks.bindAppsAdded(null, null, null, allAppsApps);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 453                         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 454                     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 455                 });</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 456             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 457         };</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 458         runOnWorkerThread(r);</span>
 459 &gt;&gt;&gt;&gt;&gt;&gt;&gt; THEIRS
 460     }
 461     public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,
 462                                 final Callbacks callbacks, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 463         if (workspaceApps == null || allAppsApps == null) {
 464             throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 465         }
 466         if (workspaceApps.isEmpty() &amp;&amp; allAppsApps.isEmpty()) {
 467             return;
 468         }
 469         // Process the newly added applications and add them to the database first
 470         Runnable r = new Runnable() {
 471             public void run() {
 472                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 473                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 474 
 475                 // Get the list of workspace screens.  We need to append to this list and
 476                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 477                 // called.
 478                 ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 479                 TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 480                 for (Integer i : orderedScreens.keySet()) {
 481                     long screenId = orderedScreens.get(i);
 482                     workspaceScreens.add(screenId);
 483                 }
 484 
 485                 synchronized(sBgLock) {
 486                     Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 487                     while (iter.hasNext()) {
 488                         ItemInfo a = iter.next();
 489                         final String name = a.title.toString();
 490                         final Intent launchIntent = a.getIntent();
 491 
 492                         // Short-circuit this logic if the icon exists somewhere on the workspace
 493                         if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 494                             continue;
 495                         }
 496 
 497                         // Add this icon to the db, creating a new page if necessary.  If there
 498                         // is only the empty page then we just add items to the first page.
 499                         // Otherwise, we add them to the next pages.
 500                         int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 501                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 502                                 name, launchIntent, startSearchPageIndex, workspaceScreens);
 503                         if (coords == null) {
 504                             LauncherProvider lp = LauncherAppState.getLauncherProvider();
 505 
 506                             // If we can&#x27;t find a valid position, then just add a new screen.
 507                             // This takes time so we need to re-queue the add until the new
 508                             // page is added.  Create as many screens as necessary to satisfy
 509                             // the startSearchPageIndex.
 510                             int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 511                                     workspaceScreens.size());
 512                             while (numPagesToAdd &gt; 0) {
 513                                 long screenId = lp.generateNewScreenId();
 514                                 // Save the screen id for binding in the workspace
 515                                 workspaceScreens.add(screenId);
 516                                 addedWorkspaceScreensFinal.add(screenId);
 517                                 numPagesToAdd--;
 518                             }
 519 
 520                             // Find the coordinate again
 521                             coords = LauncherModel.findNextAvailableIconSpace(context,
 522                                     name, launchIntent, startSearchPageIndex, workspaceScreens);
 523                         }
 524                         if (coords == null) {
 525 =======
 526     public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,
 527                                     final ArrayList&lt;AppInfo&gt; allAppsApps) {
 528         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 529         addAndBindAddedApps(context, workspaceApps, cb, allAppsApps);
 530 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 531     }
 532 
 533     public void addAndBindAddedWorkspaceApps(final Context context,
 534             final ArrayList&lt;ItemInfo&gt; workspaceApps) {
 535         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 536 
 537         if (workspaceApps == null) {
 538             throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 539         }
 540         if (workspaceApps.isEmpty()) {
 541             return;
 542         }
 543         // Process the newly added applications and add them to the database first
 544         Runnable r = new Runnable() {
 545             public void run() {
 546                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 547                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 548                 final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 549 
 550                 // Get the list of workspace screens.  We need to append to this list and
 551                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 552                 // called.
 553                 ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 554                 TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 555                 for (Integer i : orderedScreens.keySet()) {
 556                     long screenId = orderedScreens.get(i);
 557                     workspaceScreens.add(screenId);
 558                 }
 559 
 560                 synchronized(sBgLock) {
 561                     Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 562                     while (iter.hasNext()) {
 563                         ItemInfo a = iter.next();
 564                         final String name = a.title.toString();
 565                         final Intent launchIntent = a.getIntent();
 566 
 567                         // Short-circuit this logic if the icon exists somewhere on the workspace
 568                         if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 569                             // Only InstallShortcutReceiver sends us shortcutInfos, ignore them
 570                             if (a instanceof AppInfo &amp;&amp;
 571                                     LauncherModel.appWasPromise(context, launchIntent, a.user)) {
 572                                 restoredAppsFinal.add((AppInfo) a);
 573                             }
 574                             continue;
 575                         }
 576 
 577                         // Add this icon to the db, creating a new page if necessary.  If there
 578                         // is only the empty page then we just add items to the first page.
 579                         // Otherwise, we add them to the next pages.
 580                         int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 581                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 582                                 name, launchIntent, startSearchPageIndex, workspaceScreens);
 583                         if (coords == null) {
 584                             LauncherProvider lp = LauncherAppState.getLauncherProvider();
 585 
 586                             // If we can&#x27;t find a valid position, then just add a new screen.
 587                             // This takes time so we need to re-queue the add until the new
 588                             // page is added.  Create as many screens as necessary to satisfy
 589                             // the startSearchPageIndex.
 590                             int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 591                                     workspaceScreens.size());
 592                             while (numPagesToAdd &gt; 0) {
 593                                 long screenId = lp.generateNewScreenId();
 594                                 // Save the screen id for binding in the workspace
 595                                 workspaceScreens.add(screenId);
 596                                 addedWorkspaceScreensFinal.add(screenId);
 597                                 numPagesToAdd--;
 598                             }
 599 
 600                             // Find the coordinate again
 601                             coords = LauncherModel.findNextAvailableIconSpace(context,
 602                                     name, launchIntent, startSearchPageIndex, workspaceScreens);
 603                         }
 604                         if (coords == null) {
 605                             throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 606                         }
 607 
 608                         ShortcutInfo shortcutInfo;
 609                         if (a instanceof ShortcutInfo) {
 610                             shortcutInfo = (ShortcutInfo) a;
 611                         } else if (a instanceof AppInfo) {
 612                             shortcutInfo = ((AppInfo) a).makeShortcut();
 613                         } else {
 614                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 615                         }
 616 
 617                         // Add the shortcut to the db
 618                         addItemToDatabase(context, shortcutInfo,
 619                                 LauncherSettings.Favorites.CONTAINER_DESKTOP,
 620                                 coords.first, coords.second[0], coords.second[1], false);
 621                         // Save the ShortcutInfo for binding in the workspace
 622                         addedShortcutsFinal.add(shortcutInfo);
 623                     }
 624                 }
 625 
 626                 // Update the workspace screens
 627                 updateWorkspaceScreenOrder(context, workspaceScreens);
 628 
 629                 if (!addedShortcutsFinal.isEmpty()) {
 630                     runOnMainThread(new Runnable() {
 631                         public void run() {
 632                             Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 633                             if (callbacks == cb &amp;&amp; cb != null) {
 634                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 635                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 636                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 637                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 637                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 🔵</abbr>
 638                                     long lastScreenId = info.screenId;
 639                                     for (ItemInfo i : addedShortcutsFinal) {
 640                                         if (i.screenId == lastScreenId) {
 641                                             addAnimated.add(i);
 642                                         } else {
 643                                             addNotAnimated.add(i);
 644                                         }
 645                                     }
 646                                 }
 647                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 648                                         addNotAnimated, addAnimated, null);
 649                                 if (!restoredAppsFinal.isEmpty()) {
 650                                     callbacks.bindAppsUpdated(restoredAppsFinal);
 651                                 }
 652                             }
 653                         }
 654                     });
 655                 }
 656             }
 657         };
 658         runOnWorkerThread(r);
 659     }
 660 
 661     public void unbindItemInfosAndClearQueuedBindRunnables() {
 662         if (sWorkerThread.getThreadId() == Process.myTid()) {
 663             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 664                     &quot;main thread&quot;);
 665         }
 666 
 667         // Clear any deferred bind runnables
 668         synchronized (mDeferredBindRunnables) {
 669             mDeferredBindRunnables.clear();
 670         }
 671         // Remove any queued bind runnables
 672         mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 673         // Unbind all the workspace items
 674         unbindWorkspaceItemsOnMainThread();
 675     }
 676 
 677     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 678     void unbindWorkspaceItemsOnMainThread() {
 679         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 680         // by making a copy of workspace items first.
 681         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 682         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 683         synchronized (sBgLock) {
 684             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 685             tmpAppWidgets.addAll(sBgAppWidgets);
 686         }
 687         Runnable r = new Runnable() {
 688                 @Override
 689                 public void run() {
 690                    for (ItemInfo item : tmpWorkspaceItems) {
 691                        item.unbind();
 692                    }
 693                    for (ItemInfo item : tmpAppWidgets) {
 694                        item.unbind();
 695                    }
 696                 }
 697             };
 698         runOnMainThread(r);
 699     }
 700 
 701     /**
 702      * Adds an item to the DB if it was not created previously, or move it to a new
 703      * &lt;container, screen, cellX, cellY&gt;
 704      */
 705     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 706             long screenId, int cellX, int cellY) {
 707         if (item.container == ItemInfo.NO_ID) {
 708             // From all apps
 709             addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 710         } else {
 711             // From somewhere else
 712             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 713         }
 714     }
 715 
 716     static void checkItemInfoLocked(
 717             final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 718         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 719         if (modelItem != null &amp;&amp; item != modelItem) {
 720             // check all the data is consistent
 721             if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 722                 ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 723                 ShortcutInfo shortcut = (ShortcutInfo) item;
 724                 if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 725                         modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 726                         modelShortcut.id == shortcut.id &amp;&amp;
 727                         modelShortcut.itemType == shortcut.itemType &amp;&amp;
 728                         modelShortcut.container == shortcut.container &amp;&amp;
 729                         modelShortcut.screenId == shortcut.screenId &amp;&amp;
 730                         modelShortcut.cellX == shortcut.cellX &amp;&amp;
 731                         modelShortcut.cellY == shortcut.cellY &amp;&amp;
 732                         modelShortcut.spanX == shortcut.spanX &amp;&amp;
 733                         modelShortcut.spanY == shortcut.spanY &amp;&amp;
 734                         ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 735                         (modelShortcut.dropPos != null &amp;&amp;
 736                                 shortcut.dropPos != null &amp;&amp;
 737                                 modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 738                         modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 739                     // For all intents and purposes, this is the same object
 740                     return;
 741                 }
 742             }
 743 
 744             // the modelItem needs to match up perfectly with item if our model is
 745             // to be consistent with the database-- for now, just require
 746             // modelItem == item or the equality check above
 747             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 748                     &quot;modelItem: &quot; +
 749                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 750                     &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 751             RuntimeException e = new RuntimeException(msg);
 752             if (stackTrace != null) {
 753                 e.setStackTrace(stackTrace);
 754             }
 755             throw e;
 756         }
 757     }
 758 
 759     static void checkItemInfo(final ItemInfo item) {
 760         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 761         final long itemId = item.id;
 762         Runnable r = new Runnable() {
 763             public void run() {
 764                 synchronized (sBgLock) {
 765                     checkItemInfoLocked(itemId, item, stackTrace);
 766                 }
 767             }
 768         };
 769         runOnWorkerThread(r);
 770     }
 771 
 772     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 773             final ItemInfo item, final String callingFunction) {
 774         final long itemId = item.id;
 775         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 776         final ContentResolver cr = context.getContentResolver();
 777 
 778         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 779         Runnable r = new Runnable() {
 780             public void run() {
 781                 cr.update(uri, values, null, null);
 782                 updateItemArrays(item, itemId, stackTrace);
 783             }
 784         };
 785         runOnWorkerThread(r);
 786     }
 787 
 788     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 789             final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 790         final ContentResolver cr = context.getContentResolver();
 791 
 792         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 793         Runnable r = new Runnable() {
 794             public void run() {
 795                 ArrayList&lt;ContentProviderOperation&gt; ops =
 796                         new ArrayList&lt;ContentProviderOperation&gt;();
 797                 int count = items.size();
 798                 for (int i = 0; i &lt; count; i++) {
 799                     ItemInfo item = items.get(i);
 800                     final long itemId = item.id;
 801                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 802                     ContentValues values = valuesList.get(i);
 803 
 804                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 805                     updateItemArrays(item, itemId, stackTrace);
 806 
 807                 }
 808                 try {
 809                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 810                 } catch (Exception e) {
 811                     e.printStackTrace();
 812                 }
 813             }
 814         };
 815         runOnWorkerThread(r);
 816     }
 817 
 818     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 819         // Lock on mBgLock *after* the db operation
 820         synchronized (sBgLock) {
 821             checkItemInfoLocked(itemId, item, stackTrace);
 822 
 823             if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 824                     item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 825                 // Item is in a folder, make sure this folder exists
 826                 if (!sBgFolders.containsKey(item.container)) {
 827                     // An items container is being set to a that of an item which is not in
 828                     // the list of Folders.
 829                     String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 830                             item.container + &quot;, not in the list of folders&quot;;
 831                     Log.e(TAG, msg);
 832                 }
 833             }
 834 
 835             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 836             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 837             // that are on the desktop, as appropriate
 838             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 839             if (modelItem != null &amp;&amp;
 840                     (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 841                      modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 842                 switch (modelItem.itemType) {
 843                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 844                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 845                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 846                         if (!sBgWorkspaceItems.contains(modelItem)) {
 847                             sBgWorkspaceItems.add(modelItem);
 848                         }
 849                         break;
 850                     default:
 851                         break;
 852                 }
 853             } else {
 854                 sBgWorkspaceItems.remove(modelItem);
 855             }
 856         }
 857     }
 858 
 859     public void flushWorkerThread() {
 860         mFlushingWorkerThread = true;
 861         Runnable waiter = new Runnable() {
 862                 public void run() {
 863                     synchronized (this) {
 864                         notifyAll();
 865                         mFlushingWorkerThread = false;
 866                     }
 867                 }
 868             };
 869 
 870         synchronized(waiter) {
 871             runOnWorkerThread(waiter);
 872             if (mLoaderTask != null) {
 873                 synchronized(mLoaderTask) {
 874                     mLoaderTask.notify();
 875                 }
 876             }
 877             boolean success = false;
 878             while (!success) {
 879                 try {
 880                     waiter.wait();
 881                     success = true;
 882                 } catch (InterruptedException e) {
 883                 }
 884             }
 885         }
 886     }
 887 
 888     /**
 889      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 890      */
 891     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 892             final long screenId, final int cellX, final int cellY) {
 893         item.container = container;
 894         item.cellX = cellX;
 895         item.cellY = cellY;
 896 
 897         // We store hotseat items in canonical form which is this orientation invariant position
 898         // in the hotseat
 899         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 900                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 901             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 902         } else {
 903             item.screenId = screenId;
 904         }
 905 
 906         final ContentValues values = new ContentValues();
 907         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 908         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 909         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 910         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 911 
 912         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 913     }
 914 
 915     /**
 916      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 917      * cellX, cellY have already been updated on the ItemInfos.
 918      */
 919     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 920             final long container, final int screen) {
 921 
 922         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 923         int count = items.size();
 924 
 925         for (int i = 0; i &lt; count; i++) {
 926             ItemInfo item = items.get(i);
 927             item.container = container;
 928 
 929             // We store hotseat items in canonical form which is this orientation invariant position
 930             // in the hotseat
 931             if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 932                     container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 933                 item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 934                         item.cellY);
 935             } else {
 936                 item.screenId = screen;
 937             }
 938 
 939             final ContentValues values = new ContentValues();
 940             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 941             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 942             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 943             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 944 
 945             contentValues.add(values);
 946         }
 947         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 948     }
 949 
 950     /**
 951      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 952      */
 953     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 954             final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 955         item.container = container;
 956         item.cellX = cellX;
 957         item.cellY = cellY;
 958         item.spanX = spanX;
 959         item.spanY = spanY;
 960 
 961         // We store hotseat items in canonical form which is this orientation invariant position
 962         // in the hotseat
 963         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 964                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 965             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 966         } else {
 967             item.screenId = screenId;
 968         }
 969 
 970         final ContentValues values = new ContentValues();
 971         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 972         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 973         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 974         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 975         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 976         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 977 
 978         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 979     }
 980 
 981     /**
 982      * Update an item to the database in a specified container.
 983      */
 984     static void updateItemInDatabase(Context context, final ItemInfo item) {
 985         final ContentValues values = new ContentValues();
 986         item.onAddToDatabase(context, values);
 987         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 988         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 989     }
 990 
 991     /**
 992      * Returns true if the shortcuts already exists in the database.
 993      * we identify a shortcut by its title and intent.
 994      */
 995     static boolean shortcutExists(Context context, String title, Intent intent) {
 996         final ContentResolver cr = context.getContentResolver();
 997         final Intent intentWithPkg, intentWithoutPkg;
 998 
 999         if (intent.getComponent() != null) {
1000             // If component is not null, an intent with null package will produce
1001             // the same result and should also be a match.
1002             if (intent.getPackage() != null) {
1003                 intentWithPkg = intent;
1004                 intentWithoutPkg = new Intent(intent).setPackage(null);
1005             } else {
1006                 intentWithPkg = new Intent(intent).setPackage(
1007                         intent.getComponent().getPackageName());
1008                 intentWithoutPkg = intent;
1009             }
1010         } else {
1011             intentWithPkg = intent;
1012             intentWithoutPkg = intent;
1013         }
1014         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
1015             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and (intent=? or intent=?)&quot;,
1016             new String[] { title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0) }, null);
1017         boolean result = false;
1018         try {
1019             result = c.moveToFirst();
1020         } finally {
1021             c.close();
1022         }
1023         return result;
1024     }
1025 
1026     /**
1027      * Returns true if the promise shortcuts with the same package name exists on the workspace.
1028      */
1029     static boolean appWasPromise(Context context, Intent intent, UserHandleCompat user) {
1030         final ComponentName component = intent.getComponent();
1031         if (component == null) {
1032             return false;
1033         }
1034         return !getItemsByPackageName(component.getPackageName(), user).isEmpty();
1035     }
1036 
1037     /**
1038      * Returns an ItemInfo array containing all the items in the LauncherModel.
1039      * The ItemInfo.id is not set through this function.
1040      */
1041     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
1042         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1043         final ContentResolver cr = context.getContentResolver();
1044         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
1045                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
1046                 LauncherSettings.Favorites.SCREEN,
1047                 LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,
1048                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY,
1049                 LauncherSettings.Favorites.PROFILE_ID }, null, null, null);
1050 
1051         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
1052         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
1053         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1054         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1055         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1056         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
1057         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
1058         final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);
1059         UserManagerCompat userManager = UserManagerCompat.getInstance(context);
1060         try {
1061             while (c.moveToNext()) {
1062                 ItemInfo item = new ItemInfo();
1063                 item.cellX = c.getInt(cellXIndex);
1064                 item.cellY = c.getInt(cellYIndex);
1065                 item.spanX = Math.max(1, c.getInt(spanXIndex));
1066                 item.spanY = Math.max(1, c.getInt(spanYIndex));
1067                 item.container = c.getInt(containerIndex);
1068                 item.itemType = c.getInt(itemTypeIndex);
1069                 item.screenId = c.getInt(screenIndex);
1070                 long serialNumber = c.getInt(profileIdIndex);
1071                 item.user = userManager.getUserForSerialNumber(serialNumber);
1072                 // Skip if user has been deleted.
1073                 if (item.user != null) {
1074                     items.add(item);
1075                 }
1076             }
1077         } catch (Exception e) {
1078             items.clear();
1079         } finally {
1080             c.close();
1081         }
1082 
1083         return items;
1084     }
1085 
1086     /**
1087      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
1088      */
1089     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
1090         final ContentResolver cr = context.getContentResolver();
1091         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
1092                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
1093                 new String[] { String.valueOf(id),
1094                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
1095 
1096         try {
1097             if (c.moveToFirst()) {
1098                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
1099                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
1100                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
1101                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1102                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1103                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1104 
1105                 FolderInfo folderInfo = null;
1106                 switch (c.getInt(itemTypeIndex)) {
1107                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1108                         folderInfo = findOrMakeFolder(folderList, id);
1109                         break;
1110                 }
1111 
1112                 folderInfo.title = c.getString(titleIndex);
1113                 folderInfo.id = id;
1114                 folderInfo.container = c.getInt(containerIndex);
1115                 folderInfo.screenId = c.getInt(screenIndex);
1116                 folderInfo.cellX = c.getInt(cellXIndex);
1117                 folderInfo.cellY = c.getInt(cellYIndex);
1118 
1119                 return folderInfo;
1120             }
1121         } finally {
1122             c.close();
1123         }
1124 
1125         return null;
1126     }
1127 
1128     /**
1129      * Add an item to the database in a specified container. Sets the container, screen, cellX and
1130      * cellY fields of the item. Also assigns an ID to the item.
1131      */
1132     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
1133             final long screenId, final int cellX, final int cellY, final boolean notify) {
1134         item.container = container;
1135         item.cellX = cellX;
1136         item.cellY = cellY;
1137         // We store hotseat items in canonical form which is this orientation invariant position
1138         // in the hotseat
1139         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1140                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1141             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1142         } else {
1143             item.screenId = screenId;
1144         }
1145 
1146         final ContentValues values = new ContentValues();
1147         final ContentResolver cr = context.getContentResolver();
1148         item.onAddToDatabase(context, values);
1149 
1150         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1151         values.put(LauncherSettings.Favorites._ID, item.id);
1152         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
1153 
1154         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
1155         Runnable r = new Runnable() {
1156             public void run() {
1157                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
1158                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
1159 
1160                 // Lock on mBgLock *after* the db operation
1161                 synchronized (sBgLock) {
1162                     checkItemInfoLocked(item.id, item, stackTrace);
1163                     sBgItemsIdMap.put(item.id, item);
1164                     switch (item.itemType) {
1165                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1166                             sBgFolders.put(item.id, (FolderInfo) item);
1167                             // Fall through
1168                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1169                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1170                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1171                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1172                                 sBgWorkspaceItems.add(item);
1173                             } else {
1174                                 if (!sBgFolders.containsKey(item.container)) {
1175                                     // Adding an item to a folder that doesn&#x27;t exist.
1176                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1177                                             &quot; doesn&#x27;t exist&quot;;
1178                                     Log.e(TAG, msg);
1179                                 }
1180                             }
1181                             break;
1182                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1183                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1184                             break;
1185                     }
1186                 }
1187             }
1188         };
1189         runOnWorkerThread(r);
1190     }
1191 
1192     /**
1193      * Creates a new unique child id, for a given cell span across all layouts.
1194      */
1195     static int getCellLayoutChildId(
1196             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1197         return (((int) container &amp; 0xFF) &lt;&lt; 24)
1198                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1199     }
1200 
1201     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(
1202             final String pn, final UserHandleCompat user) {
1203         ItemInfoFilter filter  = new ItemInfoFilter() {
1204             @Override
1205             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1206                 return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1207             }
1208         };
1209         return filterItemInfos(sBgItemsIdMap.values(), filter);
1210     }
1211 
1212     /**
1213      * Removes all the items from the database corresponding to the specified package.
1214      */
1215     static void deletePackageFromDatabase(Context context, final String pn,
1216             final UserHandleCompat user) {
1217         deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1218     }
1219 
1220     /**
1221      * Removes the specified item from the database
1222      * @param context
1223      * @param item
1224      */
1225     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1226         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1227         items.add(item);
1228         deleteItemsFromDatabase(context, items);
1229     }
1230 
1231     /**
1232      * Removes the specified items from the database
1233      * @param context
1234      * @param item
1235      */
1236     static void deleteItemsFromDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items) {
1237         final ContentResolver cr = context.getContentResolver();
1238 
1239         Runnable r = new Runnable() {
1240             public void run() {
1241                 for (ItemInfo item : items) {
1242                     final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);
1243                     cr.delete(uri, null, null);
1244 
1245                     // Lock on mBgLock *after* the db operation
1246                     synchronized (sBgLock) {
1247                         switch (item.itemType) {
1248                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1249                                 sBgFolders.remove(item.id);
1250                                 for (ItemInfo info: sBgItemsIdMap.values()) {
1251                                     if (info.container == item.id) {
1252                                         // We are deleting a folder which still contains items that
1253                                         // think they are contained by that folder.
1254                                         String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1255                                                 &quot;contains items (&quot; + info + &quot;)&quot;;
1256                                         Log.e(TAG, msg);
1257                                     }
1258                                 }
1259                                 sBgWorkspaceItems.remove(item);
1260                                 break;
1261                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1262                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1263                                 sBgWorkspaceItems.remove(item);
1264                                 break;
1265                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1266                                 sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1267                                 break;
1268                         }
1269                         sBgItemsIdMap.remove(item.id);
1270                         sBgDbIconCache.remove(item);
1271                     }
1272                 }
1273             }
1274         };
1275         runOnWorkerThread(r);
1276     }
1277 
1278     /**
1279      * Update the order of the workspace screens in the database. The array list contains
1280      * a list of screen ids in the order that they should appear.
1281      */
1282     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1283         // Log to disk
1284         Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1285         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1286 
1287         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1288         final ContentResolver cr = context.getContentResolver();
1289         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1290 
1291         // Remove any negative screen ids -- these aren&#x27;t persisted
1292         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1293         while (iter.hasNext()) {
1294             long id = iter.next();
1295             if (id &lt; 0) {
1296                 iter.remove();
1297             }
1298         }
1299 
1300         Runnable r = new Runnable() {
1301             @Override
1302             public void run() {
1303                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1304                 // Clear the table
1305                 ops.add(ContentProviderOperation.newDelete(uri).build());
1306                 int count = screensCopy.size();
1307                 for (int i = 0; i &lt; count; i++) {
1308                     ContentValues v = new ContentValues();
1309                     long screenId = screensCopy.get(i);
1310                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1311                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1312                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1313                 }
1314 
1315                 try {
1316                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1317                 } catch (Exception ex) {
1318                     throw new RuntimeException(ex);
1319                 }
1320 
1321                 synchronized (sBgLock) {
1322                     sBgWorkspaceScreens.clear();
1323                     sBgWorkspaceScreens.addAll(screensCopy);
1324                 }
1325             }
1326         };
1327         runOnWorkerThread(r);
1328     }
1329 
1330     /**
1331      * Remove the contents of the specified folder from the database
1332      */
1333     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1334         final ContentResolver cr = context.getContentResolver();
1335 
1336         Runnable r = new Runnable() {
1337             public void run() {
1338                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1339                 // Lock on mBgLock *after* the db operation
1340                 synchronized (sBgLock) {
1341                     sBgItemsIdMap.remove(info.id);
1342                     sBgFolders.remove(info.id);
1343                     sBgDbIconCache.remove(info);
1344                     sBgWorkspaceItems.remove(info);
1345                 }
1346 
1347                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1348                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1349                 // Lock on mBgLock *after* the db operation
1350                 synchronized (sBgLock) {
1351                     for (ItemInfo childInfo : info.contents) {
1352                         sBgItemsIdMap.remove(childInfo.id);
1353                         sBgDbIconCache.remove(childInfo);
1354                     }
1355                 }
1356             }
1357         };
1358         runOnWorkerThread(r);
1359     }
1360 
1361     /**
1362      * Set this as the current Launcher activity object for the loader.
1363      */
1364     public void initialize(Callbacks callbacks) {
1365         synchronized (mLock) {
1366             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1367         }
1368     }
1369 
1370     @Override
1371     public void onPackageChanged(String packageName, UserHandleCompat user) {
1372         int op = PackageUpdatedTask.OP_UPDATE;
1373         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1374                 user));
1375     }
1376 
1377     @Override
1378     public void onPackageRemoved(String packageName, UserHandleCompat user) {
1379         int op = PackageUpdatedTask.OP_REMOVE;
1380         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1381                 user));
1382     }
1383 
1384     @Override
1385     public void onPackageAdded(String packageName, UserHandleCompat user) {
1386         int op = PackageUpdatedTask.OP_ADD;
1387         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1388                 user));
1389     }
1390 
1391     @Override
1392     public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,
1393             boolean replacing) {
1394         if (!replacing) {
1395             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,
1396                     user));
1397             if (mAppsCanBeOnRemoveableStorage) {
1398                 // Only rebind if we support removable storage. It catches the
1399                 // case where
1400                 // apps on the external sd card need to be reloaded
1401                 startLoaderFromBackground();
1402             }
1403         } else {
1404             // If we are replacing then just update the packages in the list
1405             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1406                     packageNames, user));
1407         }
1408     }
1409 
1410     @Override
1411     public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,
1412             boolean replacing) {
1413         if (!replacing) {
1414             enqueuePackageUpdated(new PackageUpdatedTask(
1415                     PackageUpdatedTask.OP_UNAVAILABLE, packageNames,
1416                     user));
1417         }
1418 
1419     }
1420 
1421     /**
1422      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1423      * ACTION_PACKAGE_CHANGED.
1424      */
1425     @Override
1426     public void onReceive(Context context, Intent intent) {
1427         if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1428 
1429         final String action = intent.getAction();
1430         if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1431             // If we have changed locale we need to clear out the labels in all apps/workspace.
1432             forceReload();
1433         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1434              // Check if configuration change was an mcc/mnc change which would affect app resources
1435              // and we would need to clear out the labels in all apps/workspace. Same handling as
1436              // above for ACTION_LOCALE_CHANGED
1437              Configuration currentConfig = context.getResources().getConfiguration();
1438              if (mPreviousConfigMcc != currentConfig.mcc) {
1439                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1440                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1441                    forceReload();
1442              }
1443              // Update previousConfig
1444              mPreviousConfigMcc = currentConfig.mcc;
1445         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1446                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1447             if (mCallbacks != null) {
1448                 Callbacks callbacks = mCallbacks.get();
1449                 if (callbacks != null) {
1450                     callbacks.bindSearchablesChanged();
1451                 }
1452             }
1453         }
1454     }
1455 
1456     void forceReload() {
1457         resetLoadedState(true, true);
1458 
1459         // Do this here because if the launcher activity is running it will be restarted.
1460         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1461         // to reload.
1462         startLoaderFromBackground();
1463     }
1464 
1465     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1466         synchronized (mLock) {
1467             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1468             // mWorkspaceLoaded to true later
1469             stopLoaderLocked();
1470             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1471             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1472         }
1473     }
1474 
1475     /**
1476      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1477      * configuration changes.  So whenever we trigger the loader from the background
1478      * tell the launcher that it needs to re-run the loader when it comes back instead
1479      * of doing it now.
1480      */
1481     public void startLoaderFromBackground() {
1482         boolean runLoader = false;
1483         if (mCallbacks != null) {
1484             Callbacks callbacks = mCallbacks.get();
1485             if (callbacks != null) {
1486                 // Only actually run the loader if they&#x27;re not paused.
1487                 if (!callbacks.setLoadOnResume()) {
1488                     runLoader = true;
1489                 }
1490             }
1491         }
1492         if (runLoader) {
1493             startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1494         }
1495     }
1496 
1497     // If there is already a loader task running, tell it to stop.
1498     // returns true if isLaunching() was true on the old task
1499     private boolean stopLoaderLocked() {
1500         boolean isLaunching = false;
1501         LoaderTask oldTask = mLoaderTask;
1502         if (oldTask != null) {
1503             if (oldTask.isLaunching()) {
1504                 isLaunching = true;
1505             }
1506             oldTask.stopLocked();
1507         }
1508         return isLaunching;
1509     }
1510 
1511     public boolean isCurrentCallbacks(Callbacks callbacks) {
1512         return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1513     }
1514 
1515     public void startLoader(boolean isLaunching, int synchronousBindPage) {
1516         startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1517     }
1518 
1519     public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1520         synchronized (mLock) {
1521             if (DEBUG_LOADERS) {
1522                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1523             }
1524 
1525             // Clear any deferred bind-runnables from the synchronized load process
1526             // We must do this before any loading/binding is scheduled below.
1527             synchronized (mDeferredBindRunnables) {
1528                 mDeferredBindRunnables.clear();
1529             }
1530 
1531             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1532             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1533                 // If there is already one running, tell it to stop.
1534                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1535                 isLaunching = isLaunching || stopLoaderLocked();
1536                 mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1537                 if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1538                         &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1539                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1540                 } else {
1541                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1542                     sWorker.post(mLoaderTask);
1543                 }
1544             }
1545         }
1546     }
1547 
1548     void bindRemainingSynchronousPages() {
1549         // Post the remaining side pages to be loaded
1550         if (!mDeferredBindRunnables.isEmpty()) {
1551             Runnable[] deferredBindRunnables = null;
1552             synchronized (mDeferredBindRunnables) {
1553                 deferredBindRunnables = mDeferredBindRunnables.toArray(
1554                         new Runnable[mDeferredBindRunnables.size()]);
1555                 mDeferredBindRunnables.clear();
1556             }
1557             for (final Runnable r : deferredBindRunnables) {
1558                 mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1559             }
1560         }
1561     }
1562 
1563     public void stopLoader() {
1564         synchronized (mLock) {
1565             if (mLoaderTask != null) {
1566                 mLoaderTask.stopLocked();
1567             }
1568         }
1569     }
1570 
1571     /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1572     private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1573         final ContentResolver contentResolver = context.getContentResolver();
1574         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1575         final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1576         TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1577 
1578         try {
1579             final int idIndex = sc.getColumnIndexOrThrow(
1580                     LauncherSettings.WorkspaceScreens._ID);
1581             final int rankIndex = sc.getColumnIndexOrThrow(
1582                     LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1583             while (sc.moveToNext()) {
1584                 try {
1585                     long screenId = sc.getLong(idIndex);
1586                     int rank = sc.getInt(rankIndex);
1587                     orderedScreens.put(rank, screenId);
1588                 } catch (Exception e) {
<abbr title="1589                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);">1589                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e,🔵</abbr>
1590                 }
1591             }
1592         } finally {
1593             sc.close();
1594         }
1595 
1596         // Log to disk
1597         Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1598         ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1599         for (Integer i : orderedScreens.keySet()) {
1600             orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1601         }
1602         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1603                 TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1604         return orderedScreens;
1605     }
1606 
1607     public boolean isAllAppsLoaded() {
1608         return mAllAppsLoaded;
1609     }
1610 
1611     boolean isLoadingWorkspace() {
1612         synchronized (mLock) {
1613             if (mLoaderTask != null) {
1614                 return mLoaderTask.isLoadingWorkspace();
1615             }
1616         }
1617         return false;
1618     }
1619 
1620     /**
1621      * Runnable for the thread that loads the contents of the launcher:
1622      *   - workspace icons
1623      *   - widgets
1624      *   - all apps icons
1625      */
1626     private class LoaderTask implements Runnable {
1627         private Context mContext;
1628         private boolean mIsLaunching;
1629         private boolean mIsLoadingAndBindingWorkspace;
1630         private boolean mStopped;
1631         private boolean mLoadAndBindStepFinished;
1632         private int mFlags;
1633 
1634         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1635 
1636         LoaderTask(Context context, boolean isLaunching, int flags) {
1637             mContext = context;
1638             mIsLaunching = isLaunching;
1639             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1640             mFlags = flags;
1641         }
1642 
1643         boolean isLaunching() {
1644             return mIsLaunching;
1645         }
1646 
1647         boolean isLoadingWorkspace() {
1648             return mIsLoadingAndBindingWorkspace;
1649         }
1650 
1651         /** Returns whether this is an upgrade path */
1652         private boolean loadAndBindWorkspace() {
1653             mIsLoadingAndBindingWorkspace = true;
1654 
1655             // Load the workspace
1656             if (DEBUG_LOADERS) {
1657                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1658             }
1659 
1660             boolean isUpgradePath = false;
1661             if (!mWorkspaceLoaded) {
1662                 isUpgradePath = loadWorkspace();
1663                 synchronized (LoaderTask.this) {
1664                     if (mStopped) {
1665                         return isUpgradePath;
1666                     }
1667                     mWorkspaceLoaded = true;
1668                 }
1669             }
1670 
1671             // Bind the workspace
1672             bindWorkspace(-1, isUpgradePath);
1673             return isUpgradePath;
1674         }
1675 
1676         private void waitForIdle() {
1677             // Wait until the either we&#x27;re stopped or the other threads are done.
1678             // This way we don&#x27;t start loading all apps until the workspace has settled
1679             // down.
1680             synchronized (LoaderTask.this) {
1681                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1682 
1683                 mHandler.postIdle(new Runnable() {
1684                         public void run() {
1685                             synchronized (LoaderTask.this) {
1686                                 mLoadAndBindStepFinished = true;
1687                                 if (DEBUG_LOADERS) {
1688                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1689                                 }
1690                                 LoaderTask.this.notify();
1691                             }
1692                         }
1693                     });
1694 
1695                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1696                     try {
1697                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1698                         // wait no longer than 1sec at a time
1699                         this.wait(1000);
1700                     } catch (InterruptedException ex) {
1701                         // Ignore
1702                     }
1703                 }
1704                 if (DEBUG_LOADERS) {
1705                     Log.d(TAG, &quot;waited &quot;
1706                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1707                             + &quot;ms for previous step to finish binding&quot;);
1708                 }
1709             }
1710         }
1711 
1712         void runBindSynchronousPage(int synchronousBindPage) {
1713             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1714                 // Ensure that we have a valid page index to load synchronously
1715                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1716                         &quot;valid page index&quot;);
1717             }
1718             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1719                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1720                 // loaded already (we should load everything asynchronously in that case)
1721                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1722             }
1723             synchronized (mLock) {
1724                 if (mIsLoaderTaskRunning) {
1725                     // Ensure that we are never running the background loading at this point since
1726                     // we also touch the background collections
1727                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1728                 }
1729             }
1730 
1731             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1732             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1733             //      this call is synchronous, we can get away with not locking).
1734 
1735             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1736             // operations from the previous activity.  We need to ensure that all queued operations
1737             // are executed before any synchronous binding work is done.
1738             mHandler.flush();
1739 
1740             // Divide the set of loaded items into those that we are binding synchronously, and
1741             // everything else that is to be bound normally (asynchronously).
1742             bindWorkspace(synchronousBindPage, false);
1743             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1744             //      arise from that.
1745             onlyBindAllApps();
1746         }
1747 
1748         public void run() {
1749             boolean isUpgrade = false;
1750 
1751             synchronized (mLock) {
1752                 mIsLoaderTaskRunning = true;
1753             }
1754             // Optimize for end-user experience: if the Launcher is up and // running with the
1755             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1756             // workspace first (default).
1757             keep_running: {
1758                 // Elevate priority when Home launches for the first time to avoid
1759                 // starving at boot time. Staring at a blank home is not cool.
1760                 synchronized (mLock) {
1761                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1762                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1763                     android.os.Process.setThreadPriority(mIsLaunching
1764                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1765                 }
1766                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1767                 isUpgrade = loadAndBindWorkspace();
1768 
1769                 if (mStopped) {
1770                     break keep_running;
1771                 }
1772 
1773                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1774                 // settled down.
1775                 synchronized (mLock) {
1776                     if (mIsLaunching) {
1777                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1778                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1779                     }
1780                 }
1781                 waitForIdle();
1782 
1783                 // second step
1784                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1785                 loadAndBindAllApps();
1786 
1787                 // Restore the default thread priority after we are done loading items
1788                 synchronized (mLock) {
1789                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1790                 }
1791             }
1792 
1793             // Update the saved icons if necessary
1794             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1795             synchronized (sBgLock) {
1796                 for (Object key : sBgDbIconCache.keySet()) {
1797                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1798                 }
1799                 sBgDbIconCache.clear();
1800             }
1801 
1802             if (LauncherAppState.isDisableAllApps()) {
1803                 // Ensure that all the applications that are in the system are
1804                 // represented on the home screen.
1805                 if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1806                     verifyApplications();
1807                 }
1808             }
1809 
1810             // Clear out this reference, otherwise we end up holding it until all of the
1811             // callback runnables are done.
1812             mContext = null;
1813 
1814             synchronized (mLock) {
1815                 // If we are still the last one to be scheduled, remove ourselves.
1816                 if (mLoaderTask == this) {
1817                     mLoaderTask = null;
1818                 }
1819                 mIsLoaderTaskRunning = false;
1820             }
1821         }
1822 
1823         public void stopLocked() {
1824             synchronized (LoaderTask.this) {
1825                 mStopped = true;
1826                 this.notify();
1827             }
1828         }
1829 
1830         /**
1831          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1832          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1833          * object that was around when the deferred message was scheduled, and if there&#x27;s
1834          * a new Callbacks object around then also return null.  This will save us from
1835          * calling onto it with data that will be ignored.
1836          */
1837         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1838             synchronized (mLock) {
1839                 if (mStopped) {
1840                     return null;
1841                 }
1842 
1843                 if (mCallbacks == null) {
1844                     return null;
1845                 }
1846 
1847                 final Callbacks callbacks = mCallbacks.get();
1848                 if (callbacks != oldCallbacks) {
1849                     return null;
1850                 }
1851                 if (callbacks == null) {
1852                     Log.w(TAG, &quot;no mCallbacks&quot;);
1853                     return null;
1854                 }
1855 
1856                 return callbacks;
1857             }
1858         }
1859 
1860         private void verifyApplications() {
1861             final Context context = mApp.getContext();
1862 
1863             // Cross reference all the applications in our apps list with items in the workspace
1864             ArrayList&lt;ItemInfo&gt; tmpInfos;
1865             ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1866             synchronized (sBgLock) {
1867                 for (AppInfo app : mBgAllAppsList.data) {
1868                     tmpInfos = getItemInfoForComponentName(app.componentName, app.user);
1869                     if (tmpInfos.isEmpty()) {
1870                         // We are missing an application icon, so add this to the workspace
1871                         added.add(app);
1872                         // This is a rare event, so lets log it
1873                         Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1874                     }
1875                 }
1876             }
1877             if (!added.isEmpty()) {
1878                 addAndBindAddedWorkspaceApps(context, added);
1879             }
1880         }
1881 
1882         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1883         private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1884                                            AtomicBoolean deleteOnInvalidPlacement) {
1885             LauncherAppState app = LauncherAppState.getInstance();
1886             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1887             final int countX = (int) grid.numColumns;
1888             final int countY = (int) grid.numRows;
1889 
1890             long containerIndex = item.screenId;
1891             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1892                 // Return early if we detect that an item is under the hotseat button
1893                 if (mCallbacks == null ||
1894                         mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1895                     deleteOnInvalidPlacement.set(true);
1896                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1897                             + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1898                             + item.cellY + &quot;) occupied by all apps&quot;);
1899                     return false;
1900                 }
1901 
1902                 final ItemInfo[][] hotseatItems =
1903                         occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1904 
1905                 if (item.screenId &gt;= grid.numHotseatIcons) {
1906                     Log.e(TAG, &quot;Error loading shortcut &quot; + item
1907                             + &quot; into hotseat position &quot; + item.screenId
1908                             + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1909                             + &quot;)&quot;);
1910                     return false;
1911                 }
1912 
1913                 if (hotseatItems != null) {
1914                     if (hotseatItems[(int) item.screenId][0] != null) {
1915                         Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1916                                 + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1917                                 + item.cellY + &quot;) occupied by &quot;
1918                                 + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1919                                 [(int) item.screenId][0]);
1920                             return false;
1921                     } else {
1922                         hotseatItems[(int) item.screenId][0] = item;
1923                         return true;
1924                     }
1925                 } else {
1926                     final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1927                     items[(int) item.screenId][0] = item;
1928                     occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1929                     return true;
1930                 }
1931             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1932                 // Skip further checking if it is not the hotseat or workspace container
1933                 return true;
1934             }
1935 
1936             if (!occupied.containsKey(item.screenId)) {
1937                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1938                 occupied.put(item.screenId, items);
1939             }
1940 
1941             final ItemInfo[][] screens = occupied.get(item.screenId);
1942             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1943                     item.cellX &lt; 0 || item.cellY &lt; 0 ||
1944                     item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1945                 Log.e(TAG, &quot;Error loading shortcut &quot; + item
1946                         + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1947                         + item.cellX + &quot;,&quot; + item.cellY
1948                         + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1949                 return false;
1950             }
1951 
1952             // Check if any workspace icons overlap with each other
1953             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1954                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1955                     if (screens[x][y] != null) {
1956                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1957                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1958                             + x + &quot;,&quot; + y
1959                             + &quot;) occupied by &quot;
1960                             + screens[x][y]);
1961                         return false;
1962                     }
1963                 }
1964             }
1965             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1966                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1967                     screens[x][y] = item;
1968                 }
1969             }
1970 
1971             return true;
1972         }
1973 
1974         /** Clears all the sBg data structures */
1975         private void clearSBgDataStructures() {
1976             synchronized (sBgLock) {
1977                 sBgWorkspaceItems.clear();
1978                 sBgAppWidgets.clear();
1979                 sBgFolders.clear();
1980                 sBgItemsIdMap.clear();
1981                 sBgDbIconCache.clear();
1982                 sBgWorkspaceScreens.clear();
1983             }
1984         }
1985 
1986         /** Returns whether this is an upgrade path */
1987         private boolean loadWorkspace() {
1988             // Log to disk
1989             Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1990 
1991             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1992 
1993             final Context context = mContext;
1994             final ContentResolver contentResolver = context.getContentResolver();
1995             final PackageManager manager = context.getPackageManager();
1996             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1997             final boolean isSafeMode = manager.isSafeMode();
1998             final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
1999             final boolean isSdCardReady = context.registerReceiver(null,
2000                     new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;
2001 
2002             LauncherAppState app = LauncherAppState.getInstance();
2003             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2004             int countX = (int) grid.numColumns;
2005             int countY = (int) grid.numRows;
2006 
2007             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
2008                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
2009                 LauncherAppState.getLauncherProvider().deleteDatabase();
2010             }
2011 
2012             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
2013                 // append the user&#x27;s Launcher2 shortcuts
2014                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
2015                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
2016             } else {
2017                 // Make sure the default workspace is loaded
2018                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
2019                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
2020             }
2021 
2022             // This code path is for our old migration code and should no longer be exercised
2023             boolean loadedOldDb = false;
2024 
2025             // Log to disk
2026             Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
2027 
2028             synchronized (sBgLock) {
2029                 clearSBgDataStructures();
2030                 final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat
2031                         .getInstance(mContext).updateAndGetActiveSessionCache();
2032 
2033                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
2034                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
2035                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;
2036                 if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
2037                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
2038 
2039                 // +1 for the hotseat (it can be larger than the workspace)
2040                 // Load workspace in reverse order to ensure that latest items are loaded first (and
2041                 // before any earlier duplicates)
2042                 final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
2043 
2044                 try {
2045                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
2046                     final int intentIndex = c.getColumnIndexOrThrow
2047                             (LauncherSettings.Favorites.INTENT);
2048                     final int titleIndex = c.getColumnIndexOrThrow
2049                             (LauncherSettings.Favorites.TITLE);
2050                     final int iconTypeIndex = c.getColumnIndexOrThrow(
2051                             LauncherSettings.Favorites.ICON_TYPE);
2052                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
2053                     final int iconPackageIndex = c.getColumnIndexOrThrow(
2054                             LauncherSettings.Favorites.ICON_PACKAGE);
2055                     final int iconResourceIndex = c.getColumnIndexOrThrow(
2056                             LauncherSettings.Favorites.ICON_RESOURCE);
2057                     final int containerIndex = c.getColumnIndexOrThrow(
2058                             LauncherSettings.Favorites.CONTAINER);
2059                     final int itemTypeIndex = c.getColumnIndexOrThrow(
2060                             LauncherSettings.Favorites.ITEM_TYPE);
2061                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
2062                             LauncherSettings.Favorites.APPWIDGET_ID);
2063                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
2064                             LauncherSettings.Favorites.APPWIDGET_PROVIDER);
2065                     final int screenIndex = c.getColumnIndexOrThrow(
2066                             LauncherSettings.Favorites.SCREEN);
2067                     final int cellXIndex = c.getColumnIndexOrThrow
2068                             (LauncherSettings.Favorites.CELLX);
2069                     final int cellYIndex = c.getColumnIndexOrThrow
2070                             (LauncherSettings.Favorites.CELLY);
2071                     final int spanXIndex = c.getColumnIndexOrThrow
2072                             (LauncherSettings.Favorites.SPANX);
2073                     final int spanYIndex = c.getColumnIndexOrThrow(
2074                             LauncherSettings.Favorites.SPANY);
2075                     final int restoredIndex = c.getColumnIndexOrThrow(
2076                             LauncherSettings.Favorites.RESTORED);
2077                     final int profileIdIndex = c.getColumnIndexOrThrow(
2078                             LauncherSettings.Favorites.PROFILE_ID);
2079                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
2080                     //final int displayModeIndex = c.getColumnIndexOrThrow(
2081                     //        LauncherSettings.Favorites.DISPLAY_MODE);
2082 
2083                     ShortcutInfo info;
2084                     String intentDescription;
2085                     LauncherAppWidgetInfo appWidgetInfo;
2086                     int container;
2087                     long id;
2088                     Intent intent;
2089                     UserHandleCompat user;
2090 
2091                     while (!mStopped &amp;&amp; c.moveToNext()) {
2092                         AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
2093                         try {
2094                             int itemType = c.getInt(itemTypeIndex);
2095                             boolean restored = 0 != c.getInt(restoredIndex);
2096                             boolean allowMissingTarget = false;
2097 
2098                             switch (itemType) {
2099                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
2100                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
2101                                 id = c.getLong(idIndex);
2102                                 intentDescription = c.getString(intentIndex);
2103                                 long serialNumber = c.getInt(profileIdIndex);
2104                                 user = mUserManager.getUserForSerialNumber(serialNumber);
2105                                 int promiseType = c.getInt(restoredIndex);
2106                                 if (user == null) {
2107                                     // User has been deleted remove the item.
2108                                     itemsToRemove.add(id);
2109                                     continue;
2110                                 }
2111                                 try {
2112                                     intent = Intent.parseUri(intentDescription, 0);
2113                                     ComponentName cn = intent.getComponent();
2114                                     if (cn != null &amp;&amp; cn.getPackageName() != null) {
2115                                         boolean validPkg = launcherApps.isPackageEnabledForProfile(
2116                                                 cn.getPackageName(), user);
2117                                         boolean validComponent = validPkg &amp;&amp;
2118                                                 launcherApps.isActivityEnabledForProfile(cn, user);
2119 
2120                                         if (validComponent) {
2121                                             if (restored) {
2122                                                 // no special handling necessary for this item
2123                                                 restoredRows.add(id);
2124                                                 restored = false;
2125                                             }
2126                                         } else if (validPkg) {
2127                                             intent = null;
2128                                             if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
2129                                                 // We allow auto install apps to have their intent
2130                                                 // updated after an install.
2131                                                 intent = manager.getLaunchIntentForPackage(
2132                                                         cn.getPackageName());
2133                                                 if (intent != null) {
2134                                                     ContentValues values = new ContentValues();
2135                                                     values.put(LauncherSettings.Favorites.INTENT,
2136                                                             intent.toUri(0));
2137                                                     String where = BaseColumns._ID + &quot;= ?&quot;;
2138                                                     String[] args = {Long.toString(id)};
<abbr title="2139                                                     contentResolver.update(contentUri, values, where, args);">2139                                                     contentResolver.update(contentUri, values, where, arg🔵</abbr>
2140                                                 }
2141                                             }
2142 
2143                                             if (intent == null) {
2144                                                 // The app is installed but the component is no
2145                                                 // longer available.
2146                                                 Launcher.addDumpLog(TAG,
2147                                                         &quot;Invalid component removed: &quot; + cn, true);
2148                                                 itemsToRemove.add(id);
2149                                                 continue;
2150                                             } else {
2151                                                 // no special handling necessary for this item
2152                                                 restoredRows.add(id);
2153                                                 restored = false;
2154                                             }
2155                                         } else if (restored) {
2156                                             // Package is not yet available but might be
2157                                             // installed later.
2158                                             Launcher.addDumpLog(TAG,
2159                                                     &quot;package not yet restored: &quot; + cn, true);
2160 
2161                                             if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {
2162                                                 // Restore has started once.
2163                                             } else if (installingPkgs.contains(cn.getPackageName())) {
2164                                                 // App restore has started. Update the flag
2165                                                 promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
2166                                                 ContentValues values = new ContentValues();
2167                                                 values.put(LauncherSettings.Favorites.RESTORED,
2168                                                         promiseType);
2169                                                 String where = BaseColumns._ID + &quot;= ?&quot;;
2170                                                 String[] args = {Long.toString(id)};
2171                                                 contentResolver.update(contentUri, values, where, args);
2172 
2173                                             } else if (REMOVE_UNRESTORED_ICONS) {
2174                                                 Launcher.addDumpLog(TAG,
2175                                                         &quot;Unrestored package removed: &quot; + cn, true);
2176                                                 itemsToRemove.add(id);
2177                                                 continue;
2178                                             }
2179                                         } else if (isSdCardReady) {
2180                                             // Do not wait for external media load anymore.
2181                                             // Log the invalid package, and remove it
2182                                             Launcher.addDumpLog(TAG,
2183                                                     &quot;Invalid package removed: &quot; + cn, true);
2184                                             itemsToRemove.add(id);
2185                                             continue;
2186                                         } else {
2187                                             // SdCard is not ready yet. Package might get available,
2188                                             // once it is ready.
2189                                             Launcher.addDumpLog(TAG, &quot;Invalid package: &quot; + cn
2190                                                     + &quot; (check again later)&quot;, true);
2191                                             HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
2192                                             if (pkgs == null) {
2193                                                 pkgs = new HashSet&lt;String&gt;();
2194                                                 sPendingPackages.put(user, pkgs);
2195                                             }
2196                                             pkgs.add(cn.getPackageName());
2197                                             allowMissingTarget = true;
2198                                             // Add the icon on the workspace anyway.
2199                                         }
2200                                     } else if (cn == null) {
2201                                         // For shortcuts with no component, keep them as they are
2202                                         restoredRows.add(id);
2203                                         restored = false;
2204                                     }
2205                                 } catch (URISyntaxException e) {
2206                                     Launcher.addDumpLog(TAG,
2207                                             &quot;Invalid uri: &quot; + intentDescription, true);
2208                                     continue;
2209                                 }
2210 
2211                                 if (restored) {
2212                                     if (user.equals(UserHandleCompat.myUserHandle())) {
2213                                         Launcher.addDumpLog(TAG,
2214                                                 &quot;constructing info for partially restored package&quot;,
2215                                                 true);
2216                                         info = getRestoredItemInfo(c, titleIndex, intent, promiseType);
2217                                         intent = getRestoredItemIntent(c, context, intent);
2218                                     } else {
2219                                         // Don&#x27;t restore items for other profiles.
2220                                         itemsToRemove.add(id);
2221                                         continue;
2222                                     }
2223                                 } else if (itemType ==
2224                                         LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
2225                                     info = getShortcutInfo(manager, intent, user, context, c,
2226                                             iconIndex, titleIndex, mLabelCache, allowMissingTarget);
2227                                 } else {
2228                                     info = getShortcutInfo(c, context, iconTypeIndex,
2229                                             iconPackageIndex, iconResourceIndex, iconIndex,
2230                                             titleIndex);
2231 
2232                                     // App shortcuts that used to be automatically added to Launcher
2233                                     // didn&#x27;t always have the correct intent flags set, so do that
2234                                     // here
2235                                     if (intent.getAction() != null &amp;&amp;
2236                                         intent.getCategories() != null &amp;&amp;
2237                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
2238                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
2239                                         intent.addFlags(
2240                                             Intent.FLAG_ACTIVITY_NEW_TASK |
2241                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
2242                                     }
2243                                 }
2244 
2245                                 if (info != null) {
2246                                     info.id = id;
2247                                     info.intent = intent;
2248                                     container = c.getInt(containerIndex);
2249                                     info.container = container;
2250                                     info.screenId = c.getInt(screenIndex);
2251                                     info.cellX = c.getInt(cellXIndex);
2252                                     info.cellY = c.getInt(cellYIndex);
2253                                     info.spanX = 1;
2254                                     info.spanY = 1;
2255                                     info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
2256                                     info.isDisabled = isSafeMode
2257                                             &amp;&amp; !Utilities.isSystemApp(context, intent);
2258 
2259                                     // check &amp; update map of what&#x27;s occupied
2260                                     deleteOnInvalidPlacement.set(false);
2261                                     if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {
2262                                         if (deleteOnInvalidPlacement.get()) {
2263                                             itemsToRemove.add(id);
2264                                         }
2265                                         break;
2266                                     }
2267 
2268                                     switch (container) {
2269                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2270                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2271                                         sBgWorkspaceItems.add(info);
2272                                         break;
2273                                     default:
2274                                         // Item is in a user folder
2275                                         FolderInfo folderInfo =
2276                                                 findOrMakeFolder(sBgFolders, container);
2277                                         folderInfo.add(info);
2278                                         break;
2279                                     }
2280                                     sBgItemsIdMap.put(info.id, info);
2281 
2282                                     // now that we&#x27;ve loaded everthing re-save it with the
2283                                     // icon in case it disappears somehow.
2284                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
2285                                 } else {
2286                                     throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2287                                 }
2288                                 break;
2289 
2290                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
2291                                 id = c.getLong(idIndex);
2292                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2293 
2294                                 folderInfo.title = c.getString(titleIndex);
2295                                 folderInfo.id = id;
2296                                 container = c.getInt(containerIndex);
2297                                 folderInfo.container = container;
2298                                 folderInfo.screenId = c.getInt(screenIndex);
2299                                 folderInfo.cellX = c.getInt(cellXIndex);
2300                                 folderInfo.cellY = c.getInt(cellYIndex);
2301                                 folderInfo.spanX = 1;
2302                                 folderInfo.spanY = 1;
2303 
2304                                 // check &amp; update map of what&#x27;s occupied
2305                                 deleteOnInvalidPlacement.set(false);
2306                                 if (!checkItemPlacement(occupied, folderInfo,
2307                                         deleteOnInvalidPlacement)) {
2308                                     if (deleteOnInvalidPlacement.get()) {
2309                                         itemsToRemove.add(id);
2310                                     }
2311                                     break;
2312                                 }
2313 
2314                                 switch (container) {
2315                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2316                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2317                                         sBgWorkspaceItems.add(folderInfo);
2318                                         break;
2319                                 }
2320 
2321                                 if (restored) {
2322                                     // no special handling required for restored folders
2323                                     restoredRows.add(id);
2324                                 }
2325 
2326                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
2327                                 sBgFolders.put(folderInfo.id, folderInfo);
2328                                 break;
2329 
2330                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2331                                 // Read all Launcher-specific widget details
2332                                 int appWidgetId = c.getInt(appWidgetIdIndex);
2333                                 String savedProvider = c.getString(appWidgetProviderIndex);
2334                                 id = c.getLong(idIndex);
2335                                 final ComponentName component =
2336                                         ComponentName.unflattenFromString(savedProvider);
2337 
2338                                 final int restoreStatus = c.getInt(restoredIndex);
2339                                 final boolean isIdValid = (restoreStatus &amp;
2340                                         LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;
2341 
2342                                 final boolean wasProviderReady = (restoreStatus &amp;
2343                                         LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;
2344 
2345                                 final AppWidgetProviderInfo provider = isIdValid
2346                                         ? widgets.getAppWidgetInfo(appWidgetId)
2347                                         : findAppWidgetProviderInfoWithComponent(context, component);
2348 
2349                                 final boolean isProviderReady = isValidProvider(provider);
2350                                 if (!isSafeMode &amp;&amp; wasProviderReady &amp;&amp; !isProviderReady) {
2351                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;
2352                                             + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;
2353                                     Log.e(TAG, log);
2354                                     Launcher.addDumpLog(TAG, log, false);
2355                                     itemsToRemove.add(id);
2356                                 } else {
2357                                     if (isProviderReady) {
2358                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2359                                                 provider.provider);
2360                                         int[] minSpan =
2361                                                 Launcher.getMinSpanForWidget(context, provider);
2362                                         appWidgetInfo.minSpanX = minSpan[0];
2363                                         appWidgetInfo.minSpanY = minSpan[1];
2364 
2365                                         int status = restoreStatus;
2366                                         if (!wasProviderReady) {
2367                                             // If provider was not previously ready, update the
2368                                             // status and UI flag.
2369 
<abbr title="2370                                             // Id would be valid only if the widget restore broadcast was received.">2370                                             // Id would be valid only if the widget restore broadcast was🔵</abbr>
2371                                             if (isIdValid) {
2372                                                 status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2373                                             } else {
2374                                                 status &amp;= ~LauncherAppWidgetInfo
2375                                                         .FLAG_PROVIDER_NOT_READY;
2376                                             }
2377                                         }
2378                                         appWidgetInfo.restoreStatus = status;
2379                                     } else {
2380                                         Log.v(TAG, &quot;Widget restore pending id=&quot; + id
2381                                                 + &quot; appWidgetId=&quot; + appWidgetId
2382                                                 + &quot; status =&quot; + restoreStatus);
2383                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2384                                                 component);
2385                                         appWidgetInfo.restoreStatus = restoreStatus;
2386 
<abbr title="2387                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {">2387                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) 🔵</abbr>
2388                                             // Restore has started once.
2389                                         } else if (installingPkgs.contains(component.getPackageName())) {
2390                                             // App restore has started. Update the flag
2391                                             appWidgetInfo.restoreStatus |=
2392                                                     LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;
2393                                         } else if (REMOVE_UNRESTORED_ICONS) {
2394                                             Launcher.addDumpLog(TAG,
2395                                                     &quot;Unrestored widget removed: &quot; + component, true);
2396                                             itemsToRemove.add(id);
2397                                             continue;
2398                                         }
2399                                     }
2400 
2401                                     appWidgetInfo.id = id;
2402                                     appWidgetInfo.screenId = c.getInt(screenIndex);
2403                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
2404                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
2405                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
2406                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
2407 
2408                                     container = c.getInt(containerIndex);
2409                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2410                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2411                                         Log.e(TAG, &quot;Widget found where container != &quot; +
2412                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2413                                         continue;
2414                                     }
2415 
2416                                     appWidgetInfo.container = c.getInt(containerIndex);
2417                                     // check &amp; update map of what&#x27;s occupied
2418                                     deleteOnInvalidPlacement.set(false);
2419                                     if (!checkItemPlacement(occupied, appWidgetInfo,
2420                                             deleteOnInvalidPlacement)) {
2421                                         if (deleteOnInvalidPlacement.get()) {
2422                                             itemsToRemove.add(id);
2423                                         }
2424                                         break;
2425                                     }
2426 
2427                                     String providerName = appWidgetInfo.providerName.flattenToString();
2428                                     if (!providerName.equals(savedProvider) ||
2429                                             (appWidgetInfo.restoreStatus != restoreStatus)) {
2430                                         ContentValues values = new ContentValues();
2431                                         values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2432                                                 providerName);
2433                                         values.put(LauncherSettings.Favorites.RESTORED,
2434                                                 appWidgetInfo.restoreStatus);
2435                                         String where = BaseColumns._ID + &quot;= ?&quot;;
2436                                         String[] args = {Long.toString(id)};
2437                                         contentResolver.update(contentUri, values, where, args);
2438                                     }
2439                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2440                                     sBgAppWidgets.add(appWidgetInfo);
2441                                 }
2442                                 break;
2443                             }
2444                         } catch (Exception e) {
2445                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2446                         }
2447                     }
2448                 } finally {
2449                     if (c != null) {
2450                         c.close();
2451                     }
2452                 }
2453 
2454                 // Break early if we&#x27;ve stopped loading
2455                 if (mStopped) {
2456                     clearSBgDataStructures();
2457                     return false;
2458                 }
2459 
2460                 if (itemsToRemove.size() &gt; 0) {
2461                     ContentProviderClient client = contentResolver.acquireContentProviderClient(
2462                             contentUri);
2463                     // Remove dead items
2464                     for (long id : itemsToRemove) {
2465                         if (DEBUG_LOADERS) {
2466                             Log.d(TAG, &quot;Removed id = &quot; + id);
2467                         }
2468                         // Don&#x27;t notify content observers
2469                         try {
2470                             client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2471                                     null, null);
2472                         } catch (RemoteException e) {
2473                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
2474                         }
2475                     }
2476                 }
2477 
2478                 if (restoredRows.size() &gt; 0) {
2479                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(
2480                             contentUri);
2481                     // Update restored items that no longer require special handling
2482                     try {
2483                         StringBuilder selectionBuilder = new StringBuilder();
2484                         selectionBuilder.append(LauncherSettings.Favorites._ID);
2485                         selectionBuilder.append(&quot; IN (&quot;);
2486                         selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2487                         selectionBuilder.append(&quot;)&quot;);
2488                         ContentValues values = new ContentValues();
2489                         values.put(LauncherSettings.Favorites.RESTORED, 0);
2490                         updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
2491                                 values, selectionBuilder.toString(), null);
2492                     } catch (RemoteException e) {
2493                         Log.w(TAG, &quot;Could not update restored rows&quot;);
2494                     }
2495                 }
2496 
2497                 if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) {
2498                     context.registerReceiver(new AppsAvailabilityCheck(),
2499                             new IntentFilter(StartupReceiver.SYSTEM_READY),
2500                             null, sWorker);
2501                 }
2502 
2503                 if (loadedOldDb) {
2504                     long maxScreenId = 0;
2505                     // If we&#x27;re importing we use the old screen order.
2506                     for (ItemInfo item: sBgItemsIdMap.values()) {
2507                         long screenId = item.screenId;
2508                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2509                                 !sBgWorkspaceScreens.contains(screenId)) {
2510                             sBgWorkspaceScreens.add(screenId);
2511                             if (screenId &gt; maxScreenId) {
2512                                 maxScreenId = screenId;
2513                             }
2514                         }
2515                     }
2516                     Collections.sort(sBgWorkspaceScreens);
2517                     // Log to disk
2518                     Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2519                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2520                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2521 
2522                     LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2523                     updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2524 
2525                     // Update the max item id after we load an old db
2526                     long maxItemId = 0;
2527                     // If we&#x27;re importing we use the old screen order.
2528                     for (ItemInfo item: sBgItemsIdMap.values()) {
2529                         maxItemId = Math.max(maxItemId, item.id);
2530                     }
2531                     LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2532                 } else {
2533                     TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2534                     for (Integer i : orderedScreens.keySet()) {
2535                         sBgWorkspaceScreens.add(orderedScreens.get(i));
2536                     }
2537                     // Log to disk
2538                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2539                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2540 
2541                     // Remove any empty screens
2542                     ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2543                     for (ItemInfo item: sBgItemsIdMap.values()) {
2544                         long screenId = item.screenId;
2545                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2546                                 unusedScreens.contains(screenId)) {
2547                             unusedScreens.remove(screenId);
2548                         }
2549                     }
2550 
2551                     // If there are any empty screens remove them, and update.
2552                     if (unusedScreens.size() != 0) {
2553                         // Log to disk
2554                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2555                                 TextUtils.join(&quot;, &quot;, unusedScreens), true);
2556 
2557                         sBgWorkspaceScreens.removeAll(unusedScreens);
2558                         updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2559                     }
2560                 }
2561 
2562                 if (DEBUG_LOADERS) {
2563                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2564                     Log.d(TAG, &quot;workspace layout: &quot;);
2565                     int nScreens = occupied.size();
2566                     for (int y = 0; y &lt; countY; y++) {
2567                         String line = &quot;&quot;;
2568 
2569                         Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2570                         while (iter.hasNext()) {
2571                             long screenId = iter.next();
2572                             if (screenId &gt; 0) {
2573                                 line += &quot; | &quot;;
2574                             }
2575                             for (int x = 0; x &lt; countX; x++) {
2576                                 ItemInfo[][] screen = occupied.get(screenId);
2577                                 if (x &lt; screen.length &amp;&amp; y &lt; screen[x].length) {
2578                                     line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2579                                 } else {
2580                                     line += &quot;!&quot;;
2581                                 }
2582                             }
2583                         }
2584                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2585                     }
2586                 }
2587             }
2588             return loadedOldDb;
2589         }
2590 
2591         /** Filters the set of items who are directly or indirectly (via another container) on the
2592          * specified screen. */
2593         private void filterCurrentWorkspaceItems(long currentScreenId,
2594                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2595                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
2596                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2597             // Purge any null ItemInfos
2598             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2599             while (iter.hasNext()) {
2600                 ItemInfo i = iter.next();
2601                 if (i == null) {
2602                     iter.remove();
2603                 }
2604             }
2605 
2606             // Order the set of items by their containers first, this allows use to walk through the
2607             // list sequentially, build up a list of containers that are in the specified screen,
2608             // as well as all items in those containers.
2609             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2610             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2611                 @Override
2612                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2613                     return (int) (lhs.container - rhs.container);
2614                 }
2615             });
2616             for (ItemInfo info : allWorkspaceItems) {
2617                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2618                     if (info.screenId == currentScreenId) {
2619                         currentScreenItems.add(info);
2620                         itemsOnScreen.add(info.id);
2621                     } else {
2622                         otherScreenItems.add(info);
2623                     }
2624                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2625                     currentScreenItems.add(info);
2626                     itemsOnScreen.add(info.id);
2627                 } else {
2628                     if (itemsOnScreen.contains(info.container)) {
2629                         currentScreenItems.add(info);
2630                         itemsOnScreen.add(info.id);
2631                     } else {
2632                         otherScreenItems.add(info);
2633                     }
2634                 }
2635             }
2636         }
2637 
2638         /** Filters the set of widgets which are on the specified screen. */
2639         private void filterCurrentAppWidgets(long currentScreenId,
2640                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2641                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2642                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2643 
2644             for (LauncherAppWidgetInfo widget : appWidgets) {
2645                 if (widget == null) continue;
2646                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2647                         widget.screenId == currentScreenId) {
2648                     currentScreenWidgets.add(widget);
2649                 } else {
2650                     otherScreenWidgets.add(widget);
2651                 }
2652             }
2653         }
2654 
2655         /** Filters the set of folders which are on the specified screen. */
2656         private void filterCurrentFolders(long currentScreenId,
2657                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2658                 HashMap&lt;Long, FolderInfo&gt; folders,
2659                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2660                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2661 
2662             for (long id : folders.keySet()) {
2663                 ItemInfo info = itemsIdMap.get(id);
2664                 FolderInfo folder = folders.get(id);
2665                 if (info == null || folder == null) continue;
2666                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2667                         info.screenId == currentScreenId) {
2668                     currentScreenFolders.put(id, folder);
2669                 } else {
2670                     otherScreenFolders.put(id, folder);
2671                 }
2672             }
2673         }
2674 
2675         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2676          * right) */
2677         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2678             final LauncherAppState app = LauncherAppState.getInstance();
2679             final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2680             // XXX: review this
2681             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2682                 @Override
2683                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2684                     int cellCountX = (int) grid.numColumns;
2685                     int cellCountY = (int) grid.numRows;
2686                     int screenOffset = cellCountX * cellCountY;
2687                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2688                     long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2689                             lhs.cellY * cellCountX + lhs.cellX);
2690                     long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2691                             rhs.cellY * cellCountX + rhs.cellX);
2692                     return (int) (lr - rr);
2693                 }
2694             });
2695         }
2696 
2697         private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2698                 final ArrayList&lt;Long&gt; orderedScreens) {
2699             final Runnable r = new Runnable() {
2700                 @Override
2701                 public void run() {
2702                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2703                     if (callbacks != null) {
2704                         callbacks.bindScreens(orderedScreens);
2705                     }
2706                 }
2707             };
2708             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2709         }
2710 
2711         private void bindWorkspaceItems(final Callbacks oldCallbacks,
2712                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
2713                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2714                 final HashMap&lt;Long, FolderInfo&gt; folders,
2715                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2716 
2717             final boolean postOnMainThread = (deferredBindRunnables != null);
2718 
2719             // Bind the workspace items
2720             int N = workspaceItems.size();
2721             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2722                 final int start = i;
2723                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2724                 final Runnable r = new Runnable() {
2725                     @Override
2726                     public void run() {
2727                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2728                         if (callbacks != null) {
2729                             callbacks.bindItems(workspaceItems, start, start+chunkSize,
2730                                     false);
2731                         }
2732                     }
2733                 };
2734                 if (postOnMainThread) {
2735                     synchronized (deferredBindRunnables) {
2736                         deferredBindRunnables.add(r);
2737                     }
2738                 } else {
2739                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2740                 }
2741             }
2742 
2743             // Bind the folders
2744             if (!folders.isEmpty()) {
2745                 final Runnable r = new Runnable() {
2746                     public void run() {
2747                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2748                         if (callbacks != null) {
2749                             callbacks.bindFolders(folders);
2750                         }
2751                     }
2752                 };
2753                 if (postOnMainThread) {
2754                     synchronized (deferredBindRunnables) {
2755                         deferredBindRunnables.add(r);
2756                     }
2757                 } else {
2758                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2759                 }
2760             }
2761 
2762             // Bind the widgets, one at a time
2763             N = appWidgets.size();
2764             for (int i = 0; i &lt; N; i++) {
2765                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2766                 final Runnable r = new Runnable() {
2767                     public void run() {
2768                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2769                         if (callbacks != null) {
2770                             callbacks.bindAppWidget(widget);
2771                         }
2772                     }
2773                 };
2774                 if (postOnMainThread) {
2775                     deferredBindRunnables.add(r);
2776                 } else {
2777                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2778                 }
2779             }
2780         }
2781 
2782         /**
2783          * Binds all loaded data to actual views on the main thread.
2784          */
2785         private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2786             final long t = SystemClock.uptimeMillis();
2787             Runnable r;
2788 
2789             // Don&#x27;t use these two variables in any of the callback runnables.
2790             // Otherwise we hold a reference to them.
2791             final Callbacks oldCallbacks = mCallbacks.get();
2792             if (oldCallbacks == null) {
2793                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2794                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2795                 return;
2796             }
2797 
2798             // Save a copy of all the bg-thread collections
2799             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2800             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2801                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2802             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2803             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2804             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2805             synchronized (sBgLock) {
2806                 workspaceItems.addAll(sBgWorkspaceItems);
2807                 appWidgets.addAll(sBgAppWidgets);
2808                 folders.putAll(sBgFolders);
2809                 itemsIdMap.putAll(sBgItemsIdMap);
2810                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2811             }
2812 
2813             final boolean isLoadingSynchronously =
2814                     synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2815             int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2816                 oldCallbacks.getCurrentWorkspaceScreen();
2817             if (currScreen &gt;= orderedScreenIds.size()) {
2818                 // There may be no workspace screens (just hotseat items and an empty page).
2819                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2820             }
2821             final int currentScreen = currScreen;
2822             final long currentScreenId = currentScreen &lt; 0
2823                     ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2824 
2825             // Load all the items that are on the current page first (and in the process, unbind
2826             // all the existing workspace items before we call startBinding() below.
2827             unbindWorkspaceItemsOnMainThread();
2828 
2829             // Separate the items that are on the current screen, and all the other remaining items
2830             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2831             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2832             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2833                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2834             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2835                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2836             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2837             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2838 
2839             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2840                     otherWorkspaceItems);
2841             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2842                     otherAppWidgets);
2843             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2844                     otherFolders);
2845             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2846             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2847 
2848             // Tell the workspace that we&#x27;re about to start binding items
2849             r = new Runnable() {
2850                 public void run() {
2851                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2852                     if (callbacks != null) {
2853                         callbacks.startBinding();
2854                     }
2855                 }
2856             };
2857             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2858 
2859             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2860 
2861             // Load items on the current page
2862             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2863                     currentFolders, null);
2864             if (isLoadingSynchronously) {
2865                 r = new Runnable() {
2866                     public void run() {
2867                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2868                         if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2869                             callbacks.onPageBoundSynchronously(currentScreen);
2870                         }
2871                     }
2872                 };
2873                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2874             }
2875 
2876             // Load all the remaining pages (if we are loading synchronously, we want to defer this
2877             // work until after the first render)
2878             synchronized (mDeferredBindRunnables) {
2879                 mDeferredBindRunnables.clear();
2880             }
2881             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2882                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
2883 
2884             // Tell the workspace that we&#x27;re done binding items
2885             r = new Runnable() {
2886                 public void run() {
2887                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2888                     if (callbacks != null) {
2889                         callbacks.finishBindingItems(isUpgradePath);
2890                     }
2891 
2892                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2893                     if (DEBUG_LOADERS) {
2894                         Log.d(TAG, &quot;bound workspace in &quot;
2895                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2896                     }
2897 
2898                     mIsLoadingAndBindingWorkspace = false;
2899                 }
2900             };
2901             if (isLoadingSynchronously) {
2902                 synchronized (mDeferredBindRunnables) {
2903                     mDeferredBindRunnables.add(r);
2904                 }
2905             } else {
2906                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2907             }
2908         }
2909 
2910         private void loadAndBindAllApps() {
2911             if (DEBUG_LOADERS) {
2912                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2913             }
2914             if (!mAllAppsLoaded) {
2915                 loadAllApps();
2916                 synchronized (LoaderTask.this) {
2917                     if (mStopped) {
2918                         return;
2919                     }
2920                     mAllAppsLoaded = true;
2921                 }
2922             } else {
2923                 onlyBindAllApps();
2924             }
2925         }
2926 
2927         private void onlyBindAllApps() {
2928             final Callbacks oldCallbacks = mCallbacks.get();
2929             if (oldCallbacks == null) {
2930                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2931                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2932                 return;
2933             }
2934 
2935             // shallow copy
2936             @SuppressWarnings(&quot;unchecked&quot;)
2937             final ArrayList&lt;AppInfo&gt; list
2938                     = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2939             Runnable r = new Runnable() {
2940                 public void run() {
2941                     final long t = SystemClock.uptimeMillis();
2942                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2943                     if (callbacks != null) {
2944                         callbacks.bindAllApplications(list);
2945                     }
2946                     if (DEBUG_LOADERS) {
2947                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2948                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2949                     }
2950                 }
2951             };
2952             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2953             if (isRunningOnMainThread) {
2954                 r.run();
2955             } else {
2956                 mHandler.post(r);
2957             }
2958         }
2959 
2960         private void loadAllApps() {
2961             final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2962 
2963             final Callbacks oldCallbacks = mCallbacks.get();
2964             if (oldCallbacks == null) {
2965                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2966                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2967                 return;
2968             }
2969 
2970             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2971             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2972 
2973             final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
2974 
2975             // Clear the list of apps
2976             mBgAllAppsList.clear();
2977             for (UserHandleCompat user : profiles) {
2978                 // Query for the set of apps
2979                 final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2980                 List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);
2981                 if (DEBUG_LOADERS) {
2982                     Log.d(TAG, &quot;getActivityList took &quot;
2983                             + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);
2984                     Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);
2985                 }
2986                 // Fail if we don&#x27;t have any apps
2987                 if (apps == null || apps.isEmpty()) {
2988                     return;
2989                 }
2990                 // Sort the applications by name
2991                 final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2992                 Collections.sort(apps,
2993                         new LauncherModel.ShortcutNameComparator(mLabelCache));
2994                 if (DEBUG_LOADERS) {
2995                     Log.d(TAG, &quot;sort took &quot;
2996                             + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2997                 }
2998 
2999                 // Create the ApplicationInfos
3000                 for (int i = 0; i &lt; apps.size(); i++) {
3001                     LauncherActivityInfoCompat app = apps.get(i);
3002                     // This builds the icon bitmaps.
3003                     mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));
3004                 }
3005             }
3006             // Huh? Shouldn&#x27;t this be inside the Runnable below?
3007             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
3008             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
3009 
3010             // Post callback on main thread
3011             mHandler.post(new Runnable() {
3012                 public void run() {
3013                     final long bindTime = SystemClock.uptimeMillis();
3014                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3015                     if (callbacks != null) {
3016                         callbacks.bindAllApplications(added);
3017                         if (DEBUG_LOADERS) {
3018                             Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
3019                                 + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
3020                         }
3021                     } else {
3022                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
3023                     }
3024                 }
3025             });
3026 
3027             if (DEBUG_LOADERS) {
3028                 Log.d(TAG, &quot;Icons processed in &quot;
3029                         + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
3030             }
3031         }
3032 
3033         public void dumpState() {
3034             synchronized (sBgLock) {
3035                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
3036                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
3037                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
3038                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
3039                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
3040             }
3041         }
3042     }
3043 
3044     void enqueuePackageUpdated(PackageUpdatedTask task) {
3045         sWorker.post(task);
3046     }
3047 
3048     private class AppsAvailabilityCheck extends BroadcastReceiver {
3049 
3050         @Override
3051         public void onReceive(Context context, Intent intent) {
3052             synchronized (sBgLock) {
3053                 final LauncherAppsCompat launcherApps = LauncherAppsCompat
3054                         .getInstance(mApp.getContext());
3055                 ArrayList&lt;String&gt; packagesRemoved;
3056                 for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
3057                     UserHandleCompat user = entry.getKey();
3058                     packagesRemoved = new ArrayList&lt;String&gt;();
3059                     for (String pkg : entry.getValue()) {
3060                         if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
3061                             Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
3062                             packagesRemoved.add(pkg);
3063                         }
3064                     }
3065                     if (!packagesRemoved.isEmpty()) {
3066                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,
3067                                 packagesRemoved.toArray(new String[packagesRemoved.size()]), user));
3068                     }
3069                 }
3070                 sPendingPackages.clear();
3071             }
3072         }
3073     }
3074 
3075     /**
3076      * Workaround to re-check unrestored items, in-case they were installed but the Package-ADD
3077      * runnable was missed by the launcher.
3078      */
3079     public void recheckRestoredItems(final Context context) {
3080         Runnable r = new Runnable() {
3081 
3082             @Override
3083             public void run() {
3084                 LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3085                 HashSet&lt;String&gt; installedPackages = new HashSet&lt;String&gt;();
3086                 UserHandleCompat user = UserHandleCompat.myUserHandle();
3087                 synchronized(sBgLock) {
3088                     for (ItemInfo info : sBgItemsIdMap.values()) {
3089                         if (info instanceof ShortcutInfo) {
3090                             ShortcutInfo si = (ShortcutInfo) info;
3091                             if (si.isPromise() &amp;&amp; si.getTargetComponent() != null
3092                                     &amp;&amp; launcherApps.isPackageEnabledForProfile(
3093                                             si.getTargetComponent().getPackageName(), user)) {
3094                                 installedPackages.add(si.getTargetComponent().getPackageName());
3095                             }
3096                         } else if (info instanceof LauncherAppWidgetInfo) {
3097                             LauncherAppWidgetInfo widget = (LauncherAppWidgetInfo) info;
3098                             if (widget.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)
3099                                     &amp;&amp; launcherApps.isPackageEnabledForProfile(
3100                                             widget.providerName.getPackageName(), user)) {
3101                                 installedPackages.add(widget.providerName.getPackageName());
3102                             }
3103                         }
3104                     }
3105                 }
3106 
3107                 if (!installedPackages.isEmpty()) {
3108                     final ArrayList&lt;AppInfo&gt; restoredApps = new ArrayList&lt;AppInfo&gt;();
3109                     for (String pkg : installedPackages) {
3110                         for (LauncherActivityInfoCompat info : launcherApps.getActivityList(pkg, user)) {
3111                             restoredApps.add(new AppInfo(context, info, user, mIconCache, null));
3112                         }
3113                     }
3114 
3115                     final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
3116                     if (!restoredApps.isEmpty()) {
3117                         mHandler.post(new Runnable() {
3118                             public void run() {
3119                                 Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3120                                 if (callbacks == cb &amp;&amp; cb != null) {
3121                                     callbacks.bindAppsRestored(restoredApps);
3122                                 }
3123                             }
3124                         });
3125                     }
3126 
3127                 }
3128             }
3129         };
3130         sWorker.post(r);
3131     }
3132 
3133     private class PackageUpdatedTask implements Runnable {
3134         int mOp;
3135         String[] mPackages;
3136         UserHandleCompat mUser;
3137 
3138         public static final int OP_NONE = 0;
3139         public static final int OP_ADD = 1;
3140         public static final int OP_UPDATE = 2;
3141         public static final int OP_REMOVE = 3; // uninstlled
3142         public static final int OP_UNAVAILABLE = 4; // external media unmounted
3143 
3144 
3145         public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
3146             mOp = op;
3147             mPackages = packages;
3148             mUser = user;
3149         }
3150 
3151         public void run() {
3152             final Context context = mApp.getContext();
3153 
3154             final String[] packages = mPackages;
3155             final int N = packages.length;
3156             switch (mOp) {
3157                 case OP_ADD:
3158                     for (int i=0; i&lt;N; i++) {
3159                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
3160 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3161                         mIconCache.remove(packages[i], mUser);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3162                         mBgAllAppsList.addPackage(context, packages[i], mUser);</span>
3163 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3164                 Log.d(TAG, &quot;Icons processed in &quot;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3165                         + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3166             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3167         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3168 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3169         public void dumpState() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3170             synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3171                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3172                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3173                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3174                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3175                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3176             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3177         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3178     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3179 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3180     void enqueuePackageUpdated(PackageUpdatedTask task) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3181         sWorker.post(task);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3182     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3183 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3184     private class PackageUpdatedTask implements Runnable {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3185         int mOp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3186         String[] mPackages;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3187 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3188         public static final int OP_NONE = 0;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3189         public static final int OP_ADD = 1;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3190         public static final int OP_UPDATE = 2;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3191         public static final int OP_REMOVE = 3; // uninstlled</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3192         public static final int OP_UNAVAILABLE = 4; // external media unmounted</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3193 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3194 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3195         public PackageUpdatedTask(int op, String[] packages) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3196             mOp = op;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3197             mPackages = packages;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3198         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3199 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3200         public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3201             final Context context = mApp.getContext();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3202 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3203             final String[] packages = mPackages;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3204             final int N = packages.length;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3205             switch (mOp) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3206                 case OP_ADD:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3207                     for (int i=0; i&lt;N; i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3208                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3209                         mIconCache.remove(packages[i]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3210                         mBgAllAppsList.addPackage(context, packages[i]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3211                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3212                     break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3213                 case OP_UPDATE:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3214                     for (int i=0; i&lt;N; i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3215                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3216                         mBgAllAppsList.updatePackage(context, packages[i]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3217                         WidgetPreviewLoader.removePackageFromDb(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3218                                 mApp.getWidgetPreviewCacheDb(), packages[i]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3219                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3220                     break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3221                 case OP_REMOVE:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3222                 case OP_UNAVAILABLE:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3223                     for (int i=0; i&lt;N; i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3224                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3225                         mBgAllAppsList.removePackage(packages[i]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3226                         WidgetPreviewLoader.removePackageFromDb(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3227                                 mApp.getWidgetPreviewCacheDb(), packages[i]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3228                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3229                     break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3230             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3231 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3232             ArrayList&lt;AppInfo&gt; added = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3233             ArrayList&lt;AppInfo&gt; modified = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3234             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3235 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3236             if (mBgAllAppsList.added.size() &gt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3237                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3238                 mBgAllAppsList.added.clear();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3239             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3240             if (mBgAllAppsList.modified.size() &gt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3241                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3242                 mBgAllAppsList.modified.clear();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3243             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3244             if (mBgAllAppsList.removed.size() &gt; 0) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3245                 removedApps.addAll(mBgAllAppsList.removed);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3246                 mBgAllAppsList.removed.clear();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3247             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3248 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3249             final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3250             if (callbacks == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3251                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3252                 return;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3253             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3254 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3255             if (added != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3256                 // Ensure that we add all the workspace applications to the db</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3257                 Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3258                 if (!LauncherAppState.isDisableAllApps()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3259                     addAndBindAddedApps(context, new ArrayList&lt;ItemInfo&gt;(), cb, added);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3260                 } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3261                     final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3262                     addAndBindAddedApps(context, addedInfos, cb, added);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3263                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3264             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3265             if (modified != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3266                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3267 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3268                 // Update the launcher db to reflect the changes</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3269                 for (AppInfo a : modifiedFinal) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3270                     ArrayList&lt;ItemInfo&gt; infos =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3271                             getItemInfoForComponentName(a.componentName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3272                     for (ItemInfo i : infos) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3273                         if (isShortcutInfoUpdateable(i)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3274                             ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3275                             info.title = a.title.toString();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3276                             updateItemInDatabase(context, info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3277                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3278                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3279                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3280 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3281                 mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3282                     public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3283                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3284                         if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3285                             callbacks.bindAppsUpdated(modifiedFinal);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3286                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3287                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3288                 });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3289             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3290 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3291             final ArrayList&lt;String&gt; removedPackageNames =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3292                     new ArrayList&lt;String&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3293             if (mOp == OP_REMOVE) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3294                 // Mark all packages in the broadcast to be removed</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3295                 removedPackageNames.addAll(Arrays.asList(packages));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3296             } else if (mOp == OP_UPDATE) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3297                 // Mark disabled packages in the broadcast to be removed</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3298                 final PackageManager pm = context.getPackageManager();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3299                 for (int i=0; i&lt;N; i++) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3300                     if (isPackageDisabled(pm, packages[i])) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3301                         removedPackageNames.add(packages[i]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3302                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3303                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3304             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3305             // Remove all the components associated with this package</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3306             for (String pn : removedPackageNames) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3307                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForPackageName(pn);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3308                 for (ItemInfo i : infos) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3309                     deleteItemFromDatabase(context, i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3310                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3311             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3312             // Remove all the specific components</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3313             for (AppInfo a : removedApps) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3314                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3315                 for (ItemInfo i : infos) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3316                     deleteItemFromDatabase(context, i);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3317                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3318             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3319             if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3320                 // Remove any queued items from the install queue</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3321                 String spKey = LauncherAppState.getSharedPreferencesKey();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3322                 SharedPreferences sp =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3323                         context.getSharedPreferences(spKey, Context.MODE_PRIVATE);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3324                 InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3325                 // Call the components-removed callback</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3326                 mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3327                     public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3328                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3329                         if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3330                             callbacks.bindComponentsRemoved(removedPackageNames, removedApps);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3331                         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3332                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3333                 });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3334             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3335 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3336             final ArrayList&lt;Object&gt; widgetsAndShortcuts =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3337                 getSortedWidgetsAndShortcuts(context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3338             mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3339                 @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3340                 public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3341                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3342                     if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3343                         callbacks.bindPackagesUpdated(widgetsAndShortcuts);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3344                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3345                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3346             });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3347 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3348             // Write all the logs to disk</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3349             mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3350                 public void run() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3351                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3352                     if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3353                         callbacks.dumpLogsToLocalData();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3354                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3355                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3356             });</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3357         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3358     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3359 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3360     // Returns a list of ResolveInfos/AppWindowInfos in sorted order</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3361     public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3362         PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3363         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3364         widgetsAndShortcuts.addAll(AppWidgetManager.getInstance(context).getInstalledProviders());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3365         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3366         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3367         Collections.sort(widgetsAndShortcuts,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3368             new LauncherModel.WidgetAndShortcutNameComparator(packageManager));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3369         return widgetsAndShortcuts;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3370     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3371 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3372     private static boolean isPackageDisabled(PackageManager pm, String packageName) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3373         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3374             PackageInfo pi = pm.getPackageInfo(packageName, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3375             return !pi.applicationInfo.enabled;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3376         } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3377             // Fall through</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3378         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3379         return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3380     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3381 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3382     public static boolean isValidPackageComponent(PackageManager pm, ComponentName cn) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3383         if (cn == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3384             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3385         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3386         if (isPackageDisabled(pm, cn.getPackageName())) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3387             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3388         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3389 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3390         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3391             // Check the activity</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3392             PackageInfo pi = pm.getPackageInfo(cn.getPackageName(), 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3393             return (pm.getActivityInfo(cn, 0) != null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3394         } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3395             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3396         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3397     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3398 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3399     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3400      * Make an ShortcutInfo object for a restored application or shortcut item that points</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3401      * to a package that is not yet installed on the system.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3402      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3403     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3404         final ShortcutInfo info = new ShortcutInfo();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3405         if (cursor != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3406             info.title =  cursor.getString(titleIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3407         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3408             info.title = &quot;&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3409         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3410         info.setIcon(mIconCache.getIcon(intent, info.title.toString()));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3411         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3412         return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3413     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3414 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3415     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3416      * Make an Intent object for a restored application or shortcut item that points</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3417      * to the market page for the item.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3418      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3419     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3420         ComponentName componentName = intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3421         Intent marketIntent = new Intent(Intent.ACTION_VIEW);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3422         Uri marketUri = new Uri.Builder()</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3423                 .scheme(&quot;market&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3424                 .authority(&quot;details&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3425                 .appendQueryParameter(&quot;id&quot;, componentName.getPackageName())</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3426                 .build();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3427         Log.d(TAG, &quot;manufactured intent uri: &quot; + marketUri.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3428         marketIntent.setData(marketUri);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3429         return marketIntent;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3430     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3431 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3432     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3433      * This is called from the code that adds shortcuts from the intent receiver.  This</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3434      * doesn&#x27;t have a Cursor, but</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3435      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3436     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3437         return getShortcutInfo(manager, intent, context, null, -1, -1, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3438     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3439 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3440     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3441      * Make an ShortcutInfo object for a shortcut that is an application.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3442      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3443      * If c is not null, then it will be used to fill in missing data like the title and icon.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3444      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3445     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3446             Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3447         ComponentName componentName = intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3448         final ShortcutInfo info = new ShortcutInfo();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3449         if (componentName != null &amp;&amp; !isValidPackageComponent(manager, componentName)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3450             Log.d(TAG, &quot;Invalid package found in getShortcutInfo: &quot; + componentName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3451             return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3452         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3453             try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3454                 PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3455                 info.initFlagsAndFirstInstallTime(pi);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3456             } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3457                 Log.d(TAG, &quot;getPackInfo failed for package &quot; +</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3458                         componentName.getPackageName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3459             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3460         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3461 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3462         // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3463         // then return null &amp; delete this.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3464 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3465         // the resource -- This may implicitly give us back the fallback icon,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3466         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3467         // to avoid saving lots of copies of that in the database, and most apps</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3468         // have icons anyway.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3469 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3470         // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3471         // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3472         // via resolveActivity().</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3473         Bitmap icon = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3474         ResolveInfo resolveInfo = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3475         ComponentName oldComponent = intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3476         Intent newIntent = new Intent(intent.getAction(), null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3477         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3478         newIntent.setPackage(oldComponent.getPackageName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3479         List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3480         for (ResolveInfo i : infos) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3481             ComponentName cn = new ComponentName(i.activityInfo.packageName,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3482                     i.activityInfo.name);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3483             if (cn.equals(oldComponent)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3484                 resolveInfo = i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3485             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3486         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3487         if (resolveInfo == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3488             resolveInfo = manager.resolveActivity(intent, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3489         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3490         if (resolveInfo != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3491             icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3492         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3493         // the db</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3494         if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3495             if (c != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3496                 icon = getIconFromCursor(c, iconIndex, context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3497             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3498         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3499         // the fallback icon</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3500         if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3501             icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3502             info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3503         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3504         info.setIcon(icon);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3505 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3506         // from the resource</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3507         if (resolveInfo != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3508             ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3509             if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3510                 info.title = labelCache.get(key);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3511             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3512                 info.title = resolveInfo.activityInfo.loadLabel(manager);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3513                 if (labelCache != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3514                     labelCache.put(key, info.title);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3515                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3516             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3517         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3518         // from the db</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3519         if (info.title == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3520             if (c != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3521                 info.title =  c.getString(titleIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3522             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3523         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3524         // fall back to the class name of the activity</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3525         if (info.title == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3526             info.title = componentName.getClassName();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3527         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3528         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3529         return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3530     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3531 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3532     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3533             ItemInfoFilter f) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3534         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3535         for (ItemInfo i : infos) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3536             if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3537                 ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3538                 ComponentName cn = info.intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3539                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3540                     filtered.add(info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3541                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3542             } else if (i instanceof FolderInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3543                 FolderInfo info = (FolderInfo) i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3544                 for (ShortcutInfo s : info.contents) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3545                     ComponentName cn = s.intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3546                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3547                         filtered.add(s);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3548                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3549                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3550             } else if (i instanceof LauncherAppWidgetInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3551                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3552                 ComponentName cn = info.providerName;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3553                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3554                     filtered.add(info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3555                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3556             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3557         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3558         return new ArrayList&lt;ItemInfo&gt;(filtered);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3559     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3560 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3561     private ArrayList&lt;ItemInfo&gt; getItemInfoForPackageName(final String pn) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3562         ItemInfoFilter filter  = new ItemInfoFilter() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3563             @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3564             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3565                 return cn.getPackageName().equals(pn);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3566             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3567         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3568         return filterItemInfos(sBgItemsIdMap.values(), filter);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3569     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3570 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3571     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3572         ItemInfoFilter filter  = new ItemInfoFilter() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3573             @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3574             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3575                 return cn.equals(cname);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3576             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3577         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3578         return filterItemInfos(sBgItemsIdMap.values(), filter);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3579     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3580 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3581     public static boolean isShortcutInfoUpdateable(ItemInfo i) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3582         if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3583             ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3584             // We need to check for ACTION_MAIN otherwise getComponent() might</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3585             // return null for some shortcuts (for instance, for shortcuts to</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3586             // web pages.)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3587             Intent intent = info.intent;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3588             ComponentName name = intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3589             if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3590                     Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3591                 return true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3592             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3593         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3594         return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3595     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3596 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3597     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3598      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3599      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3600     private ShortcutInfo getShortcutInfo(Cursor c, Context context,</span>
3601 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">3602                         mBgAllAppsList.addPackage(context, packages[i]);</span>
3603 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
3604                     }
3605                     break;
3606                 case OP_UPDATE:
3607                     for (int i=0; i&lt;N; i++) {
3608                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
3609                         mBgAllAppsList.updatePackage(context, packages[i], mUser);
3610                         WidgetPreviewLoader.removePackageFromDb(
3611                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
3612                     }
3613                     break;
3614                 case OP_REMOVE:
3615                 case OP_UNAVAILABLE:
3616                     for (int i=0; i&lt;N; i++) {
3617                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
3618                         mBgAllAppsList.removePackage(packages[i], mUser);
3619                         WidgetPreviewLoader.removePackageFromDb(
3620                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
3621                     }
3622                     break;
3623             }
3624 
3625             ArrayList&lt;AppInfo&gt; added = null;
3626             ArrayList&lt;AppInfo&gt; modified = null;
3627             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3628 
3629             if (mBgAllAppsList.added.size() &gt; 0) {
3630                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3631                 mBgAllAppsList.added.clear();
3632             }
3633             if (mBgAllAppsList.modified.size() &gt; 0) {
3634                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3635                 mBgAllAppsList.modified.clear();
3636             }
3637             if (mBgAllAppsList.removed.size() &gt; 0) {
3638                 removedApps.addAll(mBgAllAppsList.removed);
3639                 mBgAllAppsList.removed.clear();
3640             }
3641 
3642             final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
3643             if (callbacks == null) {
3644                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3645                 return;
3646             }
3647 
3648             if (added != null) {
3649                 // Ensure that we add all the workspace applications to the db
3650                 if (LauncherAppState.isDisableAllApps()) {
3651                     final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
3652                     addAndBindAddedWorkspaceApps(context, addedInfos);
3653                 } else {
3654                     addAppsToAllApps(context, added);
3655                 }
3656             }
3657 
3658             if (modified != null) {
3659                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3660 
3661                 // Update the launcher db to reflect the changes
3662                 for (AppInfo a : modifiedFinal) {
3663                     ArrayList&lt;ItemInfo&gt; infos =
3664                             getItemInfoForComponentName(a.componentName, mUser);
3665                     for (ItemInfo i : infos) {
3666                         if (isShortcutInfoUpdateable(i)) {
3667                             ShortcutInfo info = (ShortcutInfo) i;
3668                             info.title = a.title.toString();
3669                             info.contentDescription = a.contentDescription;
3670                             updateItemInDatabase(context, info);
3671                         }
3672                     }
3673                 }
3674 
3675                 mHandler.post(new Runnable() {
3676                     public void run() {
3677                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3678                         if (callbacks == cb &amp;&amp; cb != null) {
3679                             callbacks.bindAppsUpdated(modifiedFinal);
3680                         }
3681                     }
3682                 });
3683             }
3684 
3685             final ArrayList&lt;String&gt; removedPackageNames =
3686                     new ArrayList&lt;String&gt;();
3687             if (mOp == OP_REMOVE) {
3688                 // Mark all packages in the broadcast to be removed
3689                 removedPackageNames.addAll(Arrays.asList(packages));
3690             } else if (mOp == OP_UPDATE) {
3691                 // Mark disabled packages in the broadcast to be removed
3692                 final PackageManager pm = context.getPackageManager();
3693                 for (int i=0; i&lt;N; i++) {
3694                     if (isPackageDisabled(context, packages[i], mUser)) {
3695                         removedPackageNames.add(packages[i]);
3696                     }
3697                 }
3698             }
3699             // Remove all the components associated with this package
3700             for (String pn : removedPackageNames) {
3701                 deletePackageFromDatabase(context, pn, mUser);
3702             }
3703             // Remove all the specific components
3704             for (AppInfo a : removedApps) {
3705                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
3706                 deleteItemsFromDatabase(context, infos);
3707             }
3708             if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
3709                 // Remove any queued items from the install queue
3710                 String spKey = LauncherAppState.getSharedPreferencesKey();
3711                 SharedPreferences sp =
3712                         context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
3713                 InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
3714                 // Call the components-removed callback
3715                 mHandler.post(new Runnable() {
3716                     public void run() {
3717                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3718                         if (callbacks == cb &amp;&amp; cb != null) {
3719                             callbacks.bindComponentsRemoved(removedPackageNames, removedApps, mUser);
3720                         }
3721                     }
3722                 });
3723             }
3724 
3725             final ArrayList&lt;Object&gt; widgetsAndShortcuts =
3726                     getSortedWidgetsAndShortcuts(context);
3727             mHandler.post(new Runnable() {
3728                 @Override
3729                 public void run() {
3730                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3731                     if (callbacks == cb &amp;&amp; cb != null) {
3732                         callbacks.bindPackagesUpdated(widgetsAndShortcuts);
3733                     }
3734                 }
3735             });
3736 
3737             // Write all the logs to disk
3738             mHandler.post(new Runnable() {
3739                 public void run() {
3740                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3741                     if (callbacks == cb &amp;&amp; cb != null) {
3742                         callbacks.dumpLogsToLocalData();
3743                     }
3744                 }
3745             });
3746         }
3747     }
3748 
3749     // Returns a list of ResolveInfos/AppWindowInfos in sorted order
3750     public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
3751         PackageManager packageManager = context.getPackageManager();
3752         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
3753         widgetsAndShortcuts.addAll(AppWidgetManagerCompat.getInstance(context).getAllProviders());
3754 
3755         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3756         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
3757         Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));
3758         return widgetsAndShortcuts;
3759     }
3760 
3761     private static boolean isPackageDisabled(Context context, String packageName,
3762             UserHandleCompat user) {
3763         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3764         return !launcherApps.isPackageEnabledForProfile(packageName, user);
3765     }
3766 
3767     public static boolean isValidPackageActivity(Context context, ComponentName cn,
3768             UserHandleCompat user) {
3769         if (cn == null) {
3770             return false;
3771         }
3772         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3773         if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
3774             return false;
3775         }
3776         return launcherApps.isActivityEnabledForProfile(cn, user);
3777     }
3778 
3779     public static boolean isValidPackage(Context context, String packageName,
3780             UserHandleCompat user) {
3781         if (packageName == null) {
3782             return false;
3783         }
3784         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3785         return launcherApps.isPackageEnabledForProfile(packageName, user);
3786     }
3787 
3788     /**
3789      * Make an ShortcutInfo object for a restored application or shortcut item that points
3790      * to a package that is not yet installed on the system.
3791      */
3792     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent,
3793             int promiseType) {
3794         final ShortcutInfo info = new ShortcutInfo();
3795 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3796         info.user = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3797         mIconCache.getTitleAndIcon(info, intent, info.user, true);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3798 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3799         if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3800             String title = (cursor != null) ? cursor.getString(titleIndex) : null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3801             if (!TextUtils.isEmpty(title)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3802                 info.title = title;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3803             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3804             info.status = ShortcutInfo.FLAG_RESTORED_ICON;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3805         } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3806             if (TextUtils.isEmpty(info.title)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3807                 info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3808             }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">3809             info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;</span>
3810 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3811 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3812     // Returns a list of ResolveInfos/AppWindowInfos in sorted order</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3813     public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3814         PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3815         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3816         widgetsAndShortcuts.addAll(AppWidgetManager.getInstance(context).getInstalledProviders());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3817         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3818         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3819         Collections.sort(widgetsAndShortcuts,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3820             new LauncherModel.WidgetAndShortcutNameComparator(packageManager));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3821         return widgetsAndShortcuts;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3822     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3823 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3824     private static boolean isPackageDisabled(PackageManager pm, String packageName) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3825         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3826             PackageInfo pi = pm.getPackageInfo(packageName, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3827             return !pi.applicationInfo.enabled;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3828         } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3829             // Fall through</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3830         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3831         return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3832     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3833 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3834     public static boolean isValidPackageComponent(PackageManager pm, ComponentName cn) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3835         if (cn == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3836             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3837         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3838         if (isPackageDisabled(pm, cn.getPackageName())) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3839             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3840         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3841 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3842         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3843             // Check the activity</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3844             PackageInfo pi = pm.getPackageInfo(cn.getPackageName(), 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3845             return (pm.getActivityInfo(cn, 0) != null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3846         } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3847             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3848         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3849     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3850 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3851     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3852      * Make an ShortcutInfo object for a restored application or shortcut item that points</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3853      * to a package that is not yet installed on the system.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3854      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3855     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3856         final ShortcutInfo info = new ShortcutInfo();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3857         if (cursor != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3858             info.title =  cursor.getString(titleIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3859         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3860             info.title = &quot;&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3861         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3862         info.setIcon(mIconCache.getIcon(intent, info.title.toString()));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3863         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3864         return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3865     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3866 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3867     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3868      * Make an Intent object for a restored application or shortcut item that points</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3869      * to the market page for the item.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3870      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3871     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3872         ComponentName componentName = intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3873         Intent marketIntent = new Intent(Intent.ACTION_VIEW);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3874         Uri marketUri = new Uri.Builder()</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3875                 .scheme(&quot;market&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3876                 .authority(&quot;details&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3877                 .appendQueryParameter(&quot;id&quot;, componentName.getPackageName())</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3878                 .build();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3879         Log.d(TAG, &quot;manufactured intent uri: &quot; + marketUri.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3880         marketIntent.setData(marketUri);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3881         return marketIntent;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3882     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3883 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3884     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3885      * This is called from the code that adds shortcuts from the intent receiver.  This</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3886      * doesn&#x27;t have a Cursor, but</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3887      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3888     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3889         return getShortcutInfo(manager, intent, context, null, -1, -1, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3890     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3891 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3892     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3893      * Make an ShortcutInfo object for a shortcut that is an application.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3894      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3895      * If c is not null, then it will be used to fill in missing data like the title and icon.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3896      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3897     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3898             Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3899         ComponentName componentName = intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3900         final ShortcutInfo info = new ShortcutInfo();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3901         if (componentName != null &amp;&amp; !isValidPackageComponent(manager, componentName)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3902             Log.d(TAG, &quot;Invalid package found in getShortcutInfo: &quot; + componentName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3903             return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3904         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3905             try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3906                 PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3907                 info.initFlagsAndFirstInstallTime(pi);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3908             } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3909                 Log.d(TAG, &quot;getPackInfo failed for package &quot; +</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3910                         componentName.getPackageName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3911             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3912         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3913 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3914         // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3915         // then return null &amp; delete this.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3916 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3917         // the resource -- This may implicitly give us back the fallback icon,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3918         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3919         // to avoid saving lots of copies of that in the database, and most apps</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3920         // have icons anyway.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3921 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3922         // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3923         // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3924         // via resolveActivity().</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3925         Bitmap icon = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3926         ResolveInfo resolveInfo = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3927         ComponentName oldComponent = intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3928         Intent newIntent = new Intent(intent.getAction(), null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3929         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3930         newIntent.setPackage(oldComponent.getPackageName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3931         List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3932         for (ResolveInfo i : infos) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3933             ComponentName cn = new ComponentName(i.activityInfo.packageName,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3934                     i.activityInfo.name);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3935             if (cn.equals(oldComponent)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3936                 resolveInfo = i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3937             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3938         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3939         if (resolveInfo == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3940             resolveInfo = manager.resolveActivity(intent, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3941         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3942         if (resolveInfo != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3943             icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3944         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3945         // the db</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3946         if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3947             if (c != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3948                 icon = getIconFromCursor(c, iconIndex, context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3949             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3950         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3951         // the fallback icon</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3952         if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3953             icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3954             info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3955         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3956         info.setIcon(icon);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3957 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3958         // from the resource</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3959         if (resolveInfo != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3960             ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3961             if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3962                 info.title = labelCache.get(key);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3963             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3964                 info.title = resolveInfo.activityInfo.loadLabel(manager);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3965                 if (labelCache != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3966                     labelCache.put(key, info.title);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3967                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3968             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3969         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3970         // from the db</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3971         if (info.title == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3972             if (c != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3973                 info.title =  c.getString(titleIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3974             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3975         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3976         // fall back to the class name of the activity</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3977         if (info.title == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3978             info.title = componentName.getClassName();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3979         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3980         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3981         return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3982     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3983 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3984     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3985             ItemInfoFilter f) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3986         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3987         for (ItemInfo i : infos) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3988             if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3989                 ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3990                 ComponentName cn = info.intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3991                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3992                     filtered.add(info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3993                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3994             } else if (i instanceof FolderInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3995                 FolderInfo info = (FolderInfo) i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3996                 for (ShortcutInfo s : info.contents) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3997                     ComponentName cn = s.intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3998                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">3999                         filtered.add(s);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4000                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4001                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4002             } else if (i instanceof LauncherAppWidgetInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4003                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4004                 ComponentName cn = info.providerName;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4005                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4006                     filtered.add(info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4007                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4008             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4009         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4010         return new ArrayList&lt;ItemInfo&gt;(filtered);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4011     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4012 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4013     private ArrayList&lt;ItemInfo&gt; getItemInfoForPackageName(final String pn) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4014         ItemInfoFilter filter  = new ItemInfoFilter() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4015             @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4016             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4017                 return cn.getPackageName().equals(pn);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4018             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4019         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4020         return filterItemInfos(sBgItemsIdMap.values(), filter);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4021     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4022 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4023     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4024         ItemInfoFilter filter  = new ItemInfoFilter() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4025             @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4026             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4027                 return cn.equals(cname);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4028             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4029         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4030         return filterItemInfos(sBgItemsIdMap.values(), filter);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4031     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4032 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4033     public static boolean isShortcutInfoUpdateable(ItemInfo i) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4034         if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4035             ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4036             // We need to check for ACTION_MAIN otherwise getComponent() might</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4037             // return null for some shortcuts (for instance, for shortcuts to</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4038             // web pages.)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4039             Intent intent = info.intent;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4040             ComponentName name = intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4041             if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4042                     Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4043                 return true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4044             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4045         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4046         return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4047     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4048 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4049     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4050      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4051      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4052     private ShortcutInfo getShortcutInfo(Cursor c, Context context,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4053             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4054             int titleIndex) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4055 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4056         Bitmap icon = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4057         final ShortcutInfo info = new ShortcutInfo();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4058         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4059 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4060         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4061 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4062         info.title = c.getString(titleIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4063 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4064         int iconType = c.getInt(iconTypeIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4065         switch (iconType) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4066         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4067             String packageName = c.getString(iconPackageIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4068             String resourceName = c.getString(iconResourceIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4069             PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4070             info.customIcon = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4071             // the resource</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4072             try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4073                 Resources resources = packageManager.getResourcesForApplication(packageName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4074                 if (resources != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4075                     final int id = resources.getIdentifier(resourceName, null, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4076                     icon = Utilities.createIconBitmap(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4077                             mIconCache.getFullResIcon(resources, id), context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4078                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4079             } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4080                 // drop this.  we have other places to look for icons</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4081             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4082             // the db</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4083             if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4084                 icon = getIconFromCursor(c, iconIndex, context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4085             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4086             // the fallback icon</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4087             if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4088                 icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4089                 info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4090             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4091             break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4092         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4093             icon = getIconFromCursor(c, iconIndex, context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4094             if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4095                 icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4096                 info.customIcon = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4097                 info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4098             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4099                 info.customIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4100             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4101             break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4102         default:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4103             icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4104             info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4105             info.customIcon = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4106             break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4107         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4108         info.setIcon(icon);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4109         return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4110     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4111 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4112     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4113         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4114         final boolean debug = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4115         if (debug) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4116             Log.d(TAG, &quot;getIconFromCursor app=&quot;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4117                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4118         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4119         byte[] data = c.getBlob(iconIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4120         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4121             return Utilities.createIconBitmap(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4122                     BitmapFactory.decodeByteArray(data, 0, data.length), context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4123         } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4124             return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4125         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4126     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4127 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4128     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4129             int cellX, int cellY, boolean notify) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4130         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4131         if (info == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4132             return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4133         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4134         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4135 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4136         return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4137     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4138 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4139     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4140      * Attempts to find an AppWidgetProviderInfo that matches the given component.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4141      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4142     AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4143             ComponentName component) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4144         List&lt;AppWidgetProviderInfo&gt; widgets =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4145             AppWidgetManager.getInstance(context).getInstalledProviders();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4146         for (AppWidgetProviderInfo info : widgets) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4147             if (info.provider.equals(component)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4148                 return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4149             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4150         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4151         return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4152     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4153 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4154     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4155      * Returns a list of all the widgets that can handle configuration with a particular mimeType.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4156      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4157     List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4158         final PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4159         final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4160             new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4161 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4162         final Intent supportsIntent =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4163             new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4164         supportsIntent.setType(mimeType);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4165 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4166         // Create a set of widget configuration components that we can test against</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4167         final List&lt;AppWidgetProviderInfo&gt; widgets =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4168             AppWidgetManager.getInstance(context).getInstalledProviders();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4169         final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4170             new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4171         for (AppWidgetProviderInfo info : widgets) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4172             configurationComponentToWidget.put(info.configure, info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4173         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4174 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4175         // Run through each of the intents that can handle this type of clip data, and cross</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4176         // reference them with the components that are actual configuration components</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4177         final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4178                 PackageManager.MATCH_DEFAULT_ONLY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4179         for (ResolveInfo info : activities) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4180             final ActivityInfo activityInfo = info.activityInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4181             final ComponentName infoComponent = new ComponentName(activityInfo.packageName,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4182                     activityInfo.name);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4183             if (configurationComponentToWidget.containsKey(infoComponent)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4184                 supportedConfigurationActivities.add(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4185                         new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4186                                 configurationComponentToWidget.get(infoComponent)));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4187             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4188         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4189         return supportedConfigurationActivities;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4190     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4191 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4192     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4193         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4194         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4195         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4196 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4197         if (intent == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4198             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4199             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4200             return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4201         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4202 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4203         Bitmap icon = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4204         boolean customIcon = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4205         ShortcutIconResource iconResource = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4206 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4207         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4208             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4209             customIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4210         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4211             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4212             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4213                 try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4214                     iconResource = (ShortcutIconResource) extra;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4215                     final PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4216                     Resources resources = packageManager.getResourcesForApplication(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4217                             iconResource.packageName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4218                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4219                     icon = Utilities.createIconBitmap(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4220                             mIconCache.getFullResIcon(resources, id), context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4221                 } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4222                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4223                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4224             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4225         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4226 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4227         final ShortcutInfo info = new ShortcutInfo();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4228 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4229         if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4230             if (fallbackIcon != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4231                 icon = fallbackIcon;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4232             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4233                 icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4234                 info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4235             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4236         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4237         info.setIcon(icon);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4238 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4239         info.title = name;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4240         info.intent = intent;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4241         info.customIcon = customIcon;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4242         info.iconResource = iconResource;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4243 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4244         return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4245     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4246 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4247     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4248             int iconIndex) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4249         // If apps can&#x27;t be on SD, don&#x27;t even bother.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4250         if (!mAppsCanBeOnRemoveableStorage) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4251             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4252         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4253         // If this icon doesn&#x27;t have a custom icon, check to see</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4254         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4255         // we&#x27;re going to show, store what we are going to show back</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4256         // into the DB.  We do this so when we&#x27;re loading, if the</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4257         // package manager can&#x27;t find an icon (for example because</span>
4258 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">4259         info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">4260         info.setIcon(getFallbackIcon());</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">4261         if (cursor != null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">4262             info.title =  cursor.getString(titleIndex);</span>
4263 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
4264         } else {
4265             throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
4266         }
4267 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4268 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4269         info.contentDescription = mUserManager.getBadgedLabelForUser(</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">4270                 info.title.toString(), info.user);</span>
4271 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4272         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4273         Collections.sort(widgetsAndShortcuts,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4274             new LauncherModel.WidgetAndShortcutNameComparator(packageManager));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4275         return widgetsAndShortcuts;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4276     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4277 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4278     private static boolean isPackageDisabled(PackageManager pm, String packageName) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4279         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4280             PackageInfo pi = pm.getPackageInfo(packageName, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4281             return !pi.applicationInfo.enabled;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4282         } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4283             // Fall through</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4284         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4285         return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4286     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4287 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4288     public static boolean isValidPackageComponent(PackageManager pm, ComponentName cn) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4289         if (cn == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4290             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4291         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4292         if (isPackageDisabled(pm, cn.getPackageName())) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4293             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4294         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4295 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4296         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4297             // Check the activity</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4298             PackageInfo pi = pm.getPackageInfo(cn.getPackageName(), 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4299             return (pm.getActivityInfo(cn, 0) != null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4300         } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4301             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4302         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4303     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4304 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4305     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4306      * Make an ShortcutInfo object for a restored application or shortcut item that points</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4307      * to a package that is not yet installed on the system.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4308      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4309     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4310         final ShortcutInfo info = new ShortcutInfo();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4311         if (cursor != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4312             info.title =  cursor.getString(titleIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4313         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4314             info.title = &quot;&quot;;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4315         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4316         info.setIcon(mIconCache.getIcon(intent, info.title.toString()));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4317         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4318         return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4319     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4320 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4321     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4322      * Make an Intent object for a restored application or shortcut item that points</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4323      * to the market page for the item.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4324      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4325     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4326         ComponentName componentName = intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4327         Intent marketIntent = new Intent(Intent.ACTION_VIEW);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4328         Uri marketUri = new Uri.Builder()</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4329                 .scheme(&quot;market&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4330                 .authority(&quot;details&quot;)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4331                 .appendQueryParameter(&quot;id&quot;, componentName.getPackageName())</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4332                 .build();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4333         Log.d(TAG, &quot;manufactured intent uri: &quot; + marketUri.toString());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4334         marketIntent.setData(marketUri);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4335         return marketIntent;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4336     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4337 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4338     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4339      * This is called from the code that adds shortcuts from the intent receiver.  This</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4340      * doesn&#x27;t have a Cursor, but</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4341      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4342     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4343         return getShortcutInfo(manager, intent, context, null, -1, -1, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4344     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4345 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4346     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4347      * Make an ShortcutInfo object for a shortcut that is an application.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4348      *</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4349      * If c is not null, then it will be used to fill in missing data like the title and icon.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4350      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4351     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4352             Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4353         ComponentName componentName = intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4354         final ShortcutInfo info = new ShortcutInfo();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4355         if (componentName != null &amp;&amp; !isValidPackageComponent(manager, componentName)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4356             Log.d(TAG, &quot;Invalid package found in getShortcutInfo: &quot; + componentName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4357             return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4358         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4359             try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4360                 PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4361                 info.initFlagsAndFirstInstallTime(pi);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4362             } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4363                 Log.d(TAG, &quot;getPackInfo failed for package &quot; +</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4364                         componentName.getPackageName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4365             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4366         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4367 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4368         // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4369         // then return null &amp; delete this.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4370 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4371         // the resource -- This may implicitly give us back the fallback icon,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4372         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4373         // to avoid saving lots of copies of that in the database, and most apps</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4374         // have icons anyway.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4375 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4376         // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4377         // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4378         // via resolveActivity().</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4379         Bitmap icon = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4380         ResolveInfo resolveInfo = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4381         ComponentName oldComponent = intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4382         Intent newIntent = new Intent(intent.getAction(), null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4383         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4384         newIntent.setPackage(oldComponent.getPackageName());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4385         List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4386         for (ResolveInfo i : infos) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4387             ComponentName cn = new ComponentName(i.activityInfo.packageName,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4388                     i.activityInfo.name);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4389             if (cn.equals(oldComponent)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4390                 resolveInfo = i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4391             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4392         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4393         if (resolveInfo == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4394             resolveInfo = manager.resolveActivity(intent, 0);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4395         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4396         if (resolveInfo != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4397             icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4398         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4399         // the db</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4400         if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4401             if (c != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4402                 icon = getIconFromCursor(c, iconIndex, context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4403             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4404         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4405         // the fallback icon</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4406         if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4407             icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4408             info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4409         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4410         info.setIcon(icon);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4411 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4412         // from the resource</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4413         if (resolveInfo != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4414             ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4415             if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4416                 info.title = labelCache.get(key);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4417             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4418                 info.title = resolveInfo.activityInfo.loadLabel(manager);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4419                 if (labelCache != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4420                     labelCache.put(key, info.title);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4421                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4422             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4423         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4424         // from the db</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4425         if (info.title == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4426             if (c != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4427                 info.title =  c.getString(titleIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4428             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4429         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4430         // fall back to the class name of the activity</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4431         if (info.title == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4432             info.title = componentName.getClassName();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4433         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4434         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4435         return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4436     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4437 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4438     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4439             ItemInfoFilter f) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4440         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4441         for (ItemInfo i : infos) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4442             if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4443                 ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4444                 ComponentName cn = info.intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4445                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4446                     filtered.add(info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4447                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4448             } else if (i instanceof FolderInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4449                 FolderInfo info = (FolderInfo) i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4450                 for (ShortcutInfo s : info.contents) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4451                     ComponentName cn = s.intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4452                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4453                         filtered.add(s);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4454                     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4455                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4456             } else if (i instanceof LauncherAppWidgetInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4457                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4458                 ComponentName cn = info.providerName;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4459                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4460                     filtered.add(info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4461                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4462             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4463         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4464         return new ArrayList&lt;ItemInfo&gt;(filtered);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4465     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4466 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4467     private ArrayList&lt;ItemInfo&gt; getItemInfoForPackageName(final String pn) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4468         ItemInfoFilter filter  = new ItemInfoFilter() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4469             @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4470             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4471                 return cn.getPackageName().equals(pn);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4472             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4473         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4474         return filterItemInfos(sBgItemsIdMap.values(), filter);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4475     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4476 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4477     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4478         ItemInfoFilter filter  = new ItemInfoFilter() {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4479             @Override</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4480             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4481                 return cn.equals(cname);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4482             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4483         };</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4484         return filterItemInfos(sBgItemsIdMap.values(), filter);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4485     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4486 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4487     public static boolean isShortcutInfoUpdateable(ItemInfo i) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4488         if (i instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4489             ShortcutInfo info = (ShortcutInfo) i;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4490             // We need to check for ACTION_MAIN otherwise getComponent() might</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4491             // return null for some shortcuts (for instance, for shortcuts to</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4492             // web pages.)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4493             Intent intent = info.intent;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4494             ComponentName name = intent.getComponent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4495             if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4496                     Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4497                 return true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4498             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4499         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4500         return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4501     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4502 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4503     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4504      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4505      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4506     private ShortcutInfo getShortcutInfo(Cursor c, Context context,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4507             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4508             int titleIndex) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4509 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4510         Bitmap icon = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4511         final ShortcutInfo info = new ShortcutInfo();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4512         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4513 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4514         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4515 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4516         info.title = c.getString(titleIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4517 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4518         int iconType = c.getInt(iconTypeIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4519         switch (iconType) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4520         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4521             String packageName = c.getString(iconPackageIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4522             String resourceName = c.getString(iconResourceIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4523             PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4524             info.customIcon = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4525             // the resource</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4526             try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4527                 Resources resources = packageManager.getResourcesForApplication(packageName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4528                 if (resources != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4529                     final int id = resources.getIdentifier(resourceName, null, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4530                     icon = Utilities.createIconBitmap(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4531                             mIconCache.getFullResIcon(resources, id), context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4532                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4533             } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4534                 // drop this.  we have other places to look for icons</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4535             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4536             // the db</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4537             if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4538                 icon = getIconFromCursor(c, iconIndex, context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4539             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4540             // the fallback icon</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4541             if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4542                 icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4543                 info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4544             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4545             break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4546         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4547             icon = getIconFromCursor(c, iconIndex, context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4548             if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4549                 icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4550                 info.customIcon = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4551                 info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4552             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4553                 info.customIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4554             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4555             break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4556         default:</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4557             icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4558             info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4559             info.customIcon = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4560             break;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4561         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4562         info.setIcon(icon);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4563         return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4564     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4565 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4566     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4567         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4568         final boolean debug = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4569         if (debug) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4570             Log.d(TAG, &quot;getIconFromCursor app=&quot;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4571                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4572         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4573         byte[] data = c.getBlob(iconIndex);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4574         try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4575             return Utilities.createIconBitmap(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4576                     BitmapFactory.decodeByteArray(data, 0, data.length), context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4577         } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4578             return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4579         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4580     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4581 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4582     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4583             int cellX, int cellY, boolean notify) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4584         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4585         if (info == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4586             return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4587         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4588         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4589 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4590         return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4591     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4592 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4593     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4594      * Attempts to find an AppWidgetProviderInfo that matches the given component.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4595      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4596     AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4597             ComponentName component) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4598         List&lt;AppWidgetProviderInfo&gt; widgets =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4599             AppWidgetManager.getInstance(context).getInstalledProviders();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4600         for (AppWidgetProviderInfo info : widgets) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4601             if (info.provider.equals(component)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4602                 return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4603             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4604         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4605         return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4606     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4607 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4608     /**</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4609      * Returns a list of all the widgets that can handle configuration with a particular mimeType.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4610      */</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4611     List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4612         final PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4613         final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4614             new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4615 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4616         final Intent supportsIntent =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4617             new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4618         supportsIntent.setType(mimeType);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4619 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4620         // Create a set of widget configuration components that we can test against</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4621         final List&lt;AppWidgetProviderInfo&gt; widgets =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4622             AppWidgetManager.getInstance(context).getInstalledProviders();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4623         final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4624             new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4625         for (AppWidgetProviderInfo info : widgets) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4626             configurationComponentToWidget.put(info.configure, info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4627         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4628 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4629         // Run through each of the intents that can handle this type of clip data, and cross</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4630         // reference them with the components that are actual configuration components</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4631         final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4632                 PackageManager.MATCH_DEFAULT_ONLY);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4633         for (ResolveInfo info : activities) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4634             final ActivityInfo activityInfo = info.activityInfo;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4635             final ComponentName infoComponent = new ComponentName(activityInfo.packageName,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4636                     activityInfo.name);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4637             if (configurationComponentToWidget.containsKey(infoComponent)) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4638                 supportedConfigurationActivities.add(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4639                         new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4640                                 configurationComponentToWidget.get(infoComponent)));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4641             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4642         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4643         return supportedConfigurationActivities;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4644     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4645 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4646     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4647         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4648         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4649         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4650 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4651         if (intent == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4652             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4653             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4654             return null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4655         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4656 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4657         Bitmap icon = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4658         boolean customIcon = false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4659         ShortcutIconResource iconResource = null;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4660 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4661         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4662             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4663             customIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4664         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4665             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4666             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4667                 try {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4668                     iconResource = (ShortcutIconResource) extra;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4669                     final PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4670                     Resources resources = packageManager.getResourcesForApplication(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4671                             iconResource.packageName);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4672                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4673                     icon = Utilities.createIconBitmap(</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4674                             mIconCache.getFullResIcon(resources, id), context);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4675                 } catch (Exception e) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4676                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4677                 }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4678             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4679         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4680 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4681         final ShortcutInfo info = new ShortcutInfo();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4682 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4683         if (icon == null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4684             if (fallbackIcon != null) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4685                 icon = fallbackIcon;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4686             } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4687                 icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4688                 info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4689             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4690         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4691         info.setIcon(icon);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4692 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4693         info.title = name;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4694         info.intent = intent;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4695         info.customIcon = customIcon;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4696         info.iconResource = iconResource;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4697 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4698         return info;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4699     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4700 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4701     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4702             int iconIndex) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4703         // If apps can&#x27;t be on SD, don&#x27;t even bother.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4704         if (!mAppsCanBeOnRemoveableStorage) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4705             return false;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4706         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4707         // If this icon doesn&#x27;t have a custom icon, check to see</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4708         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4709         // we&#x27;re going to show, store what we are going to show back</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4710         // into the DB.  We do this so when we&#x27;re loading, if the</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4711         // package manager can&#x27;t find an icon (for example because</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4712         // the app is on SD) then we can use that instead.</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4713         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4714             cache.put(info, c.getBlob(iconIndex));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4715             return true;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4716         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">4717         return false;</span>
4718 =======
4719 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
4720         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
4721         info.promisedIntent = intent;
4722         return info;
4723     }
4724 
4725     /**
4726      * Make an Intent object for a restored application or shortcut item that points
4727      * to the market page for the item.
4728      */
4729     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
4730         ComponentName componentName = intent.getComponent();
4731         return getMarketIntent(componentName.getPackageName());
4732     }
4733 
4734     static Intent getMarketIntent(String packageName) {
4735         return new Intent(Intent.ACTION_VIEW)
4736             .setData(new Uri.Builder()
4737                 .scheme(&quot;market&quot;)
4738                 .authority(&quot;details&quot;)
4739                 .appendQueryParameter(&quot;id&quot;, packageName)
4740                 .build());
4741     }
4742 
4743     /**
4744      * This is called from the code that adds shortcuts from the intent receiver.  This
4745      * doesn&#x27;t have a Cursor, but
4746      */
4747     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
4748             UserHandleCompat user, Context context) {
4749         return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);
4750     }
4751 
4752     /**
4753      * Make an ShortcutInfo object for a shortcut that is an application.
4754      *
4755      * If c is not null, then it will be used to fill in missing data like the title and icon.
4756      */
4757     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
4758             UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,
4759             HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {
4760         if (user == null) {
4761             Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
4762             return null;
4763         }
4764 
4765         ComponentName componentName = intent.getComponent();
4766         if (componentName == null) {
4767             Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
4768             return null;
4769         }
4770 
4771         Intent newIntent = new Intent(intent.getAction(), null);
4772         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
4773         newIntent.setComponent(componentName);
4774         LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
4775         if ((lai == null) &amp;&amp; !allowMissingTarget) {
4776             Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
4777             return null;
4778         }
4779 
4780         final ShortcutInfo info = new ShortcutInfo();
4781 
4782         // the resource -- This may implicitly give us back the fallback icon,
4783         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
4784         // to avoid saving lots of copies of that in the database, and most apps
4785         // have icons anyway.
4786         Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);
4787 
4788         // the db
4789         if (icon == null) {
4790             if (c != null) {
4791                 icon = getIconFromCursor(c, iconIndex, context);
4792             }
4793         }
4794         // the fallback icon
4795         if (icon == null) {
4796             icon = mIconCache.getDefaultIcon(user);
4797             info.usingFallbackIcon = true;
4798         }
4799         info.setIcon(icon);
4800 
4801         // From the cache.
4802         if (labelCache != null) {
4803             info.title = labelCache.get(componentName);
4804         }
4805 
4806         // from the resource
4807         if (info.title == null &amp;&amp; lai != null) {
4808             info.title = lai.getLabel();
4809             if (labelCache != null) {
4810                 labelCache.put(componentName, info.title);
4811             }
4812         }
4813         // from the db
4814         if (info.title == null) {
4815             if (c != null) {
4816                 info.title =  c.getString(titleIndex);
4817             }
4818         }
4819         // fall back to the class name of the activity
4820         if (info.title == null) {
4821             info.title = componentName.getClassName();
4822         }
4823         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
4824         info.user = user;
4825         info.contentDescription = mUserManager.getBadgedLabelForUser(
4826                 info.title.toString(), info.user);
4827         return info;
4828     }
4829 
4830     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
4831             ItemInfoFilter f) {
4832         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
4833         for (ItemInfo i : infos) {
4834             if (i instanceof ShortcutInfo) {
4835                 ShortcutInfo info = (ShortcutInfo) i;
4836                 ComponentName cn = info.getTargetComponent();
4837                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
4838                     filtered.add(info);
4839                 }
4840             } else if (i instanceof FolderInfo) {
4841                 FolderInfo info = (FolderInfo) i;
4842                 for (ShortcutInfo s : info.contents) {
4843                     ComponentName cn = s.getTargetComponent();
4844                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
4845                         filtered.add(s);
4846                     }
4847                 }
4848             } else if (i instanceof LauncherAppWidgetInfo) {
4849                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
4850                 ComponentName cn = info.providerName;
4851                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
4852                     filtered.add(info);
4853                 }
4854             }
4855         }
4856         return new ArrayList&lt;ItemInfo&gt;(filtered);
4857     }
4858 
4859     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,
4860             final UserHandleCompat user) {
4861         ItemInfoFilter filter  = new ItemInfoFilter() {
4862             @Override
4863             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
4864                 if (info.user == null) {
4865                     return cn.equals(cname);
4866                 } else {
4867                     return cn.equals(cname) &amp;&amp; info.user.equals(user);
4868                 }
4869             }
4870         };
4871         return filterItemInfos(sBgItemsIdMap.values(), filter);
4872     }
4873 
4874     public static boolean isShortcutInfoUpdateable(ItemInfo i) {
4875         if (i instanceof ShortcutInfo) {
4876             ShortcutInfo info = (ShortcutInfo) i;
4877             // We need to check for ACTION_MAIN otherwise getComponent() might
4878             // return null for some shortcuts (for instance, for shortcuts to
4879             // web pages.)
4880             Intent intent = info.intent;
4881             ComponentName name = intent.getComponent();
4882             if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
4883                     Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
4884                 return true;
4885             }
4886             // placeholder shortcuts get special treatment, let them through too.
4887             if (info.isPromise()) {
4888                 return true;
4889             }
4890         }
4891         return false;
4892     }
4893 
4894     /**
4895      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
4896      */
4897     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
4898             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
4899             int titleIndex) {
4900 
4901         Bitmap icon = null;
4902         final ShortcutInfo info = new ShortcutInfo();
4903         // Non-app shortcuts are only supported for current user.
4904         info.user = UserHandleCompat.myUserHandle();
4905         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
4906 
4907         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
4908 
4909         info.title = c.getString(titleIndex);
4910 
4911         int iconType = c.getInt(iconTypeIndex);
4912         switch (iconType) {
4913         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
4914             String packageName = c.getString(iconPackageIndex);
4915             String resourceName = c.getString(iconResourceIndex);
4916             PackageManager packageManager = context.getPackageManager();
4917             info.customIcon = false;
4918             // the resource
4919             try {
4920                 Resources resources = packageManager.getResourcesForApplication(packageName);
4921                 if (resources != null) {
4922                     final int id = resources.getIdentifier(resourceName, null, null);
4923                     icon = Utilities.createIconBitmap(
4924                             mIconCache.getFullResIcon(resources, id), context);
4925                 }
4926             } catch (Exception e) {
4927                 // drop this.  we have other places to look for icons
4928             }
4929             // the db
4930             if (icon == null) {
4931                 icon = getIconFromCursor(c, iconIndex, context);
4932             }
4933             // the fallback icon
4934             if (icon == null) {
4935                 icon = mIconCache.getDefaultIcon(info.user);
4936                 info.usingFallbackIcon = true;
4937             }
4938             break;
4939         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
4940             icon = getIconFromCursor(c, iconIndex, context);
4941             if (icon == null) {
4942                 icon = mIconCache.getDefaultIcon(info.user);
4943                 info.customIcon = false;
4944                 info.usingFallbackIcon = true;
4945             } else {
4946                 info.customIcon = true;
4947             }
4948             break;
4949         default:
4950             icon = mIconCache.getDefaultIcon(info.user);
4951             info.usingFallbackIcon = true;
4952             info.customIcon = false;
4953             break;
4954         }
4955         info.setIcon(icon);
4956         return info;
4957     }
4958 
4959     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
4960         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
4961         final boolean debug = false;
4962         if (debug) {
4963             Log.d(TAG, &quot;getIconFromCursor app=&quot;
4964                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
4965         }
4966         byte[] data = c.getBlob(iconIndex);
4967         try {
4968             return Utilities.createIconBitmap(
4969                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
4970         } catch (Exception e) {
4971             return null;
4972         }
4973     }
4974 
4975     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
4976             int cellX, int cellY, boolean notify) {
4977         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
4978         if (info == null) {
4979             return null;
4980         }
4981         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
4982 
4983         return info;
4984     }
4985 
4986     /**
4987      * Attempts to find an AppWidgetProviderInfo that matches the given component.
4988      */
4989     static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
4990             ComponentName component) {
4991         List&lt;AppWidgetProviderInfo&gt; widgets =
4992             AppWidgetManager.getInstance(context).getInstalledProviders();
4993         for (AppWidgetProviderInfo info : widgets) {
4994             if (info.provider.equals(component)) {
4995                 return info;
4996             }
4997         }
4998         return null;
4999     }
5000 
5001     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
5002         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
5003         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
5004         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
5005 
5006         if (intent == null) {
5007             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
5008             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
5009             return null;
5010         }
5011 
5012         Bitmap icon = null;
5013         boolean customIcon = false;
5014         ShortcutIconResource iconResource = null;
5015 
5016         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
5017             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
5018             customIcon = true;
5019         } else {
5020             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
5021             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
5022                 try {
5023                     iconResource = (ShortcutIconResource) extra;
5024                     final PackageManager packageManager = context.getPackageManager();
5025                     Resources resources = packageManager.getResourcesForApplication(
5026                             iconResource.packageName);
5027                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
5028                     icon = Utilities.createIconBitmap(
5029                             mIconCache.getFullResIcon(resources, id),
5030                             context);
5031                 } catch (Exception e) {
5032                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
5033                 }
5034             }
5035         }
5036 
5037         final ShortcutInfo info = new ShortcutInfo();
5038 
5039         // Only support intents for current user for now. Intents sent from other
5040         // users wouldn&#x27;t get here without intent forwarding anyway.
5041         info.user = UserHandleCompat.myUserHandle();
5042         if (icon == null) {
5043             if (fallbackIcon != null) {
5044                 icon = fallbackIcon;
5045             } else {
5046                 icon = mIconCache.getDefaultIcon(info.user);
5047                 info.usingFallbackIcon = true;
5048             }
5049         }
5050         info.setIcon(icon);
5051 
5052         info.title = name;
5053         info.contentDescription = mUserManager.getBadgedLabelForUser(
5054                 info.title.toString(), info.user);
5055         info.intent = intent;
5056         info.customIcon = customIcon;
5057         info.iconResource = iconResource;
5058 
5059         return info;
5060     }
5061 
5062     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
5063             int iconIndex) {
5064         // If apps can&#x27;t be on SD, don&#x27;t even bother.
5065         if (!mAppsCanBeOnRemoveableStorage) {
5066             return false;
5067         }
5068         // If this icon doesn&#x27;t have a custom icon, check to see
5069         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
5070         // we&#x27;re going to show, store what we are going to show back
5071         // into the DB.  We do this so when we&#x27;re loading, if the
5072         // package manager can&#x27;t find an icon (for example because
5073         // the app is on SD) then we can use that instead.
5074         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
5075             cache.put(info, c.getBlob(iconIndex));
5076             return true;
5077         }
5078         return false;
5079     }
5080     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
5081         boolean needSave = false;
5082         try {
5083             if (data != null) {
5084                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
5085                 Bitmap loaded = info.getIcon(mIconCache);
5086                 needSave = !saved.sameAs(loaded);
5087             } else {
5088                 needSave = true;
5089             }
5090         } catch (Exception e) {
5091             needSave = true;
5092         }
5093         if (needSave) {
5094             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
5095             // This is slower than is ideal, but this only happens once
5096             // or when the app is updated with a new icon.
5097             updateItemInDatabase(context, info);
5098         }
5099     }
5100 
5101     /**
5102      * Return an existing FolderInfo object if we have encountered this ID previously,
5103      * or make a new one.
5104      */
5105     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
5106         // See if a placeholder was created for us already
5107         FolderInfo folderInfo = folders.get(id);
5108         if (folderInfo == null) {
5109             // No placeholder -- create a new instance
5110             folderInfo = new FolderInfo();
5111             folders.put(id, folderInfo);
5112         }
5113         return folderInfo;
5114     }
5115 
5116     public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
5117         final Collator collator = Collator.getInstance();
5118         return new Comparator&lt;AppInfo&gt;() {
5119             public final int compare(AppInfo a, AppInfo b) {
5120                 if (a.user.equals(b.user)) {
5121                     int result = collator.compare(a.title.toString().trim(),
5122                             b.title.toString().trim());
5123                     if (result == 0) {
5124                         result = a.componentName.compareTo(b.componentName);
5125                     }
5126                     return result;
5127                 } else {
5128                     // TODO Need to figure out rules for sorting
5129                     // profiles, this puts work second.
5130                     return a.user.toString().compareTo(b.user.toString());
5131                 }
5132             }
5133         };
5134     }
5135     public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
5136             = new Comparator&lt;AppInfo&gt;() {
5137         public final int compare(AppInfo a, AppInfo b) {
5138             if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
5139             if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
5140             return 0;
5141         }
5142     };
5143     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
5144         if (info.activityInfo != null) {
5145             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
5146         } else {
5147             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
5148         }
5149     }
5150     public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {
5151         private Collator mCollator;
5152         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
5153         ShortcutNameComparator(PackageManager pm) {
5154             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
5155             mCollator = Collator.getInstance();
5156         }
5157         ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {
5158             mLabelCache = labelCache;
5159             mCollator = Collator.getInstance();
5160         }
5161         public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {
5162             String labelA, labelB;
5163             ComponentName keyA = a.getComponentName();
5164             ComponentName keyB = b.getComponentName();
5165             if (mLabelCache.containsKey(keyA)) {
5166                 labelA = mLabelCache.get(keyA).toString();
5167             } else {
5168                 labelA = a.getLabel().toString().trim();
5169 
5170                 mLabelCache.put(keyA, labelA);
5171             }
5172             if (mLabelCache.containsKey(keyB)) {
5173                 labelB = mLabelCache.get(keyB).toString();
5174             } else {
5175                 labelB = b.getLabel().toString().trim();
5176 
5177                 mLabelCache.put(keyB, labelB);
5178             }
5179             return mCollator.compare(labelA, labelB);
5180         }
5181     };
5182     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
5183         private final AppWidgetManagerCompat mManager;
5184         private final PackageManager mPackageManager;
5185         private final HashMap&lt;Object, String&gt; mLabelCache;
5186         private final Collator mCollator;
5187 
5188         WidgetAndShortcutNameComparator(Context context) {
5189             mManager = AppWidgetManagerCompat.getInstance(context);
5190             mPackageManager = context.getPackageManager();
5191             mLabelCache = new HashMap&lt;Object, String&gt;();
5192             mCollator = Collator.getInstance();
5193         }
5194         public final int compare(Object a, Object b) {
5195             String labelA, labelB;
5196             if (mLabelCache.containsKey(a)) {
5197                 labelA = mLabelCache.get(a);
5198             } else {
5199                 labelA = (a instanceof AppWidgetProviderInfo)
5200                         ? mManager.loadLabel((AppWidgetProviderInfo) a)
5201                         : ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();
5202                 mLabelCache.put(a, labelA);
5203             }
5204             if (mLabelCache.containsKey(b)) {
5205                 labelB = mLabelCache.get(b);
5206             } else {
5207                 labelB = (b instanceof AppWidgetProviderInfo)
5208                         ? mManager.loadLabel((AppWidgetProviderInfo) b)
5209                         : ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();
5210                 mLabelCache.put(b, labelB);
5211             }
5212             return mCollator.compare(labelA, labelB);
5213         }
5214     };
5215 
5216     static boolean isValidProvider(AppWidgetProviderInfo provider) {
5217         return (provider != null) &amp;&amp; (provider.provider != null)
5218                 &amp;&amp; (provider.provider.getPackageName() != null);
5219     }
5220 
5221     public void dumpState() {
5222         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
5223         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
5224         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
5225         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
5226         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
5227         if (mLoaderTask != null) {
5228             mLoaderTask.dumpState();
5229         } else {
5230             Log.d(TAG, &quot;mLoaderTask=null&quot;);
5231         }
5232     }
5233 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.app.SearchManager;
  20 import android.appwidget.AppWidgetManager;
  21 import android.appwidget.AppWidgetProviderInfo;
  22 import android.content.BroadcastReceiver;
  23 import android.content.ComponentName;
  24 import android.content.ContentProviderClient;
  25 import android.content.ContentProviderOperation;
  26 import android.content.ContentResolver;
  27 import android.content.ContentValues;
  28 import android.content.Context;
  29 import android.content.Intent;
  30 import android.content.Intent.ShortcutIconResource;
  31 import android.content.IntentFilter;
  32 import android.content.SharedPreferences;
  33 import android.content.pm.PackageManager;
  34 import android.content.pm.ProviderInfo;
  35 import android.content.pm.ResolveInfo;
  36 import android.content.res.Configuration;
  37 import android.content.res.Resources;
  38 import android.database.Cursor;
  39 import android.graphics.Bitmap;
  40 import android.graphics.BitmapFactory;
  41 import android.net.Uri;
  42 import android.os.Environment;
  43 import android.os.Handler;
  44 import android.os.HandlerThread;
  45 import android.os.Parcelable;
  46 import android.os.Process;
  47 import android.os.RemoteException;
  48 import android.os.SystemClock;
  49 import android.provider.BaseColumns;
  50 import android.text.TextUtils;
  51 import android.util.Log;
  52 import android.util.Pair;
  53 
  54 import com.android.launcher3.compat.AppWidgetManagerCompat;
  55 import com.android.launcher3.compat.LauncherActivityInfoCompat;
  56 import com.android.launcher3.compat.LauncherAppsCompat;
  57 import com.android.launcher3.compat.PackageInstallerCompat;
  58 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  59 import com.android.launcher3.compat.UserHandleCompat;
  60 import com.android.launcher3.compat.UserManagerCompat;
  61 
  62 import java.lang.ref.WeakReference;
  63 import java.net.URISyntaxException;
  64 import java.security.InvalidParameterException;
  65 import java.text.Collator;
  66 import java.util.ArrayList;
  67 import java.util.Arrays;
  68 import java.util.Collection;
  69 import java.util.Collections;
  70 import java.util.Comparator;
  71 import java.util.HashMap;
  72 import java.util.HashSet;
  73 import java.util.Iterator;
  74 import java.util.List;
  75 import java.util.Map.Entry;
  76 import java.util.Set;
  77 import java.util.TreeMap;
  78 import java.util.concurrent.atomic.AtomicBoolean;
  79 
  80 /**
  81  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  82  * LauncherModel object held in a static. Also provide APIs for updating the database state
  83  * for the Launcher.
  84  */
  85 public class LauncherModel extends BroadcastReceiver
  86         implements LauncherAppsCompat.OnAppsChangedCallbackCompat {
  87     static final boolean DEBUG_LOADERS = false;
  88     private static final boolean DEBUG_RECEIVER = false;
  89     private static final boolean REMOVE_UNRESTORED_ICONS = true;
  90 
  91     static final String TAG = &quot;Launcher.Model&quot;;
  92 
  93     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  94     // false = strew non-workspace apps across the workspace on upgrade
  95     public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  96     public static final int LOADER_FLAG_NONE = 0;
  97     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
  98     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
  99 
 100     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 101     private static final long INVALID_SCREEN_ID = -1L;
 102 
 103     private final boolean mAppsCanBeOnRemoveableStorage;
 104     private final boolean mOldContentProviderExists;
 105 
 106     private final LauncherAppState mApp;
 107     private final Object mLock = new Object();
 108     private DeferredHandler mHandler = new DeferredHandler();
 109     private LoaderTask mLoaderTask;
 110     private boolean mIsLoaderTaskRunning;
 111     private volatile boolean mFlushingWorkerThread;
 112 
 113     // Specific runnable types that are run on the main thread deferred handler, this allows us to
 114     // clear all queued binding runnables when the Launcher activity is destroyed.
 115     private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 116     private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
 117 
 118     private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 119 
 120     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 121     static {
 122         sWorkerThread.start();
 123     }
 124     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 125 
 126     // We start off with everything not loaded.  After that, we assume that
 127     // our monitoring of the package manager provides all updates and we never
 128     // need to do a requery.  These are only ever touched from the loader thread.
 129     private boolean mWorkspaceLoaded;
 130     private boolean mAllAppsLoaded;
 131 
 132     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 133     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 134     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 135     // a normal load, we also clear this set of Runnables.
 136     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 137 
 138     private WeakReference&lt;Callbacks&gt; mCallbacks;
 139 
 140     // &lt; only access in worker thread &gt;
 141     AllAppsList mBgAllAppsList;
 142 
 143     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 144     // other locks, this one can generally be held long-term because we never expect any of these
 145     // static data structures to be referenced outside of the worker thread except on the first
 146     // load after configuration change.
 147     static final Object sBgLock = new Object();
 148 
 149     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 150     // LauncherModel to their ids
 151     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 152 
 153     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 154     //       created by LauncherModel that are directly on the home screen (however, no widgets or
 155     //       shortcuts within folders).
 156     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 157 
 158     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 159     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 160         new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 161 
 162     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 163     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 164 
 165     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 166     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 167 
 168     // sBgWorkspaceScreens is the ordered set of workspace screens.
 169     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 170 
 171     // sPendingPackages is a set of packages which could be on sdcard and are not available yet
 172     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages =
 173             new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();
 174 
 175     // &lt;/ only access in worker thread &gt;
 176 
 177     private IconCache mIconCache;
 178 
 179     protected int mPreviousConfigMcc;
 180 
 181     private final LauncherAppsCompat mLauncherApps;
 182     private final UserManagerCompat mUserManager;
 183 
 184     public interface Callbacks {
 185         public boolean setLoadOnResume();
 186         public int getCurrentWorkspaceScreen();
 187         public void startBinding();
 188         public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 189                               boolean forceAnimateIcons);
 190         public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 191         public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 192         public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 193         public void finishBindingItems(boolean upgradePath);
 194         public void bindAppWidget(LauncherAppWidgetInfo info);
 195         public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 196         public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 197                                   ArrayList&lt;ItemInfo&gt; addNotAnimated,
 198                                   ArrayList&lt;ItemInfo&gt; addAnimated,
 199                                   ArrayList&lt;AppInfo&gt; addedApps);
 200         public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 201         public void bindAppsRestored(ArrayList&lt;AppInfo&gt; apps);
 202         public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);
 203         public void updatePackageBadge(String packageName);
 204         public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
 205                         ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user);
 206         public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 207         public void bindSearchablesChanged();
 208         public boolean isAllAppsButtonRank(int rank);
 209         public void onPageBoundSynchronously(int page);
 210         public void dumpLogsToLocalData();
 211     }
 212 
 213     public interface ItemInfoFilter {
 214         public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 215     }
 216 
 217     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 218         Context context = app.getContext();
 219 
 220         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 221         String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 222         // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 223         // resource string.
 224         String redirectAuthority = Uri.parse(oldProvider).getAuthority();
 225         ProviderInfo providerInfo =
 226                 context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);
 227         ProviderInfo redirectProvider =
 228                 context.getPackageManager().resolveContentProvider(redirectAuthority, 0);
 229 
 230         Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 231         mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 232 
 233         if (mOldContentProviderExists) {
 234             Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 235         } else {
 236             Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 237         }
 238 
 239         mApp = app;
 240         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 241         mIconCache = iconCache;
 242 
 243         final Resources res = context.getResources();
 244         Configuration config = res.getConfiguration();
 245         mPreviousConfigMcc = config.mcc;
 246         mLauncherApps = LauncherAppsCompat.getInstance(context);
 247         mUserManager = UserManagerCompat.getInstance(context);
 248     }
 249 
 250     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 251      * posted on the main thread handler. */
 252     private void runOnMainThread(Runnable r) {
 253         runOnMainThread(r, 0);
 254     }
 255     private void runOnMainThread(Runnable r, int type) {
 256         if (sWorkerThread.getThreadId() == Process.myTid()) {
 257             // If we are on the worker thread, post onto the main handler
 258             mHandler.post(r);
 259         } else {
 260             r.run();
 261         }
 262     }
 263 
 264     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 265      * posted on the worker thread handler. */
 266     private static void runOnWorkerThread(Runnable r) {
 267         if (sWorkerThread.getThreadId() == Process.myTid()) {
 268             r.run();
 269         } else {
 270             // If we are not on the worker thread, then post to the worker handler
 271             sWorker.post(r);
 272         }
 273     }
 274 
 275     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 276         return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 277     }
 278 
 279     static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 280                                  long screen) {
 281         LauncherAppState app = LauncherAppState.getInstance();
 282         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 283         final int xCount = (int) grid.numColumns;
 284         final int yCount = (int) grid.numRows;
 285         boolean[][] occupied = new boolean[xCount][yCount];
 286 
 287         int cellX, cellY, spanX, spanY;
 288         for (int i = 0; i &lt; items.size(); ++i) {
 289             final ItemInfo item = items.get(i);
 290             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 291                 if (item.screenId == screen) {
 292                     cellX = item.cellX;
 293                     cellY = item.cellY;
 294                     spanX = item.spanX;
 295                     spanY = item.spanY;
 296                     for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 297                         for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 298                             occupied[x][y] = true;
 299                         }
 300                     }
 301                 }
 302             }
 303         }
 304 
 305         return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 306     }
 307     static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 308                                                         Intent launchIntent,
 309                                                         int firstScreenIndex,
 310                                                         ArrayList&lt;Long&gt; workspaceScreens) {
 311         // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 312         LauncherAppState app = LauncherAppState.getInstance();
 313         LauncherModel model = app.getModel();
 314         boolean found = false;
 315         synchronized (app) {
 316             if (sWorkerThread.getThreadId() != Process.myTid()) {
 317                 // Flush the LauncherModel worker thread, so that if we just did another
 318                 // processInstallShortcut, we give it time for its shortcut to get added to the
 319                 // database (getItemsInLocalCoordinates reads the database)
 320                 model.flushWorkerThread();
 321             }
 322             final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 323 
 324             // Try adding to the workspace screens incrementally, starting at the default or center
 325             // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 326             firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 327             int count = workspaceScreens.size();
 328             for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 329                 int[] tmpCoordinates = new int[2];
 330                 if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 331                         workspaceScreens.get(screen))) {
 332                     // Update the Launcher db
 333                     return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 334                 }
 335             }
 336         }
 337         return null;
 338     }
 339 
 340     public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {
 341         // Process the updated package state
 342         Runnable r = new Runnable() {
 343             public void run() {
 344                 Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 345                 if (callbacks != null) {
 346                     callbacks.updatePackageState(installInfo);
 347                 }
 348             }
 349         };
 350         mHandler.post(r);
 351     }
 352 
 353     public void updatePackageBadge(final String packageName) {
 354         // Process the updated package badge
 355         Runnable r = new Runnable() {
 356             public void run() {
 357                 Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 358                 if (callbacks != null) {
 359                     callbacks.updatePackageBadge(packageName);
 360                 }
 361             }
 362         };
 363         mHandler.post(r);
 364     }
 365 
 366     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 367         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 368 
 369         if (allAppsApps == null) {
 370             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 371         }
 372         if (allAppsApps.isEmpty()) {
 373             return;
 374         }
 375 
 376         final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 377         Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();
 378         while (iter.hasNext()) {
 379             ItemInfo a = iter.next();
 380             if (LauncherModel.appWasPromise(ctx, a.getIntent(), a.user)) {
 381                 restoredAppsFinal.add((AppInfo) a);
 382             }
 383         }
 384 
 385         // Process the newly added applications and add them to the database first
 386         Runnable r = new Runnable() {
 387             public void run() {
 388                 runOnMainThread(new Runnable() {
 389                     public void run() {
 390                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 391                         if (callbacks == cb &amp;&amp; cb != null) {
 392                             if (!restoredAppsFinal.isEmpty()) {
 393                                 for (AppInfo info : restoredAppsFinal) {
 394                                     final Intent intent = info.getIntent();
 395                                     if (intent != null) {
 396                                         mIconCache.deletePreloadedIcon(intent.getComponent(),
 397                                                 info.user);
 398                                     }
 399                                 }
 400                                 callbacks.bindAppsUpdated(restoredAppsFinal);
 401                             }
 402                             callbacks.bindAppsAdded(null, null, null, allAppsApps);
 403                         }
 404                     }
 405                 });
 406             }
 407         };
 408         runOnWorkerThread(r);
 409     }
 410 
 411     public void addAndBindAddedWorkspaceApps(final Context context,
 412             final ArrayList&lt;ItemInfo&gt; workspaceApps) {
 413         final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
 414 
 415         if (workspaceApps == null) {
 416             throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 417         }
 418         if (workspaceApps.isEmpty()) {
 419             return;
 420         }
 421         // Process the newly added applications and add them to the database first
 422         Runnable r = new Runnable() {
 423             public void run() {
 424                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 425                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 426                 final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 427 
 428                 // Get the list of workspace screens.  We need to append to this list and
 429                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 430                 // called.
 431                 ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 432                 TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 433                 for (Integer i : orderedScreens.keySet()) {
 434                     long screenId = orderedScreens.get(i);
 435                     workspaceScreens.add(screenId);
 436                 }
 437 
 438                 synchronized(sBgLock) {
 439                     Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 440                     while (iter.hasNext()) {
 441                         ItemInfo a = iter.next();
 442                         final String name = a.title.toString();
 443                         final Intent launchIntent = a.getIntent();
 444 
 445                         // Short-circuit this logic if the icon exists somewhere on the workspace
 446                         if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 447                             // Only InstallShortcutReceiver sends us shortcutInfos, ignore them
 448                             if (a instanceof AppInfo &amp;&amp;
 449                                     LauncherModel.appWasPromise(context, launchIntent, a.user)) {
 450                                 restoredAppsFinal.add((AppInfo) a);
 451                             }
 452                             continue;
 453                         }
 454 
 455                         // Add this icon to the db, creating a new page if necessary.  If there
 456                         // is only the empty page then we just add items to the first page.
 457                         // Otherwise, we add them to the next pages.
 458                         int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 459                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 460                                 name, launchIntent, startSearchPageIndex, workspaceScreens);
 461                         if (coords == null) {
 462                             LauncherProvider lp = LauncherAppState.getLauncherProvider();
 463 
 464                             // If we can&#x27;t find a valid position, then just add a new screen.
 465                             // This takes time so we need to re-queue the add until the new
 466                             // page is added.  Create as many screens as necessary to satisfy
 467                             // the startSearchPageIndex.
 468                             int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 469                                     workspaceScreens.size());
 470                             while (numPagesToAdd &gt; 0) {
 471                                 long screenId = lp.generateNewScreenId();
 472                                 // Save the screen id for binding in the workspace
 473                                 workspaceScreens.add(screenId);
 474                                 addedWorkspaceScreensFinal.add(screenId);
 475                                 numPagesToAdd--;
 476                             }
 477 
 478                             // Find the coordinate again
 479                             coords = LauncherModel.findNextAvailableIconSpace(context,
 480                                     name, launchIntent, startSearchPageIndex, workspaceScreens);
 481                         }
 482                         if (coords == null) {
 483                             throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 484                         }
 485 
 486                         ShortcutInfo shortcutInfo;
 487                         if (a instanceof ShortcutInfo) {
 488                             shortcutInfo = (ShortcutInfo) a;
 489                         } else if (a instanceof AppInfo) {
 490                             shortcutInfo = ((AppInfo) a).makeShortcut();
 491                         } else {
 492                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 493                         }
 494 
 495                         // Add the shortcut to the db
 496                         addItemToDatabase(context, shortcutInfo,
 497                                 LauncherSettings.Favorites.CONTAINER_DESKTOP,
 498                                 coords.first, coords.second[0], coords.second[1], false);
 499                         // Save the ShortcutInfo for binding in the workspace
 500                         addedShortcutsFinal.add(shortcutInfo);
 501                     }
 502                 }
 503 
 504                 // Update the workspace screens
 505                 updateWorkspaceScreenOrder(context, workspaceScreens);
 506 
 507                 if (!addedShortcutsFinal.isEmpty()) {
 508                     runOnMainThread(new Runnable() {
 509                         public void run() {
 510                             Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 511                             if (callbacks == cb &amp;&amp; cb != null) {
 512                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 513                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 514                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 515                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 515                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 🔵</abbr>
 516                                     long lastScreenId = info.screenId;
 517                                     for (ItemInfo i : addedShortcutsFinal) {
 518                                         if (i.screenId == lastScreenId) {
 519                                             addAnimated.add(i);
 520                                         } else {
 521                                             addNotAnimated.add(i);
 522                                         }
 523                                     }
 524                                 }
 525                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
 526                                         addNotAnimated, addAnimated, null);
 527                                 if (!restoredAppsFinal.isEmpty()) {
 528                                     callbacks.bindAppsUpdated(restoredAppsFinal);
 529                                 }
 530                             }
 531                         }
 532                     });
 533                 }
 534             }
 535         };
 536         runOnWorkerThread(r);
 537     }
 538 
 539     public void unbindItemInfosAndClearQueuedBindRunnables() {
 540         if (sWorkerThread.getThreadId() == Process.myTid()) {
 541             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 542                     &quot;main thread&quot;);
 543         }
 544 
 545         // Clear any deferred bind runnables
 546         synchronized (mDeferredBindRunnables) {
 547             mDeferredBindRunnables.clear();
 548         }
 549         // Remove any queued bind runnables
 550         mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 551         // Unbind all the workspace items
 552         unbindWorkspaceItemsOnMainThread();
 553     }
 554 
 555     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 556     void unbindWorkspaceItemsOnMainThread() {
 557         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 558         // by making a copy of workspace items first.
 559         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 560         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 561         synchronized (sBgLock) {
 562             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 563             tmpAppWidgets.addAll(sBgAppWidgets);
 564         }
 565         Runnable r = new Runnable() {
 566                 @Override
 567                 public void run() {
 568                    for (ItemInfo item : tmpWorkspaceItems) {
 569                        item.unbind();
 570                    }
 571                    for (ItemInfo item : tmpAppWidgets) {
 572                        item.unbind();
 573                    }
 574                 }
 575             };
 576         runOnMainThread(r);
 577     }
 578 
 579     /**
 580      * Adds an item to the DB if it was not created previously, or move it to a new
 581      * &lt;container, screen, cellX, cellY&gt;
 582      */
 583     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 584             long screenId, int cellX, int cellY) {
 585         if (item.container == ItemInfo.NO_ID) {
 586             // From all apps
 587             addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 588         } else {
 589             // From somewhere else
 590             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 591         }
 592     }
 593 
 594     static void checkItemInfoLocked(
 595             final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 596         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 597         if (modelItem != null &amp;&amp; item != modelItem) {
 598             // check all the data is consistent
 599             if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 600                 ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 601                 ShortcutInfo shortcut = (ShortcutInfo) item;
 602                 if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 603                         modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 604                         modelShortcut.id == shortcut.id &amp;&amp;
 605                         modelShortcut.itemType == shortcut.itemType &amp;&amp;
 606                         modelShortcut.container == shortcut.container &amp;&amp;
 607                         modelShortcut.screenId == shortcut.screenId &amp;&amp;
 608                         modelShortcut.cellX == shortcut.cellX &amp;&amp;
 609                         modelShortcut.cellY == shortcut.cellY &amp;&amp;
 610                         modelShortcut.spanX == shortcut.spanX &amp;&amp;
 611                         modelShortcut.spanY == shortcut.spanY &amp;&amp;
 612                         ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 613                         (modelShortcut.dropPos != null &amp;&amp;
 614                                 shortcut.dropPos != null &amp;&amp;
 615                                 modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 616                         modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 617                     // For all intents and purposes, this is the same object
 618                     return;
 619                 }
 620             }
 621 
 622             // the modelItem needs to match up perfectly with item if our model is
 623             // to be consistent with the database-- for now, just require
 624             // modelItem == item or the equality check above
 625             String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 626                     &quot;modelItem: &quot; +
 627                     ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 628                     &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 629             RuntimeException e = new RuntimeException(msg);
 630             if (stackTrace != null) {
 631                 e.setStackTrace(stackTrace);
 632             }
 633             throw e;
 634         }
 635     }
 636 
 637     static void checkItemInfo(final ItemInfo item) {
 638         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 639         final long itemId = item.id;
 640         Runnable r = new Runnable() {
 641             public void run() {
 642                 synchronized (sBgLock) {
 643                     checkItemInfoLocked(itemId, item, stackTrace);
 644                 }
 645             }
 646         };
 647         runOnWorkerThread(r);
 648     }
 649 
 650     static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 651             final ItemInfo item, final String callingFunction) {
 652         final long itemId = item.id;
 653         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 654         final ContentResolver cr = context.getContentResolver();
 655 
 656         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 657         Runnable r = new Runnable() {
 658             public void run() {
 659                 cr.update(uri, values, null, null);
 660                 updateItemArrays(item, itemId, stackTrace);
 661             }
 662         };
 663         runOnWorkerThread(r);
 664     }
 665 
 666     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 667             final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 668         final ContentResolver cr = context.getContentResolver();
 669 
 670         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 671         Runnable r = new Runnable() {
 672             public void run() {
 673                 ArrayList&lt;ContentProviderOperation&gt; ops =
 674                         new ArrayList&lt;ContentProviderOperation&gt;();
 675                 int count = items.size();
 676                 for (int i = 0; i &lt; count; i++) {
 677                     ItemInfo item = items.get(i);
 678                     final long itemId = item.id;
 679                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 680                     ContentValues values = valuesList.get(i);
 681 
 682                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 683                     updateItemArrays(item, itemId, stackTrace);
 684 
 685                 }
 686                 try {
 687                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 688                 } catch (Exception e) {
 689                     e.printStackTrace();
 690                 }
 691             }
 692         };
 693         runOnWorkerThread(r);
 694     }
 695 
 696     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 697         // Lock on mBgLock *after* the db operation
 698         synchronized (sBgLock) {
 699             checkItemInfoLocked(itemId, item, stackTrace);
 700 
 701             if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 702                     item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 703                 // Item is in a folder, make sure this folder exists
 704                 if (!sBgFolders.containsKey(item.container)) {
 705                     // An items container is being set to a that of an item which is not in
 706                     // the list of Folders.
 707                     String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 708                             item.container + &quot;, not in the list of folders&quot;;
 709                     Log.e(TAG, msg);
 710                 }
 711             }
 712 
 713             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 714             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 715             // that are on the desktop, as appropriate
 716             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 717             if (modelItem != null &amp;&amp;
 718                     (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 719                      modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 720                 switch (modelItem.itemType) {
 721                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 722                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 723                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 724                         if (!sBgWorkspaceItems.contains(modelItem)) {
 725                             sBgWorkspaceItems.add(modelItem);
 726                         }
 727                         break;
 728                     default:
 729                         break;
 730                 }
 731             } else {
 732                 sBgWorkspaceItems.remove(modelItem);
 733             }
 734         }
 735     }
 736 
 737     public void flushWorkerThread() {
 738         mFlushingWorkerThread = true;
 739         Runnable waiter = new Runnable() {
 740                 public void run() {
 741                     synchronized (this) {
 742                         notifyAll();
 743                         mFlushingWorkerThread = false;
 744                     }
 745                 }
 746             };
 747 
 748         synchronized(waiter) {
 749             runOnWorkerThread(waiter);
 750             if (mLoaderTask != null) {
 751                 synchronized(mLoaderTask) {
 752                     mLoaderTask.notify();
 753                 }
 754             }
 755             boolean success = false;
 756             while (!success) {
 757                 try {
 758                     waiter.wait();
 759                     success = true;
 760                 } catch (InterruptedException e) {
 761                 }
 762             }
 763         }
 764     }
 765 
 766     /**
 767      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 768      */
 769     static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 770             final long screenId, final int cellX, final int cellY) {
 771         item.container = container;
 772         item.cellX = cellX;
 773         item.cellY = cellY;
 774 
 775         // We store hotseat items in canonical form which is this orientation invariant position
 776         // in the hotseat
 777         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 778                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 779             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 780         } else {
 781             item.screenId = screenId;
 782         }
 783 
 784         final ContentValues values = new ContentValues();
 785         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 786         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 787         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 788         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 789 
 790         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 791     }
 792 
 793     /**
 794      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 795      * cellX, cellY have already been updated on the ItemInfos.
 796      */
 797     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 798             final long container, final int screen) {
 799 
 800         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 801         int count = items.size();
 802 
 803         for (int i = 0; i &lt; count; i++) {
 804             ItemInfo item = items.get(i);
 805             item.container = container;
 806 
 807             // We store hotseat items in canonical form which is this orientation invariant position
 808             // in the hotseat
 809             if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 810                     container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 811                 item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 812                         item.cellY);
 813             } else {
 814                 item.screenId = screen;
 815             }
 816 
 817             final ContentValues values = new ContentValues();
 818             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 819             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 820             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 821             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 822 
 823             contentValues.add(values);
 824         }
 825         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 826     }
 827 
 828     /**
 829      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 830      */
 831     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 832             final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 833         item.container = container;
 834         item.cellX = cellX;
 835         item.cellY = cellY;
 836         item.spanX = spanX;
 837         item.spanY = spanY;
 838 
 839         // We store hotseat items in canonical form which is this orientation invariant position
 840         // in the hotseat
 841         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 842                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 843             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 844         } else {
 845             item.screenId = screenId;
 846         }
 847 
 848         final ContentValues values = new ContentValues();
 849         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 850         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 851         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 852         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 853         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 854         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 855 
 856         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 857     }
 858 
 859     /**
 860      * Update an item to the database in a specified container.
 861      */
 862     static void updateItemInDatabase(Context context, final ItemInfo item) {
 863         final ContentValues values = new ContentValues();
 864         item.onAddToDatabase(context, values);
 865         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 866         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 867     }
 868 
 869     /**
 870      * Returns true if the shortcuts already exists in the database.
 871      * we identify a shortcut by its title and intent.
 872      */
 873     static boolean shortcutExists(Context context, String title, Intent intent) {
 874         final ContentResolver cr = context.getContentResolver();
 875         final Intent intentWithPkg, intentWithoutPkg;
 876 
 877         if (intent.getComponent() != null) {
 878             // If component is not null, an intent with null package will produce
 879             // the same result and should also be a match.
 880             if (intent.getPackage() != null) {
 881                 intentWithPkg = intent;
 882                 intentWithoutPkg = new Intent(intent).setPackage(null);
 883             } else {
 884                 intentWithPkg = new Intent(intent).setPackage(
 885                         intent.getComponent().getPackageName());
 886                 intentWithoutPkg = intent;
 887             }
 888         } else {
 889             intentWithPkg = intent;
 890             intentWithoutPkg = intent;
 891         }
 892         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
 893             new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and (intent=? or intent=?)&quot;,
 894             new String[] { title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0) }, null);
 895         boolean result = false;
 896         try {
 897             result = c.moveToFirst();
 898         } finally {
 899             c.close();
 900         }
 901         return result;
 902     }
 903 
 904     /**
 905      * Returns true if the promise shortcuts with the same package name exists on the workspace.
 906      */
 907     static boolean appWasPromise(Context context, Intent intent, UserHandleCompat user) {
 908         final ComponentName component = intent.getComponent();
 909         if (component == null) {
 910             return false;
 911         }
 912         return !getItemsByPackageName(component.getPackageName(), user).isEmpty();
 913     }
 914 
 915     /**
 916      * Returns an ItemInfo array containing all the items in the LauncherModel.
 917      * The ItemInfo.id is not set through this function.
 918      */
 919     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 920         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 921         final ContentResolver cr = context.getContentResolver();
 922         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 923                 LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
 924                 LauncherSettings.Favorites.SCREEN,
 925                 LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,
 926                 LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY,
 927                 LauncherSettings.Favorites.PROFILE_ID }, null, null, null);
 928 
 929         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 930         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 931         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 932         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 933         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 934         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 935         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 936         final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);
 937         UserManagerCompat userManager = UserManagerCompat.getInstance(context);
 938         try {
 939             while (c.moveToNext()) {
 940                 ItemInfo item = new ItemInfo();
 941                 item.cellX = c.getInt(cellXIndex);
 942                 item.cellY = c.getInt(cellYIndex);
 943                 item.spanX = Math.max(1, c.getInt(spanXIndex));
 944                 item.spanY = Math.max(1, c.getInt(spanYIndex));
 945                 item.container = c.getInt(containerIndex);
 946                 item.itemType = c.getInt(itemTypeIndex);
 947                 item.screenId = c.getInt(screenIndex);
 948                 long serialNumber = c.getInt(profileIdIndex);
 949                 item.user = userManager.getUserForSerialNumber(serialNumber);
 950                 // Skip if user has been deleted.
 951                 if (item.user != null) {
 952                     items.add(item);
 953                 }
 954             }
 955         } catch (Exception e) {
 956             items.clear();
 957         } finally {
 958             c.close();
 959         }
 960 
 961         return items;
 962     }
 963 
 964     /**
 965      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 966      */
 967     FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
 968         final ContentResolver cr = context.getContentResolver();
 969         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
 970                 &quot;_id=? and (itemType=? or itemType=?)&quot;,
 971                 new String[] { String.valueOf(id),
 972                         String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
 973 
 974         try {
 975             if (c.moveToFirst()) {
 976                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 977                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 978                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 979                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 980                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 981                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 982 
 983                 FolderInfo folderInfo = null;
 984                 switch (c.getInt(itemTypeIndex)) {
 985                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 986                         folderInfo = findOrMakeFolder(folderList, id);
 987                         break;
 988                 }
 989 
 990                 folderInfo.title = c.getString(titleIndex);
 991                 folderInfo.id = id;
 992                 folderInfo.container = c.getInt(containerIndex);
 993                 folderInfo.screenId = c.getInt(screenIndex);
 994                 folderInfo.cellX = c.getInt(cellXIndex);
 995                 folderInfo.cellY = c.getInt(cellYIndex);
 996 
 997                 return folderInfo;
 998             }
 999         } finally {
1000             c.close();
1001         }
1002 
1003         return null;
1004     }
1005 
1006     /**
1007      * Add an item to the database in a specified container. Sets the container, screen, cellX and
1008      * cellY fields of the item. Also assigns an ID to the item.
1009      */
1010     static void addItemToDatabase(Context context, final ItemInfo item, final long container,
1011             final long screenId, final int cellX, final int cellY, final boolean notify) {
1012         item.container = container;
1013         item.cellX = cellX;
1014         item.cellY = cellY;
1015         // We store hotseat items in canonical form which is this orientation invariant position
1016         // in the hotseat
1017         if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1018                 container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1019             item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1020         } else {
1021             item.screenId = screenId;
1022         }
1023 
1024         final ContentValues values = new ContentValues();
1025         final ContentResolver cr = context.getContentResolver();
1026         item.onAddToDatabase(context, values);
1027 
1028         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1029         values.put(LauncherSettings.Favorites._ID, item.id);
1030         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
1031 
1032         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
1033         Runnable r = new Runnable() {
1034             public void run() {
1035                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
1036                         LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
1037 
1038                 // Lock on mBgLock *after* the db operation
1039                 synchronized (sBgLock) {
1040                     checkItemInfoLocked(item.id, item, stackTrace);
1041                     sBgItemsIdMap.put(item.id, item);
1042                     switch (item.itemType) {
1043                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1044                             sBgFolders.put(item.id, (FolderInfo) item);
1045                             // Fall through
1046                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1047                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1048                             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1049                                     item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1050                                 sBgWorkspaceItems.add(item);
1051                             } else {
1052                                 if (!sBgFolders.containsKey(item.container)) {
1053                                     // Adding an item to a folder that doesn&#x27;t exist.
1054                                     String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1055                                             &quot; doesn&#x27;t exist&quot;;
1056                                     Log.e(TAG, msg);
1057                                 }
1058                             }
1059                             break;
1060                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1061                             sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1062                             break;
1063                     }
1064                 }
1065             }
1066         };
1067         runOnWorkerThread(r);
1068     }
1069 
1070     /**
1071      * Creates a new unique child id, for a given cell span across all layouts.
1072      */
1073     static int getCellLayoutChildId(
1074             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1075         return (((int) container &amp; 0xFF) &lt;&lt; 24)
1076                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1077     }
1078 
1079     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(
1080             final String pn, final UserHandleCompat user) {
1081         ItemInfoFilter filter  = new ItemInfoFilter() {
1082             @Override
1083             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1084                 return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1085             }
1086         };
1087         return filterItemInfos(sBgItemsIdMap.values(), filter);
1088     }
1089 
1090     /**
1091      * Removes all the items from the database corresponding to the specified package.
1092      */
1093     static void deletePackageFromDatabase(Context context, final String pn,
1094             final UserHandleCompat user) {
1095         deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1096     }
1097 
1098     /**
1099      * Removes the specified item from the database
1100      * @param context
1101      * @param item
1102      */
1103     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1104         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1105         items.add(item);
1106         deleteItemsFromDatabase(context, items);
1107     }
1108 
1109     /**
1110      * Removes the specified items from the database
1111      * @param context
1112      * @param item
1113      */
1114     static void deleteItemsFromDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items) {
1115         final ContentResolver cr = context.getContentResolver();
1116 
1117         Runnable r = new Runnable() {
1118             public void run() {
1119                 for (ItemInfo item : items) {
1120                     final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);
1121                     cr.delete(uri, null, null);
1122 
1123                     // Lock on mBgLock *after* the db operation
1124                     synchronized (sBgLock) {
1125                         switch (item.itemType) {
1126                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1127                                 sBgFolders.remove(item.id);
1128                                 for (ItemInfo info: sBgItemsIdMap.values()) {
1129                                     if (info.container == item.id) {
1130                                         // We are deleting a folder which still contains items that
1131                                         // think they are contained by that folder.
1132                                         String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +
1133                                                 &quot;contains items (&quot; + info + &quot;)&quot;;
1134                                         Log.e(TAG, msg);
1135                                     }
1136                                 }
1137                                 sBgWorkspaceItems.remove(item);
1138                                 break;
1139                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1140                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1141                                 sBgWorkspaceItems.remove(item);
1142                                 break;
1143                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1144                                 sBgAppWidgets.remove((LauncherAppWidgetInfo) item);
1145                                 break;
1146                         }
1147                         sBgItemsIdMap.remove(item.id);
1148                         sBgDbIconCache.remove(item);
1149                     }
1150                 }
1151             }
1152         };
1153         runOnWorkerThread(r);
1154     }
1155 
1156     /**
1157      * Update the order of the workspace screens in the database. The array list contains
1158      * a list of screen ids in the order that they should appear.
1159      */
1160     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1161         // Log to disk
1162         Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1163         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1164 
1165         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1166         final ContentResolver cr = context.getContentResolver();
1167         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1168 
1169         // Remove any negative screen ids -- these aren&#x27;t persisted
1170         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1171         while (iter.hasNext()) {
1172             long id = iter.next();
1173             if (id &lt; 0) {
1174                 iter.remove();
1175             }
1176         }
1177 
1178         Runnable r = new Runnable() {
1179             @Override
1180             public void run() {
1181                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1182                 // Clear the table
1183                 ops.add(ContentProviderOperation.newDelete(uri).build());
1184                 int count = screensCopy.size();
1185                 for (int i = 0; i &lt; count; i++) {
1186                     ContentValues v = new ContentValues();
1187                     long screenId = screensCopy.get(i);
1188                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1189                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1190                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1191                 }
1192 
1193                 try {
1194                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1195                 } catch (Exception ex) {
1196                     throw new RuntimeException(ex);
1197                 }
1198 
1199                 synchronized (sBgLock) {
1200                     sBgWorkspaceScreens.clear();
1201                     sBgWorkspaceScreens.addAll(screensCopy);
1202                 }
1203             }
1204         };
1205         runOnWorkerThread(r);
1206     }
1207 
1208     /**
1209      * Remove the contents of the specified folder from the database
1210      */
1211     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1212         final ContentResolver cr = context.getContentResolver();
1213 
1214         Runnable r = new Runnable() {
1215             public void run() {
1216                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1217                 // Lock on mBgLock *after* the db operation
1218                 synchronized (sBgLock) {
1219                     sBgItemsIdMap.remove(info.id);
1220                     sBgFolders.remove(info.id);
1221                     sBgDbIconCache.remove(info);
1222                     sBgWorkspaceItems.remove(info);
1223                 }
1224 
1225                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1226                         LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1227                 // Lock on mBgLock *after* the db operation
1228                 synchronized (sBgLock) {
1229                     for (ItemInfo childInfo : info.contents) {
1230                         sBgItemsIdMap.remove(childInfo.id);
1231                         sBgDbIconCache.remove(childInfo);
1232                     }
1233                 }
1234             }
1235         };
1236         runOnWorkerThread(r);
1237     }
1238 
1239     /**
1240      * Set this as the current Launcher activity object for the loader.
1241      */
1242     public void initialize(Callbacks callbacks) {
1243         synchronized (mLock) {
1244             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1245         }
1246     }
1247 
1248     @Override
1249     public void onPackageChanged(String packageName, UserHandleCompat user) {
1250         int op = PackageUpdatedTask.OP_UPDATE;
1251         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1252                 user));
1253     }
1254 
1255     @Override
1256     public void onPackageRemoved(String packageName, UserHandleCompat user) {
1257         int op = PackageUpdatedTask.OP_REMOVE;
1258         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1259                 user));
1260     }
1261 
1262     @Override
1263     public void onPackageAdded(String packageName, UserHandleCompat user) {
1264         int op = PackageUpdatedTask.OP_ADD;
1265         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },
1266                 user));
1267     }
1268 
1269     @Override
1270     public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,
1271             boolean replacing) {
1272         if (!replacing) {
1273             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,
1274                     user));
1275             if (mAppsCanBeOnRemoveableStorage) {
1276                 // Only rebind if we support removable storage. It catches the
1277                 // case where
1278                 // apps on the external sd card need to be reloaded
1279                 startLoaderFromBackground();
1280             }
1281         } else {
1282             // If we are replacing then just update the packages in the list
1283             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,
1284                     packageNames, user));
1285         }
1286     }
1287 
1288     @Override
1289     public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,
1290             boolean replacing) {
1291         if (!replacing) {
1292             enqueuePackageUpdated(new PackageUpdatedTask(
1293                     PackageUpdatedTask.OP_UNAVAILABLE, packageNames,
1294                     user));
1295         }
1296 
1297     }
1298 
1299     /**
1300      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1301      * ACTION_PACKAGE_CHANGED.
1302      */
1303     @Override
1304     public void onReceive(Context context, Intent intent) {
1305         if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1306 
1307         final String action = intent.getAction();
1308         if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1309             // If we have changed locale we need to clear out the labels in all apps/workspace.
1310             forceReload();
1311         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1312              // Check if configuration change was an mcc/mnc change which would affect app resources
1313              // and we would need to clear out the labels in all apps/workspace. Same handling as
1314              // above for ACTION_LOCALE_CHANGED
1315              Configuration currentConfig = context.getResources().getConfiguration();
1316              if (mPreviousConfigMcc != currentConfig.mcc) {
1317                    Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1318                        + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1319                    forceReload();
1320              }
1321              // Update previousConfig
1322              mPreviousConfigMcc = currentConfig.mcc;
1323         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1324                    SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1325             if (mCallbacks != null) {
1326                 Callbacks callbacks = mCallbacks.get();
1327                 if (callbacks != null) {
1328                     callbacks.bindSearchablesChanged();
1329                 }
1330             }
1331         }
1332     }
1333 
1334     void forceReload() {
1335         resetLoadedState(true, true);
1336 
1337         // Do this here because if the launcher activity is running it will be restarted.
1338         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1339         // to reload.
1340         startLoaderFromBackground();
1341     }
1342 
1343     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1344         synchronized (mLock) {
1345             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1346             // mWorkspaceLoaded to true later
1347             stopLoaderLocked();
1348             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1349             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1350         }
1351     }
1352 
1353     /**
1354      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1355      * configuration changes.  So whenever we trigger the loader from the background
1356      * tell the launcher that it needs to re-run the loader when it comes back instead
1357      * of doing it now.
1358      */
1359     public void startLoaderFromBackground() {
1360         boolean runLoader = false;
1361         if (mCallbacks != null) {
1362             Callbacks callbacks = mCallbacks.get();
1363             if (callbacks != null) {
1364                 // Only actually run the loader if they&#x27;re not paused.
1365                 if (!callbacks.setLoadOnResume()) {
1366                     runLoader = true;
1367                 }
1368             }
1369         }
1370         if (runLoader) {
1371             startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1372         }
1373     }
1374 
1375     // If there is already a loader task running, tell it to stop.
1376     // returns true if isLaunching() was true on the old task
1377     private boolean stopLoaderLocked() {
1378         boolean isLaunching = false;
1379         LoaderTask oldTask = mLoaderTask;
1380         if (oldTask != null) {
1381             if (oldTask.isLaunching()) {
1382                 isLaunching = true;
1383             }
1384             oldTask.stopLocked();
1385         }
1386         return isLaunching;
1387     }
1388 
1389     public boolean isCurrentCallbacks(Callbacks callbacks) {
1390         return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1391     }
1392 
1393     public void startLoader(boolean isLaunching, int synchronousBindPage) {
1394         startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1395     }
1396 
1397     public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1398         synchronized (mLock) {
1399             if (DEBUG_LOADERS) {
1400                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1401             }
1402 
1403             // Clear any deferred bind-runnables from the synchronized load process
1404             // We must do this before any loading/binding is scheduled below.
1405             synchronized (mDeferredBindRunnables) {
1406                 mDeferredBindRunnables.clear();
1407             }
1408 
1409             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1410             if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1411                 // If there is already one running, tell it to stop.
1412                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1413                 isLaunching = isLaunching || stopLoaderLocked();
1414                 mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1415                 if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1416                         &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1417                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1418                 } else {
1419                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1420                     sWorker.post(mLoaderTask);
1421                 }
1422             }
1423         }
1424     }
1425 
1426     void bindRemainingSynchronousPages() {
1427         // Post the remaining side pages to be loaded
1428         if (!mDeferredBindRunnables.isEmpty()) {
1429             Runnable[] deferredBindRunnables = null;
1430             synchronized (mDeferredBindRunnables) {
1431                 deferredBindRunnables = mDeferredBindRunnables.toArray(
1432                         new Runnable[mDeferredBindRunnables.size()]);
1433                 mDeferredBindRunnables.clear();
1434             }
1435             for (final Runnable r : deferredBindRunnables) {
1436                 mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1437             }
1438         }
1439     }
1440 
1441     public void stopLoader() {
1442         synchronized (mLock) {
1443             if (mLoaderTask != null) {
1444                 mLoaderTask.stopLocked();
1445             }
1446         }
1447     }
1448 
1449     /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1450     private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1451         final ContentResolver contentResolver = context.getContentResolver();
1452         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1453         final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1454         TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1455 
1456         try {
1457             final int idIndex = sc.getColumnIndexOrThrow(
1458                     LauncherSettings.WorkspaceScreens._ID);
1459             final int rankIndex = sc.getColumnIndexOrThrow(
1460                     LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1461             while (sc.moveToNext()) {
1462                 try {
1463                     long screenId = sc.getLong(idIndex);
1464                     int rank = sc.getInt(rankIndex);
1465                     orderedScreens.put(rank, screenId);
1466                 } catch (Exception e) {
<abbr title="1467                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);">1467                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e,🔵</abbr>
1468                 }
1469             }
1470         } finally {
1471             sc.close();
1472         }
1473 
1474         // Log to disk
1475         Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1476         ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1477         for (Integer i : orderedScreens.keySet()) {
1478             orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1479         }
1480         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1481                 TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1482         return orderedScreens;
1483     }
1484 
1485     public boolean isAllAppsLoaded() {
1486         return mAllAppsLoaded;
1487     }
1488 
1489     boolean isLoadingWorkspace() {
1490         synchronized (mLock) {
1491             if (mLoaderTask != null) {
1492                 return mLoaderTask.isLoadingWorkspace();
1493             }
1494         }
1495         return false;
1496     }
1497 
1498     /**
1499      * Runnable for the thread that loads the contents of the launcher:
1500      *   - workspace icons
1501      *   - widgets
1502      *   - all apps icons
1503      */
1504     private class LoaderTask implements Runnable {
1505         private Context mContext;
1506         private boolean mIsLaunching;
1507         private boolean mIsLoadingAndBindingWorkspace;
1508         private boolean mStopped;
1509         private boolean mLoadAndBindStepFinished;
1510         private int mFlags;
1511 
1512         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1513 
1514         LoaderTask(Context context, boolean isLaunching, int flags) {
1515             mContext = context;
1516             mIsLaunching = isLaunching;
1517             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1518             mFlags = flags;
1519         }
1520 
1521         boolean isLaunching() {
1522             return mIsLaunching;
1523         }
1524 
1525         boolean isLoadingWorkspace() {
1526             return mIsLoadingAndBindingWorkspace;
1527         }
1528 
1529         /** Returns whether this is an upgrade path */
1530         private boolean loadAndBindWorkspace() {
1531             mIsLoadingAndBindingWorkspace = true;
1532 
1533             // Load the workspace
1534             if (DEBUG_LOADERS) {
1535                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1536             }
1537 
1538             boolean isUpgradePath = false;
1539             if (!mWorkspaceLoaded) {
1540                 isUpgradePath = loadWorkspace();
1541                 synchronized (LoaderTask.this) {
1542                     if (mStopped) {
1543                         return isUpgradePath;
1544                     }
1545                     mWorkspaceLoaded = true;
1546                 }
1547             }
1548 
1549             // Bind the workspace
1550             bindWorkspace(-1, isUpgradePath);
1551             return isUpgradePath;
1552         }
1553 
1554         private void waitForIdle() {
1555             // Wait until the either we&#x27;re stopped or the other threads are done.
1556             // This way we don&#x27;t start loading all apps until the workspace has settled
1557             // down.
1558             synchronized (LoaderTask.this) {
1559                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1560 
1561                 mHandler.postIdle(new Runnable() {
1562                         public void run() {
1563                             synchronized (LoaderTask.this) {
1564                                 mLoadAndBindStepFinished = true;
1565                                 if (DEBUG_LOADERS) {
1566                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1567                                 }
1568                                 LoaderTask.this.notify();
1569                             }
1570                         }
1571                     });
1572 
1573                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1574                     try {
1575                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1576                         // wait no longer than 1sec at a time
1577                         this.wait(1000);
1578                     } catch (InterruptedException ex) {
1579                         // Ignore
1580                     }
1581                 }
1582                 if (DEBUG_LOADERS) {
1583                     Log.d(TAG, &quot;waited &quot;
1584                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1585                             + &quot;ms for previous step to finish binding&quot;);
1586                 }
1587             }
1588         }
1589 
1590         void runBindSynchronousPage(int synchronousBindPage) {
1591             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1592                 // Ensure that we have a valid page index to load synchronously
1593                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1594                         &quot;valid page index&quot;);
1595             }
1596             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1597                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1598                 // loaded already (we should load everything asynchronously in that case)
1599                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1600             }
1601             synchronized (mLock) {
1602                 if (mIsLoaderTaskRunning) {
1603                     // Ensure that we are never running the background loading at this point since
1604                     // we also touch the background collections
1605                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1606                 }
1607             }
1608 
1609             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1610             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1611             //      this call is synchronous, we can get away with not locking).
1612 
1613             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1614             // operations from the previous activity.  We need to ensure that all queued operations
1615             // are executed before any synchronous binding work is done.
1616             mHandler.flush();
1617 
1618             // Divide the set of loaded items into those that we are binding synchronously, and
1619             // everything else that is to be bound normally (asynchronously).
1620             bindWorkspace(synchronousBindPage, false);
1621             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1622             //      arise from that.
1623             onlyBindAllApps();
1624         }
1625 
1626         public void run() {
1627             boolean isUpgrade = false;
1628 
1629             synchronized (mLock) {
1630                 mIsLoaderTaskRunning = true;
1631             }
1632             // Optimize for end-user experience: if the Launcher is up and // running with the
1633             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1634             // workspace first (default).
1635             keep_running: {
1636                 // Elevate priority when Home launches for the first time to avoid
1637                 // starving at boot time. Staring at a blank home is not cool.
1638                 synchronized (mLock) {
1639                     if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1640                             (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1641                     android.os.Process.setThreadPriority(mIsLaunching
1642                             ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1643                 }
1644                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1645                 isUpgrade = loadAndBindWorkspace();
1646 
1647                 if (mStopped) {
1648                     break keep_running;
1649                 }
1650 
1651                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1652                 // settled down.
1653                 synchronized (mLock) {
1654                     if (mIsLaunching) {
1655                         if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1656                         android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1657                     }
1658                 }
1659                 waitForIdle();
1660 
1661                 // second step
1662                 if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1663                 loadAndBindAllApps();
1664 
1665                 // Restore the default thread priority after we are done loading items
1666                 synchronized (mLock) {
1667                     android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1668                 }
1669             }
1670 
1671             // Update the saved icons if necessary
1672             if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1673             synchronized (sBgLock) {
1674                 for (Object key : sBgDbIconCache.keySet()) {
1675                     updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1676                 }
1677                 sBgDbIconCache.clear();
1678             }
1679 
1680             if (LauncherAppState.isDisableAllApps()) {
1681                 // Ensure that all the applications that are in the system are
1682                 // represented on the home screen.
1683                 if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1684                     verifyApplications();
1685                 }
1686             }
1687 
1688             // Clear out this reference, otherwise we end up holding it until all of the
1689             // callback runnables are done.
1690             mContext = null;
1691 
1692             synchronized (mLock) {
1693                 // If we are still the last one to be scheduled, remove ourselves.
1694                 if (mLoaderTask == this) {
1695                     mLoaderTask = null;
1696                 }
1697                 mIsLoaderTaskRunning = false;
1698             }
1699         }
1700 
1701         public void stopLocked() {
1702             synchronized (LoaderTask.this) {
1703                 mStopped = true;
1704                 this.notify();
1705             }
1706         }
1707 
1708         /**
1709          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1710          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1711          * object that was around when the deferred message was scheduled, and if there&#x27;s
1712          * a new Callbacks object around then also return null.  This will save us from
1713          * calling onto it with data that will be ignored.
1714          */
1715         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1716             synchronized (mLock) {
1717                 if (mStopped) {
1718                     return null;
1719                 }
1720 
1721                 if (mCallbacks == null) {
1722                     return null;
1723                 }
1724 
1725                 final Callbacks callbacks = mCallbacks.get();
1726                 if (callbacks != oldCallbacks) {
1727                     return null;
1728                 }
1729                 if (callbacks == null) {
1730                     Log.w(TAG, &quot;no mCallbacks&quot;);
1731                     return null;
1732                 }
1733 
1734                 return callbacks;
1735             }
1736         }
1737 
1738         private void verifyApplications() {
1739             final Context context = mApp.getContext();
1740 
1741             // Cross reference all the applications in our apps list with items in the workspace
1742             ArrayList&lt;ItemInfo&gt; tmpInfos;
1743             ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1744             synchronized (sBgLock) {
1745                 for (AppInfo app : mBgAllAppsList.data) {
1746                     tmpInfos = getItemInfoForComponentName(app.componentName, app.user);
1747                     if (tmpInfos.isEmpty()) {
1748                         // We are missing an application icon, so add this to the workspace
1749                         added.add(app);
1750                         // This is a rare event, so lets log it
1751                         Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1752                     }
1753                 }
1754             }
1755             if (!added.isEmpty()) {
1756                 addAndBindAddedWorkspaceApps(context, added);
1757             }
1758         }
1759 
1760         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1761         private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1762                                            AtomicBoolean deleteOnInvalidPlacement) {
1763             LauncherAppState app = LauncherAppState.getInstance();
1764             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1765             final int countX = (int) grid.numColumns;
1766             final int countY = (int) grid.numRows;
1767 
1768             long containerIndex = item.screenId;
1769             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1770                 // Return early if we detect that an item is under the hotseat button
1771                 if (mCallbacks == null ||
1772                         mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1773                     deleteOnInvalidPlacement.set(true);
1774                     Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1775                             + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1776                             + item.cellY + &quot;) occupied by all apps&quot;);
1777                     return false;
1778                 }
1779 
1780                 final ItemInfo[][] hotseatItems =
1781                         occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1782 
1783                 if (item.screenId &gt;= grid.numHotseatIcons) {
1784                     Log.e(TAG, &quot;Error loading shortcut &quot; + item
1785                             + &quot; into hotseat position &quot; + item.screenId
1786                             + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1787                             + &quot;)&quot;);
1788                     return false;
1789                 }
1790 
1791                 if (hotseatItems != null) {
1792                     if (hotseatItems[(int) item.screenId][0] != null) {
1793                         Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1794                                 + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1795                                 + item.cellY + &quot;) occupied by &quot;
1796                                 + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1797                                 [(int) item.screenId][0]);
1798                             return false;
1799                     } else {
1800                         hotseatItems[(int) item.screenId][0] = item;
1801                         return true;
1802                     }
1803                 } else {
1804                     final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1805                     items[(int) item.screenId][0] = item;
1806                     occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1807                     return true;
1808                 }
1809             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1810                 // Skip further checking if it is not the hotseat or workspace container
1811                 return true;
1812             }
1813 
1814             if (!occupied.containsKey(item.screenId)) {
1815                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1816                 occupied.put(item.screenId, items);
1817             }
1818 
1819             final ItemInfo[][] screens = occupied.get(item.screenId);
1820             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1821                     item.cellX &lt; 0 || item.cellY &lt; 0 ||
1822                     item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1823                 Log.e(TAG, &quot;Error loading shortcut &quot; + item
1824                         + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1825                         + item.cellX + &quot;,&quot; + item.cellY
1826                         + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1827                 return false;
1828             }
1829 
1830             // Check if any workspace icons overlap with each other
1831             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1832                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1833                     if (screens[x][y] != null) {
1834                         Log.e(TAG, &quot;Error loading shortcut &quot; + item
1835                             + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1836                             + x + &quot;,&quot; + y
1837                             + &quot;) occupied by &quot;
1838                             + screens[x][y]);
1839                         return false;
1840                     }
1841                 }
1842             }
1843             for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1844                 for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1845                     screens[x][y] = item;
1846                 }
1847             }
1848 
1849             return true;
1850         }
1851 
1852         /** Clears all the sBg data structures */
1853         private void clearSBgDataStructures() {
1854             synchronized (sBgLock) {
1855                 sBgWorkspaceItems.clear();
1856                 sBgAppWidgets.clear();
1857                 sBgFolders.clear();
1858                 sBgItemsIdMap.clear();
1859                 sBgDbIconCache.clear();
1860                 sBgWorkspaceScreens.clear();
1861             }
1862         }
1863 
1864         /** Returns whether this is an upgrade path */
1865         private boolean loadWorkspace() {
1866             // Log to disk
1867             Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1868 
1869             final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1870 
1871             final Context context = mContext;
1872             final ContentResolver contentResolver = context.getContentResolver();
1873             final PackageManager manager = context.getPackageManager();
1874             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1875             final boolean isSafeMode = manager.isSafeMode();
1876             final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
1877             final boolean isSdCardReady = context.registerReceiver(null,
1878                     new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;
1879 
1880             LauncherAppState app = LauncherAppState.getInstance();
1881             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1882             int countX = (int) grid.numColumns;
1883             int countY = (int) grid.numRows;
1884 
1885             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1886                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1887                 LauncherAppState.getLauncherProvider().deleteDatabase();
1888             }
1889 
1890             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1891                 // append the user&#x27;s Launcher2 shortcuts
1892                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1893                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1894             } else {
1895                 // Make sure the default workspace is loaded
1896                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1897                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1898             }
1899 
1900             // This code path is for our old migration code and should no longer be exercised
1901             boolean loadedOldDb = false;
1902 
1903             // Log to disk
1904             Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1905 
1906             synchronized (sBgLock) {
1907                 clearSBgDataStructures();
1908                 final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat
1909                         .getInstance(mContext).updateAndGetActiveSessionCache();
1910 
1911                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1912                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1913                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;
1914                 if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
1915                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1916 
1917                 // +1 for the hotseat (it can be larger than the workspace)
1918                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1919                 // before any earlier duplicates)
1920                 final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
1921 
1922                 try {
1923                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1924                     final int intentIndex = c.getColumnIndexOrThrow
1925                             (LauncherSettings.Favorites.INTENT);
1926                     final int titleIndex = c.getColumnIndexOrThrow
1927                             (LauncherSettings.Favorites.TITLE);
1928                     final int iconTypeIndex = c.getColumnIndexOrThrow(
1929                             LauncherSettings.Favorites.ICON_TYPE);
1930                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
1931                     final int iconPackageIndex = c.getColumnIndexOrThrow(
1932                             LauncherSettings.Favorites.ICON_PACKAGE);
1933                     final int iconResourceIndex = c.getColumnIndexOrThrow(
1934                             LauncherSettings.Favorites.ICON_RESOURCE);
1935                     final int containerIndex = c.getColumnIndexOrThrow(
1936                             LauncherSettings.Favorites.CONTAINER);
1937                     final int itemTypeIndex = c.getColumnIndexOrThrow(
1938                             LauncherSettings.Favorites.ITEM_TYPE);
1939                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(
1940                             LauncherSettings.Favorites.APPWIDGET_ID);
1941                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
1942                             LauncherSettings.Favorites.APPWIDGET_PROVIDER);
1943                     final int screenIndex = c.getColumnIndexOrThrow(
1944                             LauncherSettings.Favorites.SCREEN);
1945                     final int cellXIndex = c.getColumnIndexOrThrow
1946                             (LauncherSettings.Favorites.CELLX);
1947                     final int cellYIndex = c.getColumnIndexOrThrow
1948                             (LauncherSettings.Favorites.CELLY);
1949                     final int spanXIndex = c.getColumnIndexOrThrow
1950                             (LauncherSettings.Favorites.SPANX);
1951                     final int spanYIndex = c.getColumnIndexOrThrow(
1952                             LauncherSettings.Favorites.SPANY);
1953                     final int restoredIndex = c.getColumnIndexOrThrow(
1954                             LauncherSettings.Favorites.RESTORED);
1955                     final int profileIdIndex = c.getColumnIndexOrThrow(
1956                             LauncherSettings.Favorites.PROFILE_ID);
1957                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1958                     //final int displayModeIndex = c.getColumnIndexOrThrow(
1959                     //        LauncherSettings.Favorites.DISPLAY_MODE);
1960 
1961                     ShortcutInfo info;
1962                     String intentDescription;
1963                     LauncherAppWidgetInfo appWidgetInfo;
1964                     int container;
1965                     long id;
1966                     Intent intent;
1967                     UserHandleCompat user;
1968 
1969                     while (!mStopped &amp;&amp; c.moveToNext()) {
1970                         AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
1971                         try {
1972                             int itemType = c.getInt(itemTypeIndex);
1973                             boolean restored = 0 != c.getInt(restoredIndex);
1974                             boolean allowMissingTarget = false;
1975 
1976                             switch (itemType) {
1977                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1978                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1979                                 id = c.getLong(idIndex);
1980                                 intentDescription = c.getString(intentIndex);
1981                                 long serialNumber = c.getInt(profileIdIndex);
1982                                 user = mUserManager.getUserForSerialNumber(serialNumber);
1983                                 int promiseType = c.getInt(restoredIndex);
1984                                 if (user == null) {
1985                                     // User has been deleted remove the item.
1986                                     itemsToRemove.add(id);
1987                                     continue;
1988                                 }
1989                                 try {
1990                                     intent = Intent.parseUri(intentDescription, 0);
1991                                     ComponentName cn = intent.getComponent();
1992                                     if (cn != null &amp;&amp; cn.getPackageName() != null) {
1993                                         boolean validPkg = launcherApps.isPackageEnabledForProfile(
1994                                                 cn.getPackageName(), user);
1995                                         boolean validComponent = validPkg &amp;&amp;
1996                                                 launcherApps.isActivityEnabledForProfile(cn, user);
1997 
1998                                         if (validComponent) {
1999                                             if (restored) {
2000                                                 // no special handling necessary for this item
2001                                                 restoredRows.add(id);
2002                                                 restored = false;
2003                                             }
2004                                         } else if (validPkg) {
2005                                             intent = null;
2006                                             if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
2007                                                 // We allow auto install apps to have their intent
2008                                                 // updated after an install.
2009                                                 intent = manager.getLaunchIntentForPackage(
2010                                                         cn.getPackageName());
2011                                                 if (intent != null) {
2012                                                     ContentValues values = new ContentValues();
2013                                                     values.put(LauncherSettings.Favorites.INTENT,
2014                                                             intent.toUri(0));
2015                                                     String where = BaseColumns._ID + &quot;= ?&quot;;
2016                                                     String[] args = {Long.toString(id)};
<abbr title="2017                                                     contentResolver.update(contentUri, values, where, args);">2017                                                     contentResolver.update(contentUri, values, where, arg🔵</abbr>
2018                                                 }
2019                                             }
2020 
2021                                             if (intent == null) {
2022                                                 // The app is installed but the component is no
2023                                                 // longer available.
2024                                                 Launcher.addDumpLog(TAG,
2025                                                         &quot;Invalid component removed: &quot; + cn, true);
2026                                                 itemsToRemove.add(id);
2027                                                 continue;
2028                                             } else {
2029                                                 // no special handling necessary for this item
2030                                                 restoredRows.add(id);
2031                                                 restored = false;
2032                                             }
2033                                         } else if (restored) {
2034                                             // Package is not yet available but might be
2035                                             // installed later.
2036                                             Launcher.addDumpLog(TAG,
2037                                                     &quot;package not yet restored: &quot; + cn, true);
2038 
2039                                             if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {
2040                                                 // Restore has started once.
2041                                             } else if (installingPkgs.contains(cn.getPackageName())) {
2042                                                 // App restore has started. Update the flag
2043                                                 promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
2044                                                 ContentValues values = new ContentValues();
2045                                                 values.put(LauncherSettings.Favorites.RESTORED,
2046                                                         promiseType);
2047                                                 String where = BaseColumns._ID + &quot;= ?&quot;;
2048                                                 String[] args = {Long.toString(id)};
2049                                                 contentResolver.update(contentUri, values, where, args);
2050 
2051                                             } else if (REMOVE_UNRESTORED_ICONS) {
2052                                                 Launcher.addDumpLog(TAG,
2053                                                         &quot;Unrestored package removed: &quot; + cn, true);
2054                                                 itemsToRemove.add(id);
2055                                                 continue;
2056                                             }
2057                                         } else if (isSdCardReady) {
2058                                             // Do not wait for external media load anymore.
2059                                             // Log the invalid package, and remove it
2060                                             Launcher.addDumpLog(TAG,
2061                                                     &quot;Invalid package removed: &quot; + cn, true);
2062                                             itemsToRemove.add(id);
2063                                             continue;
2064                                         } else {
2065                                             // SdCard is not ready yet. Package might get available,
2066                                             // once it is ready.
2067                                             Launcher.addDumpLog(TAG, &quot;Invalid package: &quot; + cn
2068                                                     + &quot; (check again later)&quot;, true);
2069                                             HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
2070                                             if (pkgs == null) {
2071                                                 pkgs = new HashSet&lt;String&gt;();
2072                                                 sPendingPackages.put(user, pkgs);
2073                                             }
2074                                             pkgs.add(cn.getPackageName());
2075                                             allowMissingTarget = true;
2076                                             // Add the icon on the workspace anyway.
2077                                         }
2078                                     } else if (cn == null) {
2079                                         // For shortcuts with no component, keep them as they are
2080                                         restoredRows.add(id);
2081                                         restored = false;
2082                                     }
2083                                 } catch (URISyntaxException e) {
2084                                     Launcher.addDumpLog(TAG,
2085                                             &quot;Invalid uri: &quot; + intentDescription, true);
2086                                     continue;
2087                                 }
2088 
2089                                 if (restored) {
2090                                     if (user.equals(UserHandleCompat.myUserHandle())) {
2091                                         Launcher.addDumpLog(TAG,
2092                                                 &quot;constructing info for partially restored package&quot;,
2093                                                 true);
2094                                         info = getRestoredItemInfo(c, titleIndex, intent, promiseType);
2095                                         intent = getRestoredItemIntent(c, context, intent);
2096                                     } else {
2097                                         // Don&#x27;t restore items for other profiles.
2098                                         itemsToRemove.add(id);
2099                                         continue;
2100                                     }
2101                                 } else if (itemType ==
2102                                         LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
2103                                     info = getShortcutInfo(manager, intent, user, context, c,
2104                                             iconIndex, titleIndex, mLabelCache, allowMissingTarget);
2105                                 } else {
2106                                     info = getShortcutInfo(c, context, iconTypeIndex,
2107                                             iconPackageIndex, iconResourceIndex, iconIndex,
2108                                             titleIndex);
2109 
2110                                     // App shortcuts that used to be automatically added to Launcher
2111                                     // didn&#x27;t always have the correct intent flags set, so do that
2112                                     // here
2113                                     if (intent.getAction() != null &amp;&amp;
2114                                         intent.getCategories() != null &amp;&amp;
2115                                         intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
2116                                         intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
2117                                         intent.addFlags(
2118                                             Intent.FLAG_ACTIVITY_NEW_TASK |
2119                                             Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
2120                                     }
2121                                 }
2122 
2123                                 if (info != null) {
2124                                     info.id = id;
2125                                     info.intent = intent;
2126                                     container = c.getInt(containerIndex);
2127                                     info.container = container;
2128                                     info.screenId = c.getInt(screenIndex);
2129                                     info.cellX = c.getInt(cellXIndex);
2130                                     info.cellY = c.getInt(cellYIndex);
2131                                     info.spanX = 1;
2132                                     info.spanY = 1;
2133                                     info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
2134                                     info.isDisabled = isSafeMode
2135                                             &amp;&amp; !Utilities.isSystemApp(context, intent);
2136 
2137                                     // check &amp; update map of what&#x27;s occupied
2138                                     deleteOnInvalidPlacement.set(false);
2139                                     if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {
2140                                         if (deleteOnInvalidPlacement.get()) {
2141                                             itemsToRemove.add(id);
2142                                         }
2143                                         break;
2144                                     }
2145 
2146                                     switch (container) {
2147                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2148                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2149                                         sBgWorkspaceItems.add(info);
2150                                         break;
2151                                     default:
2152                                         // Item is in a user folder
2153                                         FolderInfo folderInfo =
2154                                                 findOrMakeFolder(sBgFolders, container);
2155                                         folderInfo.add(info);
2156                                         break;
2157                                     }
2158                                     sBgItemsIdMap.put(info.id, info);
2159 
2160                                     // now that we&#x27;ve loaded everthing re-save it with the
2161                                     // icon in case it disappears somehow.
2162                                     queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
2163                                 } else {
2164                                     throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2165                                 }
2166                                 break;
2167 
2168                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
2169                                 id = c.getLong(idIndex);
2170                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2171 
2172                                 folderInfo.title = c.getString(titleIndex);
2173                                 folderInfo.id = id;
2174                                 container = c.getInt(containerIndex);
2175                                 folderInfo.container = container;
2176                                 folderInfo.screenId = c.getInt(screenIndex);
2177                                 folderInfo.cellX = c.getInt(cellXIndex);
2178                                 folderInfo.cellY = c.getInt(cellYIndex);
2179                                 folderInfo.spanX = 1;
2180                                 folderInfo.spanY = 1;
2181 
2182                                 // check &amp; update map of what&#x27;s occupied
2183                                 deleteOnInvalidPlacement.set(false);
2184                                 if (!checkItemPlacement(occupied, folderInfo,
2185                                         deleteOnInvalidPlacement)) {
2186                                     if (deleteOnInvalidPlacement.get()) {
2187                                         itemsToRemove.add(id);
2188                                     }
2189                                     break;
2190                                 }
2191 
2192                                 switch (container) {
2193                                     case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2194                                     case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2195                                         sBgWorkspaceItems.add(folderInfo);
2196                                         break;
2197                                 }
2198 
2199                                 if (restored) {
2200                                     // no special handling required for restored folders
2201                                     restoredRows.add(id);
2202                                 }
2203 
2204                                 sBgItemsIdMap.put(folderInfo.id, folderInfo);
2205                                 sBgFolders.put(folderInfo.id, folderInfo);
2206                                 break;
2207 
2208                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2209                                 // Read all Launcher-specific widget details
2210                                 int appWidgetId = c.getInt(appWidgetIdIndex);
2211                                 String savedProvider = c.getString(appWidgetProviderIndex);
2212                                 id = c.getLong(idIndex);
2213                                 final ComponentName component =
2214                                         ComponentName.unflattenFromString(savedProvider);
2215 
2216                                 final int restoreStatus = c.getInt(restoredIndex);
2217                                 final boolean isIdValid = (restoreStatus &amp;
2218                                         LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;
2219 
2220                                 final boolean wasProviderReady = (restoreStatus &amp;
2221                                         LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;
2222 
2223                                 final AppWidgetProviderInfo provider = isIdValid
2224                                         ? widgets.getAppWidgetInfo(appWidgetId)
2225                                         : findAppWidgetProviderInfoWithComponent(context, component);
2226 
2227                                 final boolean isProviderReady = isValidProvider(provider);
2228                                 if (!isSafeMode &amp;&amp; wasProviderReady &amp;&amp; !isProviderReady) {
2229                                     String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;
2230                                             + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;
2231                                     Log.e(TAG, log);
2232                                     Launcher.addDumpLog(TAG, log, false);
2233                                     itemsToRemove.add(id);
2234                                 } else {
2235                                     if (isProviderReady) {
2236                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2237                                                 provider.provider);
2238                                         int[] minSpan =
2239                                                 Launcher.getMinSpanForWidget(context, provider);
2240                                         appWidgetInfo.minSpanX = minSpan[0];
2241                                         appWidgetInfo.minSpanY = minSpan[1];
2242 
2243                                         int status = restoreStatus;
2244                                         if (!wasProviderReady) {
2245                                             // If provider was not previously ready, update the
2246                                             // status and UI flag.
2247 
<abbr title="2248                                             // Id would be valid only if the widget restore broadcast was received.">2248                                             // Id would be valid only if the widget restore broadcast was🔵</abbr>
2249                                             if (isIdValid) {
2250                                                 status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2251                                             } else {
2252                                                 status &amp;= ~LauncherAppWidgetInfo
2253                                                         .FLAG_PROVIDER_NOT_READY;
2254                                             }
2255                                         }
2256                                         appWidgetInfo.restoreStatus = status;
2257                                     } else {
2258                                         Log.v(TAG, &quot;Widget restore pending id=&quot; + id
2259                                                 + &quot; appWidgetId=&quot; + appWidgetId
2260                                                 + &quot; status =&quot; + restoreStatus);
2261                                         appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,
2262                                                 component);
2263                                         appWidgetInfo.restoreStatus = restoreStatus;
2264 
<abbr title="2265                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {">2265                                         if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) 🔵</abbr>
2266                                             // Restore has started once.
2267                                         } else if (installingPkgs.contains(component.getPackageName())) {
2268                                             // App restore has started. Update the flag
2269                                             appWidgetInfo.restoreStatus |=
2270                                                     LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;
2271                                         } else if (REMOVE_UNRESTORED_ICONS) {
2272                                             Launcher.addDumpLog(TAG,
2273                                                     &quot;Unrestored widget removed: &quot; + component, true);
2274                                             itemsToRemove.add(id);
2275                                             continue;
2276                                         }
2277                                     }
2278 
2279                                     appWidgetInfo.id = id;
2280                                     appWidgetInfo.screenId = c.getInt(screenIndex);
2281                                     appWidgetInfo.cellX = c.getInt(cellXIndex);
2282                                     appWidgetInfo.cellY = c.getInt(cellYIndex);
2283                                     appWidgetInfo.spanX = c.getInt(spanXIndex);
2284                                     appWidgetInfo.spanY = c.getInt(spanYIndex);
2285 
2286                                     container = c.getInt(containerIndex);
2287                                     if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2288                                         container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2289                                         Log.e(TAG, &quot;Widget found where container != &quot; +
2290                                             &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2291                                         continue;
2292                                     }
2293 
2294                                     appWidgetInfo.container = c.getInt(containerIndex);
2295                                     // check &amp; update map of what&#x27;s occupied
2296                                     deleteOnInvalidPlacement.set(false);
2297                                     if (!checkItemPlacement(occupied, appWidgetInfo,
2298                                             deleteOnInvalidPlacement)) {
2299                                         if (deleteOnInvalidPlacement.get()) {
2300                                             itemsToRemove.add(id);
2301                                         }
2302                                         break;
2303                                     }
2304 
2305                                     String providerName = appWidgetInfo.providerName.flattenToString();
2306                                     if (!providerName.equals(savedProvider) ||
2307                                             (appWidgetInfo.restoreStatus != restoreStatus)) {
2308                                         ContentValues values = new ContentValues();
2309                                         values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2310                                                 providerName);
2311                                         values.put(LauncherSettings.Favorites.RESTORED,
2312                                                 appWidgetInfo.restoreStatus);
2313                                         String where = BaseColumns._ID + &quot;= ?&quot;;
2314                                         String[] args = {Long.toString(id)};
2315                                         contentResolver.update(contentUri, values, where, args);
2316                                     }
2317                                     sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2318                                     sBgAppWidgets.add(appWidgetInfo);
2319                                 }
2320                                 break;
2321                             }
2322                         } catch (Exception e) {
2323                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2324                         }
2325                     }
2326                 } finally {
2327                     if (c != null) {
2328                         c.close();
2329                     }
2330                 }
2331 
2332                 // Break early if we&#x27;ve stopped loading
2333                 if (mStopped) {
2334                     clearSBgDataStructures();
2335                     return false;
2336                 }
2337 
2338                 if (itemsToRemove.size() &gt; 0) {
2339                     ContentProviderClient client = contentResolver.acquireContentProviderClient(
2340                             contentUri);
2341                     // Remove dead items
2342                     for (long id : itemsToRemove) {
2343                         if (DEBUG_LOADERS) {
2344                             Log.d(TAG, &quot;Removed id = &quot; + id);
2345                         }
2346                         // Don&#x27;t notify content observers
2347                         try {
2348                             client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2349                                     null, null);
2350                         } catch (RemoteException e) {
2351                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
2352                         }
2353                     }
2354                 }
2355 
2356                 if (restoredRows.size() &gt; 0) {
2357                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(
2358                             contentUri);
2359                     // Update restored items that no longer require special handling
2360                     try {
2361                         StringBuilder selectionBuilder = new StringBuilder();
2362                         selectionBuilder.append(LauncherSettings.Favorites._ID);
2363                         selectionBuilder.append(&quot; IN (&quot;);
2364                         selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2365                         selectionBuilder.append(&quot;)&quot;);
2366                         ContentValues values = new ContentValues();
2367                         values.put(LauncherSettings.Favorites.RESTORED, 0);
2368                         updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
2369                                 values, selectionBuilder.toString(), null);
2370                     } catch (RemoteException e) {
2371                         Log.w(TAG, &quot;Could not update restored rows&quot;);
2372                     }
2373                 }
2374 
2375                 if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) {
2376                     context.registerReceiver(new AppsAvailabilityCheck(),
2377                             new IntentFilter(StartupReceiver.SYSTEM_READY),
2378                             null, sWorker);
2379                 }
2380 
2381                 if (loadedOldDb) {
2382                     long maxScreenId = 0;
2383                     // If we&#x27;re importing we use the old screen order.
2384                     for (ItemInfo item: sBgItemsIdMap.values()) {
2385                         long screenId = item.screenId;
2386                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2387                                 !sBgWorkspaceScreens.contains(screenId)) {
2388                             sBgWorkspaceScreens.add(screenId);
2389                             if (screenId &gt; maxScreenId) {
2390                                 maxScreenId = screenId;
2391                             }
2392                         }
2393                     }
2394                     Collections.sort(sBgWorkspaceScreens);
2395                     // Log to disk
2396                     Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2397                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2398                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2399 
2400                     LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2401                     updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2402 
2403                     // Update the max item id after we load an old db
2404                     long maxItemId = 0;
2405                     // If we&#x27;re importing we use the old screen order.
2406                     for (ItemInfo item: sBgItemsIdMap.values()) {
2407                         maxItemId = Math.max(maxItemId, item.id);
2408                     }
2409                     LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2410                 } else {
2411                     TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2412                     for (Integer i : orderedScreens.keySet()) {
2413                         sBgWorkspaceScreens.add(orderedScreens.get(i));
2414                     }
2415                     // Log to disk
2416                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2417                             TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2418 
2419                     // Remove any empty screens
2420                     ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2421                     for (ItemInfo item: sBgItemsIdMap.values()) {
2422                         long screenId = item.screenId;
2423                         if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2424                                 unusedScreens.contains(screenId)) {
2425                             unusedScreens.remove(screenId);
2426                         }
2427                     }
2428 
2429                     // If there are any empty screens remove them, and update.
2430                     if (unusedScreens.size() != 0) {
2431                         // Log to disk
2432                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2433                                 TextUtils.join(&quot;, &quot;, unusedScreens), true);
2434 
2435                         sBgWorkspaceScreens.removeAll(unusedScreens);
2436                         updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2437                     }
2438                 }
2439 
2440                 if (DEBUG_LOADERS) {
2441                     Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2442                     Log.d(TAG, &quot;workspace layout: &quot;);
2443                     int nScreens = occupied.size();
2444                     for (int y = 0; y &lt; countY; y++) {
2445                         String line = &quot;&quot;;
2446 
2447                         Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2448                         while (iter.hasNext()) {
2449                             long screenId = iter.next();
2450                             if (screenId &gt; 0) {
2451                                 line += &quot; | &quot;;
2452                             }
2453                             for (int x = 0; x &lt; countX; x++) {
2454                                 ItemInfo[][] screen = occupied.get(screenId);
2455                                 if (x &lt; screen.length &amp;&amp; y &lt; screen[x].length) {
2456                                     line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2457                                 } else {
2458                                     line += &quot;!&quot;;
2459                                 }
2460                             }
2461                         }
2462                         Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2463                     }
2464                 }
2465             }
2466             return loadedOldDb;
2467         }
2468 
2469         /** Filters the set of items who are directly or indirectly (via another container) on the
2470          * specified screen. */
2471         private void filterCurrentWorkspaceItems(long currentScreenId,
2472                 ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2473                 ArrayList&lt;ItemInfo&gt; currentScreenItems,
2474                 ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2475             // Purge any null ItemInfos
2476             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2477             while (iter.hasNext()) {
2478                 ItemInfo i = iter.next();
2479                 if (i == null) {
2480                     iter.remove();
2481                 }
2482             }
2483 
2484             // Order the set of items by their containers first, this allows use to walk through the
2485             // list sequentially, build up a list of containers that are in the specified screen,
2486             // as well as all items in those containers.
2487             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2488             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2489                 @Override
2490                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2491                     return (int) (lhs.container - rhs.container);
2492                 }
2493             });
2494             for (ItemInfo info : allWorkspaceItems) {
2495                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2496                     if (info.screenId == currentScreenId) {
2497                         currentScreenItems.add(info);
2498                         itemsOnScreen.add(info.id);
2499                     } else {
2500                         otherScreenItems.add(info);
2501                     }
2502                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2503                     currentScreenItems.add(info);
2504                     itemsOnScreen.add(info.id);
2505                 } else {
2506                     if (itemsOnScreen.contains(info.container)) {
2507                         currentScreenItems.add(info);
2508                         itemsOnScreen.add(info.id);
2509                     } else {
2510                         otherScreenItems.add(info);
2511                     }
2512                 }
2513             }
2514         }
2515 
2516         /** Filters the set of widgets which are on the specified screen. */
2517         private void filterCurrentAppWidgets(long currentScreenId,
2518                 ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2519                 ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2520                 ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2521 
2522             for (LauncherAppWidgetInfo widget : appWidgets) {
2523                 if (widget == null) continue;
2524                 if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2525                         widget.screenId == currentScreenId) {
2526                     currentScreenWidgets.add(widget);
2527                 } else {
2528                     otherScreenWidgets.add(widget);
2529                 }
2530             }
2531         }
2532 
2533         /** Filters the set of folders which are on the specified screen. */
2534         private void filterCurrentFolders(long currentScreenId,
2535                 HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2536                 HashMap&lt;Long, FolderInfo&gt; folders,
2537                 HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2538                 HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2539 
2540             for (long id : folders.keySet()) {
2541                 ItemInfo info = itemsIdMap.get(id);
2542                 FolderInfo folder = folders.get(id);
2543                 if (info == null || folder == null) continue;
2544                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2545                         info.screenId == currentScreenId) {
2546                     currentScreenFolders.put(id, folder);
2547                 } else {
2548                     otherScreenFolders.put(id, folder);
2549                 }
2550             }
2551         }
2552 
2553         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2554          * right) */
2555         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2556             final LauncherAppState app = LauncherAppState.getInstance();
2557             final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2558             // XXX: review this
2559             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2560                 @Override
2561                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2562                     int cellCountX = (int) grid.numColumns;
2563                     int cellCountY = (int) grid.numRows;
2564                     int screenOffset = cellCountX * cellCountY;
2565                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2566                     long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2567                             lhs.cellY * cellCountX + lhs.cellX);
2568                     long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2569                             rhs.cellY * cellCountX + rhs.cellX);
2570                     return (int) (lr - rr);
2571                 }
2572             });
2573         }
2574 
2575         private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2576                 final ArrayList&lt;Long&gt; orderedScreens) {
2577             final Runnable r = new Runnable() {
2578                 @Override
2579                 public void run() {
2580                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2581                     if (callbacks != null) {
2582                         callbacks.bindScreens(orderedScreens);
2583                     }
2584                 }
2585             };
2586             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2587         }
2588 
2589         private void bindWorkspaceItems(final Callbacks oldCallbacks,
2590                 final ArrayList&lt;ItemInfo&gt; workspaceItems,
2591                 final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2592                 final HashMap&lt;Long, FolderInfo&gt; folders,
2593                 ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2594 
2595             final boolean postOnMainThread = (deferredBindRunnables != null);
2596 
2597             // Bind the workspace items
2598             int N = workspaceItems.size();
2599             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2600                 final int start = i;
2601                 final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2602                 final Runnable r = new Runnable() {
2603                     @Override
2604                     public void run() {
2605                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2606                         if (callbacks != null) {
2607                             callbacks.bindItems(workspaceItems, start, start+chunkSize,
2608                                     false);
2609                         }
2610                     }
2611                 };
2612                 if (postOnMainThread) {
2613                     synchronized (deferredBindRunnables) {
2614                         deferredBindRunnables.add(r);
2615                     }
2616                 } else {
2617                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2618                 }
2619             }
2620 
2621             // Bind the folders
2622             if (!folders.isEmpty()) {
2623                 final Runnable r = new Runnable() {
2624                     public void run() {
2625                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2626                         if (callbacks != null) {
2627                             callbacks.bindFolders(folders);
2628                         }
2629                     }
2630                 };
2631                 if (postOnMainThread) {
2632                     synchronized (deferredBindRunnables) {
2633                         deferredBindRunnables.add(r);
2634                     }
2635                 } else {
2636                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2637                 }
2638             }
2639 
2640             // Bind the widgets, one at a time
2641             N = appWidgets.size();
2642             for (int i = 0; i &lt; N; i++) {
2643                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2644                 final Runnable r = new Runnable() {
2645                     public void run() {
2646                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2647                         if (callbacks != null) {
2648                             callbacks.bindAppWidget(widget);
2649                         }
2650                     }
2651                 };
2652                 if (postOnMainThread) {
2653                     deferredBindRunnables.add(r);
2654                 } else {
2655                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2656                 }
2657             }
2658         }
2659 
2660         /**
2661          * Binds all loaded data to actual views on the main thread.
2662          */
2663         private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2664             final long t = SystemClock.uptimeMillis();
2665             Runnable r;
2666 
2667             // Don&#x27;t use these two variables in any of the callback runnables.
2668             // Otherwise we hold a reference to them.
2669             final Callbacks oldCallbacks = mCallbacks.get();
2670             if (oldCallbacks == null) {
2671                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2672                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2673                 return;
2674             }
2675 
2676             // Save a copy of all the bg-thread collections
2677             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2678             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2679                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2680             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2681             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2682             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2683             synchronized (sBgLock) {
2684                 workspaceItems.addAll(sBgWorkspaceItems);
2685                 appWidgets.addAll(sBgAppWidgets);
2686                 folders.putAll(sBgFolders);
2687                 itemsIdMap.putAll(sBgItemsIdMap);
2688                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2689             }
2690 
2691             final boolean isLoadingSynchronously =
2692                     synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2693             int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2694                 oldCallbacks.getCurrentWorkspaceScreen();
2695             if (currScreen &gt;= orderedScreenIds.size()) {
2696                 // There may be no workspace screens (just hotseat items and an empty page).
2697                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2698             }
2699             final int currentScreen = currScreen;
2700             final long currentScreenId = currentScreen &lt; 0
2701                     ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2702 
2703             // Load all the items that are on the current page first (and in the process, unbind
2704             // all the existing workspace items before we call startBinding() below.
2705             unbindWorkspaceItemsOnMainThread();
2706 
2707             // Separate the items that are on the current screen, and all the other remaining items
2708             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2709             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2710             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2711                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2712             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2713                     new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2714             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2715             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2716 
2717             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2718                     otherWorkspaceItems);
2719             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2720                     otherAppWidgets);
2721             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2722                     otherFolders);
2723             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2724             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2725 
2726             // Tell the workspace that we&#x27;re about to start binding items
2727             r = new Runnable() {
2728                 public void run() {
2729                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2730                     if (callbacks != null) {
2731                         callbacks.startBinding();
2732                     }
2733                 }
2734             };
2735             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2736 
2737             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2738 
2739             // Load items on the current page
2740             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2741                     currentFolders, null);
2742             if (isLoadingSynchronously) {
2743                 r = new Runnable() {
2744                     public void run() {
2745                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2746                         if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2747                             callbacks.onPageBoundSynchronously(currentScreen);
2748                         }
2749                     }
2750                 };
2751                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2752             }
2753 
2754             // Load all the remaining pages (if we are loading synchronously, we want to defer this
2755             // work until after the first render)
2756             synchronized (mDeferredBindRunnables) {
2757                 mDeferredBindRunnables.clear();
2758             }
2759             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2760                     (isLoadingSynchronously ? mDeferredBindRunnables : null));
2761 
2762             // Tell the workspace that we&#x27;re done binding items
2763             r = new Runnable() {
2764                 public void run() {
2765                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2766                     if (callbacks != null) {
2767                         callbacks.finishBindingItems(isUpgradePath);
2768                     }
2769 
2770                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2771                     if (DEBUG_LOADERS) {
2772                         Log.d(TAG, &quot;bound workspace in &quot;
2773                             + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2774                     }
2775 
2776                     mIsLoadingAndBindingWorkspace = false;
2777                 }
2778             };
2779             if (isLoadingSynchronously) {
2780                 synchronized (mDeferredBindRunnables) {
2781                     mDeferredBindRunnables.add(r);
2782                 }
2783             } else {
2784                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2785             }
2786         }
2787 
2788         private void loadAndBindAllApps() {
2789             if (DEBUG_LOADERS) {
2790                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2791             }
2792             if (!mAllAppsLoaded) {
2793                 loadAllApps();
2794                 synchronized (LoaderTask.this) {
2795                     if (mStopped) {
2796                         return;
2797                     }
2798                     mAllAppsLoaded = true;
2799                 }
2800             } else {
2801                 onlyBindAllApps();
2802             }
2803         }
2804 
2805         private void onlyBindAllApps() {
2806             final Callbacks oldCallbacks = mCallbacks.get();
2807             if (oldCallbacks == null) {
2808                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2809                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2810                 return;
2811             }
2812 
2813             // shallow copy
2814             @SuppressWarnings(&quot;unchecked&quot;)
2815             final ArrayList&lt;AppInfo&gt; list
2816                     = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
2817             Runnable r = new Runnable() {
2818                 public void run() {
2819                     final long t = SystemClock.uptimeMillis();
2820                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2821                     if (callbacks != null) {
2822                         callbacks.bindAllApplications(list);
2823                     }
2824                     if (DEBUG_LOADERS) {
2825                         Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
2826                                 + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2827                     }
2828                 }
2829             };
2830             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2831             if (isRunningOnMainThread) {
2832                 r.run();
2833             } else {
2834                 mHandler.post(r);
2835             }
2836         }
2837 
2838         private void loadAllApps() {
2839             final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2840 
2841             final Callbacks oldCallbacks = mCallbacks.get();
2842             if (oldCallbacks == null) {
2843                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2844                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2845                 return;
2846             }
2847 
2848             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2849             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2850 
2851             final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
2852 
2853             // Clear the list of apps
2854             mBgAllAppsList.clear();
2855             for (UserHandleCompat user : profiles) {
2856                 // Query for the set of apps
2857                 final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2858                 List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);
2859                 if (DEBUG_LOADERS) {
2860                     Log.d(TAG, &quot;getActivityList took &quot;
2861                             + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);
2862                     Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);
2863                 }
2864                 // Fail if we don&#x27;t have any apps
2865                 if (apps == null || apps.isEmpty()) {
2866                     return;
2867                 }
2868                 // Sort the applications by name
2869                 final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2870                 Collections.sort(apps,
2871                         new LauncherModel.ShortcutNameComparator(mLabelCache));
2872                 if (DEBUG_LOADERS) {
2873                     Log.d(TAG, &quot;sort took &quot;
2874                             + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);
2875                 }
2876 
2877                 // Create the ApplicationInfos
2878                 for (int i = 0; i &lt; apps.size(); i++) {
2879                     LauncherActivityInfoCompat app = apps.get(i);
2880                     // This builds the icon bitmaps.
2881                     mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));
2882                 }
2883             }
2884             // Huh? Shouldn&#x27;t this be inside the Runnable below?
2885             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2886             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2887 
2888             // Post callback on main thread
2889             mHandler.post(new Runnable() {
2890                 public void run() {
2891                     final long bindTime = SystemClock.uptimeMillis();
2892                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2893                     if (callbacks != null) {
2894                         callbacks.bindAllApplications(added);
2895                         if (DEBUG_LOADERS) {
2896                             Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
2897                                 + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
2898                         }
2899                     } else {
2900                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2901                     }
2902                 }
2903             });
2904 
2905             if (DEBUG_LOADERS) {
2906                 Log.d(TAG, &quot;Icons processed in &quot;
2907                         + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
2908             }
2909         }
2910 
2911         public void dumpState() {
2912             synchronized (sBgLock) {
2913                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2914                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2915                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2916                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2917                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2918             }
2919         }
2920     }
2921 
2922     void enqueuePackageUpdated(PackageUpdatedTask task) {
2923         sWorker.post(task);
2924     }
2925 
2926     private class AppsAvailabilityCheck extends BroadcastReceiver {
2927 
2928         @Override
2929         public void onReceive(Context context, Intent intent) {
2930             synchronized (sBgLock) {
2931                 final LauncherAppsCompat launcherApps = LauncherAppsCompat
2932                         .getInstance(mApp.getContext());
2933                 ArrayList&lt;String&gt; packagesRemoved;
2934                 for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
2935                     UserHandleCompat user = entry.getKey();
2936                     packagesRemoved = new ArrayList&lt;String&gt;();
2937                     for (String pkg : entry.getValue()) {
2938                         if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
2939                             Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
2940                             packagesRemoved.add(pkg);
2941                         }
2942                     }
2943                     if (!packagesRemoved.isEmpty()) {
2944                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,
2945                                 packagesRemoved.toArray(new String[packagesRemoved.size()]), user));
2946                     }
2947                 }
2948                 sPendingPackages.clear();
2949             }
2950         }
2951     }
2952 
2953     /**
2954      * Workaround to re-check unrestored items, in-case they were installed but the Package-ADD
2955      * runnable was missed by the launcher.
2956      */
2957     public void recheckRestoredItems(final Context context) {
2958         Runnable r = new Runnable() {
2959 
2960             @Override
2961             public void run() {
2962                 LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2963                 HashSet&lt;String&gt; installedPackages = new HashSet&lt;String&gt;();
2964                 UserHandleCompat user = UserHandleCompat.myUserHandle();
2965                 synchronized(sBgLock) {
2966                     for (ItemInfo info : sBgItemsIdMap.values()) {
2967                         if (info instanceof ShortcutInfo) {
2968                             ShortcutInfo si = (ShortcutInfo) info;
2969                             if (si.isPromise() &amp;&amp; si.getTargetComponent() != null
2970                                     &amp;&amp; launcherApps.isPackageEnabledForProfile(
2971                                             si.getTargetComponent().getPackageName(), user)) {
2972                                 installedPackages.add(si.getTargetComponent().getPackageName());
2973                             }
2974                         } else if (info instanceof LauncherAppWidgetInfo) {
2975                             LauncherAppWidgetInfo widget = (LauncherAppWidgetInfo) info;
2976                             if (widget.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)
2977                                     &amp;&amp; launcherApps.isPackageEnabledForProfile(
2978                                             widget.providerName.getPackageName(), user)) {
2979                                 installedPackages.add(widget.providerName.getPackageName());
2980                             }
2981                         }
2982                     }
2983                 }
2984 
2985                 if (!installedPackages.isEmpty()) {
2986                     final ArrayList&lt;AppInfo&gt; restoredApps = new ArrayList&lt;AppInfo&gt;();
2987                     for (String pkg : installedPackages) {
2988                         for (LauncherActivityInfoCompat info : launcherApps.getActivityList(pkg, user)) {
2989                             restoredApps.add(new AppInfo(context, info, user, mIconCache, null));
2990                         }
2991                     }
2992 
2993                     final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
2994                     if (!restoredApps.isEmpty()) {
2995                         mHandler.post(new Runnable() {
2996                             public void run() {
2997                                 Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
2998                                 if (callbacks == cb &amp;&amp; cb != null) {
2999                                     callbacks.bindAppsRestored(restoredApps);
3000                                 }
3001                             }
3002                         });
3003                     }
3004 
3005                 }
3006             }
3007         };
3008         sWorker.post(r);
3009     }
3010 
3011     private class PackageUpdatedTask implements Runnable {
3012         int mOp;
3013         String[] mPackages;
3014         UserHandleCompat mUser;
3015 
3016         public static final int OP_NONE = 0;
3017         public static final int OP_ADD = 1;
3018         public static final int OP_UPDATE = 2;
3019         public static final int OP_REMOVE = 3; // uninstlled
3020         public static final int OP_UNAVAILABLE = 4; // external media unmounted
3021 
3022 
3023         public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
3024             mOp = op;
3025             mPackages = packages;
3026             mUser = user;
3027         }
3028 
3029         public void run() {
3030             final Context context = mApp.getContext();
3031 
3032             final String[] packages = mPackages;
3033             final int N = packages.length;
3034             switch (mOp) {
3035                 case OP_ADD:
3036                     for (int i=0; i&lt;N; i++) {
3037                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
3038                         mIconCache.remove(packages[i], mUser);
3039                         mBgAllAppsList.addPackage(context, packages[i], mUser);
3040                     }
3041                     break;
3042                 case OP_UPDATE:
3043                     for (int i=0; i&lt;N; i++) {
3044                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
3045                         mBgAllAppsList.updatePackage(context, packages[i], mUser);
3046                         WidgetPreviewLoader.removePackageFromDb(
3047                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
3048                     }
3049                     break;
3050                 case OP_REMOVE:
3051                 case OP_UNAVAILABLE:
3052                     for (int i=0; i&lt;N; i++) {
3053                         if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
3054                         mBgAllAppsList.removePackage(packages[i], mUser);
3055                         WidgetPreviewLoader.removePackageFromDb(
3056                                 mApp.getWidgetPreviewCacheDb(), packages[i]);
3057                     }
3058                     break;
3059             }
3060 
3061             ArrayList&lt;AppInfo&gt; added = null;
3062             ArrayList&lt;AppInfo&gt; modified = null;
3063             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3064 
3065             if (mBgAllAppsList.added.size() &gt; 0) {
3066                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3067                 mBgAllAppsList.added.clear();
3068             }
3069             if (mBgAllAppsList.modified.size() &gt; 0) {
3070                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3071                 mBgAllAppsList.modified.clear();
3072             }
3073             if (mBgAllAppsList.removed.size() &gt; 0) {
3074                 removedApps.addAll(mBgAllAppsList.removed);
3075                 mBgAllAppsList.removed.clear();
3076             }
3077 
3078             final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
3079             if (callbacks == null) {
3080                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3081                 return;
3082             }
3083 
3084             if (added != null) {
3085                 // Ensure that we add all the workspace applications to the db
3086                 if (LauncherAppState.isDisableAllApps()) {
3087                     final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
3088                     addAndBindAddedWorkspaceApps(context, addedInfos);
3089                 } else {
3090                     addAppsToAllApps(context, added);
3091                 }
3092             }
3093 
3094             if (modified != null) {
3095                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3096 
3097                 // Update the launcher db to reflect the changes
3098                 for (AppInfo a : modifiedFinal) {
3099                     ArrayList&lt;ItemInfo&gt; infos =
3100                             getItemInfoForComponentName(a.componentName, mUser);
3101                     for (ItemInfo i : infos) {
3102                         if (isShortcutInfoUpdateable(i)) {
3103                             ShortcutInfo info = (ShortcutInfo) i;
3104                             info.title = a.title.toString();
3105                             info.contentDescription = a.contentDescription;
3106                             updateItemInDatabase(context, info);
3107                         }
3108                     }
3109                 }
3110 
3111                 mHandler.post(new Runnable() {
3112                     public void run() {
3113                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3114                         if (callbacks == cb &amp;&amp; cb != null) {
3115                             callbacks.bindAppsUpdated(modifiedFinal);
3116                         }
3117                     }
3118                 });
3119             }
3120 
3121             final ArrayList&lt;String&gt; removedPackageNames =
3122                     new ArrayList&lt;String&gt;();
3123             if (mOp == OP_REMOVE) {
3124                 // Mark all packages in the broadcast to be removed
3125                 removedPackageNames.addAll(Arrays.asList(packages));
3126             } else if (mOp == OP_UPDATE) {
3127                 // Mark disabled packages in the broadcast to be removed
3128                 final PackageManager pm = context.getPackageManager();
3129                 for (int i=0; i&lt;N; i++) {
3130                     if (isPackageDisabled(context, packages[i], mUser)) {
3131                         removedPackageNames.add(packages[i]);
3132                     }
3133                 }
3134             }
3135             // Remove all the components associated with this package
3136             for (String pn : removedPackageNames) {
3137                 deletePackageFromDatabase(context, pn, mUser);
3138             }
3139             // Remove all the specific components
3140             for (AppInfo a : removedApps) {
3141                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
3142                 deleteItemsFromDatabase(context, infos);
3143             }
3144             if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
3145                 // Remove any queued items from the install queue
3146                 String spKey = LauncherAppState.getSharedPreferencesKey();
3147                 SharedPreferences sp =
3148                         context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
3149                 InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
3150                 // Call the components-removed callback
3151                 mHandler.post(new Runnable() {
3152                     public void run() {
3153                         Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3154                         if (callbacks == cb &amp;&amp; cb != null) {
3155                             callbacks.bindComponentsRemoved(removedPackageNames, removedApps, mUser);
3156                         }
3157                     }
3158                 });
3159             }
3160 
3161             final ArrayList&lt;Object&gt; widgetsAndShortcuts =
3162                     getSortedWidgetsAndShortcuts(context);
3163             mHandler.post(new Runnable() {
3164                 @Override
3165                 public void run() {
3166                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3167                     if (callbacks == cb &amp;&amp; cb != null) {
3168                         callbacks.bindPackagesUpdated(widgetsAndShortcuts);
3169                     }
3170                 }
3171             });
3172 
3173             // Write all the logs to disk
3174             mHandler.post(new Runnable() {
3175                 public void run() {
3176                     Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3177                     if (callbacks == cb &amp;&amp; cb != null) {
3178                         callbacks.dumpLogsToLocalData();
3179                     }
3180                 }
3181             });
3182         }
3183     }
3184 
3185     // Returns a list of ResolveInfos/AppWindowInfos in sorted order
3186     public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
3187         PackageManager packageManager = context.getPackageManager();
3188         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
3189         widgetsAndShortcuts.addAll(AppWidgetManagerCompat.getInstance(context).getAllProviders());
3190 
3191         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3192         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
3193         Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));
3194         return widgetsAndShortcuts;
3195     }
3196 
3197     private static boolean isPackageDisabled(Context context, String packageName,
3198             UserHandleCompat user) {
3199         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3200         return !launcherApps.isPackageEnabledForProfile(packageName, user);
3201     }
3202 
3203     public static boolean isValidPackageActivity(Context context, ComponentName cn,
3204             UserHandleCompat user) {
3205         if (cn == null) {
3206             return false;
3207         }
3208         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3209         if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
3210             return false;
3211         }
3212         return launcherApps.isActivityEnabledForProfile(cn, user);
3213     }
3214 
3215     public static boolean isValidPackage(Context context, String packageName,
3216             UserHandleCompat user) {
3217         if (packageName == null) {
3218             return false;
3219         }
3220         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
3221         return launcherApps.isPackageEnabledForProfile(packageName, user);
3222     }
3223 
3224     /**
3225      * Make an ShortcutInfo object for a restored application or shortcut item that points
3226      * to a package that is not yet installed on the system.
3227      */
3228     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent,
3229             int promiseType) {
3230         final ShortcutInfo info = new ShortcutInfo();
3231         info.user = UserHandleCompat.myUserHandle();
3232         mIconCache.getTitleAndIcon(info, intent, info.user, true);
3233 
3234         if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
3235             String title = (cursor != null) ? cursor.getString(titleIndex) : null;
3236             if (!TextUtils.isEmpty(title)) {
3237                 info.title = title;
3238             }
3239             info.status = ShortcutInfo.FLAG_RESTORED_ICON;
3240         } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
3241             if (TextUtils.isEmpty(info.title)) {
3242                 info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;
3243             }
3244             info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;
3245         } else {
3246             throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
3247         }
3248 
3249         info.contentDescription = mUserManager.getBadgedLabelForUser(
3250                 info.title.toString(), info.user);
3251         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3252         info.promisedIntent = intent;
3253         return info;
3254     }
3255 
3256     /**
3257      * Make an Intent object for a restored application or shortcut item that points
3258      * to the market page for the item.
3259      */
3260     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
3261         ComponentName componentName = intent.getComponent();
3262         return getMarketIntent(componentName.getPackageName());
3263     }
3264 
3265     static Intent getMarketIntent(String packageName) {
3266         return new Intent(Intent.ACTION_VIEW)
3267             .setData(new Uri.Builder()
3268                 .scheme(&quot;market&quot;)
3269                 .authority(&quot;details&quot;)
3270                 .appendQueryParameter(&quot;id&quot;, packageName)
3271                 .build());
3272     }
3273 
3274     /**
3275      * This is called from the code that adds shortcuts from the intent receiver.  This
3276      * doesn&#x27;t have a Cursor, but
3277      */
3278     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3279             UserHandleCompat user, Context context) {
3280         return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);
3281     }
3282 
3283     /**
3284      * Make an ShortcutInfo object for a shortcut that is an application.
3285      *
3286      * If c is not null, then it will be used to fill in missing data like the title and icon.
3287      */
3288     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,
3289             UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,
3290             HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {
3291         if (user == null) {
3292             Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
3293             return null;
3294         }
3295 
3296         ComponentName componentName = intent.getComponent();
3297         if (componentName == null) {
3298             Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
3299             return null;
3300         }
3301 
3302         Intent newIntent = new Intent(intent.getAction(), null);
3303         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3304         newIntent.setComponent(componentName);
3305         LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
3306         if ((lai == null) &amp;&amp; !allowMissingTarget) {
3307             Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
3308             return null;
3309         }
3310 
3311         final ShortcutInfo info = new ShortcutInfo();
3312 
3313         // the resource -- This may implicitly give us back the fallback icon,
3314         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
3315         // to avoid saving lots of copies of that in the database, and most apps
3316         // have icons anyway.
3317         Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);
3318 
3319         // the db
3320         if (icon == null) {
3321             if (c != null) {
3322                 icon = getIconFromCursor(c, iconIndex, context);
3323             }
3324         }
3325         // the fallback icon
3326         if (icon == null) {
3327             icon = mIconCache.getDefaultIcon(user);
3328             info.usingFallbackIcon = true;
3329         }
3330         info.setIcon(icon);
3331 
3332         // From the cache.
3333         if (labelCache != null) {
3334             info.title = labelCache.get(componentName);
3335         }
3336 
3337         // from the resource
3338         if (info.title == null &amp;&amp; lai != null) {
3339             info.title = lai.getLabel();
3340             if (labelCache != null) {
3341                 labelCache.put(componentName, info.title);
3342             }
3343         }
3344         // from the db
3345         if (info.title == null) {
3346             if (c != null) {
3347                 info.title =  c.getString(titleIndex);
3348             }
3349         }
3350         // fall back to the class name of the activity
3351         if (info.title == null) {
3352             info.title = componentName.getClassName();
3353         }
3354         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
3355         info.user = user;
3356         info.contentDescription = mUserManager.getBadgedLabelForUser(
3357                 info.title.toString(), info.user);
3358         return info;
3359     }
3360 
3361     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
3362             ItemInfoFilter f) {
3363         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3364         for (ItemInfo i : infos) {
3365             if (i instanceof ShortcutInfo) {
3366                 ShortcutInfo info = (ShortcutInfo) i;
3367                 ComponentName cn = info.getTargetComponent();
3368                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3369                     filtered.add(info);
3370                 }
3371             } else if (i instanceof FolderInfo) {
3372                 FolderInfo info = (FolderInfo) i;
3373                 for (ShortcutInfo s : info.contents) {
3374                     ComponentName cn = s.getTargetComponent();
3375                     if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3376                         filtered.add(s);
3377                     }
3378                 }
3379             } else if (i instanceof LauncherAppWidgetInfo) {
3380                 LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3381                 ComponentName cn = info.providerName;
3382                 if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3383                     filtered.add(info);
3384                 }
3385             }
3386         }
3387         return new ArrayList&lt;ItemInfo&gt;(filtered);
3388     }
3389 
3390     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,
3391             final UserHandleCompat user) {
3392         ItemInfoFilter filter  = new ItemInfoFilter() {
3393             @Override
3394             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3395                 if (info.user == null) {
3396                     return cn.equals(cname);
3397                 } else {
3398                     return cn.equals(cname) &amp;&amp; info.user.equals(user);
3399                 }
3400             }
3401         };
3402         return filterItemInfos(sBgItemsIdMap.values(), filter);
3403     }
3404 
3405     public static boolean isShortcutInfoUpdateable(ItemInfo i) {
3406         if (i instanceof ShortcutInfo) {
3407             ShortcutInfo info = (ShortcutInfo) i;
3408             // We need to check for ACTION_MAIN otherwise getComponent() might
3409             // return null for some shortcuts (for instance, for shortcuts to
3410             // web pages.)
3411             Intent intent = info.intent;
3412             ComponentName name = intent.getComponent();
3413             if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3414                     Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3415                 return true;
3416             }
3417             // placeholder shortcuts get special treatment, let them through too.
3418             if (info.isPromise()) {
3419                 return true;
3420             }
3421         }
3422         return false;
3423     }
3424 
3425     /**
3426      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3427      */
3428     private ShortcutInfo getShortcutInfo(Cursor c, Context context,
3429             int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
3430             int titleIndex) {
3431 
3432         Bitmap icon = null;
3433         final ShortcutInfo info = new ShortcutInfo();
3434         // Non-app shortcuts are only supported for current user.
3435         info.user = UserHandleCompat.myUserHandle();
3436         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3437 
3438         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3439 
3440         info.title = c.getString(titleIndex);
3441 
3442         int iconType = c.getInt(iconTypeIndex);
3443         switch (iconType) {
3444         case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
3445             String packageName = c.getString(iconPackageIndex);
3446             String resourceName = c.getString(iconResourceIndex);
3447             PackageManager packageManager = context.getPackageManager();
3448             info.customIcon = false;
3449             // the resource
3450             try {
3451                 Resources resources = packageManager.getResourcesForApplication(packageName);
3452                 if (resources != null) {
3453                     final int id = resources.getIdentifier(resourceName, null, null);
3454                     icon = Utilities.createIconBitmap(
3455                             mIconCache.getFullResIcon(resources, id), context);
3456                 }
3457             } catch (Exception e) {
3458                 // drop this.  we have other places to look for icons
3459             }
3460             // the db
3461             if (icon == null) {
3462                 icon = getIconFromCursor(c, iconIndex, context);
3463             }
3464             // the fallback icon
3465             if (icon == null) {
3466                 icon = mIconCache.getDefaultIcon(info.user);
3467                 info.usingFallbackIcon = true;
3468             }
3469             break;
3470         case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
3471             icon = getIconFromCursor(c, iconIndex, context);
3472             if (icon == null) {
3473                 icon = mIconCache.getDefaultIcon(info.user);
3474                 info.customIcon = false;
3475                 info.usingFallbackIcon = true;
3476             } else {
3477                 info.customIcon = true;
3478             }
3479             break;
3480         default:
3481             icon = mIconCache.getDefaultIcon(info.user);
3482             info.usingFallbackIcon = true;
3483             info.customIcon = false;
3484             break;
3485         }
3486         info.setIcon(icon);
3487         return info;
3488     }
3489 
3490     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3491         @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3492         final boolean debug = false;
3493         if (debug) {
3494             Log.d(TAG, &quot;getIconFromCursor app=&quot;
3495                     + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3496         }
3497         byte[] data = c.getBlob(iconIndex);
3498         try {
3499             return Utilities.createIconBitmap(
3500                     BitmapFactory.decodeByteArray(data, 0, data.length), context);
3501         } catch (Exception e) {
3502             return null;
3503         }
3504     }
3505 
3506     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
3507             int cellX, int cellY, boolean notify) {
3508         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3509         if (info == null) {
3510             return null;
3511         }
3512         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3513 
3514         return info;
3515     }
3516 
3517     /**
3518      * Attempts to find an AppWidgetProviderInfo that matches the given component.
3519      */
3520     static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,
3521             ComponentName component) {
3522         List&lt;AppWidgetProviderInfo&gt; widgets =
3523             AppWidgetManager.getInstance(context).getInstalledProviders();
3524         for (AppWidgetProviderInfo info : widgets) {
3525             if (info.provider.equals(component)) {
3526                 return info;
3527             }
3528         }
3529         return null;
3530     }
3531 
3532     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3533         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3534         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3535         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3536 
3537         if (intent == null) {
3538             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3539             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3540             return null;
3541         }
3542 
3543         Bitmap icon = null;
3544         boolean customIcon = false;
3545         ShortcutIconResource iconResource = null;
3546 
3547         if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
3548             icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
3549             customIcon = true;
3550         } else {
3551             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3552             if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
3553                 try {
3554                     iconResource = (ShortcutIconResource) extra;
3555                     final PackageManager packageManager = context.getPackageManager();
3556                     Resources resources = packageManager.getResourcesForApplication(
3557                             iconResource.packageName);
3558                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
3559                     icon = Utilities.createIconBitmap(
3560                             mIconCache.getFullResIcon(resources, id),
3561                             context);
3562                 } catch (Exception e) {
3563                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
3564                 }
3565             }
3566         }
3567 
3568         final ShortcutInfo info = new ShortcutInfo();
3569 
3570         // Only support intents for current user for now. Intents sent from other
3571         // users wouldn&#x27;t get here without intent forwarding anyway.
3572         info.user = UserHandleCompat.myUserHandle();
3573         if (icon == null) {
3574             if (fallbackIcon != null) {
3575                 icon = fallbackIcon;
3576             } else {
3577                 icon = mIconCache.getDefaultIcon(info.user);
3578                 info.usingFallbackIcon = true;
3579             }
3580         }
3581         info.setIcon(icon);
3582 
3583         info.title = name;
3584         info.contentDescription = mUserManager.getBadgedLabelForUser(
3585                 info.title.toString(), info.user);
3586         info.intent = intent;
3587         info.customIcon = customIcon;
3588         info.iconResource = iconResource;
3589 
3590         return info;
3591     }
3592 
3593     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3594             int iconIndex) {
3595         // If apps can&#x27;t be on SD, don&#x27;t even bother.
3596         if (!mAppsCanBeOnRemoveableStorage) {
3597             return false;
3598         }
3599         // If this icon doesn&#x27;t have a custom icon, check to see
3600         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3601         // we&#x27;re going to show, store what we are going to show back
3602         // into the DB.  We do this so when we&#x27;re loading, if the
3603         // package manager can&#x27;t find an icon (for example because
3604         // the app is on SD) then we can use that instead.
3605         if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
3606             cache.put(info, c.getBlob(iconIndex));
3607             return true;
3608         }
3609         return false;
3610     }
3611     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3612         boolean needSave = false;
3613         try {
3614             if (data != null) {
3615                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3616                 Bitmap loaded = info.getIcon(mIconCache);
3617                 needSave = !saved.sameAs(loaded);
3618             } else {
3619                 needSave = true;
3620             }
3621         } catch (Exception e) {
3622             needSave = true;
3623         }
3624         if (needSave) {
3625             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3626             // This is slower than is ideal, but this only happens once
3627             // or when the app is updated with a new icon.
3628             updateItemInDatabase(context, info);
3629         }
3630     }
3631 
3632     /**
3633      * Return an existing FolderInfo object if we have encountered this ID previously,
3634      * or make a new one.
3635      */
3636     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3637         // See if a placeholder was created for us already
3638         FolderInfo folderInfo = folders.get(id);
3639         if (folderInfo == null) {
3640             // No placeholder -- create a new instance
3641             folderInfo = new FolderInfo();
3642             folders.put(id, folderInfo);
3643         }
3644         return folderInfo;
3645     }
3646 
3647     public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3648         final Collator collator = Collator.getInstance();
3649         return new Comparator&lt;AppInfo&gt;() {
3650             public final int compare(AppInfo a, AppInfo b) {
3651                 if (a.user.equals(b.user)) {
3652                     int result = collator.compare(a.title.toString().trim(),
3653                             b.title.toString().trim());
3654                     if (result == 0) {
3655                         result = a.componentName.compareTo(b.componentName);
3656                     }
3657                     return result;
3658                 } else {
3659                     // TODO Need to figure out rules for sorting
3660                     // profiles, this puts work second.
3661                     return a.user.toString().compareTo(b.user.toString());
3662                 }
3663             }
3664         };
3665     }
3666     public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
3667             = new Comparator&lt;AppInfo&gt;() {
3668         public final int compare(AppInfo a, AppInfo b) {
3669             if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
3670             if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
3671             return 0;
3672         }
3673     };
3674     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3675         if (info.activityInfo != null) {
3676             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3677         } else {
3678             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3679         }
3680     }
3681     public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {
3682         private Collator mCollator;
3683         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3684         ShortcutNameComparator(PackageManager pm) {
3685             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3686             mCollator = Collator.getInstance();
3687         }
3688         ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {
3689             mLabelCache = labelCache;
3690             mCollator = Collator.getInstance();
3691         }
3692         public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {
3693             String labelA, labelB;
3694             ComponentName keyA = a.getComponentName();
3695             ComponentName keyB = b.getComponentName();
3696             if (mLabelCache.containsKey(keyA)) {
3697                 labelA = mLabelCache.get(keyA).toString();
3698             } else {
3699                 labelA = a.getLabel().toString().trim();
3700 
3701                 mLabelCache.put(keyA, labelA);
3702             }
3703             if (mLabelCache.containsKey(keyB)) {
3704                 labelB = mLabelCache.get(keyB).toString();
3705             } else {
3706                 labelB = b.getLabel().toString().trim();
3707 
3708                 mLabelCache.put(keyB, labelB);
3709             }
3710             return mCollator.compare(labelA, labelB);
3711         }
3712     };
3713     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3714         private final AppWidgetManagerCompat mManager;
3715         private final PackageManager mPackageManager;
3716         private final HashMap&lt;Object, String&gt; mLabelCache;
3717         private final Collator mCollator;
3718 
3719         WidgetAndShortcutNameComparator(Context context) {
3720             mManager = AppWidgetManagerCompat.getInstance(context);
3721             mPackageManager = context.getPackageManager();
3722             mLabelCache = new HashMap&lt;Object, String&gt;();
3723             mCollator = Collator.getInstance();
3724         }
3725         public final int compare(Object a, Object b) {
3726             String labelA, labelB;
3727             if (mLabelCache.containsKey(a)) {
3728                 labelA = mLabelCache.get(a);
3729             } else {
3730                 labelA = (a instanceof AppWidgetProviderInfo)
3731                         ? mManager.loadLabel((AppWidgetProviderInfo) a)
3732                         : ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();
3733                 mLabelCache.put(a, labelA);
3734             }
3735             if (mLabelCache.containsKey(b)) {
3736                 labelB = mLabelCache.get(b);
3737             } else {
3738                 labelB = (b instanceof AppWidgetProviderInfo)
3739                         ? mManager.loadLabel((AppWidgetProviderInfo) b)
3740                         : ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();
3741                 mLabelCache.put(b, labelB);
3742             }
3743             return mCollator.compare(labelA, labelB);
3744         }
3745     };
3746 
3747     static boolean isValidProvider(AppWidgetProviderInfo provider) {
3748         return (provider != null) &amp;&amp; (provider.provider != null)
3749                 &amp;&amp; (provider.provider.getPackageName() != null);
3750     }
3751 
3752     public void dumpState() {
3753         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3754         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3755         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3756         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3757         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3758         if (mLoaderTask != null) {
3759             mLoaderTask.dumpState();
3760         } else {
3761             Log.d(TAG, &quot;mLoaderTask=null&quot;);
3762         }
3763     }
3764 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.SearchManager;
  19 import android.appwidget.AppWidgetManager;
  20 import android.appwidget.AppWidgetProviderInfo;
  21 import android.content.BroadcastReceiver;
  22 import android.content.ComponentName;
  23 import android.content.ContentProviderClient;
  24 import android.content.ContentProviderOperation;
  25 import android.content.ContentResolver;
  26 import android.content.ContentValues;
  27 import android.content.Context;
  28 import android.content.Intent.ShortcutIconResource;
  29 import android.content.Intent;
  30 import android.content.IntentFilter;
  31 import android.content.SharedPreferences;
  32 import android.content.pm.PackageManager;
  33 import android.content.pm.ProviderInfo;
  34 import android.content.pm.ResolveInfo;
  35 import android.content.res.Configuration;
  36 import android.content.res.Resources;
  37 import android.database.Cursor;
  38 import android.graphics.Bitmap;
  39 import android.graphics.BitmapFactory;
  40 import android.net.Uri;
  41 import android.os.Environment;
  42 import android.os.Handler;
  43 import android.os.HandlerThread;
  44 import android.os.Parcelable;
  45 import android.os.Process;
  46 import android.os.RemoteException;
  47 import android.os.SystemClock;
  48 import android.provider.BaseColumns;
  49 import android.text.TextUtils;
  50 import android.util.Log;
  51 import android.util.Pair;
  52 import com.android.launcher3.compat.AppWidgetManagerCompat;
  53 import com.android.launcher3.compat.LauncherActivityInfoCompat;
  54 import com.android.launcher3.compat.LauncherAppsCompat;
  55 import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;
  56 import com.android.launcher3.compat.PackageInstallerCompat;
  57 import com.android.launcher3.compat.UserHandleCompat;
  58 import com.android.launcher3.compat.UserManagerCompat;
  59 import java.lang.ref.WeakReference;
  60 import java.net.URISyntaxException;
  61 import java.security.InvalidParameterException;
  62 import java.text.Collator;
  63 import java.util.ArrayList;
  64 import java.util.Arrays;
  65 import java.util.Collection;
  66 import java.util.Collections;
  67 import java.util.Comparator;
  68 import java.util.HashMap;
  69 import java.util.HashSet;
  70 import java.util.Iterator;
  71 import java.util.List;
  72 import java.util.Map.Entry;
  73 import java.util.Set;
  74 import java.util.TreeMap;
  75 import java.util.concurrent.atomic.AtomicBoolean;
  76 
  77 
  78 /**
  79  * Maintains in-memory state of the Launcher. It is expected that there should be only one
  80  * LauncherModel object held in a static. Also provide APIs for updating the database state
  81  * for the Launcher.
  82  */
<abbr title="  83 public class LauncherModel extends BroadcastReceiver implements LauncherAppsCompat.OnAppsChangedCallbackCompat {">  83 public class LauncherModel extends BroadcastReceiver implements LauncherAppsCompat.OnAppsChangedCallbackC🔵</abbr>
  84     static final boolean DEBUG_LOADERS = false;
  85 
  86     private static final boolean DEBUG_RECEIVER = false;
  87 
  88     private static final boolean REMOVE_UNRESTORED_ICONS = true;
  89 
  90     static final String TAG = &quot;Launcher.Model&quot;;
  91 
  92     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  93     // false = strew non-workspace apps across the workspace on upgrade
  94     // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
  95     // false = strew non-workspace apps across the workspace on upgrade
  96     public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
  97 
  98     public static final int LOADER_FLAG_NONE = 0;
  99 
 100     public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
 101 
 102     public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
 103 
 104     // batch size for the workspace icons
 105     private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 106 
 107     private static final long INVALID_SCREEN_ID = -1L;
 108 
 109     private final boolean mAppsCanBeOnRemoveableStorage;
 110 
 111     private final boolean mOldContentProviderExists;
 112 
 113     private final LauncherAppState mApp;
 114 
 115     private final Object mLock = new Object();
 116 
 117     private DeferredHandler mHandler = new DeferredHandler();
 118 
 119     private LoaderTask mLoaderTask;
 120 
 121     private boolean mIsLoaderTaskRunning;
 122 
 123     private volatile boolean mFlushingWorkerThread;
 124 
 125     // Specific runnable types that are run on the main thread deferred handler, this allows us to
 126     // clear all queued binding runnables when the Launcher activity is destroyed.
 127     private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 128 
 129     private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
 130 
 131     private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;
 132 
 133     private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 134 
 135     static {
 136         sWorkerThread.start();
 137     }
 138 
 139     private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 140 
 141     // We start off with everything not loaded.  After that, we assume that
 142     // our monitoring of the package manager provides all updates and we never
 143     // need to do a requery.  These are only ever touched from the loader thread.
 144     private boolean mWorkspaceLoaded;
 145 
 146     private boolean mAllAppsLoaded;
 147 
 148     // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 149     // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 150     // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 151     // a normal load, we also clear this set of Runnables.
 152     static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 153 
 154     private WeakReference&lt;Callbacks&gt; mCallbacks;
 155 
 156     // &lt; only access in worker thread &gt;
 157     // &lt; only access in worker thread &gt;
 158     AllAppsList mBgAllAppsList;
 159 
 160     // The lock that must be acquired before referencing any static bg data structures.  Unlike
 161     // other locks, this one can generally be held long-term because we never expect any of these
 162     // static data structures to be referenced outside of the worker thread except on the first
 163     // load after configuration change.
 164     static final Object sBgLock = new Object();
 165 
 166     // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 167     // LauncherModel to their ids
 168     static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 169 
 170     // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 171     //       created by LauncherModel that are directly on the home screen (however, no widgets or
 172     //       shortcuts within folders).
 173     static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 174 
 175     // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 176     static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 177 
 178     // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 179     static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 180 
 181     // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 182     static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 183 
 184     // sBgWorkspaceScreens is the ordered set of workspace screens.
 185     // sBgWorkspaceScreens is the ordered set of workspace screens.
 186     static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 187 
 188     // sPendingPackages is a set of packages which could be on sdcard and are not available yet
<abbr title=" 189     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages = new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();"> 189     static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages = new HashMap&lt;UserHandleComp🔵</abbr>
 190 
 191     // &lt;/ only access in worker thread &gt;
 192     // &lt;/ only access in worker thread &gt;
 193 
 194     private IconCache mIconCache;
 195 
 196     protected int mPreviousConfigMcc;
 197 
 198     private final LauncherAppsCompat mLauncherApps;
 199 
 200     private final UserManagerCompat mUserManager;
 201 
 202     public interface Callbacks {
 203         public boolean setLoadOnResume();
 204 
 205         public int getCurrentWorkspaceScreen();
 206 
 207         public void startBinding();
 208 
<abbr title=" 209         public abstract void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end, boolean forceAnimateIcons);"> 209         public abstract void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end, boolean forceAn🔵</abbr>
 210 
 211         public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 212 
 213         public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 214 
 215         public abstract void bindFolders(HashMap&lt;Long, FolderInfo&gt; folders);
 216 
 217         public void finishBindingItems(boolean upgradePath);
 218 
 219         public abstract void bindAppWidget(LauncherAppWidgetInfo info);
 220 
 221         public abstract void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 222 
<abbr title=" 223         public abstract void bindAppsAdded(ArrayList&lt;Long&gt; newScreens, ArrayList&lt;ItemInfo&gt; addNotAnimated, ArrayList&lt;ItemInfo&gt; addAnimated, ArrayList&lt;AppInfo&gt; addedApps);"> 223         public abstract void bindAppsAdded(ArrayList&lt;Long&gt; newScreens, ArrayList&lt;ItemInfo&gt; addNotAnimated🔵</abbr>
 224 
 225         public abstract void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
 226 
 227         public void bindAppsRestored(ArrayList&lt;AppInfo&gt; apps);
 228 
 229         public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);
 230 
 231         public void updatePackageBadge(String packageName);
 232 
<abbr title=" 233         public abstract void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames, ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user);"> 233         public abstract void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames, ArrayList&lt;AppInfo&gt; app🔵</abbr>
 234 
 235         public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 236 
 237         public void bindSearchablesChanged();
 238 
 239         public boolean isAllAppsButtonRank(int rank);
 240 
 241         public void onPageBoundSynchronously(int page);
 242 
 243         public void dumpLogsToLocalData();
 244     }
 245 
 246     public interface ItemInfoFilter {
 247         public abstract boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 248     }
 249 
 250     LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 251         Context context = app.getContext();
 252         mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
 253         String oldProvider = context.getString(R.string.old_launcher_provider_uri);
 254         // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different
 255         // resource string.
 256         String redirectAuthority = Uri.parse(oldProvider).getAuthority();
<abbr title=" 257         ProviderInfo providerInfo = context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);"> 257         ProviderInfo providerInfo = context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY,🔵</abbr>
<abbr title=" 258         ProviderInfo redirectProvider = context.getPackageManager().resolveContentProvider(redirectAuthority, 0);"> 258         ProviderInfo redirectProvider = context.getPackageManager().resolveContentProvider(redirectAuthor🔵</abbr>
 259         Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);
 260         mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);
 261         if (mOldContentProviderExists) {
 262             Log.d(TAG, &quot;Old launcher provider exists.&quot;);
 263         } else {
 264             Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);
 265         }
 266         mApp = app;
 267         mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 268         mIconCache = iconCache;
 269         final Resources res = context.getResources();
 270         Configuration config = res.getConfiguration();
 271         mPreviousConfigMcc = config.mcc;
 272         mLauncherApps = LauncherAppsCompat.getInstance(context);
 273         mUserManager = UserManagerCompat.getInstance(context);
 274     }
 275 
 276     /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 277      * posted on the main thread handler. */
 278     private void runOnMainThread(Runnable r) {
 279         runOnMainThread(r, 0);
 280     }
 281 
 282     private void runOnMainThread(Runnable r, int type) {
 283         if (sWorkerThread.getThreadId() == Process.myTid()) {
 284             // If we are on the worker thread, post onto the main handler
 285             mHandler.post(r);
 286         } else {
 287             r.run();
 288         }
 289     }
 290 
 291     /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 292      * posted on the worker thread handler. */
 293     private static void runOnWorkerThread(Runnable r) {
 294         if (sWorkerThread.getThreadId() == Process.myTid()) {
 295             r.run();
 296         } else {
 297             // If we are not on the worker thread, then post to the worker handler
 298             sWorker.post(r);
 299         }
 300     }
 301 
 302     boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 303         return mOldContentProviderExists &amp;&amp; (!launcher.isLauncherPreinstalled());
 304     }
 305 
 306     static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy, long screen) {
 307         LauncherAppState app = LauncherAppState.getInstance();
 308         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 309         final int xCount = ((int) (grid.numColumns));
 310         final int yCount = ((int) (grid.numRows));
 311         boolean[][] occupied = new boolean[xCount][yCount];
 312         int cellX;
 313         int cellY;
 314         int spanX;
 315         int spanY;
 316         for (int i = 0; i &lt; items.size(); ++i) {
 317             final ItemInfo item = items.get(i);
 318             if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 319                 if (item.screenId == screen) {
 320                     cellX = item.cellX;
 321                     cellY = item.cellY;
 322                     spanX = item.spanX;
 323                     spanY = item.spanY;
 324                     for (int x = cellX; ((0 &lt;= x) &amp;&amp; (x &lt; (cellX + spanX))) &amp;&amp; (x &lt; xCount); x++) {
 325                         for (int y = cellY; ((0 &lt;= y) &amp;&amp; (y &lt; (cellY + spanY))) &amp;&amp; (y &lt; yCount); y++) {
 326                             occupied[x][y] = true;
 327                         }
 328                     }
 329                 }
 330             }
 331         }
 332         return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 333     }
 334 
<abbr title=" 335     static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name, Intent launchIntent, int firstScreenIndex, ArrayList&lt;Long&gt; workspaceScreens) {"> 335     static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name, Intent launchIntent🔵</abbr>
 336         // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 337         LauncherAppState app = LauncherAppState.getInstance();
 338         LauncherModel model = app.getModel();
 339         boolean found = false;
 340         synchronized(app) {
 341             if (sWorkerThread.getThreadId() != Process.myTid()) {
 342                 // Flush the LauncherModel worker thread, so that if we just did another
 343                 // processInstallShortcut, we give it time for its shortcut to get added to the
 344                 // database (getItemsInLocalCoordinates reads the database)
 345                 model.flushWorkerThread();
 346             }
 347             final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 348             // Try adding to the workspace screens incrementally, starting at the default or center
 349             // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 350             firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 351             int count = workspaceScreens.size();
 352             for (int screen = firstScreenIndex; (screen &lt; count) &amp;&amp; (!found); screen++) {
 353                 int[] tmpCoordinates = new int[2];
<abbr title=" 354                 if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates, workspaceScreens.get(screen))) {"> 354                 if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates, workspaceScreens.get(screen🔵</abbr>
 355                     // Update the Launcher db
 356                     return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 357                 }
 358             }
 359         }
 360         return null;
 361     }
 362 
 363     public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {
 364         // Process the updated package state
 365         Runnable r = new Runnable() {
 366             public void run() {
 367                 Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
 368                 if (callbacks != null) {
 369                     callbacks.updatePackageState(installInfo);
 370                 }
 371             }
 372         };
 373         mHandler.post(r);
 374     }
 375 
 376     public void updatePackageBadge(final String packageName) {
 377         // Process the updated package badge
 378         Runnable r = new Runnable() {
 379             public void run() {
 380                 Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
 381                 if (callbacks != null) {
 382                     callbacks.updatePackageBadge(packageName);
 383                 }
 384             }
 385         };
 386         mHandler.post(r);
 387     }
 388 
 389     public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {
 390         final Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
 391         if (allAppsApps == null) {
 392             throw new RuntimeException(&quot;allAppsApps must not be null&quot;);
 393         }
 394         if (allAppsApps.isEmpty()) {
 395             return;
 396         }
 397         final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 398         Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();
 399         while (iter.hasNext()) {
 400             ItemInfo a = iter.next();
 401             if (LauncherModel.appWasPromise(ctx, a.getIntent(), a.user)) {
 402                 restoredAppsFinal.add(((AppInfo) (a)));
 403             }
 404         }
 405         // Process the newly added applications and add them to the database first
 406         Runnable r = new Runnable() {
 407             public void run() {
 408                 runOnMainThread(new Runnable() {
 409                     public void run() {
 410                         Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
 411                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
 412                             if (!restoredAppsFinal.isEmpty()) {
 413                                 for (AppInfo info : restoredAppsFinal) {
 414                                     final Intent intent = info.getIntent();
 415                                     if (intent != null) {
 416                                         mIconCache.deletePreloadedIcon(intent.getComponent(), info.user);
 417                                     }
 418                                 }
 419                                 callbacks.bindAppsUpdated(restoredAppsFinal);
 420                             }
 421                             callbacks.bindAppsAdded(null, null, null, allAppsApps);
 422                         }
 423                     }
 424                 });
 425             }
 426         };
 427         runOnWorkerThread(r);
 428     }
 429 
<abbr title=" 430     public void addAndBindAddedWorkspaceApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps) {"> 430     public void addAndBindAddedWorkspaceApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceAp🔵</abbr>
 431         final Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
 432         if (workspaceApps == null) {
 433             throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 434         }
 435         if (workspaceApps.isEmpty()) {
 436             return;
 437         }
 438         // Process the newly added applications and add them to the database first
 439         Runnable r = new Runnable() {
 440             public void run() {
 441                 final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 442                 final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
 443                 final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();
 444                 // Get the list of workspace screens.  We need to append to this list and
 445                 // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 446                 // called.
 447                 ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 448                 TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 449                 for (Integer i : orderedScreens.keySet()) {
 450                     long screenId = orderedScreens.get(i);
 451                     workspaceScreens.add(screenId);
 452                 }
 453                 synchronized(sBgLock) {
 454                     Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 455                     while (iter.hasNext()) {
 456                         ItemInfo a = iter.next();
 457                         final String name = a.title.toString();
 458                         final Intent launchIntent = a.getIntent();
 459                         // Short-circuit this logic if the icon exists somewhere on the workspace
 460                         if (LauncherModel.shortcutExists(context, name, launchIntent)) {
 461                             // Only InstallShortcutReceiver sends us shortcutInfos, ignore them
<abbr title=" 462                             if ((a instanceof AppInfo) &amp;&amp; LauncherModel.appWasPromise(context, launchIntent, a.user)) {"> 462                             if ((a instanceof AppInfo) &amp;&amp; LauncherModel.appWasPromise(context, launchInte🔵</abbr>
 463                                 restoredAppsFinal.add(((AppInfo) (a)));
 464                             }
 465                             continue;
 466                         }
 467                         // Add this icon to the db, creating a new page if necessary.  If there
 468                         // is only the empty page then we just add items to the first page.
 469                         // Otherwise, we add them to the next pages.
 470                         int startSearchPageIndex = (workspaceScreens.isEmpty()) ? 0 : 1;
<abbr title=" 471                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context, name, launchIntent, startSearchPageIndex, workspaceScreens);"> 471                         Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context, name🔵</abbr>
 472                         if (coords == null) {
 473                             LauncherProvider lp = LauncherAppState.getLauncherProvider();
 474                             // If we can&#x27;t find a valid position, then just add a new screen.
 475                             // This takes time so we need to re-queue the add until the new
 476                             // page is added.  Create as many screens as necessary to satisfy
 477                             // the startSearchPageIndex.
<abbr title=" 478                             int numPagesToAdd = Math.max(1, (startSearchPageIndex + 1) - workspaceScreens.size());"> 478                             int numPagesToAdd = Math.max(1, (startSearchPageIndex + 1) - workspaceScreens🔵</abbr>
 479                             while (numPagesToAdd &gt; 0) {
 480                                 long screenId = lp.generateNewScreenId();
 481                                 // Save the screen id for binding in the workspace
 482                                 workspaceScreens.add(screenId);
 483                                 addedWorkspaceScreensFinal.add(screenId);
 484                                 numPagesToAdd--;
 485                             }
 486                             // Find the coordinate again
<abbr title=" 487                             coords = LauncherModel.findNextAvailableIconSpace(context, name, launchIntent, startSearchPageIndex, workspaceScreens);"> 487                             coords = LauncherModel.findNextAvailableIconSpace(context, name, launchIntent🔵</abbr>
 488                         }
 489                         if (coords == null) {
 490                             throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 491                         }
 492                         ShortcutInfo shortcutInfo;
 493                         if (a instanceof ShortcutInfo) {
 494                             shortcutInfo = ((ShortcutInfo) (a));
 495                         } else if (a instanceof AppInfo) {
 496                             shortcutInfo = ((AppInfo) (a)).makeShortcut();
 497                         } else {
 498                             throw new RuntimeException(&quot;Unexpected info type&quot;);
 499                         }
 500                         // Add the shortcut to the db
<abbr title=" 501                         addItemToDatabase(context, shortcutInfo, LauncherSettings.Favorites.CONTAINER_DESKTOP, coords.first, coords.second[0], coords.second[1], false);"> 501                         addItemToDatabase(context, shortcutInfo, LauncherSettings.Favorites.CONTAINER_DES🔵</abbr>
 502                         // Save the ShortcutInfo for binding in the workspace
 503                         addedShortcutsFinal.add(shortcutInfo);
 504                     }
 505                 }
 506                 // Update the workspace screens
 507                 updateWorkspaceScreenOrder(context, workspaceScreens);
 508                 if (!addedShortcutsFinal.isEmpty()) {
 509                     runOnMainThread(new Runnable() {
 510                         public void run() {
 511                             Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
 512                             if ((callbacks == cb) &amp;&amp; (cb != null)) {
 513                                 final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 514                                 final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 515                                 if (!addedShortcutsFinal.isEmpty()) {
<abbr title=" 516                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);"> 516                                     ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 🔵</abbr>
 517                                     long lastScreenId = info.screenId;
 518                                     for (ItemInfo i : addedShortcutsFinal) {
 519                                         if (i.screenId == lastScreenId) {
 520                                             addAnimated.add(i);
 521                                         } else {
 522                                             addNotAnimated.add(i);
 523                                         }
 524                                     }
 525                                 }
<abbr title=" 526                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal, addNotAnimated, addAnimated, null);"> 526                                 callbacks.bindAppsAdded(addedWorkspaceScreensFinal, addNotAnimated, addAn🔵</abbr>
 527                                 if (!restoredAppsFinal.isEmpty()) {
 528                                     callbacks.bindAppsUpdated(restoredAppsFinal);
 529                                 }
 530                             }
 531                         }
 532                     });
 533                 }
 534             }
 535         };
 536         runOnWorkerThread(r);
 537     }
 538 
 539     public void unbindItemInfosAndClearQueuedBindRunnables() {
 540         if (sWorkerThread.getThreadId() == Process.myTid()) {
<abbr title=" 541             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; + &quot;main thread&quot;);"> 541             throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; + &quot;mai🔵</abbr>
 542         }
 543         // Clear any deferred bind runnables
 544         synchronized(mDeferredBindRunnables) {
 545             mDeferredBindRunnables.clear();
 546         }
 547         // Remove any queued bind runnables
 548         mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 549         // Unbind all the workspace items
 550         unbindWorkspaceItemsOnMainThread();
 551     }
 552 
 553     /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 554     void unbindWorkspaceItemsOnMainThread() {
 555         // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 556         // by making a copy of workspace items first.
 557         final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 558         final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 559         synchronized(sBgLock) {
 560             tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 561             tmpAppWidgets.addAll(sBgAppWidgets);
 562         }
 563         Runnable r = new Runnable() {
 564             @Override
 565             public void run() {
 566                 for (ItemInfo item : tmpWorkspaceItems) {
 567                     item.unbind();
 568                 }
 569                 for (ItemInfo item : tmpAppWidgets) {
 570                     item.unbind();
 571                 }
 572             }
 573         };
 574         runOnMainThread(r);
 575     }
 576 
 577     /**
 578      * Adds an item to the DB if it was not created previously, or move it to a new
 579      * &lt;container, screen, cellX, cellY&gt;
 580      */
<abbr title=" 581     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container, long screenId, int cellX, int cellY) {"> 581     static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container, long screenId, in🔵</abbr>
 582         if (item.container == ItemInfo.NO_ID) {
 583             // From all apps
 584             addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 585         } else {
 586             // From somewhere else
 587             moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 588         }
 589     }
 590 
<abbr title=" 591     static void checkItemInfoLocked(final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {"> 591     static void checkItemInfoLocked(final long itemId, final ItemInfo item, StackTraceElement[] stackTrac🔵</abbr>
 592         ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 593         if ((modelItem != null) &amp;&amp; (item != modelItem)) {
 594             // check all the data is consistent
 595             if ((modelItem instanceof ShortcutInfo) &amp;&amp; (item instanceof ShortcutInfo)) {
 596                 ShortcutInfo modelShortcut = ((ShortcutInfo) (modelItem));
 597                 ShortcutInfo shortcut = ((ShortcutInfo) (item));
<abbr title=" 598                 if ((((((((((modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp; modelShortcut.intent.filterEquals(shortcut.intent)) &amp;&amp; (modelShortcut.id == shortcut.id)) &amp;&amp; (modelShortcut.itemType == shortcut.itemType)) &amp;&amp; (modelShortcut.container == shortcut.container)) &amp;&amp; (modelShortcut.screenId == shortcut.screenId)) &amp;&amp; (modelShortcut.cellX == shortcut.cellX)) &amp;&amp; (modelShortcut.cellY == shortcut.cellY)) &amp;&amp; (modelShortcut.spanX == shortcut.spanX)) &amp;&amp; (modelShortcut.spanY == shortcut.spanY)) &amp;&amp; (((modelShortcut.dropPos == null) &amp;&amp; (shortcut.dropPos == null)) || ((((modelShortcut.dropPos != null) &amp;&amp; (shortcut.dropPos != null)) &amp;&amp; (modelShortcut.dropPos[0] == shortcut.dropPos[0])) &amp;&amp; (modelShortcut.dropPos[1] == shortcut.dropPos[1])))) {"> 598                 if ((((((((((modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp; modelSho🔵</abbr>
 599                     // For all intents and purposes, this is the same object
 600                     return;
 601                 }
 602             }
 603             // the modelItem needs to match up perfectly with item if our model is
 604             // to be consistent with the database-- for now, just require
 605             // modelItem == item or the equality check above
<abbr title=" 606             String msg = (((&quot;item: &quot; + (item != null ? item.toString() : &quot;null&quot;)) + &quot;modelItem: &quot;) + (modelItem != null ? modelItem.toString() : &quot;null&quot;)) + &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;"> 606             String msg = (((&quot;item: &quot; + (item != null ? item.toString() : &quot;null&quot;)) + &quot;modelItem: &quot;) + (mod🔵</abbr>
 607             RuntimeException e = new RuntimeException(msg);
 608             if (stackTrace != null) {
 609                 e.setStackTrace(stackTrace);
 610             }
 611             throw e;
 612         }
 613     }
 614 
 615     static void checkItemInfo(final ItemInfo item) {
 616         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 617         final long itemId = item.id;
 618         Runnable r = new Runnable() {
 619             public void run() {
 620                 synchronized(sBgLock) {
 621                     checkItemInfoLocked(itemId, item, stackTrace);
 622                 }
 623             }
 624         };
 625         runOnWorkerThread(r);
 626     }
 627 
<abbr title=" 628     static void updateItemInDatabaseHelper(Context context, final ContentValues values, final ItemInfo item, final String callingFunction) {"> 628     static void updateItemInDatabaseHelper(Context context, final ContentValues values, final ItemInfo it🔵</abbr>
 629         final long itemId = item.id;
 630         final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 631         final ContentResolver cr = context.getContentResolver();
 632         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 633         Runnable r = new Runnable() {
 634             public void run() {
 635                 cr.update(uri, values, null, null);
 636                 updateItemArrays(item, itemId, stackTrace);
 637             }
 638         };
 639         runOnWorkerThread(r);
 640     }
 641 
<abbr title=" 642     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList, final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {"> 642     static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList, f🔵</abbr>
 643         final ContentResolver cr = context.getContentResolver();
 644         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 645         Runnable r = new Runnable() {
 646             public void run() {
 647                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
 648                 int count = items.size();
 649                 for (int i = 0; i &lt; count; i++) {
 650                     ItemInfo item = items.get(i);
 651                     final long itemId = item.id;
 652                     final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 653                     ContentValues values = valuesList.get(i);
 654                     ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 655                     updateItemArrays(item, itemId, stackTrace);
 656                 }
 657                 try {
 658                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 659                 } catch (java.lang.Exception e) {
 660                     e.printStackTrace();
 661                 }
 662             }
 663         };
 664         runOnWorkerThread(r);
 665     }
 666 
 667     static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 668         // Lock on mBgLock *after* the db operation
 669         synchronized(sBgLock) {
 670             checkItemInfoLocked(itemId, item, stackTrace);
<abbr title=" 671             if ((item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 671             if ((item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (item.container != La🔵</abbr>
 672                 // Item is in a folder, make sure this folder exists
 673                 if (!sBgFolders.containsKey(item.container)) {
 674                     // An items container is being set to a that of an item which is not in
 675                     // the list of Folders.
<abbr title=" 676                     String msg = (((&quot;item: &quot; + item) + &quot; container being set to: &quot;) + item.container) + &quot;, not in the list of folders&quot;;"> 676                     String msg = (((&quot;item: &quot; + item) + &quot; container being set to: &quot;) + item.container) + &quot;🔵</abbr>
 677                     Log.e(TAG, msg);
 678                 }
 679             }
 680             // Items are added/removed from the corresponding FolderInfo elsewhere, such
 681             // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 682             // that are on the desktop, as appropriate
 683             ItemInfo modelItem = sBgItemsIdMap.get(itemId);
<abbr title=" 684             if ((modelItem != null) &amp;&amp; ((modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) || (modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT))) {"> 684             if ((modelItem != null) &amp;&amp; ((modelItem.container == LauncherSettings.Favorites.CONTAINER_DESK🔵</abbr>
 685                 switch (modelItem.itemType) {
 686                     case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
 687                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
 688                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
 689                         if (!sBgWorkspaceItems.contains(modelItem)) {
 690                             sBgWorkspaceItems.add(modelItem);
 691                         }
 692                         break;
 693                     default :
 694                         break;
 695                 }
 696             } else {
 697                 sBgWorkspaceItems.remove(modelItem);
 698             }
 699         }
 700     }
 701 
 702     public void flushWorkerThread() {
 703         mFlushingWorkerThread = true;
 704         Runnable waiter = new Runnable() {
 705                 public void run() {
 706                     synchronized (this) {
 707                         notifyAll();
 708                         mFlushingWorkerThread = false;
 709                     }
 710                 }
 711             };
 712 
 713         synchronized(waiter) {
 714             runOnWorkerThread(waiter);
 715             if (mLoaderTask != null) {
 716                 synchronized(mLoaderTask) {
 717                     mLoaderTask.notify();
 718                 }
 719             }
 720             boolean success = false;
 721             while (!success) {
 722                 try {
 723                     waiter.wait();
 724                     success = true;
 725                 } catch (InterruptedException e) {
 726                 }
 727             }
 728         }
 729     }
 730 
 731     /**
 732      * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 733      */
<abbr title=" 734     static void moveItemInDatabase(Context context, final ItemInfo item, final long container, final long screenId, final int cellX, final int cellY) {"> 734     static void moveItemInDatabase(Context context, final ItemInfo item, final long container, final long🔵</abbr>
 735         item.container = container;
 736         item.cellX = cellX;
 737         item.cellY = cellY;
 738         // We store hotseat items in canonical form which is this orientation invariant position
 739         // in the hotseat
<abbr title=" 740         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 740         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites🔵</abbr>
 741             item.screenId = ((Launcher) (context)).getHotseat().getOrderInHotseat(cellX, cellY);
 742         } else {
 743             item.screenId = screenId;
 744         }
 745         final ContentValues values = new ContentValues();
 746         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 747         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 748         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 749         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 750         updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 751     }
 752 
 753     /**
 754      * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 755      * cellX, cellY have already been updated on the ItemInfos.
 756      */
<abbr title=" 757     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items, final long container, final int screen) {"> 757     static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items, final long containe🔵</abbr>
 758         ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 759         int count = items.size();
 760         for (int i = 0; i &lt; count; i++) {
 761             ItemInfo item = items.get(i);
 762             item.container = container;
 763             // We store hotseat items in canonical form which is this orientation invariant position
 764             // in the hotseat
<abbr title=" 765             if (((context instanceof Launcher) &amp;&amp; (screen &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 765             if (((context instanceof Launcher) &amp;&amp; (screen &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorit🔵</abbr>
<abbr title=" 766                 item.screenId = ((Launcher) (context)).getHotseat().getOrderInHotseat(item.cellX, item.cellY);"> 766                 item.screenId = ((Launcher) (context)).getHotseat().getOrderInHotseat(item.cellX, item.ce🔵</abbr>
 767             } else {
 768                 item.screenId = screen;
 769             }
 770             final ContentValues values = new ContentValues();
 771             values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 772             values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 773             values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 774             values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 775             contentValues.add(values);
 776         }
 777         updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 778     }
 779 
 780     /**
 781      * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 782      */
<abbr title=" 783     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container, final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {"> 783     static void modifyItemInDatabase(Context context, final ItemInfo item, final long container, final lo🔵</abbr>
 784         item.container = container;
 785         item.cellX = cellX;
 786         item.cellY = cellY;
 787         item.spanX = spanX;
 788         item.spanY = spanY;
 789         // We store hotseat items in canonical form which is this orientation invariant position
 790         // in the hotseat
<abbr title=" 791         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 791         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites🔵</abbr>
 792             item.screenId = ((Launcher) (context)).getHotseat().getOrderInHotseat(cellX, cellY);
 793         } else {
 794             item.screenId = screenId;
 795         }
 796         final ContentValues values = new ContentValues();
 797         values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 798         values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 799         values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 800         values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 801         values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 802         values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 803         updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 804     }
 805 
 806     /**
 807      * Update an item to the database in a specified container.
 808      */
 809     static void updateItemInDatabase(Context context, final ItemInfo item) {
 810         final ContentValues values = new ContentValues();
 811         item.onAddToDatabase(context, values);
 812         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 813         updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 814     }
 815 
 816     /**
 817      * Returns true if the shortcuts already exists in the database.
 818      * we identify a shortcut by its title and intent.
 819      */
 820     static boolean shortcutExists(Context context, String title, Intent intent) {
 821         final ContentResolver cr = context.getContentResolver();
 822         final Intent intentWithPkg;
 823         final Intent intentWithoutPkg;
 824         if (intent.getComponent() != null) {
 825             // If component is not null, an intent with null package will produce
 826             // the same result and should also be a match.
 827             if (intent.getPackage() != null) {
 828                 intentWithPkg = intent;
 829                 intentWithoutPkg = new Intent(intent).setPackage(null);
 830             } else {
 831                 intentWithPkg = new Intent(intent).setPackage(intent.getComponent().getPackageName());
 832                 intentWithoutPkg = intent;
 833             }
 834         } else {
 835             intentWithPkg = intent;
 836             intentWithoutPkg = intent;
 837         }
<abbr title=" 838         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[]{ &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and (intent=? or intent=?)&quot;, new String[]{ title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0) }, null);"> 838         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[]{ &quot;title&quot;, &quot;intent&quot; }, &quot;t🔵</abbr>
 839         boolean result = false;
 840         try {
 841             result = c.moveToFirst();
 842         } finally {
 843             c.close();
 844         }
 845         return result;
 846     }
 847 
 848     /**
 849      * Returns true if the promise shortcuts with the same package name exists on the workspace.
 850      */
 851     static boolean appWasPromise(Context context, Intent intent, UserHandleCompat user) {
 852         final ComponentName component = intent.getComponent();
 853         if (component == null) {
 854             return false;
 855         }
 856         return !getItemsByPackageName(component.getPackageName(), user).isEmpty();
 857     }
 858 
 859     /**
 860      * Returns an ItemInfo array containing all the items in the LauncherModel.
 861      * The ItemInfo.id is not set through this function.
 862      */
 863     static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 864         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 865         final ContentResolver cr = context.getContentResolver();
<abbr title=" 866         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[]{ LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER, LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY, LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY, LauncherSettings.Favorites.PROFILE_ID }, null, null, null);"> 866         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[]{ LauncherSettings.Favori🔵</abbr>
 867         final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 868         final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 869         final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 870         final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 871         final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 872         final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 873         final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
 874         final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);
 875         UserManagerCompat userManager = UserManagerCompat.getInstance(context);
 876         try {
 877             while (c.moveToNext()) {
 878                 ItemInfo item = new ItemInfo();
 879                 item.cellX = c.getInt(cellXIndex);
 880                 item.cellY = c.getInt(cellYIndex);
 881                 item.spanX = Math.max(1, c.getInt(spanXIndex));
 882                 item.spanY = Math.max(1, c.getInt(spanYIndex));
 883                 item.container = c.getInt(containerIndex);
 884                 item.itemType = c.getInt(itemTypeIndex);
 885                 item.screenId = c.getInt(screenIndex);
 886                 long serialNumber = c.getInt(profileIdIndex);
 887                 item.user = userManager.getUserForSerialNumber(serialNumber);
 888                 // Skip if user has been deleted.
 889                 if (item.user != null) {
 890                     items.add(item);
 891                 }
 892             }
 893         } catch (java.lang.Exception e) {
 894             items.clear();
 895         } finally {
 896             c.close();
 897         }
 898         return items;
 899     }
 900 
 901     /**
 902      * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
 903      */
 904     FolderInfo getFolderById(Context context, HashMap&lt;Long, FolderInfo&gt; folderList, long id) {
 905         final ContentResolver cr = context.getContentResolver();
<abbr title=" 906         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null, &quot;_id=? and (itemType=? or itemType=?)&quot;, new String[]{ String.valueOf(id), String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER) }, null);"> 906         Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null, &quot;_id=? and (itemType=? or itemT🔵</abbr>
 907         try {
 908             if (c.moveToFirst()) {
 909                 final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 910                 final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
 911                 final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 912                 final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 913                 final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 914                 final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 915                 FolderInfo folderInfo = null;
 916                 switch (c.getInt(itemTypeIndex)) {
 917                     case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
 918                         folderInfo = findOrMakeFolder(folderList, id);
 919                         break;
 920                 }
 921                 folderInfo.title = c.getString(titleIndex);
 922                 folderInfo.id = id;
 923                 folderInfo.container = c.getInt(containerIndex);
 924                 folderInfo.screenId = c.getInt(screenIndex);
 925                 folderInfo.cellX = c.getInt(cellXIndex);
 926                 folderInfo.cellY = c.getInt(cellYIndex);
 927                 return folderInfo;
 928             }
 929         } finally {
 930             c.close();
 931         }
 932         return null;
 933     }
 934 
 935     /**
 936      * Add an item to the database in a specified container. Sets the container, screen, cellX and
 937      * cellY fields of the item. Also assigns an ID to the item.
 938      */
<abbr title=" 939     static void addItemToDatabase(Context context, final ItemInfo item, final long container, final long screenId, final int cellX, final int cellY, final boolean notify) {"> 939     static void addItemToDatabase(Context context, final ItemInfo item, final long container, final long 🔵</abbr>
 940         item.container = container;
 941         item.cellX = cellX;
 942         item.cellY = cellY;
 943         // We store hotseat items in canonical form which is this orientation invariant position
 944         // in the hotseat
<abbr title=" 945         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 945         if (((context instanceof Launcher) &amp;&amp; (screenId &lt; 0)) &amp;&amp; (container == LauncherSettings.Favorites🔵</abbr>
 946             item.screenId = ((Launcher) (context)).getHotseat().getOrderInHotseat(cellX, cellY);
 947         } else {
 948             item.screenId = screenId;
 949         }
 950         final ContentValues values = new ContentValues();
 951         final ContentResolver cr = context.getContentResolver();
 952         item.onAddToDatabase(context, values);
 953         item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
 954         values.put(LauncherSettings.Favorites._ID, item.id);
 955         item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 956         final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 957         Runnable r = new Runnable() {
 958             public void run() {
<abbr title=" 959                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI : LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);"> 959                 cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI : LauncherSettings.Favorites.CO🔵</abbr>
 960                 // Lock on mBgLock *after* the db operation
 961                 synchronized(sBgLock) {
 962                     checkItemInfoLocked(item.id, item, stackTrace);
 963                     sBgItemsIdMap.put(item.id, item);
 964                     switch (item.itemType) {
 965                         case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
 966                             sBgFolders.put(item.id, ((FolderInfo) (item)));
 967                             // Fall through
 968                         case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
 969                         case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
<abbr title=" 970                             if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) || (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {"> 970                             if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) || (item🔵</abbr>
 971                                 sBgWorkspaceItems.add(item);
 972                             } else if (!sBgFolders.containsKey(item.container)) {
 973                                 // Adding an item to a folder that doesn&#x27;t exist.
<abbr title=" 974                                 String msg = ((&quot;adding item: &quot; + item) + &quot; to a folder that &quot;) + &quot; doesn&#x27;t exist&quot;;"> 974                                 String msg = ((&quot;adding item: &quot; + item) + &quot; to a folder that &quot;) + &quot; doesn&#x27;🔵</abbr>
 975                                 Log.e(TAG, msg);
 976                             }
 977                             break;
 978                         case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET :
 979                             sBgAppWidgets.add(((LauncherAppWidgetInfo) (item)));
 980                             break;
 981                     }
 982                 }
 983             }
 984         };
 985         runOnWorkerThread(r);
 986     }
 987 
 988     /**
 989      * Creates a new unique child id, for a given cell span across all layouts.
 990      */
 991     static int getCellLayoutChildId(
 992             long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
 993         return (((int) container &amp; 0xFF) &lt;&lt; 24)
 994                 | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
 995     }
 996 
<abbr title=" 997     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(final String pn, final UserHandleCompat user) {"> 997     private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(final String pn, final UserHandleCompat user🔵</abbr>
 998         ItemInfoFilter filter = new ItemInfoFilter() {
 999             @Override
1000             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
1001                 return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);
1002             }
1003         };
1004         return filterItemInfos(sBgItemsIdMap.values(), filter);
1005     }
1006 
1007     /**
1008      * Removes all the items from the database corresponding to the specified package.
1009      */
<abbr title="1010     static void deletePackageFromDatabase(Context context, final String pn, final UserHandleCompat user) {">1010     static void deletePackageFromDatabase(Context context, final String pn, final UserHandleCompat user) 🔵</abbr>
1011         deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));
1012     }
1013 
1014     /**
1015      * Removes the specified item from the database
1016      * @param context
1017      * @param item
1018      */
1019     static void deleteItemFromDatabase(Context context, final ItemInfo item) {
1020         ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
1021         items.add(item);
1022         deleteItemsFromDatabase(context, items);
1023     }
1024 
1025     /**
1026      * Removes the specified items from the database
1027      * @param context
1028      * @param item
1029      */
1030     static void deleteItemsFromDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items) {
1031         final ContentResolver cr = context.getContentResolver();
1032         Runnable r = new Runnable() {
1033             public void run() {
1034                 for (ItemInfo item : items) {
1035                     final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);
1036                     cr.delete(uri, null, null);
1037                 // Lock on mBgLock *after* the db operation
1038                     synchronized(sBgLock) {
1039                         switch (item.itemType) {
1040                             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
1041                                 sBgFolders.remove(item.id);
1042                                 for (ItemInfo info : sBgItemsIdMap.values()) {
1043                                     if (info.container == item.id) {
1044                                     // We are deleting a folder which still contains items that
1045                                     // think they are contained by that folder.
<abbr title="1046                                         String msg = ((((&quot;deleting a folder (&quot; + item) + &quot;) which still &quot;) + &quot;contains items (&quot;) + info) + &quot;)&quot;;">1046                                         String msg = ((((&quot;deleting a folder (&quot; + item) + &quot;) which still &quot;🔵</abbr>
1047                                         Log.e(TAG, msg);
1048                                     }
1049                                 }
1050                                 sBgWorkspaceItems.remove(item);
1051                                 break;
1052                             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
1053                             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
1054                                 sBgWorkspaceItems.remove(item);
1055                                 break;
1056                             case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET :
1057                                 sBgAppWidgets.remove(((LauncherAppWidgetInfo) (item)));
1058                                 break;
1059                         }
1060                         sBgItemsIdMap.remove(item.id);
1061                         sBgDbIconCache.remove(item);
1062                     }
1063                 }
1064             }
1065         };
1066         runOnWorkerThread(r);
1067     }
1068 
1069     /**
1070      * Update the order of the workspace screens in the database. The array list contains
1071      * a list of screen ids in the order that they should appear.
1072      */
1073     void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1074         // Log to disk
1075         Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1076         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1077         final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1078         final ContentResolver cr = context.getContentResolver();
1079         final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1080         // Remove any negative screen ids -- these aren&#x27;t persisted
1081         Iterator&lt;Long&gt; iter = screensCopy.iterator();
1082         while (iter.hasNext()) {
1083             long id = iter.next();
1084             if (id &lt; 0) {
1085                 iter.remove();
1086             }
1087         }
1088         Runnable r = new Runnable() {
1089             @Override
1090             public void run() {
1091                 ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1092                 // Clear the table
1093                 ops.add(ContentProviderOperation.newDelete(uri).build());
1094                 int count = screensCopy.size();
1095                 for (int i = 0; i &lt; count; i++) {
1096                     ContentValues v = new ContentValues();
1097                     long screenId = screensCopy.get(i);
1098                     v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1099                     v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1100                     ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1101                 }
1102                 try {
1103                     cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1104                 } catch (java.lang.Exception ex) {
1105                     throw new RuntimeException(ex);
1106                 }
1107                 synchronized(sBgLock) {
1108                     sBgWorkspaceScreens.clear();
1109                     sBgWorkspaceScreens.addAll(screensCopy);
1110                 }
1111             }
1112         };
1113         runOnWorkerThread(r);
1114     }
1115 
1116     /**
1117      * Remove the contents of the specified folder from the database
1118      */
1119     static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1120         final ContentResolver cr = context.getContentResolver();
1121         Runnable r = new Runnable() {
1122             public void run() {
1123                 cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1124                 // Lock on mBgLock *after* the db operation
1125                 synchronized(sBgLock) {
1126                     sBgItemsIdMap.remove(info.id);
1127                     sBgFolders.remove(info.id);
1128                     sBgDbIconCache.remove(info);
1129                     sBgWorkspaceItems.remove(info);
1130                 }
<abbr title="1131                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, (LauncherSettings.Favorites.CONTAINER + &quot;=&quot;) + info.id, null);">1131                 cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, (LauncherSettings.Favor🔵</abbr>
1132                 // Lock on mBgLock *after* the db operation
1133                 synchronized(sBgLock) {
1134                     for (ItemInfo childInfo : info.contents) {
1135                         sBgItemsIdMap.remove(childInfo.id);
1136                         sBgDbIconCache.remove(childInfo);
1137                     }
1138                 }
1139             }
1140         };
1141         runOnWorkerThread(r);
1142     }
1143 
1144     /**
1145      * Set this as the current Launcher activity object for the loader.
1146      */
1147     public void initialize(Callbacks callbacks) {
1148         synchronized (mLock) {
1149             mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1150         }
1151     }
1152 
1153     @Override
1154     public void onPackageChanged(String packageName, UserHandleCompat user) {
1155         int op = PackageUpdatedTask.OP_UPDATE;
1156         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[]{ packageName }, user));
1157     }
1158 
1159     @Override
1160     public void onPackageRemoved(String packageName, UserHandleCompat user) {
1161         int op = PackageUpdatedTask.OP_REMOVE;
1162         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[]{ packageName }, user));
1163     }
1164 
1165     @Override
1166     public void onPackageAdded(String packageName, UserHandleCompat user) {
1167         int op = PackageUpdatedTask.OP_ADD;
1168         enqueuePackageUpdated(new PackageUpdatedTask(op, new String[]{ packageName }, user));
1169     }
1170 
1171     @Override
1172     public void onPackagesAvailable(String[] packageNames, UserHandleCompat user, boolean replacing) {
1173         if (!replacing) {
1174             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames, user));
1175             if (mAppsCanBeOnRemoveableStorage) {
1176                 // Only rebind if we support removable storage. It catches the
1177                 // case where
1178                 // apps on the external sd card need to be reloaded
1179                 startLoaderFromBackground();
1180             }
1181         } else {
1182             // If we are replacing then just update the packages in the list
<abbr title="1183             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE, packageNames, user));">1183             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE, packageNames, user🔵</abbr>
1184         }
1185     }
1186 
1187     @Override
1188     public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user, boolean replacing) {
1189         if (!replacing) {
<abbr title="1190             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UNAVAILABLE, packageNames, user));">1190             enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UNAVAILABLE, packageNames,🔵</abbr>
1191         }
1192     }
1193 
1194     /**
1195      * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1196      * ACTION_PACKAGE_CHANGED.
1197      */
1198     @Override
1199     public void onReceive(Context context, Intent intent) {
1200         if (DEBUG_RECEIVER) {
1201             Log.d(TAG, &quot;onReceive intent=&quot; + intent);
1202         }
1203         final String action = intent.getAction();
1204         if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {
1205             // If we have changed locale we need to clear out the labels in all apps/workspace.
1206             forceReload();
1207         } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1208             // Check if configuration change was an mcc/mnc change which would affect app resources
1209             // and we would need to clear out the labels in all apps/workspace. Same handling as
1210             // above for ACTION_LOCALE_CHANGED
1211             Configuration currentConfig = context.getResources().getConfiguration();
1212             if (mPreviousConfigMcc != currentConfig.mcc) {
<abbr title="1213                 Log.d(TAG, ((&quot;Reload apps on config change. curr_mcc:&quot; + currentConfig.mcc) + &quot; prevmcc:&quot;) + mPreviousConfigMcc);">1213                 Log.d(TAG, ((&quot;Reload apps on config change. curr_mcc:&quot; + currentConfig.mcc) + &quot; prevmcc:&quot;🔵</abbr>
1214                 forceReload();
1215             }
1216             // Update previousConfig
1217             mPreviousConfigMcc = currentConfig.mcc;
<abbr title="1218         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) || SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {">1218         } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) || SearchManager.IN🔵</abbr>
1219             if (mCallbacks != null) {
1220                 Callbacks callbacks = mCallbacks.get();
1221                 if (callbacks != null) {
1222                     callbacks.bindSearchablesChanged();
1223                 }
1224             }
1225         }
1226     }
1227 
1228     void forceReload() {
1229         resetLoadedState(true, true);
1230         // Do this here because if the launcher activity is running it will be restarted.
1231         // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1232         // to reload.
1233         startLoaderFromBackground();
1234     }
1235 
1236     public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1237         synchronized (mLock) {
1238             // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1239             // mWorkspaceLoaded to true later
1240             stopLoaderLocked();
1241             if (resetAllAppsLoaded) mAllAppsLoaded = false;
1242             if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1243         }
1244     }
1245 
1246     /**
1247      * When the launcher is in the background, it&#x27;s possible for it to miss paired
1248      * configuration changes.  So whenever we trigger the loader from the background
1249      * tell the launcher that it needs to re-run the loader when it comes back instead
1250      * of doing it now.
1251      */
1252     public void startLoaderFromBackground() {
1253         boolean runLoader = false;
1254         if (mCallbacks != null) {
1255             Callbacks callbacks = mCallbacks.get();
1256             if (callbacks != null) {
1257                 // Only actually run the loader if they&#x27;re not paused.
1258                 if (!callbacks.setLoadOnResume()) {
1259                     runLoader = true;
1260                 }
1261             }
1262         }
1263         if (runLoader) {
1264             startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1265         }
1266     }
1267 
1268     // If there is already a loader task running, tell it to stop.
1269     // returns true if isLaunching() was true on the old task
1270     private boolean stopLoaderLocked() {
1271         boolean isLaunching = false;
1272         LoaderTask oldTask = mLoaderTask;
1273         if (oldTask != null) {
1274             if (oldTask.isLaunching()) {
1275                 isLaunching = true;
1276             }
1277             oldTask.stopLocked();
1278         }
1279         return isLaunching;
1280     }
1281 
1282     public boolean isCurrentCallbacks(Callbacks callbacks) {
1283         return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);
1284     }
1285 
1286     public void startLoader(boolean isLaunching, int synchronousBindPage) {
1287         startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1288     }
1289 
1290     public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1291         synchronized(mLock) {
1292             if (DEBUG_LOADERS) {
1293                 Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1294             }
1295             // Clear any deferred bind-runnables from the synchronized load process
1296             // We must do this before any loading/binding is scheduled below.
1297             synchronized(mDeferredBindRunnables) {
1298                 mDeferredBindRunnables.clear();
1299             }
1300             // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1301             if ((mCallbacks != null) &amp;&amp; (mCallbacks.get() != null)) {
1302                 // If there is already one running, tell it to stop.
1303                 // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1304                 isLaunching = isLaunching || stopLoaderLocked();
1305                 mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
<abbr title="1306                 if (((synchronousBindPage != PagedView.INVALID_RESTORE_PAGE) &amp;&amp; mAllAppsLoaded) &amp;&amp; mWorkspaceLoaded) {">1306                 if (((synchronousBindPage != PagedView.INVALID_RESTORE_PAGE) &amp;&amp; mAllAppsLoaded) &amp;&amp; mWorks🔵</abbr>
1307                     mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1308                 } else {
1309                     sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1310                     sWorker.post(mLoaderTask);
1311                 }
1312             }
1313         }
1314     }
1315 
1316     void bindRemainingSynchronousPages() {
1317         // Post the remaining side pages to be loaded
1318         if (!mDeferredBindRunnables.isEmpty()) {
1319             Runnable[] deferredBindRunnables = null;
1320             synchronized(mDeferredBindRunnables) {
<abbr title="1321                 deferredBindRunnables = mDeferredBindRunnables.toArray(new Runnable[mDeferredBindRunnables.size()]);">1321                 deferredBindRunnables = mDeferredBindRunnables.toArray(new Runnable[mDeferredBindRunnable🔵</abbr>
1322                 mDeferredBindRunnables.clear();
1323             }
1324             for (final Runnable r : deferredBindRunnables) {
1325                 mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1326             }
1327         }
1328     }
1329 
1330     public void stopLoader() {
1331         synchronized (mLock) {
1332             if (mLoaderTask != null) {
1333                 mLoaderTask.stopLocked();
1334             }
1335         }
1336     }
1337 
1338     /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1339     private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1340         final ContentResolver contentResolver = context.getContentResolver();
1341         final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1342         final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1343         TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1344         try {
1345             final int idIndex = sc.getColumnIndexOrThrow(LauncherSettings.WorkspaceScreens._ID);
<abbr title="1346             final int rankIndex = sc.getColumnIndexOrThrow(LauncherSettings.WorkspaceScreens.SCREEN_RANK);">1346             final int rankIndex = sc.getColumnIndexOrThrow(LauncherSettings.WorkspaceScreens.SCREEN_RANK)🔵</abbr>
1347             while (sc.moveToNext()) {
1348                 try {
1349                     long screenId = sc.getLong(idIndex);
1350                     int rank = sc.getInt(rankIndex);
1351                     orderedScreens.put(rank, screenId);
1352                 } catch (java.lang.Exception e) {
<abbr title="1353                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);">1353                     Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e,🔵</abbr>
1354                 }
1355             }
1356         } finally {
1357             sc.close();
1358         }
1359         // Log to disk
1360         Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1361         ArrayList&lt;String&gt; orderedScreensPairs = new ArrayList&lt;String&gt;();
1362         for (Integer i : orderedScreens.keySet()) {
1363             orderedScreensPairs.add((((&quot;{ &quot; + i) + &quot;: &quot;) + orderedScreens.get(i)) + &quot; }&quot;);
1364         }
<abbr title="1365         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);">1365         Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, orderedScreensPairs), tr🔵</abbr>
1366         return orderedScreens;
1367     }
1368 
1369     public boolean isAllAppsLoaded() {
1370         return mAllAppsLoaded;
1371     }
1372 
1373     boolean isLoadingWorkspace() {
1374         synchronized (mLock) {
1375             if (mLoaderTask != null) {
1376                 return mLoaderTask.isLoadingWorkspace();
1377             }
1378         }
1379         return false;
1380     }
1381 
1382     /**
1383      * Runnable for the thread that loads the contents of the launcher:
1384      *   - workspace icons
1385      *   - widgets
1386      *   - all apps icons
1387      */
1388     private class LoaderTask implements Runnable {
1389         private Context mContext;
1390 
1391         private boolean mIsLaunching;
1392 
1393         private boolean mIsLoadingAndBindingWorkspace;
1394 
1395         private boolean mStopped;
1396 
1397         private boolean mLoadAndBindStepFinished;
1398 
1399         private int mFlags;
1400 
1401         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1402 
1403         LoaderTask(Context context, boolean isLaunching, int flags) {
1404             mContext = context;
1405             mIsLaunching = isLaunching;
1406             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1407             mFlags = flags;
1408         }
1409 
1410         boolean isLaunching() {
1411             return mIsLaunching;
1412         }
1413 
1414         boolean isLoadingWorkspace() {
1415             return mIsLoadingAndBindingWorkspace;
1416         }
1417 
1418         /** Returns whether this is an upgrade path */
1419         private boolean loadAndBindWorkspace() {
1420             mIsLoadingAndBindingWorkspace = true;
1421 
1422             // Load the workspace
1423             if (DEBUG_LOADERS) {
1424                 Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1425             }
1426 
1427             boolean isUpgradePath = false;
1428             if (!mWorkspaceLoaded) {
1429                 isUpgradePath = loadWorkspace();
1430                 synchronized (LoaderTask.this) {
1431                     if (mStopped) {
1432                         return isUpgradePath;
1433                     }
1434                     mWorkspaceLoaded = true;
1435                 }
1436             }
1437 
1438             // Bind the workspace
1439             bindWorkspace(-1, isUpgradePath);
1440             return isUpgradePath;
1441         }
1442 
1443         private void waitForIdle() {
1444             // Wait until the either we&#x27;re stopped or the other threads are done.
1445             // This way we don&#x27;t start loading all apps until the workspace has settled
1446             // down.
1447             synchronized (LoaderTask.this) {
1448                 final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1449 
1450                 mHandler.postIdle(new Runnable() {
1451                         public void run() {
1452                             synchronized (LoaderTask.this) {
1453                                 mLoadAndBindStepFinished = true;
1454                                 if (DEBUG_LOADERS) {
1455                                     Log.d(TAG, &quot;done with previous binding step&quot;);
1456                                 }
1457                                 LoaderTask.this.notify();
1458                             }
1459                         }
1460                     });
1461 
1462                 while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1463                     try {
1464                         // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1465                         // wait no longer than 1sec at a time
1466                         this.wait(1000);
1467                     } catch (InterruptedException ex) {
1468                         // Ignore
1469                     }
1470                 }
1471                 if (DEBUG_LOADERS) {
1472                     Log.d(TAG, &quot;waited &quot;
1473                             + (SystemClock.uptimeMillis()-workspaceWaitTime)
1474                             + &quot;ms for previous step to finish binding&quot;);
1475                 }
1476             }
1477         }
1478 
1479         void runBindSynchronousPage(int synchronousBindPage) {
1480             if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1481                 // Ensure that we have a valid page index to load synchronously
1482                 throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1483                         &quot;valid page index&quot;);
1484             }
1485             if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1486                 // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1487                 // loaded already (we should load everything asynchronously in that case)
1488                 throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1489             }
1490             synchronized (mLock) {
1491                 if (mIsLoaderTaskRunning) {
1492                     // Ensure that we are never running the background loading at this point since
1493                     // we also touch the background collections
1494                     throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1495                 }
1496             }
1497 
1498             // XXX: Throw an exception if we are already loading (since we touch the worker thread
1499             //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1500             //      this call is synchronous, we can get away with not locking).
1501 
1502             // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1503             // operations from the previous activity.  We need to ensure that all queued operations
1504             // are executed before any synchronous binding work is done.
1505             mHandler.flush();
1506 
1507             // Divide the set of loaded items into those that we are binding synchronously, and
1508             // everything else that is to be bound normally (asynchronously).
1509             bindWorkspace(synchronousBindPage, false);
1510             // XXX: For now, continue posting the binding of AllApps as there are other issues that
1511             //      arise from that.
1512             onlyBindAllApps();
1513         }
1514 
1515         public void run() {
1516             boolean isUpgrade = false;
1517             synchronized(mLock) {
1518                 mIsLoaderTaskRunning = true;
1519             }
1520             // Optimize for end-user experience: if the Launcher is up and // running with the
1521             // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1522             // workspace first (default).
1523             keep_running : {
1524                 // Elevate priority when Home launches for the first time to avoid
1525                 // starving at boot time. Staring at a blank home is not cool.
1526                 synchronized(mLock) {
1527                     if (DEBUG_LOADERS) {
<abbr title="1528                         Log.d(TAG, &quot;Setting thread priority to &quot; + (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));">1528                         Log.d(TAG, &quot;Setting thread priority to &quot; + (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUN🔵</abbr>
1529                     }
<abbr title="1530                     Process.setThreadPriority(mIsLaunching ? java.lang.Process.THREAD_PRIORITY_DEFAULT : java.lang.Process.THREAD_PRIORITY_BACKGROUND);">1530                     Process.setThreadPriority(mIsLaunching ? java.lang.Process.THREAD_PRIORITY_DEFAULT : 🔵</abbr>
1531                 }
1532                 if (DEBUG_LOADERS) {
1533                     Log.d(TAG, &quot;step 1: loading workspace&quot;);
1534                 }
1535                 isUpgrade = loadAndBindWorkspace();
1536                 if (mStopped) {
1537                     break keep_running;
1538                 }
1539                 // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1540                 // settled down.
1541                 synchronized(mLock) {
1542                     if (mIsLaunching) {
1543                         if (DEBUG_LOADERS) {
1544                             Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1545                         }
1546                         Process.setThreadPriority(java.lang.Process.THREAD_PRIORITY_BACKGROUND);
1547                     }
1548                 }
1549                 waitForIdle();
1550                 // second step
1551                 if (DEBUG_LOADERS) {
1552                     Log.d(TAG, &quot;step 2: loading all apps&quot;);
1553                 }
1554                 loadAndBindAllApps();
1555                 // Restore the default thread priority after we are done loading items
1556                 synchronized(mLock) {
1557                     Process.setThreadPriority(java.lang.Process.THREAD_PRIORITY_DEFAULT);
1558                 }
1559             }
1560             // Update the saved icons if necessary
1561             if (DEBUG_LOADERS) {
1562                 Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1563             }
1564             synchronized(sBgLock) {
1565                 for (Object key : sBgDbIconCache.keySet()) {
1566                     updateSavedIcon(mContext, ((ShortcutInfo) (key)), sBgDbIconCache.get(key));
1567                 }
1568                 sBgDbIconCache.clear();
1569             }
1570             if (LauncherAppState.isDisableAllApps()) {
1571                 // Ensure that all the applications that are in the system are
1572                 // represented on the home screen.
1573                 if ((!UPGRADE_USE_MORE_APPS_FOLDER) || (!isUpgrade)) {
1574                     verifyApplications();
1575                 }
1576             }
1577             // Clear out this reference, otherwise we end up holding it until all of the
1578             // callback runnables are done.
1579             mContext = null;
1580             synchronized(mLock) {
1581                 // If we are still the last one to be scheduled, remove ourselves.
1582                 if (mLoaderTask == this) {
1583                     mLoaderTask = null;
1584                 }
1585                 mIsLoaderTaskRunning = false;
1586             }
1587         }
1588 
1589         public void stopLocked() {
1590             synchronized (LoaderTask.this) {
1591                 mStopped = true;
1592                 this.notify();
1593             }
1594         }
1595 
1596         /**
1597          * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1598          * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1599          * object that was around when the deferred message was scheduled, and if there&#x27;s
1600          * a new Callbacks object around then also return null.  This will save us from
1601          * calling onto it with data that will be ignored.
1602          */
1603         Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1604             synchronized (mLock) {
1605                 if (mStopped) {
1606                     return null;
1607                 }
1608 
1609                 if (mCallbacks == null) {
1610                     return null;
1611                 }
1612 
1613                 final Callbacks callbacks = mCallbacks.get();
1614                 if (callbacks != oldCallbacks) {
1615                     return null;
1616                 }
1617                 if (callbacks == null) {
1618                     Log.w(TAG, &quot;no mCallbacks&quot;);
1619                     return null;
1620                 }
1621 
1622                 return callbacks;
1623             }
1624         }
1625 
1626         private void verifyApplications() {
1627             final Context context = mApp.getContext();
1628             // Cross reference all the applications in our apps list with items in the workspace
1629             ArrayList&lt;ItemInfo&gt; tmpInfos;
1630             ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1631             synchronized(sBgLock) {
1632                 for (AppInfo app : mBgAllAppsList.data) {
1633                     tmpInfos = getItemInfoForComponentName(app.componentName, app.user);
1634                     if (tmpInfos.isEmpty()) {
1635                         // We are missing an application icon, so add this to the workspace
1636                         added.add(app);
1637                         // This is a rare event, so lets log it
1638                         Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1639                     }
1640                 }
1641             }
1642             if (!added.isEmpty()) {
1643                 addAndBindAddedWorkspaceApps(context, added);
1644             }
1645         }
1646 
1647         // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
<abbr title="1648         private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item, AtomicBoolean deleteOnInvalidPlacement) {">1648         private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item, AtomicBoo🔵</abbr>
1649             LauncherAppState app = LauncherAppState.getInstance();
1650             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1651             final int countX = ((int) (grid.numColumns));
1652             final int countY = ((int) (grid.numRows));
1653             long containerIndex = item.screenId;
1654             if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1655                 // Return early if we detect that an item is under the hotseat button
<abbr title="1656                 if ((mCallbacks == null) || mCallbacks.get().isAllAppsButtonRank(((int) (item.screenId)))) {">1656                 if ((mCallbacks == null) || mCallbacks.get().isAllAppsButtonRank(((int) (item.screenId)))🔵</abbr>
1657                     deleteOnInvalidPlacement.set(true);
<abbr title="1658                     Log.e(TAG, (((((((&quot;Error loading shortcut into hotseat &quot; + item) + &quot; into position (&quot;) + item.screenId) + &quot;:&quot;) + item.cellX) + &quot;,&quot;) + item.cellY) + &quot;) occupied by all apps&quot;);">1658                     Log.e(TAG, (((((((&quot;Error loading shortcut into hotseat &quot; + item) + &quot; into position (&quot;🔵</abbr>
1659                     return false;
1660                 }
<abbr title="1661                 final ItemInfo[][] hotseatItems = occupied.get(((long) (LauncherSettings.Favorites.CONTAINER_HOTSEAT)));">1661                 final ItemInfo[][] hotseatItems = occupied.get(((long) (LauncherSettings.Favorites.CONTAI🔵</abbr>
1662                 if (item.screenId &gt;= grid.numHotseatIcons) {
<abbr title="1663                     Log.e(TAG, (((((&quot;Error loading shortcut &quot; + item) + &quot; into hotseat position &quot;) + item.screenId) + &quot;, position out of bounds: (0 to &quot;) + (grid.numHotseatIcons - 1)) + &quot;)&quot;);">1663                     Log.e(TAG, (((((&quot;Error loading shortcut &quot; + item) + &quot; into hotseat position &quot;) + item🔵</abbr>
1664                     return false;
1665                 }
1666                 if (hotseatItems != null) {
1667                     if (hotseatItems[((int) (item.screenId))][0] != null) {
<abbr title="1668                         Log.e(TAG, ((((((((&quot;Error loading shortcut into hotseat &quot; + item) + &quot; into position (&quot;) + item.screenId) + &quot;:&quot;) + item.cellX) + &quot;,&quot;) + item.cellY) + &quot;) occupied by &quot;) + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)[((int) (item.screenId))][0]);">1668                         Log.e(TAG, ((((((((&quot;Error loading shortcut into hotseat &quot; + item) + &quot; into positi🔵</abbr>
1669                         return false;
1670                     } else {
1671                         hotseatItems[((int) (item.screenId))][0] = item;
1672                         return true;
1673                     }
1674                 } else {
1675                     final ItemInfo[][] items = new ItemInfo[((int) (grid.numHotseatIcons))][1];
1676                     items[((int) (item.screenId))][0] = item;
1677                     occupied.put(((long) (LauncherSettings.Favorites.CONTAINER_HOTSEAT)), items);
1678                     return true;
1679                 }
1680             } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1681                 // Skip further checking if it is not the hotseat or workspace container
1682                 return true;
1683             }
1684             if (!occupied.containsKey(item.screenId)) {
1685                 ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1686                 occupied.put(item.screenId, items);
1687             }
1688             final ItemInfo[][] screens = occupied.get(item.screenId);
<abbr title="1689             if (((((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (item.cellX &lt; 0)) || (item.cellY &lt; 0)) || ((item.cellX + item.spanX) &gt; countX)) || ((item.cellY + item.spanY) &gt; countY)) {">1689             if (((((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (item.cellX &lt; 0)) 🔵</abbr>
<abbr title="1690                 Log.e(TAG, (((((((((((((&quot;Error loading shortcut &quot; + item) + &quot; into cell (&quot;) + containerIndex) + &quot;-&quot;) + item.screenId) + &quot;:&quot;) + item.cellX) + &quot;,&quot;) + item.cellY) + &quot;) out of screen bounds ( &quot;) + countX) + &quot;x&quot;) + countY) + &quot;)&quot;);">1690                 Log.e(TAG, (((((((((((((&quot;Error loading shortcut &quot; + item) + &quot; into cell (&quot;) + containerIn🔵</abbr>
1691                 return false;
1692             }
1693             // Check if any workspace icons overlap with each other
1694             for (int x = item.cellX; x &lt; (item.cellX + item.spanX); x++) {
1695                 for (int y = item.cellY; y &lt; (item.cellY + item.spanY); y++) {
1696                     if (screens[x][y] != null) {
<abbr title="1697                         Log.e(TAG, ((((((((((&quot;Error loading shortcut &quot; + item) + &quot; into cell (&quot;) + containerIndex) + &quot;-&quot;) + item.screenId) + &quot;:&quot;) + x) + &quot;,&quot;) + y) + &quot;) occupied by &quot;) + screens[x][y]);">1697                         Log.e(TAG, ((((((((((&quot;Error loading shortcut &quot; + item) + &quot; into cell (&quot;) + contai🔵</abbr>
1698                         return false;
1699                     }
1700                 }
1701             }
1702             for (int x = item.cellX; x &lt; (item.cellX + item.spanX); x++) {
1703                 for (int y = item.cellY; y &lt; (item.cellY + item.spanY); y++) {
1704                     screens[x][y] = item;
1705                 }
1706             }
1707             return true;
1708         }
1709 
1710         /** Clears all the sBg data structures */
1711         private void clearSBgDataStructures() {
1712             synchronized (sBgLock) {
1713                 sBgWorkspaceItems.clear();
1714                 sBgAppWidgets.clear();
1715                 sBgFolders.clear();
1716                 sBgItemsIdMap.clear();
1717                 sBgDbIconCache.clear();
1718                 sBgWorkspaceScreens.clear();
1719             }
1720         }
1721 
1722         /** Returns whether this is an upgrade path */
1723         private boolean loadWorkspace() {
1724             // Log to disk
1725             Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
1726             final long t = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
1727             final Context context = mContext;
1728             final ContentResolver contentResolver = context.getContentResolver();
1729             final PackageManager manager = context.getPackageManager();
1730             final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
1731             final boolean isSafeMode = manager.isSafeMode();
1732             final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
<abbr title="1733             final boolean isSdCardReady = context.registerReceiver(null, new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;">1733             final boolean isSdCardReady = context.registerReceiver(null, new IntentFilter(StartupReceiver🔵</abbr>
1734             LauncherAppState app = LauncherAppState.getInstance();
1735             DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1736             int countX = ((int) (grid.numColumns));
1737             int countY = ((int) (grid.numRows));
1738             if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
1739                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
1740                 LauncherAppState.getLauncherProvider().deleteDatabase();
1741             }
1742             if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
1743                 // append the user&#x27;s Launcher2 shortcuts
1744                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
1745                 LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
1746             } else {
1747                 // Make sure the default workspace is loaded
1748                 Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
1749                 LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();
1750             }
1751             // This code path is for our old migration code and should no longer be exercised
1752             boolean loadedOldDb = false;
1753             // Log to disk
1754             Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
1755             synchronized(sBgLock) {
1756                 clearSBgDataStructures();
<abbr title="1757                 final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat.getInstance(mContext).updateAndGetActiveSessionCache();">1757                 final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat.getInstance(mContext).updat🔵</abbr>
1758                 final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
1759                 final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
1760                 final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;
1761                 if (DEBUG_LOADERS) {
1762                     Log.d(TAG, &quot;loading model from &quot; + contentUri);
1763                 }
1764                 final Cursor c = contentResolver.query(contentUri, null, null, null, null);
1765                 // +1 for the hotseat (it can be larger than the workspace)
1766                 // Load workspace in reverse order to ensure that latest items are loaded first (and
1767                 // before any earlier duplicates)
1768                 final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
1769                 try {
1770                     final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
1771                     final int intentIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.INTENT);
1772                     final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
<abbr title="1773                     final int iconTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYPE);">1773                     final int iconTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_TYP🔵</abbr>
1774                     final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
<abbr title="1775                     final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_PACKAGE);">1775                     final int iconPackageIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_🔵</abbr>
<abbr title="1776                     final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON_RESOURCE);">1776                     final int iconResourceIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON🔵</abbr>
<abbr title="1777                     final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);">1777                     final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAIN🔵</abbr>
<abbr title="1778                     final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);">1778                     final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYP🔵</abbr>
<abbr title="1779                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWIDGET_ID);">1779                     final int appWidgetIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWI🔵</abbr>
<abbr title="1780                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.APPWIDGET_PROVIDER);">1780                     final int appWidgetProviderIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites🔵</abbr>
1781                     final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1782                     final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1783                     final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1784                     final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
1785                     final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
<abbr title="1786                     final int restoredIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.RESTORED);">1786                     final int restoredIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.RESTORED🔵</abbr>
<abbr title="1787                     final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);">1787                     final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE🔵</abbr>
1788                     //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
1789                     //final int displayModeIndex = c.getColumnIndexOrThrow(
1790                     //        LauncherSettings.Favorites.DISPLAY_MODE);
1791                     ShortcutInfo info;
1792                     String intentDescription;
1793                     LauncherAppWidgetInfo appWidgetInfo;
1794                     int container;
1795                     long id;
1796                     Intent intent;
1797                     UserHandleCompat user;
1798                     while ((!mStopped) &amp;&amp; c.moveToNext()) {
1799                         AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
1800                         try {
1801                             int itemType = c.getInt(itemTypeIndex);
1802                             boolean restored = 0 != c.getInt(restoredIndex);
1803                             boolean allowMissingTarget = false;
1804                             switch (itemType) {
1805                                 case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION :
1806                                 case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT :
1807                                     id = c.getLong(idIndex);
1808                                     intentDescription = c.getString(intentIndex);
1809                                     long serialNumber = c.getInt(profileIdIndex);
1810                                     user = mUserManager.getUserForSerialNumber(serialNumber);
1811                                     int promiseType = c.getInt(restoredIndex);
1812                                     if (user == null) {
1813                                         // User has been deleted remove the item.
1814                                         itemsToRemove.add(id);
1815                                         continue;
1816                                     }
1817                                     try {
1818                                         intent = Intent.parseUri(intentDescription, 0);
1819                                         ComponentName cn = intent.getComponent();
1820                                         if ((cn != null) &amp;&amp; (cn.getPackageName() != null)) {
<abbr title="1821                                             boolean validPkg = launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user);">1821                                             boolean validPkg = launcherApps.isPackageEnabledForProfile(cn🔵</abbr>
<abbr title="1822                                             boolean validComponent = validPkg &amp;&amp; launcherApps.isActivityEnabledForProfile(cn, user);">1822                                             boolean validComponent = validPkg &amp;&amp; launcherApps.isActivityE🔵</abbr>
1823                                             if (validComponent) {
1824                                                 if (restored) {
1825                                                     // no special handling necessary for this item
1826                                                     restoredRows.add(id);
1827                                                     restored = false;
1828                                                 }
1829                                             } else if (validPkg) {
1830                                                 intent = null;
<abbr title="1831                                                 if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {">1831                                                 if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 🔵</abbr>
1832                                                     // We allow auto install apps to have their intent
1833                                                     // updated after an install.
<abbr title="1834                                                     intent = manager.getLaunchIntentForPackage(cn.getPackageName());">1834                                                     intent = manager.getLaunchIntentForPackage(cn.getPack🔵</abbr>
1835                                                     if (intent != null) {
1836                                                         ContentValues values = new ContentValues();
<abbr title="1837                                                         values.put(LauncherSettings.Favorites.INTENT, intent.toUri(0));">1837                                                         values.put(LauncherSettings.Favorites.INTENT, int🔵</abbr>
1838                                                         String where = BaseColumns._ID + &quot;= ?&quot;;
<abbr title="1839                                                         String[] args = new java.lang.String[]{ Long.toString(id) };">1839                                                         String[] args = new java.lang.String[]{ Long.toSt🔵</abbr>
<abbr title="1840                                                         contentResolver.update(contentUri, values, where, args);">1840                                                         contentResolver.update(contentUri, values, where,🔵</abbr>
1841                                                     }
1842                                                 }
1843                                                 if (intent == null) {
1844                                                     // The app is installed but the component is no
1845                                                 // longer available.
<abbr title="1846                                                     Launcher.addDumpLog(TAG, &quot;Invalid component removed: &quot; + cn, true);">1846                                                     Launcher.addDumpLog(TAG, &quot;Invalid component removed: 🔵</abbr>
1847                                                     itemsToRemove.add(id);
1848                                                     continue;
1849                                                 } else {
1850                                                     // no special handling necessary for this item
1851                                                     restoredRows.add(id);
1852                                                     restored = false;
1853                                                 }
1854                                             } else if (restored) {
1855                                             // Package is not yet available but might be
1856                                             // installed later.
<abbr title="1857                                                 Launcher.addDumpLog(TAG, &quot;package not yet restored: &quot; + cn, true);">1857                                                 Launcher.addDumpLog(TAG, &quot;package not yet restored: &quot; + c🔵</abbr>
<abbr title="1858                                                 if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {">1858                                                 if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 🔵</abbr>
1859                                                     // Restore has started once.
<abbr title="1860                                                 } else if (installingPkgs.contains(cn.getPackageName())) {">1860                                                 } else if (installingPkgs.contains(cn.getPackageName())) 🔵</abbr>
1861                                                     // App restore has started. Update the flag
1862                                                     promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;
1863                                                     ContentValues values = new ContentValues();
<abbr title="1864                                                     values.put(LauncherSettings.Favorites.RESTORED, promiseType);">1864                                                     values.put(LauncherSettings.Favorites.RESTORED, promi🔵</abbr>
1865                                                     String where = BaseColumns._ID + &quot;= ?&quot;;
<abbr title="1866                                                     String[] args = new java.lang.String[]{ Long.toString(id) };">1866                                                     String[] args = new java.lang.String[]{ Long.toString🔵</abbr>
<abbr title="1867                                                     contentResolver.update(contentUri, values, where, args);">1867                                                     contentResolver.update(contentUri, values, where, arg🔵</abbr>
1868                                                 } else if (REMOVE_UNRESTORED_ICONS) {
<abbr title="1869                                                     Launcher.addDumpLog(TAG, &quot;Unrestored package removed: &quot; + cn, true);">1869                                                     Launcher.addDumpLog(TAG, &quot;Unrestored package removed:🔵</abbr>
1870                                                     itemsToRemove.add(id);
1871                                                     continue;
1872                                                 }
1873                                             } else if (isSdCardReady) {
1874                                             // Do not wait for external media load anymore.
1875                                                 // Log the invalid package, and remove it
<abbr title="1876                                                 Launcher.addDumpLog(TAG, &quot;Invalid package removed: &quot; + cn, true);">1876                                                 Launcher.addDumpLog(TAG, &quot;Invalid package removed: &quot; + cn🔵</abbr>
1877                                                 itemsToRemove.add(id);
1878                                                 continue;
1879                                             } else {
1880                                                 // SdCard is not ready yet. Package might get available,
1881                                                 // once it is ready.
<abbr title="1882                                                 Launcher.addDumpLog(TAG, (&quot;Invalid package: &quot; + cn) + &quot; (check again later)&quot;, true);">1882                                                 Launcher.addDumpLog(TAG, (&quot;Invalid package: &quot; + cn) + &quot; (🔵</abbr>
1883                                                 HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);
1884                                                 if (pkgs == null) {
1885                                                     pkgs = new HashSet&lt;String&gt;();
1886                                                     sPendingPackages.put(user, pkgs);
1887                                                 }
1888                                                 pkgs.add(cn.getPackageName());
1889                                                 allowMissingTarget = true;
1890                                             // Add the icon on the workspace anyway.
1891                                             }
1892                                         } else if (cn == null) {
1893                                             // For shortcuts with no component, keep them as they are
1894                                             restoredRows.add(id);
1895                                             restored = false;
1896                                         }
1897                                     } catch (URISyntaxException e) {
<abbr title="1898                                         Launcher.addDumpLog(TAG, &quot;Invalid uri: &quot; + intentDescription, true);">1898                                         Launcher.addDumpLog(TAG, &quot;Invalid uri: &quot; + intentDescription, tru🔵</abbr>
1899                                         continue;
1900                                     }
1901                                     if (restored) {
1902                                         if (user.equals(UserHandleCompat.myUserHandle())) {
<abbr title="1903                                             Launcher.addDumpLog(TAG, &quot;constructing info for partially restored package&quot;, true);">1903                                             Launcher.addDumpLog(TAG, &quot;constructing info for partially res🔵</abbr>
<abbr title="1904                                             info = getRestoredItemInfo(c, titleIndex, intent, promiseType);">1904                                             info = getRestoredItemInfo(c, titleIndex, intent, promiseType🔵</abbr>
1905                                             intent = getRestoredItemIntent(c, context, intent);
1906                                         } else {
1907                                             // Don&#x27;t restore items for other profiles.
1908                                             itemsToRemove.add(id);
1909                                             continue;
1910                                         }
<abbr title="1911                                     } else if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {">1911                                     } else if (itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATI🔵</abbr>
<abbr title="1912                                         info = getShortcutInfo(manager, intent, user, context, c, iconIndex, titleIndex, mLabelCache, allowMissingTarget);">1912                                         info = getShortcutInfo(manager, intent, user, context, c, iconInd🔵</abbr>
1913                                     } else {
<abbr title="1914                                         info = getShortcutInfo(c, context, iconTypeIndex, iconPackageIndex, iconResourceIndex, iconIndex, titleIndex);">1914                                         info = getShortcutInfo(c, context, iconTypeIndex, iconPackageInde🔵</abbr>
1915                                     // App shortcuts that used to be automatically added to Launcher
1916                                     // didn&#x27;t always have the correct intent flags set, so do that
1917                                     // here
<abbr title="1918                                         if ((((intent.getAction() != null) &amp;&amp; (intent.getCategories() != null)) &amp;&amp; intent.getAction().equals(Intent.ACTION_MAIN)) &amp;&amp; intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {">1918                                         if ((((intent.getAction() != null) &amp;&amp; (intent.getCategories() != 🔵</abbr>
<abbr title="1919                                             intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);">1919                                             intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_A🔵</abbr>
1920                                         }
1921                                     }
1922                                     if (info != null) {
1923                                         info.id = id;
1924                                         info.intent = intent;
1925                                         container = c.getInt(containerIndex);
1926                                         info.container = container;
1927                                         info.screenId = c.getInt(screenIndex);
1928                                         info.cellX = c.getInt(cellXIndex);
1929                                         info.cellY = c.getInt(cellYIndex);
1930                                         info.spanX = 1;
1931                                         info.spanY = 1;
1932                                         info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);
<abbr title="1933                                         info.isDisabled = isSafeMode &amp;&amp; (!Utilities.isSystemApp(context, intent));">1933                                         info.isDisabled = isSafeMode &amp;&amp; (!Utilities.isSystemApp(context, 🔵</abbr>
1934                                         // check &amp; update map of what&#x27;s occupied
1935                                         deleteOnInvalidPlacement.set(false);
<abbr title="1936                                         if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {">1936                                         if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)🔵</abbr>
1937                                             if (deleteOnInvalidPlacement.get()) {
1938                                                 itemsToRemove.add(id);
1939                                             }
1940                                             break;
1941                                         }
1942                                         switch (container) {
1943                                             case LauncherSettings.Favorites.CONTAINER_DESKTOP :
1944                                             case LauncherSettings.Favorites.CONTAINER_HOTSEAT :
1945                                                 sBgWorkspaceItems.add(info);
1946                                                 break;
1947                                             default :
1948                                         // Item is in a user folder
<abbr title="1949                                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, container);">1949                                                 FolderInfo folderInfo = findOrMakeFolder(sBgFolders, cont🔵</abbr>
1950                                                 folderInfo.add(info);
1951                                                 break;
1952                                         }
1953                                         sBgItemsIdMap.put(info.id, info);
1954                                         // now that we&#x27;ve loaded everthing re-save it with the
1955                                         // icon in case it disappears somehow.
1956                                         queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
1957                                     } else {
1958                                         throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
1959                                     }
1960                                     break;
1961                                 case LauncherSettings.Favorites.ITEM_TYPE_FOLDER :
1962                                     id = c.getLong(idIndex);
1963                                     FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
1964                                     folderInfo.title = c.getString(titleIndex);
1965                                     folderInfo.id = id;
1966                                     container = c.getInt(containerIndex);
1967                                     folderInfo.container = container;
1968                                     folderInfo.screenId = c.getInt(screenIndex);
1969                                     folderInfo.cellX = c.getInt(cellXIndex);
1970                                     folderInfo.cellY = c.getInt(cellYIndex);
1971                                     folderInfo.spanX = 1;
1972                                     folderInfo.spanY = 1;
1973                                     // check &amp; update map of what&#x27;s occupied
1974                                     deleteOnInvalidPlacement.set(false);
<abbr title="1975                                     if (!checkItemPlacement(occupied, folderInfo, deleteOnInvalidPlacement)) {">1975                                     if (!checkItemPlacement(occupied, folderInfo, deleteOnInvalidPlacemen🔵</abbr>
1976                                         if (deleteOnInvalidPlacement.get()) {
1977                                             itemsToRemove.add(id);
1978                                         }
1979                                         break;
1980                                     }
1981                                     switch (container) {
1982                                         case LauncherSettings.Favorites.CONTAINER_DESKTOP :
1983                                         case LauncherSettings.Favorites.CONTAINER_HOTSEAT :
1984                                             sBgWorkspaceItems.add(folderInfo);
1985                                             break;
1986                                     }
1987                                     if (restored) {
1988                                         // no special handling required for restored folders
1989                                         restoredRows.add(id);
1990                                     }
1991                                     sBgItemsIdMap.put(folderInfo.id, folderInfo);
1992                                     sBgFolders.put(folderInfo.id, folderInfo);
1993                                     break;
1994                                 case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET :
1995                                     // Read all Launcher-specific widget details
1996                                     int appWidgetId = c.getInt(appWidgetIdIndex);
1997                                     String savedProvider = c.getString(appWidgetProviderIndex);
1998                                     id = c.getLong(idIndex);
<abbr title="1999                                     final ComponentName component = ComponentName.unflattenFromString(savedProvider);">1999                                     final ComponentName component = ComponentName.unflattenFromString(sav🔵</abbr>
2000                                     final int restoreStatus = c.getInt(restoredIndex);
<abbr title="2001                                     final boolean isIdValid = (restoreStatus &amp; LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;">2001                                     final boolean isIdValid = (restoreStatus &amp; LauncherAppWidgetInfo.FLAG🔵</abbr>
<abbr title="2002                                     final boolean wasProviderReady = (restoreStatus &amp; LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;">2002                                     final boolean wasProviderReady = (restoreStatus &amp; LauncherAppWidgetIn🔵</abbr>
<abbr title="2003                                     final AppWidgetProviderInfo provider = (isIdValid) ? widgets.getAppWidgetInfo(appWidgetId) : findAppWidgetProviderInfoWithComponent(context, component);">2003                                     final AppWidgetProviderInfo provider = (isIdValid) ? widgets.getAppWi🔵</abbr>
2004                                     final boolean isProviderReady = isValidProvider(provider);
2005                                     if (((!isSafeMode) &amp;&amp; wasProviderReady) &amp;&amp; (!isProviderReady)) {
<abbr title="2006                                         String log = (((&quot;Deleting widget that isn\&#x27;t installed anymore: &quot; + &quot;id=&quot;) + id) + &quot; appWidgetId=&quot;) + appWidgetId;">2006                                         String log = (((&quot;Deleting widget that isn\&#x27;t installed anymore: &quot;🔵</abbr>
2007                                         Log.e(TAG, log);
2008                                         Launcher.addDumpLog(TAG, log, false);
2009                                         itemsToRemove.add(id);
2010                                     } else {
2011                                         if (isProviderReady) {
<abbr title="2012                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, provider.provider);">2012                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, provid🔵</abbr>
<abbr title="2013                                             int[] minSpan = Launcher.getMinSpanForWidget(context, provider);">2013                                             int[] minSpan = Launcher.getMinSpanForWidget(context, provide🔵</abbr>
2014                                             appWidgetInfo.minSpanX = minSpan[0];
2015                                             appWidgetInfo.minSpanY = minSpan[1];
2016                                             int status = restoreStatus;
2017                                             if (!wasProviderReady) {
2018                                                 // If provider was not previously ready, update the
2019                                                 // status and UI flag.
<abbr title="2020                                                 // Id would be valid only if the widget restore broadcast was received.">2020                                                 // Id would be valid only if the widget restore broadcast🔵</abbr>
2021                                                 if (isIdValid) {
2022                                                     status = LauncherAppWidgetInfo.RESTORE_COMPLETED;
2023                                                 } else {
<abbr title="2024                                                     status &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY;">2024                                                     status &amp;= ~LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_RE🔵</abbr>
2025                                                 }
2026                                             }
2027                                             appWidgetInfo.restoreStatus = status;
2028                                         } else {
<abbr title="2029                                             Log.v(TAG, ((((&quot;Widget restore pending id=&quot; + id) + &quot; appWidgetId=&quot;) + appWidgetId) + &quot; status =&quot;) + restoreStatus);">2029                                             Log.v(TAG, ((((&quot;Widget restore pending id=&quot; + id) + &quot; appWidg🔵</abbr>
<abbr title="2030                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, component);">2030                                             appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId, compon🔵</abbr>
2031                                             appWidgetInfo.restoreStatus = restoreStatus;
<abbr title="2032                                             if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {">2032                                             if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_START🔵</abbr>
2033                                                 // Restore has started once.
<abbr title="2034                                             } else if (installingPkgs.contains(component.getPackageName())) {">2034                                             } else if (installingPkgs.contains(component.getPackageName()🔵</abbr>
2035                                                 // App restore has started. Update the flag
<abbr title="2036                                                 appWidgetInfo.restoreStatus |= LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;">2036                                                 appWidgetInfo.restoreStatus |= LauncherAppWidgetInfo.FLAG🔵</abbr>
2037                                             } else if (REMOVE_UNRESTORED_ICONS) {
<abbr title="2038                                                 Launcher.addDumpLog(TAG, &quot;Unrestored widget removed: &quot; + component, true);">2038                                                 Launcher.addDumpLog(TAG, &quot;Unrestored widget removed: &quot; + 🔵</abbr>
2039                                                 itemsToRemove.add(id);
2040                                                 continue;
2041                                             }
2042                                         }
2043                                         appWidgetInfo.id = id;
2044                                         appWidgetInfo.screenId = c.getInt(screenIndex);
2045                                         appWidgetInfo.cellX = c.getInt(cellXIndex);
2046                                         appWidgetInfo.cellY = c.getInt(cellYIndex);
2047                                         appWidgetInfo.spanX = c.getInt(spanXIndex);
2048                                         appWidgetInfo.spanY = c.getInt(spanYIndex);
2049                                         container = c.getInt(containerIndex);
<abbr title="2050                                         if ((container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (container != LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {">2050                                         if ((container != LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;🔵</abbr>
<abbr title="2051                                             Log.e(TAG, &quot;Widget found where container != &quot; + &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);">2051                                             Log.e(TAG, &quot;Widget found where container != &quot; + &quot;CONTAINER_DE🔵</abbr>
2052                                             continue;
2053                                         }
2054                                         appWidgetInfo.container = c.getInt(containerIndex);
2055                                         // check &amp; update map of what&#x27;s occupied
2056                                         deleteOnInvalidPlacement.set(false);
<abbr title="2057                                         if (!checkItemPlacement(occupied, appWidgetInfo, deleteOnInvalidPlacement)) {">2057                                         if (!checkItemPlacement(occupied, appWidgetInfo, deleteOnInvalidP🔵</abbr>
2058                                             if (deleteOnInvalidPlacement.get()) {
2059                                                 itemsToRemove.add(id);
2060                                             }
2061                                             break;
2062                                         }
<abbr title="2063                                         String providerName = appWidgetInfo.providerName.flattenToString();">2063                                         String providerName = appWidgetInfo.providerName.flattenToString(🔵</abbr>
<abbr title="2064                                         if ((!providerName.equals(savedProvider)) || (appWidgetInfo.restoreStatus != restoreStatus)) {">2064                                         if ((!providerName.equals(savedProvider)) || (appWidgetInfo.resto🔵</abbr>
2065                                             ContentValues values = new ContentValues();
<abbr title="2066                                             values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER, providerName);">2066                                             values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER, pro🔵</abbr>
<abbr title="2067                                             values.put(LauncherSettings.Favorites.RESTORED, appWidgetInfo.restoreStatus);">2067                                             values.put(LauncherSettings.Favorites.RESTORED, appWidgetInfo🔵</abbr>
2068                                             String where = BaseColumns._ID + &quot;= ?&quot;;
2069                                             String[] args = new java.lang.String[]{ Long.toString(id) };
2070                                             contentResolver.update(contentUri, values, where, args);
2071                                         }
2072                                         sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2073                                         sBgAppWidgets.add(appWidgetInfo);
2074                                     }
2075                                     break;
2076                             }
2077                         } catch (java.lang.Exception e) {
2078                             Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2079                         }
2080                     }
2081                 } finally {
2082                     if (c != null) {
2083                         c.close();
2084                     }
2085                 }
2086                 // Break early if we&#x27;ve stopped loading
2087                 if (mStopped) {
2088                     clearSBgDataStructures();
2089                     return false;
2090                 }
2091                 if (itemsToRemove.size() &gt; 0) {
<abbr title="2092                     ContentProviderClient client = contentResolver.acquireContentProviderClient(contentUri);">2092                     ContentProviderClient client = contentResolver.acquireContentProviderClient(contentUr🔵</abbr>
2093                     // Remove dead items
2094                     for (long id : itemsToRemove) {
2095                         if (DEBUG_LOADERS) {
2096                             Log.d(TAG, &quot;Removed id = &quot; + id);
2097                         }
2098                         // Don&#x27;t notify content observers
2099                         try {
<abbr title="2100                             client.delete(LauncherSettings.Favorites.getContentUri(id, false), null, null);">2100                             client.delete(LauncherSettings.Favorites.getContentUri(id, false), null, null🔵</abbr>
2101                         } catch (RemoteException e) {
2102                             Log.w(TAG, &quot;Could not remove id = &quot; + id);
2103                         }
2104                     }
2105                 }
2106                 if (restoredRows.size() &gt; 0) {
<abbr title="2107                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(contentUri);">2107                     ContentProviderClient updater = contentResolver.acquireContentProviderClient(contentU🔵</abbr>
2108                     // Update restored items that no longer require special handling
2109                     try {
2110                         StringBuilder selectionBuilder = new StringBuilder();
2111                         selectionBuilder.append(LauncherSettings.Favorites._ID);
2112                         selectionBuilder.append(&quot; IN (&quot;);
2113                         selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2114                         selectionBuilder.append(&quot;)&quot;);
2115                         ContentValues values = new ContentValues();
2116                         values.put(LauncherSettings.Favorites.RESTORED, 0);
<abbr title="2117                         updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values, selectionBuilder.toString(), null);">2117                         updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values, se🔵</abbr>
2118                     } catch (RemoteException e) {
2119                         Log.w(TAG, &quot;Could not update restored rows&quot;);
2120                     }
2121                 }
2122                 if ((!isSdCardReady) &amp;&amp; (!sPendingPackages.isEmpty())) {
<abbr title="2123                     context.registerReceiver(new AppsAvailabilityCheck(), new IntentFilter(StartupReceiver.SYSTEM_READY), null, sWorker);">2123                     context.registerReceiver(new AppsAvailabilityCheck(), new IntentFilter(StartupReceive🔵</abbr>
2124                 }
2125                 if (loadedOldDb) {
2126                     long maxScreenId = 0;
2127                     // If we&#x27;re importing we use the old screen order.
2128                     for (ItemInfo item : sBgItemsIdMap.values()) {
2129                         long screenId = item.screenId;
<abbr title="2130                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (!sBgWorkspaceScreens.contains(screenId))) {">2130                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (!sBgWork🔵</abbr>
2131                             sBgWorkspaceScreens.add(screenId);
2132                             if (screenId &gt; maxScreenId) {
2133                                 maxScreenId = screenId;
2134                             }
2135                         }
2136                     }
2137                     Collections.sort(sBgWorkspaceScreens);
2138                     // Log to disk
2139                     Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
<abbr title="2140                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);">2140                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, 🔵</abbr>
2141                     LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2142                     updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2143                     // Update the max item id after we load an old db
2144                     long maxItemId = 0;
2145                     // If we&#x27;re importing we use the old screen order.
2146                     for (ItemInfo item : sBgItemsIdMap.values()) {
2147                         maxItemId = Math.max(maxItemId, item.id);
2148                     }
2149                     LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2150                 } else {
2151                     TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2152                     for (Integer i : orderedScreens.keySet()) {
2153                         sBgWorkspaceScreens.add(orderedScreens.get(i));
2154                     }
2155                     // Log to disk
<abbr title="2156                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);">2156                     Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; + TextUtils.join(&quot;, &quot;, 🔵</abbr>
2157                     // Remove any empty screens
2158                     ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2159                     for (ItemInfo item : sBgItemsIdMap.values()) {
2160                         long screenId = item.screenId;
<abbr title="2161                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; unusedScreens.contains(screenId)) {">2161                         if ((item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; unusedScr🔵</abbr>
2162                             unusedScreens.remove(screenId);
2163                         }
2164                     }
2165                     // If there are any empty screens remove them, and update.
2166                     if (unusedScreens.size() != 0) {
2167                         // Log to disk
<abbr title="2168                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; + TextUtils.join(&quot;, &quot;, unusedScreens), true);">2168                         Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; + TextUti🔵</abbr>
2169                         sBgWorkspaceScreens.removeAll(unusedScreens);
2170                         updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2171                     }
2172                 }
2173                 if (DEBUG_LOADERS) {
2174                     Log.d(TAG, (&quot;loaded workspace in &quot; + (SystemClock.uptimeMillis() - t)) + &quot;ms&quot;);
2175                     Log.d(TAG, &quot;workspace layout: &quot;);
2176                     int nScreens = occupied.size();
2177                     for (int y = 0; y &lt; countY; y++) {
2178                         String line = &quot;&quot;;
2179                         Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2180                         while (iter.hasNext()) {
2181                             long screenId = iter.next();
2182                             if (screenId &gt; 0) {
2183                                 line += &quot; | &quot;;
2184                             }
2185                             for (int x = 0; x &lt; countX; x++) {
2186                                 ItemInfo[][] screen = occupied.get(screenId);
2187                                 if ((x &lt; screen.length) &amp;&amp; (y &lt; screen[x].length)) {
2188                                     line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;
2189                                 } else {
2190                                     line += &quot;!&quot;;
2191                                 }
2192                             }
2193                         }
2194                         Log.d(TAG, (&quot;[ &quot; + line) + &quot; ]&quot;);
2195                     }
2196                 }
2197             }
2198             return loadedOldDb;
2199         }
2200 
2201         /** Filters the set of items who are directly or indirectly (via another container) on the
2202          * specified screen. */
<abbr title="2203         private void filterCurrentWorkspaceItems(long currentScreenId, ArrayList&lt;ItemInfo&gt; allWorkspaceItems, ArrayList&lt;ItemInfo&gt; currentScreenItems, ArrayList&lt;ItemInfo&gt; otherScreenItems) {">2203         private void filterCurrentWorkspaceItems(long currentScreenId, ArrayList&lt;ItemInfo&gt; allWorkspaceIt🔵</abbr>
2204             // Purge any null ItemInfos
2205             Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2206             while (iter.hasNext()) {
2207                 ItemInfo i = iter.next();
2208                 if (i == null) {
2209                     iter.remove();
2210                 }
2211             }
2212             // Order the set of items by their containers first, this allows use to walk through the
2213             // list sequentially, build up a list of containers that are in the specified screen,
2214             // as well as all items in those containers.
2215             Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2216             Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2217                 @Override
2218                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2219                     return ((int) (lhs.container - rhs.container));
2220                 }
2221             });
2222             for (ItemInfo info : allWorkspaceItems) {
2223                 if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2224                     if (info.screenId == currentScreenId) {
2225                         currentScreenItems.add(info);
2226                         itemsOnScreen.add(info.id);
2227                     } else {
2228                         otherScreenItems.add(info);
2229                     }
2230                 } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2231                     currentScreenItems.add(info);
2232                     itemsOnScreen.add(info.id);
2233                 } else if (itemsOnScreen.contains(info.container)) {
2234                     currentScreenItems.add(info);
2235                     itemsOnScreen.add(info.id);
2236                 } else {
2237                     otherScreenItems.add(info);
2238                 }
2239             }
2240         }
2241 
2242         /** Filters the set of widgets which are on the specified screen. */
<abbr title="2243         private void filterCurrentAppWidgets(long currentScreenId, ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets, ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets, ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {">2243         private void filterCurrentAppWidgets(long currentScreenId, ArrayList&lt;LauncherAppWidgetInfo&gt; appWi🔵</abbr>
2244             for (LauncherAppWidgetInfo widget : appWidgets) {
2245                 if (widget == null) {
2246                     continue;
2247                 }
<abbr title="2248                 if ((widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (widget.screenId == currentScreenId)) {">2248                 if ((widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (widget.screenI🔵</abbr>
2249                     currentScreenWidgets.add(widget);
2250                 } else {
2251                     otherScreenWidgets.add(widget);
2252                 }
2253             }
2254         }
2255 
2256         /** Filters the set of folders which are on the specified screen. */
<abbr title="2257         private void filterCurrentFolders(long currentScreenId, HashMap&lt;Long, ItemInfo&gt; itemsIdMap, HashMap&lt;Long, FolderInfo&gt; folders, HashMap&lt;Long, FolderInfo&gt; currentScreenFolders, HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {">2257         private void filterCurrentFolders(long currentScreenId, HashMap&lt;Long, ItemInfo&gt; itemsIdMap, HashM🔵</abbr>
2258             for (long id : folders.keySet()) {
2259                 ItemInfo info = itemsIdMap.get(id);
2260                 FolderInfo folder = folders.get(id);
2261                 if ((info == null) || (folder == null)) {
2262                     continue;
2263                 }
<abbr title="2264                 if ((info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (info.screenId == currentScreenId)) {">2264                 if ((info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) &amp;&amp; (info.screenId ==🔵</abbr>
2265                     currentScreenFolders.put(id, folder);
2266                 } else {
2267                     otherScreenFolders.put(id, folder);
2268                 }
2269             }
2270         }
2271 
2272         /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2273          * right) */
2274         private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2275             final LauncherAppState app = LauncherAppState.getInstance();
2276             final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2277             // XXX: review this
2278             Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2279                 @Override
2280                 public int compare(ItemInfo lhs, ItemInfo rhs) {
2281                     int cellCountX = ((int) (grid.numColumns));
2282                     int cellCountY = ((int) (grid.numRows));
2283                     int screenOffset = cellCountX * cellCountY;
2284                     int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1);// +1 hotseat
2285 
<abbr title="2286                     long lr = (((lhs.container * containerOffset) + (lhs.screenId * screenOffset)) + (lhs.cellY * cellCountX)) + lhs.cellX;">2286                     long lr = (((lhs.container * containerOffset) + (lhs.screenId * screenOffset)) + (lhs🔵</abbr>
<abbr title="2287                     long rr = (((rhs.container * containerOffset) + (rhs.screenId * screenOffset)) + (rhs.cellY * cellCountX)) + rhs.cellX;">2287                     long rr = (((rhs.container * containerOffset) + (rhs.screenId * screenOffset)) + (rhs🔵</abbr>
2288                     return ((int) (lr - rr));
2289                 }
2290             });
2291         }
2292 
2293         private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2294                 final ArrayList&lt;Long&gt; orderedScreens) {
2295             final Runnable r = new Runnable() {
2296                 @Override
2297                 public void run() {
2298                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2299                     if (callbacks != null) {
2300                         callbacks.bindScreens(orderedScreens);
2301                     }
2302                 }
2303             };
2304             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2305         }
2306 
<abbr title="2307         private void bindWorkspaceItems(final Callbacks oldCallbacks, final ArrayList&lt;ItemInfo&gt; workspaceItems, final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets, final HashMap&lt;Long, FolderInfo&gt; folders, ArrayList&lt;Runnable&gt; deferredBindRunnables) {">2307         private void bindWorkspaceItems(final Callbacks oldCallbacks, final ArrayList&lt;ItemInfo&gt; workspace🔵</abbr>
2308             final boolean postOnMainThread = deferredBindRunnables != null;
2309             // Bind the workspace items
2310             int N = workspaceItems.size();
2311             for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2312                 final int start = i;
2313                 final int chunkSize = ((i + ITEMS_CHUNK) &lt;= N) ? ITEMS_CHUNK : N - i;
2314                 final Runnable r = new Runnable() {
2315                     @Override
2316                     public void run() {
2317                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2318                         if (callbacks != null) {
2319                             callbacks.bindItems(workspaceItems, start, start + chunkSize, false);
2320                         }
2321                     }
2322                 };
2323                 if (postOnMainThread) {
2324                     synchronized(deferredBindRunnables) {
2325                         deferredBindRunnables.add(r);
2326                     }
2327                 } else {
2328                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2329                 }
2330             }
2331             // Bind the folders
2332             if (!folders.isEmpty()) {
2333                 final Runnable r = new Runnable() {
2334                     public void run() {
2335                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2336                         if (callbacks != null) {
2337                             callbacks.bindFolders(folders);
2338                         }
2339                     }
2340                 };
2341                 if (postOnMainThread) {
2342                     synchronized(deferredBindRunnables) {
2343                         deferredBindRunnables.add(r);
2344                     }
2345                 } else {
2346                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2347                 }
2348             }
2349             // Bind the widgets, one at a time
2350             N = appWidgets.size();
2351             for (int i = 0; i &lt; N; i++) {
2352                 final LauncherAppWidgetInfo widget = appWidgets.get(i);
2353                 final Runnable r = new Runnable() {
2354                     public void run() {
2355                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2356                         if (callbacks != null) {
2357                             callbacks.bindAppWidget(widget);
2358                         }
2359                     }
2360                 };
2361                 if (postOnMainThread) {
2362                     deferredBindRunnables.add(r);
2363                 } else {
2364                     runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2365                 }
2366             }
2367         }
2368 
2369         /**
2370          * Binds all loaded data to actual views on the main thread.
2371          */
2372         private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2373             final long t = SystemClock.uptimeMillis();
2374             Runnable r;
2375             // Don&#x27;t use these two variables in any of the callback runnables.
2376             // Otherwise we hold a reference to them.
2377             final Callbacks oldCallbacks = mCallbacks.get();
2378             if (oldCallbacks == null) {
2379                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2380                 Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2381                 return;
2382             }
2383             // Save a copy of all the bg-thread collections
2384             ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2385             ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2386             HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2387             HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2388             ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2389             synchronized(sBgLock) {
2390                 workspaceItems.addAll(sBgWorkspaceItems);
2391                 appWidgets.addAll(sBgAppWidgets);
2392                 folders.putAll(sBgFolders);
2393                 itemsIdMap.putAll(sBgItemsIdMap);
2394                 orderedScreenIds.addAll(sBgWorkspaceScreens);
2395             }
2396             final boolean isLoadingSynchronously = synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
<abbr title="2397             int currScreen = (isLoadingSynchronously) ? synchronizeBindPage : oldCallbacks.getCurrentWorkspaceScreen();">2397             int currScreen = (isLoadingSynchronously) ? synchronizeBindPage : oldCallbacks.getCurrentWork🔵</abbr>
2398             if (currScreen &gt;= orderedScreenIds.size()) {
2399                 // There may be no workspace screens (just hotseat items and an empty page).
2400                 currScreen = PagedView.INVALID_RESTORE_PAGE;
2401             }
2402             final int currentScreen = currScreen;
<abbr title="2403             final long currentScreenId = (currentScreen &lt; 0) ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);">2403             final long currentScreenId = (currentScreen &lt; 0) ? INVALID_SCREEN_ID : orderedScreenIds.get(c🔵</abbr>
2404             // Load all the items that are on the current page first (and in the process, unbind
2405             // all the existing workspace items before we call startBinding() below.
2406             unbindWorkspaceItemsOnMainThread();
2407             // Separate the items that are on the current screen, and all the other remaining items
2408             ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2409             ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2410             ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2411             ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets = new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2412             HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2413             HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
<abbr title="2414             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems, otherWorkspaceItems);">2414             filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems, otherWork🔵</abbr>
2415             filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets, otherAppWidgets);
2416             filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders, otherFolders);
2417             sortWorkspaceItemsSpatially(currentWorkspaceItems);
2418             sortWorkspaceItemsSpatially(otherWorkspaceItems);
2419             // Tell the workspace that we&#x27;re about to start binding items
2420             r = new Runnable() {
2421                 public void run() {
2422                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2423                     if (callbacks != null) {
2424                         callbacks.startBinding();
2425                     }
2426                 }
2427             };
2428             runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2429             bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2430             // Load items on the current page
<abbr title="2431             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets, currentFolders, null);">2431             bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets, currentFolders, nu🔵</abbr>
2432             if (isLoadingSynchronously) {
2433                 r = new Runnable() {
2434                     public void run() {
2435                         Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2436                         if ((callbacks != null) &amp;&amp; (currentScreen != PagedView.INVALID_RESTORE_PAGE)) {
2437                             callbacks.onPageBoundSynchronously(currentScreen);
2438                         }
2439                     }
2440                 };
2441                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2442             }
2443             // Load all the remaining pages (if we are loading synchronously, we want to defer this
2444             // work until after the first render)
2445             synchronized(mDeferredBindRunnables) {
2446                 mDeferredBindRunnables.clear();
2447             }
<abbr title="2448             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders, isLoadingSynchronously ? mDeferredBindRunnables : null);">2448             bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders, isLoadin🔵</abbr>
2449             // Tell the workspace that we&#x27;re done binding items
2450             r = new Runnable() {
2451                 public void run() {
2452                     Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2453                     if (callbacks != null) {
2454                         callbacks.finishBindingItems(isUpgradePath);
2455                     }
2456                     // If we&#x27;re profiling, ensure this is the last thing in the queue.
2457                     if (DEBUG_LOADERS) {
2458                         Log.d(TAG, (&quot;bound workspace in &quot; + (SystemClock.uptimeMillis() - t)) + &quot;ms&quot;);
2459                     }
2460                     mIsLoadingAndBindingWorkspace = false;
2461                 }
2462             };
2463             if (isLoadingSynchronously) {
2464                 synchronized(mDeferredBindRunnables) {
2465                     mDeferredBindRunnables.add(r);
2466                 }
2467             } else {
2468                 runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2469             }
2470         }
2471 
2472         private void loadAndBindAllApps() {
2473             if (DEBUG_LOADERS) {
2474                 Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2475             }
2476             if (!mAllAppsLoaded) {
2477                 loadAllApps();
2478                 synchronized (LoaderTask.this) {
2479                     if (mStopped) {
2480                         return;
2481                     }
2482                     mAllAppsLoaded = true;
2483                 }
2484             } else {
2485                 onlyBindAllApps();
2486             }
2487         }
2488 
2489         private void onlyBindAllApps() {
2490             final Callbacks oldCallbacks = mCallbacks.get();
2491             if (oldCallbacks == null) {
2492                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2493                 Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
2494                 return;
2495             }
2496             // shallow copy
2497             @SuppressWarnings(&quot;unchecked&quot;)
2498             final ArrayList&lt;AppInfo&gt; list = ((ArrayList&lt;AppInfo&gt;) (mBgAllAppsList.data.clone()));
2499             Runnable r = new Runnable() {
2500                 public void run() {
2501                     final long t = SystemClock.uptimeMillis();
2502                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2503                     if (callbacks != null) {
2504                         callbacks.bindAllApplications(list);
2505                     }
2506                     if (DEBUG_LOADERS) {
<abbr title="2507                         Log.d(TAG, (((&quot;bound all &quot; + list.size()) + &quot; apps from cache in &quot;) + (SystemClock.uptimeMillis() - t)) + &quot;ms&quot;);">2507                         Log.d(TAG, (((&quot;bound all &quot; + list.size()) + &quot; apps from cache in &quot;) + (SystemCloc🔵</abbr>
2508                     }
2509                 }
2510             };
2511             boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
2512             if (isRunningOnMainThread) {
2513                 r.run();
2514             } else {
2515                 mHandler.post(r);
2516             }
2517         }
2518 
2519         private void loadAllApps() {
2520             final long loadTime = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
2521             final Callbacks oldCallbacks = mCallbacks.get();
2522             if (oldCallbacks == null) {
2523                 // This launcher has exited and nobody bothered to tell us.  Just bail.
2524                 Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
2525                 return;
2526             }
2527             final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
2528             mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2529             final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();
2530             // Clear the list of apps
2531             mBgAllAppsList.clear();
2532             for (UserHandleCompat user : profiles) {
2533                 // Query for the set of apps
2534                 final long qiaTime = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
2535                 List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);
2536                 if (DEBUG_LOADERS) {
<abbr title="2537                     Log.d(TAG, ((&quot;getActivityList took &quot; + (SystemClock.uptimeMillis() - qiaTime)) + &quot;ms for user &quot;) + user);">2537                     Log.d(TAG, ((&quot;getActivityList took &quot; + (SystemClock.uptimeMillis() - qiaTime)) + &quot;ms 🔵</abbr>
2538                     Log.d(TAG, ((&quot;getActivityList got &quot; + apps.size()) + &quot; apps for user &quot;) + user);
2539                 }
2540             // Fail if we don&#x27;t have any apps
2541                 if ((apps == null) || apps.isEmpty()) {
2542                     return;
2543                 }
2544                 // Sort the applications by name
2545                 final long sortTime = (DEBUG_LOADERS) ? SystemClock.uptimeMillis() : 0;
2546                 Collections.sort(apps, new LauncherModel.ShortcutNameComparator(mLabelCache));
2547                 if (DEBUG_LOADERS) {
2548                     Log.d(TAG, (&quot;sort took &quot; + (SystemClock.uptimeMillis() - sortTime)) + &quot;ms&quot;);
2549                 }
2550             // Create the ApplicationInfos
2551                 for (int i = 0; i &lt; apps.size(); i++) {
2552                     LauncherActivityInfoCompat app = apps.get(i);
2553                 // This builds the icon bitmaps.
2554                     mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));
2555                 }
2556             }
2557             // Huh? Shouldn&#x27;t this be inside the Runnable below?
2558             final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
2559             mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
2560             // Post callback on main thread
2561             mHandler.post(new Runnable() {
2562                 public void run() {
2563                     final long bindTime = SystemClock.uptimeMillis();
2564                     final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2565                     if (callbacks != null) {
2566                         callbacks.bindAllApplications(added);
2567                         if (DEBUG_LOADERS) {
<abbr title="2568                             Log.d(TAG, (((&quot;bound &quot; + added.size()) + &quot; apps in &quot;) + (SystemClock.uptimeMillis() - bindTime)) + &quot;ms&quot;);">2568                             Log.d(TAG, (((&quot;bound &quot; + added.size()) + &quot; apps in &quot;) + (SystemClock.uptimeMi🔵</abbr>
2569                         }
2570                     } else {
2571                         Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
2572                     }
2573                 }
2574             });
2575             if (DEBUG_LOADERS) {
2576                 Log.d(TAG, (&quot;Icons processed in &quot; + (SystemClock.uptimeMillis() - loadTime)) + &quot;ms&quot;);
2577             }
2578         }
2579 
2580         public void dumpState() {
2581             synchronized(sBgLock) {
2582                 Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
2583                 Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
2584                 Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
2585                 Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
2586                 Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
2587             }
2588         }
2589     }
2590 
2591     void enqueuePackageUpdated(PackageUpdatedTask task) {
2592         sWorker.post(task);
2593     }
2594 
2595     private class AppsAvailabilityCheck extends BroadcastReceiver {
2596         @Override
2597         public void onReceive(Context context, Intent intent) {
2598             synchronized(sBgLock) {
<abbr title="2599                 final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(mApp.getContext());">2599                 final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(mApp.getContext())🔵</abbr>
2600                 ArrayList&lt;String&gt; packagesRemoved;
2601                 for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {
2602                     UserHandleCompat user = entry.getKey();
2603                     packagesRemoved = new ArrayList&lt;String&gt;();
2604                     for (String pkg : entry.getValue()) {
2605                         if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {
2606                             Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);
2607                             packagesRemoved.add(pkg);
2608                         }
2609                     }
2610                     if (!packagesRemoved.isEmpty()) {
<abbr title="2611                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE, packagesRemoved.toArray(new String[packagesRemoved.size()]), user));">2611                         enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE, packag🔵</abbr>
2612                     }
2613                 }
2614                 sPendingPackages.clear();
2615             }
2616         }
2617     }
2618 
2619     /**
2620      * Workaround to re-check unrestored items, in-case they were installed but the Package-ADD
2621      * runnable was missed by the launcher.
2622      */
2623     public void recheckRestoredItems(final Context context) {
2624         Runnable r = new Runnable() {
2625             @Override
2626             public void run() {
2627                 LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2628                 HashSet&lt;String&gt; installedPackages = new HashSet&lt;String&gt;();
2629                 UserHandleCompat user = UserHandleCompat.myUserHandle();
2630                 synchronized(sBgLock) {
2631                     for (ItemInfo info : sBgItemsIdMap.values()) {
2632                         if (info instanceof ShortcutInfo) {
2633                             ShortcutInfo si = ((ShortcutInfo) (info));
<abbr title="2634                             if ((si.isPromise() &amp;&amp; (si.getTargetComponent() != null)) &amp;&amp; launcherApps.isPackageEnabledForProfile(si.getTargetComponent().getPackageName(), user)) {">2634                             if ((si.isPromise() &amp;&amp; (si.getTargetComponent() != null)) &amp;&amp; launcherApps.isP🔵</abbr>
2635                                 installedPackages.add(si.getTargetComponent().getPackageName());
2636                             }
2637                         } else if (info instanceof LauncherAppWidgetInfo) {
2638                             LauncherAppWidgetInfo widget = ((LauncherAppWidgetInfo) (info));
<abbr title="2639                             if (widget.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) &amp;&amp; launcherApps.isPackageEnabledForProfile(widget.providerName.getPackageName(), user)) {">2639                             if (widget.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) &amp;&amp; l🔵</abbr>
2640                                 installedPackages.add(widget.providerName.getPackageName());
2641                             }
2642                         }
2643                     }
2644                 }
2645                 if (!installedPackages.isEmpty()) {
2646                     final ArrayList&lt;AppInfo&gt; restoredApps = new ArrayList&lt;AppInfo&gt;();
2647                     for (String pkg : installedPackages) {
2648                         for (LauncherActivityInfoCompat info : launcherApps.getActivityList(pkg, user)) {
2649                             restoredApps.add(new AppInfo(context, info, user, mIconCache, null));
2650                         }
2651                     }
2652                     final Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
2653                     if (!restoredApps.isEmpty()) {
2654                         mHandler.post(new Runnable() {
2655                             public void run() {
2656                                 Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2657                                 if ((callbacks == cb) &amp;&amp; (cb != null)) {
2658                                     callbacks.bindAppsRestored(restoredApps);
2659                                 }
2660                             }
2661                         });
2662                     }
2663                 }
2664             }
2665         };
2666         sWorker.post(r);
2667     }
2668 
2669     private class PackageUpdatedTask implements Runnable {
2670         int mOp;
2671 
2672         String[] mPackages;
2673 
2674         UserHandleCompat mUser;
2675 
2676         public static final int OP_NONE = 0;
2677 
2678         public static final int OP_ADD = 1;
2679 
2680         public static final int OP_UPDATE = 2;
2681 
2682         // uninstlled
2683         public static final int OP_REMOVE = 3; // uninstlled
2684 
2685         // external media unmounted
2686         public static final int OP_UNAVAILABLE = 4; // external media unmounted
2687 
2688         public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {
2689             mOp = op;
2690             mPackages = packages;
2691             mUser = user;
2692         }
2693 
2694         public void run() {
2695             final Context context = mApp.getContext();
2696             final String[] packages = mPackages;
2697             final int N = packages.length;
2698             switch (mOp) {
2699                 case OP_ADD :
2700                     for (int i = 0; i &lt; N; i++) {
2701                         if (DEBUG_LOADERS) {
2702                             Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
2703                         }
2704                         mIconCache.remove(packages[i], mUser);
2705                         mBgAllAppsList.addPackage(context, packages[i], mUser);
2706                     }
2707                     break;
2708                 case OP_UPDATE :
2709                     for (int i = 0; i &lt; N; i++) {
2710                         if (DEBUG_LOADERS) {
2711                             Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
2712                         }
2713                         mBgAllAppsList.updatePackage(context, packages[i], mUser);
<abbr title="2714                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[i]);">2714                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[🔵</abbr>
2715                     }
2716                     break;
2717                 case OP_REMOVE :
2718                 case OP_UNAVAILABLE :
2719                     for (int i = 0; i &lt; N; i++) {
2720                         if (DEBUG_LOADERS) {
2721                             Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
2722                         }
2723                         mBgAllAppsList.removePackage(packages[i], mUser);
<abbr title="2724                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[i]);">2724                         WidgetPreviewLoader.removePackageFromDb(mApp.getWidgetPreviewCacheDb(), packages[🔵</abbr>
2725                     }
2726                     break;
2727             }
2728             ArrayList&lt;AppInfo&gt; added = null;
2729             ArrayList&lt;AppInfo&gt; modified = null;
2730             final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
2731             if (mBgAllAppsList.added.size() &gt; 0) {
2732                 added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
2733                 mBgAllAppsList.added.clear();
2734             }
2735             if (mBgAllAppsList.modified.size() &gt; 0) {
2736                 modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
2737                 mBgAllAppsList.modified.clear();
2738             }
2739             if (mBgAllAppsList.removed.size() &gt; 0) {
2740                 removedApps.addAll(mBgAllAppsList.removed);
2741                 mBgAllAppsList.removed.clear();
2742             }
2743             final Callbacks callbacks = (mCallbacks != null) ? mCallbacks.get() : null;
2744             if (callbacks == null) {
2745                 Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
2746                 return;
2747             }
2748             if (added != null) {
2749                 // Ensure that we add all the workspace applications to the db
2750                 if (LauncherAppState.isDisableAllApps()) {
2751                     final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);
2752                     addAndBindAddedWorkspaceApps(context, addedInfos);
2753                 } else {
2754                     addAppsToAllApps(context, added);
2755                 }
2756             }
2757             if (modified != null) {
2758                 final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
2759                 // Update the launcher db to reflect the changes
2760                 for (AppInfo a : modifiedFinal) {
2761                     ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
2762                     for (ItemInfo i : infos) {
2763                         if (isShortcutInfoUpdateable(i)) {
2764                             ShortcutInfo info = ((ShortcutInfo) (i));
2765                             info.title = a.title.toString();
2766                             info.contentDescription = a.contentDescription;
2767                             updateItemInDatabase(context, info);
2768                         }
2769                     }
2770                 }
2771                 mHandler.post(new Runnable() {
2772                     public void run() {
2773                         Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2774                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
2775                             callbacks.bindAppsUpdated(modifiedFinal);
2776                         }
2777                     }
2778                 });
2779             }
2780             final ArrayList&lt;String&gt; removedPackageNames = new ArrayList&lt;String&gt;();
2781             if (mOp == OP_REMOVE) {
2782                 // Mark all packages in the broadcast to be removed
2783                 removedPackageNames.addAll(Arrays.asList(packages));
2784             } else if (mOp == OP_UPDATE) {
2785                 // Mark disabled packages in the broadcast to be removed
2786                 final PackageManager pm = context.getPackageManager();
2787                 for (int i = 0; i &lt; N; i++) {
2788                     if (isPackageDisabled(context, packages[i], mUser)) {
2789                         removedPackageNames.add(packages[i]);
2790                     }
2791                 }
2792             }
2793             // Remove all the components associated with this package
2794             for (String pn : removedPackageNames) {
2795                 deletePackageFromDatabase(context, pn, mUser);
2796             }
2797             // Remove all the specific components
2798             for (AppInfo a : removedApps) {
2799                 ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);
2800                 deleteItemsFromDatabase(context, infos);
2801             }
2802             if ((!removedPackageNames.isEmpty()) || (!removedApps.isEmpty())) {
2803                 // Remove any queued items from the install queue
2804                 String spKey = LauncherAppState.getSharedPreferencesKey();
2805                 SharedPreferences sp = context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
2806                 InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
2807                 // Call the components-removed callback
2808                 mHandler.post(new Runnable() {
2809                     public void run() {
2810                         Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2811                         if ((callbacks == cb) &amp;&amp; (cb != null)) {
2812                             callbacks.bindComponentsRemoved(removedPackageNames, removedApps, mUser);
2813                         }
2814                     }
2815                 });
2816             }
2817             final ArrayList&lt;Object&gt; widgetsAndShortcuts = getSortedWidgetsAndShortcuts(context);
2818             mHandler.post(new Runnable() {
2819                 @Override
2820                 public void run() {
2821                     Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2822                     if ((callbacks == cb) &amp;&amp; (cb != null)) {
2823                         callbacks.bindPackagesUpdated(widgetsAndShortcuts);
2824                     }
2825                 }
2826             });
2827             // Write all the logs to disk
2828             mHandler.post(new Runnable() {
2829                 public void run() {
2830                     Callbacks cb = (mCallbacks != null) ? mCallbacks.get() : null;
2831                     if ((callbacks == cb) &amp;&amp; (cb != null)) {
2832                         callbacks.dumpLogsToLocalData();
2833                     }
2834                 }
2835             });
2836         }
2837     }
2838 
2839     // Returns a list of ResolveInfos/AppWindowInfos in sorted order
2840     public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
2841         PackageManager packageManager = context.getPackageManager();
2842         final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
2843         widgetsAndShortcuts.addAll(AppWidgetManagerCompat.getInstance(context).getAllProviders());
2844         Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
2845         widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
2846         Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));
2847         return widgetsAndShortcuts;
2848     }
2849 
<abbr title="2850     private static boolean isPackageDisabled(Context context, String packageName, UserHandleCompat user) {">2850     private static boolean isPackageDisabled(Context context, String packageName, UserHandleCompat user) 🔵</abbr>
2851         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2852         return !launcherApps.isPackageEnabledForProfile(packageName, user);
2853     }
2854 
<abbr title="2855     public static boolean isValidPackageActivity(Context context, ComponentName cn, UserHandleCompat user) {">2855     public static boolean isValidPackageActivity(Context context, ComponentName cn, UserHandleCompat user🔵</abbr>
2856         if (cn == null) {
2857             return false;
2858         }
2859         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2860         if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {
2861             return false;
2862         }
2863         return launcherApps.isActivityEnabledForProfile(cn, user);
2864     }
2865 
2866     public static boolean isValidPackage(Context context, String packageName, UserHandleCompat user) {
2867         if (packageName == null) {
2868             return false;
2869         }
2870         final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);
2871         return launcherApps.isPackageEnabledForProfile(packageName, user);
2872     }
2873 
2874     /**
2875      * Make an ShortcutInfo object for a restored application or shortcut item that points
2876      * to a package that is not yet installed on the system.
2877      */
<abbr title="2878     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent, int promiseType) {">2878     public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent, int promiseType🔵</abbr>
2879         final ShortcutInfo info = new ShortcutInfo();
2880         info.user = UserHandleCompat.myUserHandle();
2881         mIconCache.getTitleAndIcon(info, intent, info.user, true);
2882         if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {
2883             String title = (cursor != null) ? cursor.getString(titleIndex) : null;
2884             if (!TextUtils.isEmpty(title)) {
2885                 info.title = title;
2886             }
2887             info.status = ShortcutInfo.FLAG_RESTORED_ICON;
2888         } else if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {
2889             if (TextUtils.isEmpty(info.title)) {
2890                 info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;
2891             }
2892             info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;
2893         } else {
2894             throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);
2895         }
2896         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title.toString(), info.user);
2897         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
2898         info.promisedIntent = intent;
2899         return info;
2900     }
2901 
2902     /**
2903      * Make an Intent object for a restored application or shortcut item that points
2904      * to the market page for the item.
2905      */
2906     private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
2907         ComponentName componentName = intent.getComponent();
2908         return getMarketIntent(componentName.getPackageName());
2909     }
2910 
2911     static Intent getMarketIntent(String packageName) {
<abbr title="2912         return new Intent(Intent.ACTION_VIEW).setData(new Uri.Builder().scheme(&quot;market&quot;).authority(&quot;details&quot;).appendQueryParameter(&quot;id&quot;, packageName).build());">2912         return new Intent(Intent.ACTION_VIEW).setData(new Uri.Builder().scheme(&quot;market&quot;).authority(&quot;detai🔵</abbr>
2913     }
2914 
2915     /**
2916      * This is called from the code that adds shortcuts from the intent receiver.  This
2917      * doesn&#x27;t have a Cursor, but
2918      */
<abbr title="2919     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, UserHandleCompat user, Context context) {">2919     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, UserHandleCompat user, Con🔵</abbr>
2920         return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);
2921     }
2922 
2923     /**
2924      * Make an ShortcutInfo object for a shortcut that is an application.
2925      *
2926      * If c is not null, then it will be used to fill in missing data like the title and icon.
2927      */
<abbr title="2928     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {">2928     public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, UserHandleCompat user, Con🔵</abbr>
2929         if (user == null) {
2930             Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);
2931             return null;
2932         }
2933         ComponentName componentName = intent.getComponent();
2934         if (componentName == null) {
2935             Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);
2936             return null;
2937         }
2938         Intent newIntent = new Intent(intent.getAction(), null);
2939         newIntent.addCategory(Intent.CATEGORY_LAUNCHER);
2940         newIntent.setComponent(componentName);
2941         LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);
2942         if ((lai == null) &amp;&amp; (!allowMissingTarget)) {
2943             Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);
2944             return null;
2945         }
2946         final ShortcutInfo info = new ShortcutInfo();
2947         // the resource -- This may implicitly give us back the fallback icon,
2948         // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
2949         // to avoid saving lots of copies of that in the database, and most apps
2950         // have icons anyway.
2951         Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);
2952         // the db
2953         if (icon == null) {
2954             if (c != null) {
2955                 icon = getIconFromCursor(c, iconIndex, context);
2956             }
2957         }
2958         // the fallback icon
2959         if (icon == null) {
2960             icon = mIconCache.getDefaultIcon(user);
2961             info.usingFallbackIcon = true;
2962         }
2963         info.setIcon(icon);
2964         // From the cache.
2965         if (labelCache != null) {
2966             info.title = labelCache.get(componentName);
2967         }
2968         // from the resource
2969         if ((info.title == null) &amp;&amp; (lai != null)) {
2970             info.title = lai.getLabel();
2971             if (labelCache != null) {
2972                 labelCache.put(componentName, info.title);
2973             }
2974         }
2975         // from the db
2976         if (info.title == null) {
2977             if (c != null) {
2978                 info.title = c.getString(titleIndex);
2979             }
2980         }
2981         // fall back to the class name of the activity
2982         if (info.title == null) {
2983             info.title = componentName.getClassName();
2984         }
2985         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
2986         info.user = user;
2987         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title.toString(), info.user);
2988         return info;
2989     }
2990 
2991     static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos, ItemInfoFilter f) {
2992         HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
2993         for (ItemInfo i : infos) {
2994             if (i instanceof ShortcutInfo) {
2995                 ShortcutInfo info = ((ShortcutInfo) (i));
2996                 ComponentName cn = info.getTargetComponent();
2997                 if ((cn != null) &amp;&amp; f.filterItem(null, info, cn)) {
2998                     filtered.add(info);
2999                 }
3000             } else if (i instanceof FolderInfo) {
3001                 FolderInfo info = ((FolderInfo) (i));
3002                 for (ShortcutInfo s : info.contents) {
3003                     ComponentName cn = s.getTargetComponent();
3004                     if ((cn != null) &amp;&amp; f.filterItem(info, s, cn)) {
3005                         filtered.add(s);
3006                     }
3007                 }
3008             } else if (i instanceof LauncherAppWidgetInfo) {
3009                 LauncherAppWidgetInfo info = ((LauncherAppWidgetInfo) (i));
3010                 ComponentName cn = info.providerName;
3011                 if ((cn != null) &amp;&amp; f.filterItem(null, info, cn)) {
3012                     filtered.add(info);
3013                 }
3014             }
3015         }
3016         return new ArrayList&lt;ItemInfo&gt;(filtered);
3017     }
3018 
<abbr title="3019     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname, final UserHandleCompat user) {">3019     private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname, final UserHandleCo🔵</abbr>
3020         ItemInfoFilter filter = new ItemInfoFilter() {
3021             @Override
3022             public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
3023                 if (info.user == null) {
3024                     return cn.equals(cname);
3025                 } else {
3026                     return cn.equals(cname) &amp;&amp; info.user.equals(user);
3027                 }
3028             }
3029         };
3030         return filterItemInfos(sBgItemsIdMap.values(), filter);
3031     }
3032 
3033     public static boolean isShortcutInfoUpdateable(ItemInfo i) {
3034         if (i instanceof ShortcutInfo) {
3035             ShortcutInfo info = ((ShortcutInfo) (i));
3036             // We need to check for ACTION_MAIN otherwise getComponent() might
3037             // return null for some shortcuts (for instance, for shortcuts to
3038             // web pages.)
3039             Intent intent = info.intent;
3040             ComponentName name = intent.getComponent();
<abbr title="3041             if (((info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) &amp;&amp; Intent.ACTION_MAIN.equals(intent.getAction())) &amp;&amp; (name != null)) {">3041             if (((info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) &amp;&amp; Intent.ACTION_MAI🔵</abbr>
3042                 return true;
3043             }
3044             // placeholder shortcuts get special treatment, let them through too.
3045             if (info.isPromise()) {
3046                 return true;
3047             }
3048         }
3049         return false;
3050     }
3051 
3052     /**
3053      * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3054      */
<abbr title="3055     private ShortcutInfo getShortcutInfo(Cursor c, Context context, int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex, int titleIndex) {">3055     private ShortcutInfo getShortcutInfo(Cursor c, Context context, int iconTypeIndex, int iconPackageInd🔵</abbr>
3056         Bitmap icon = null;
3057         final ShortcutInfo info = new ShortcutInfo();
3058         // Non-app shortcuts are only supported for current user.
3059         info.user = UserHandleCompat.myUserHandle();
3060         info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3061         // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3062         info.title = c.getString(titleIndex);
3063         int iconType = c.getInt(iconTypeIndex);
3064         switch (iconType) {
3065             case LauncherSettings.Favorites.ICON_TYPE_RESOURCE :
3066                 String packageName = c.getString(iconPackageIndex);
3067                 String resourceName = c.getString(iconResourceIndex);
3068                 PackageManager packageManager = context.getPackageManager();
3069                 info.customIcon = false;
3070             // the resource
3071                 try {
3072                     Resources resources = packageManager.getResourcesForApplication(packageName);
3073                     if (resources != null) {
3074                         final int id = resources.getIdentifier(resourceName, null, null);
<abbr title="3075                         icon = Utilities.createIconBitmap(mIconCache.getFullResIcon(resources, id), context);">3075                         icon = Utilities.createIconBitmap(mIconCache.getFullResIcon(resources, id), conte🔵</abbr>
3076                     }
3077                 } catch (java.lang.Exception e) {
3078                     // drop this.  we have other places to look for icons
3079                 }
3080             // the db
3081                 if (icon == null) {
3082                     icon = getIconFromCursor(c, iconIndex, context);
3083                 }
3084             // the fallback icon
3085                 if (icon == null) {
3086                     icon = mIconCache.getDefaultIcon(info.user);
3087                     info.usingFallbackIcon = true;
3088                 }
3089                 break;
3090             case LauncherSettings.Favorites.ICON_TYPE_BITMAP :
3091                 icon = getIconFromCursor(c, iconIndex, context);
3092                 if (icon == null) {
3093                     icon = mIconCache.getDefaultIcon(info.user);
3094                     info.customIcon = false;
3095                     info.usingFallbackIcon = true;
3096                 } else {
3097                     info.customIcon = true;
3098                 }
3099                 break;
3100             default :
3101                 icon = mIconCache.getDefaultIcon(info.user);
3102                 info.usingFallbackIcon = true;
3103                 info.customIcon = false;
3104                 break;
3105         }
3106         info.setIcon(icon);
3107         return info;
3108     }
3109 
3110     Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3111         // suppress dead code warning
3112         @SuppressWarnings(&quot;all&quot;)
3113         final boolean debug = false;
3114         if (debug) {
<abbr title="3115             Log.d(TAG, &quot;getIconFromCursor app=&quot; + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));">3115             Log.d(TAG, &quot;getIconFromCursor app=&quot; + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Fa🔵</abbr>
3116         }
3117         byte[] data = c.getBlob(iconIndex);
3118         try {
<abbr title="3119             return Utilities.createIconBitmap(BitmapFactory.decodeByteArray(data, 0, data.length), context);">3119             return Utilities.createIconBitmap(BitmapFactory.decodeByteArray(data, 0, data.length), contex🔵</abbr>
3120         } catch (java.lang.Exception e) {
3121             return null;
3122         }
3123     }
3124 
<abbr title="3125     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen, int cellX, int cellY, boolean notify) {">3125     ShortcutInfo addShortcut(Context context, Intent data, long container, int screen, int cellX, int cel🔵</abbr>
3126         final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3127         if (info == null) {
3128             return null;
3129         }
3130         addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3131         return info;
3132     }
3133 
3134     /**
3135      * Attempts to find an AppWidgetProviderInfo that matches the given component.
3136      */
<abbr title="3137     static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context, ComponentName component) {">3137     static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context, ComponentName co🔵</abbr>
<abbr title="3138         List&lt;AppWidgetProviderInfo&gt; widgets = AppWidgetManager.getInstance(context).getInstalledProviders();">3138         List&lt;AppWidgetProviderInfo&gt; widgets = AppWidgetManager.getInstance(context).getInstalledProviders🔵</abbr>
3139         for (AppWidgetProviderInfo info : widgets) {
3140             if (info.provider.equals(component)) {
3141                 return info;
3142             }
3143         }
3144         return null;
3145     }
3146 
3147     ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3148         Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3149         String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3150         Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3151         if (intent == null) {
3152             // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3153             Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3154             return null;
3155         }
3156         Bitmap icon = null;
3157         boolean customIcon = false;
3158         ShortcutIconResource iconResource = null;
3159         if ((bitmap != null) &amp;&amp; (bitmap instanceof Bitmap)) {
3160             icon = Utilities.createIconBitmap(new FastBitmapDrawable(((Bitmap) (bitmap))), context);
3161             customIcon = true;
3162         } else {
3163             Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3164             if ((extra != null) &amp;&amp; (extra instanceof ShortcutIconResource)) {
3165                 try {
3166                     iconResource = ((ShortcutIconResource) (extra));
3167                     final PackageManager packageManager = context.getPackageManager();
<abbr title="3168                     Resources resources = packageManager.getResourcesForApplication(iconResource.packageName);">3168                     Resources resources = packageManager.getResourcesForApplication(iconResource.packageN🔵</abbr>
3169                     final int id = resources.getIdentifier(iconResource.resourceName, null, null);
3170                     icon = Utilities.createIconBitmap(mIconCache.getFullResIcon(resources, id), context);
3171                 } catch (java.lang.Exception e) {
3172                     Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
3173                 }
3174             }
3175         }
3176         final ShortcutInfo info = new ShortcutInfo();
3177         // Only support intents for current user for now. Intents sent from other
3178         // users wouldn&#x27;t get here without intent forwarding anyway.
3179         info.user = UserHandleCompat.myUserHandle();
3180         if (icon == null) {
3181             if (fallbackIcon != null) {
3182                 icon = fallbackIcon;
3183             } else {
3184                 icon = mIconCache.getDefaultIcon(info.user);
3185                 info.usingFallbackIcon = true;
3186             }
3187         }
3188         info.setIcon(icon);
3189         info.title = name;
3190         info.contentDescription = mUserManager.getBadgedLabelForUser(info.title.toString(), info.user);
3191         info.intent = intent;
3192         info.customIcon = customIcon;
3193         info.iconResource = iconResource;
3194         return info;
3195     }
3196 
<abbr title="3197     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c, int iconIndex) {">3197     boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c, int iconInde🔵</abbr>
3198         // If apps can&#x27;t be on SD, don&#x27;t even bother.
3199         if (!mAppsCanBeOnRemoveableStorage) {
3200             return false;
3201         }
3202         // If this icon doesn&#x27;t have a custom icon, check to see
3203         // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3204         // we&#x27;re going to show, store what we are going to show back
3205         // into the DB.  We do this so when we&#x27;re loading, if the
3206         // package manager can&#x27;t find an icon (for example because
3207         // the app is on SD) then we can use that instead.
3208         if ((!info.customIcon) &amp;&amp; (!info.usingFallbackIcon)) {
3209             cache.put(info, c.getBlob(iconIndex));
3210             return true;
3211         }
3212         return false;
3213     }
3214 
3215     void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
3216         boolean needSave = false;
3217         try {
3218             if (data != null) {
3219                 Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
3220                 Bitmap loaded = info.getIcon(mIconCache);
3221                 needSave = !saved.sameAs(loaded);
3222             } else {
3223                 needSave = true;
3224             }
3225         } catch (java.lang.Exception e) {
3226             needSave = true;
3227         }
3228         if (needSave) {
3229             Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
3230             // This is slower than is ideal, but this only happens once
3231             // or when the app is updated with a new icon.
3232             updateItemInDatabase(context, info);
3233         }
3234     }
3235 
3236     /**
3237      * Return an existing FolderInfo object if we have encountered this ID previously,
3238      * or make a new one.
3239      */
3240     private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
3241         // See if a placeholder was created for us already
3242         FolderInfo folderInfo = folders.get(id);
3243         if (folderInfo == null) {
3244             // No placeholder -- create a new instance
3245             folderInfo = new FolderInfo();
3246             folders.put(id, folderInfo);
3247         }
3248         return folderInfo;
3249     }
3250 
3251     public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
3252         final Collator collator = Collator.getInstance();
3253         return new Comparator&lt;AppInfo&gt;() {
3254             public final int compare(AppInfo a, AppInfo b) {
3255                 if (a.user.equals(b.user)) {
3256                     int result = collator.compare(a.title.toString().trim(), b.title.toString().trim());
3257                     if (result == 0) {
3258                         result = a.componentName.compareTo(b.componentName);
3259                     }
3260                     return result;
3261                 } else {
3262                     // TODO Need to figure out rules for sorting
3263                     // profiles, this puts work second.
3264                     return a.user.toString().compareTo(b.user.toString());
3265                 }
3266             }
3267         };
3268     }
3269 
3270     public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR = new Comparator&lt;AppInfo&gt;() {
3271         public final int compare(AppInfo a, AppInfo b) {
3272             if (a.firstInstallTime &lt; b.firstInstallTime) {
3273                 return 1;
3274             }
3275             if (a.firstInstallTime &gt; b.firstInstallTime) {
3276                 return -1;
3277             }
3278             return 0;
3279         }
3280     };
3281 
3282     static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
3283         if (info.activityInfo != null) {
3284             return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
3285         } else {
3286             return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
3287         }
3288     }
3289 
3290     public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {
3291         private Collator mCollator;
3292 
3293         private HashMap&lt;Object, CharSequence&gt; mLabelCache;
3294 
3295         ShortcutNameComparator(PackageManager pm) {
3296             mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
3297             mCollator = Collator.getInstance();
3298         }
3299 
3300         ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {
3301             mLabelCache = labelCache;
3302             mCollator = Collator.getInstance();
3303         }
3304 
3305         public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {
3306             String labelA;
3307             String labelB;
3308             ComponentName keyA = a.getComponentName();
3309             ComponentName keyB = b.getComponentName();
3310             if (mLabelCache.containsKey(keyA)) {
3311                 labelA = mLabelCache.get(keyA).toString();
3312             } else {
3313                 labelA = a.getLabel().toString().trim();
3314                 mLabelCache.put(keyA, labelA);
3315             }
3316             if (mLabelCache.containsKey(keyB)) {
3317                 labelB = mLabelCache.get(keyB).toString();
3318             } else {
3319                 labelB = b.getLabel().toString().trim();
3320                 mLabelCache.put(keyB, labelB);
3321             }
3322             return mCollator.compare(labelA, labelB);
3323         }
3324     }
3325 
3326     public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
3327         private final AppWidgetManagerCompat mManager;
3328 
3329         private final PackageManager mPackageManager;
3330 
3331         private final HashMap&lt;Object, String&gt; mLabelCache;
3332 
3333         private final Collator mCollator;
3334 
3335         WidgetAndShortcutNameComparator(Context context) {
3336             mManager = AppWidgetManagerCompat.getInstance(context);
3337             mPackageManager = context.getPackageManager();
3338             mLabelCache = new HashMap&lt;Object, String&gt;();
3339             mCollator = Collator.getInstance();
3340         }
3341 
3342         public final int compare(Object a, Object b) {
3343             String labelA;
3344             String labelB;
3345             if (mLabelCache.containsKey(a)) {
3346                 labelA = mLabelCache.get(a);
3347             } else {
<abbr title="3348                 labelA = (a instanceof AppWidgetProviderInfo) ? mManager.loadLabel(((AppWidgetProviderInfo) (a))) : ((ResolveInfo) (a)).loadLabel(mPackageManager).toString().trim();">3348                 labelA = (a instanceof AppWidgetProviderInfo) ? mManager.loadLabel(((AppWidgetProviderInf🔵</abbr>
3349                 mLabelCache.put(a, labelA);
3350             }
3351             if (mLabelCache.containsKey(b)) {
3352                 labelB = mLabelCache.get(b);
3353             } else {
<abbr title="3354                 labelB = (b instanceof AppWidgetProviderInfo) ? mManager.loadLabel(((AppWidgetProviderInfo) (b))) : ((ResolveInfo) (b)).loadLabel(mPackageManager).toString().trim();">3354                 labelB = (b instanceof AppWidgetProviderInfo) ? mManager.loadLabel(((AppWidgetProviderInf🔵</abbr>
3355                 mLabelCache.put(b, labelB);
3356             }
3357             return mCollator.compare(labelA, labelB);
3358         }
3359     }
3360 
3361     static boolean isValidProvider(AppWidgetProviderInfo provider) {
<abbr title="3362         return ((provider != null) &amp;&amp; (provider.provider != null)) &amp;&amp; (provider.provider.getPackageName() != null);">3362         return ((provider != null) &amp;&amp; (provider.provider != null)) &amp;&amp; (provider.provider.getPackageName()🔵</abbr>
3363     }
3364 
3365     public void dumpState() {
3366         Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
3367         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
3368         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
3369         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
3370         AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
3371         if (mLoaderTask != null) {
3372             mLoaderTask.dumpState();
3373         } else {
3374             Log.d(TAG, &quot;mLoaderTask=null&quot;);
3375         }
3376     }
3377 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.app.SearchManager;
  20  import android.appwidget.AppWidgetManager;
  21  import android.appwidget.AppWidgetProviderInfo;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 -import android.content.*;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import android.content.BroadcastReceiver;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import android.content.ComponentName;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import android.content.ContentProviderClient;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +import android.content.ContentProviderOperation;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +import android.content.ContentResolver;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +import android.content.ContentValues;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +import android.content.Context;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 +import android.content.Intent;</span>
  31  import android.content.Intent.ShortcutIconResource;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  32 -import android.content.pm.ActivityInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 -import android.content.pm.PackageInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 +import android.content.IntentFilter;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 +import android.content.SharedPreferences;</span>
  36  import android.content.pm.PackageManager;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  37 -import android.content.pm.PackageManager.NameNotFoundException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  38 +import android.content.pm.ProviderInfo;</span>
  39  import android.content.pm.ResolveInfo;
  40  import android.content.res.Configuration;
  41  import android.content.res.Resources;
  42  import android.database.Cursor;
  43  import android.graphics.Bitmap;
  44  import android.graphics.BitmapFactory;
  45  import android.net.Uri;
  46  import android.os.Environment;
  47  import android.os.Handler;
  48  import android.os.HandlerThread;
  49  import android.os.Parcelable;
  50  import android.os.Process;
  51  import android.os.RemoteException;
  52  import android.os.SystemClock;
  53  import android.provider.BaseColumns;
  54  import android.text.TextUtils;
  55  import android.util.Log;
  56  import android.util.Pair;
  57  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  58 -import com.android.launcher3.InstallWidgetReceiver.WidgetMimeTypeHandlerData;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +import com.android.launcher3.compat.AppWidgetManagerCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +import com.android.launcher3.compat.LauncherActivityInfoCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +import com.android.launcher3.compat.LauncherAppsCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +import com.android.launcher3.compat.PackageInstallerCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +import com.android.launcher3.compat.PackageInstallerCompat.PackageInstallInfo;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +import com.android.launcher3.compat.UserHandleCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  65 +import com.android.launcher3.compat.UserManagerCompat;</span>
  66  
  67  import java.lang.ref.WeakReference;
  68  import java.net.URISyntaxException;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  69 +import java.security.InvalidParameterException;</span>
  70  import java.text.Collator;
  71  import java.util.ArrayList;
  72  import java.util.Arrays;
  73  import java.util.Collection;
  74  import java.util.Collections;
  75  import java.util.Comparator;
  76  import java.util.HashMap;
  77  import java.util.HashSet;
  78  import java.util.Iterator;
  79  import java.util.List;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  80 +import java.util.Map.Entry;</span>
  81  import java.util.Set;
  82  import java.util.TreeMap;
  83  import java.util.concurrent.atomic.AtomicBoolean;
  84  
  85  /**
  86   * Maintains in-memory state of the Launcher. It is expected that there should be only one
  87   * LauncherModel object held in a static. Also provide APIs for updating the database state
  88   * for the Launcher.
  89   */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  90 -public class LauncherModel extends BroadcastReceiver {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  91 +public class LauncherModel extends BroadcastReceiver</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  92 +        implements LauncherAppsCompat.OnAppsChangedCallbackCompat {</span>
  93      static final boolean DEBUG_LOADERS = false;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  94 +    private static final boolean DEBUG_RECEIVER = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +    private static final boolean REMOVE_UNRESTORED_ICONS = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  96 +</span>
  97      static final String TAG = &quot;Launcher.Model&quot;;
  98  
  99      // true = use a &quot;More Apps&quot; folder for non-workspace apps on upgrade
 100      // false = strew non-workspace apps across the workspace on upgrade
 101      public static final boolean UPGRADE_USE_MORE_APPS_FOLDER = false;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 102 -</span>
 103      public static final int LOADER_FLAG_NONE = 0;
 104      public static final int LOADER_FLAG_CLEAR_WORKSPACE = 1 &lt;&lt; 0;
 105      public static final int LOADER_FLAG_MIGRATE_SHORTCUTS = 1 &lt;&lt; 1;
 106  
 107      private static final int ITEMS_CHUNK = 6; // batch size for the workspace icons
 108      private static final long INVALID_SCREEN_ID = -1L;
 109  
 110      private final boolean mAppsCanBeOnRemoveableStorage;
 111      private final boolean mOldContentProviderExists;
 112  
 113      private final LauncherAppState mApp;
 114      private final Object mLock = new Object();
 115      private DeferredHandler mHandler = new DeferredHandler();
 116      private LoaderTask mLoaderTask;
 117      private boolean mIsLoaderTaskRunning;
 118      private volatile boolean mFlushingWorkerThread;
 119  
 120      // Specific runnable types that are run on the main thread deferred handler, this allows us to
 121      // clear all queued binding runnables when the Launcher activity is destroyed.
 122      private static final int MAIN_THREAD_NORMAL_RUNNABLE = 0;
 123      private static final int MAIN_THREAD_BINDING_RUNNABLE = 1;
 124  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +    private static final String MIGRATE_AUTHORITY = &quot;com.android.launcher2.settings&quot;;</span>
 126  
 127      private static final HandlerThread sWorkerThread = new HandlerThread(&quot;launcher-loader&quot;);
 128      static {
 129          sWorkerThread.start();
 130      }
 131      private static final Handler sWorker = new Handler(sWorkerThread.getLooper());
 132  
 133      // We start off with everything not loaded.  After that, we assume that
 134      // our monitoring of the package manager provides all updates and we never
 135      // need to do a requery.  These are only ever touched from the loader thread.
 136      private boolean mWorkspaceLoaded;
 137      private boolean mAllAppsLoaded;
 138  
 139      // When we are loading pages synchronously, we can&#x27;t just post the binding of items on the side
 140      // pages as this delays the rotation process.  Instead, we wait for a callback from the first
 141      // draw (in Workspace) to initiate the binding of the remaining side pages.  Any time we start
 142      // a normal load, we also clear this set of Runnables.
 143      static final ArrayList&lt;Runnable&gt; mDeferredBindRunnables = new ArrayList&lt;Runnable&gt;();
 144  
 145      private WeakReference&lt;Callbacks&gt; mCallbacks;
 146  
 147      // &lt; only access in worker thread &gt;
 148      AllAppsList mBgAllAppsList;
 149  
 150      // The lock that must be acquired before referencing any static bg data structures.  Unlike
 151      // other locks, this one can generally be held long-term because we never expect any of these
 152      // static data structures to be referenced outside of the worker thread except on the first
 153      // load after configuration change.
 154      static final Object sBgLock = new Object();
 155  
 156      // sBgItemsIdMap maps *all* the ItemInfos (shortcuts, folders, and widgets) created by
 157      // LauncherModel to their ids
 158      static final HashMap&lt;Long, ItemInfo&gt; sBgItemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
 159  
 160      // sBgWorkspaceItems is passed to bindItems, which expects a list of all folders and shortcuts
 161      //       created by LauncherModel that are directly on the home screen (however, no widgets or
 162      //       shortcuts within folders).
 163      static final ArrayList&lt;ItemInfo&gt; sBgWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 164  
 165      // sBgAppWidgets is all LauncherAppWidgetInfo created by LauncherModel. Passed to bindAppWidget()
 166      static final ArrayList&lt;LauncherAppWidgetInfo&gt; sBgAppWidgets =
 167          new ArrayList&lt;LauncherAppWidgetInfo&gt;();
 168  
 169      // sBgFolders is all FolderInfos created by LauncherModel. Passed to bindFolders()
 170      static final HashMap&lt;Long, FolderInfo&gt; sBgFolders = new HashMap&lt;Long, FolderInfo&gt;();
 171  
 172      // sBgDbIconCache is the set of ItemInfos that need to have their icons updated in the database
 173      static final HashMap&lt;Object, byte[]&gt; sBgDbIconCache = new HashMap&lt;Object, byte[]&gt;();
 174  
 175      // sBgWorkspaceScreens is the ordered set of workspace screens.
 176      static final ArrayList&lt;Long&gt; sBgWorkspaceScreens = new ArrayList&lt;Long&gt;();
 177  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 178 +    // sPendingPackages is a set of packages which could be on sdcard and are not available yet</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 179 +    static final HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; sPendingPackages =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 180 +            new HashMap&lt;UserHandleCompat, HashSet&lt;String&gt;&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +</span>
 182      // &lt;/ only access in worker thread &gt;
 183  
 184      private IconCache mIconCache;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 185 -    private Bitmap mDefaultIcon;</span>
 186  
 187      protected int mPreviousConfigMcc;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +    private final LauncherAppsCompat mLauncherApps;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +    private final UserManagerCompat mUserManager;</span>
 191  
 192      public interface Callbacks {
 193          public boolean setLoadOnResume();
 194          public int getCurrentWorkspaceScreen();
 195          public void startBinding();
 196          public void bindItems(ArrayList&lt;ItemInfo&gt; shortcuts, int start, int end,
 197                                boolean forceAnimateIcons);
 198          public void bindScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 199          public void bindAddScreens(ArrayList&lt;Long&gt; orderedScreenIds);
 200          public void bindFolders(HashMap&lt;Long,FolderInfo&gt; folders);
 201          public void finishBindingItems(boolean upgradePath);
 202          public void bindAppWidget(LauncherAppWidgetInfo info);
 203          public void bindAllApplications(ArrayList&lt;AppInfo&gt; apps);
 204          public void bindAppsAdded(ArrayList&lt;Long&gt; newScreens,
 205                                    ArrayList&lt;ItemInfo&gt; addNotAnimated,
 206                                    ArrayList&lt;ItemInfo&gt; addAnimated,
 207                                    ArrayList&lt;AppInfo&gt; addedApps);
 208          public void bindAppsUpdated(ArrayList&lt;AppInfo&gt; apps);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +        public void bindAppsRestored(ArrayList&lt;AppInfo&gt; apps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +        public void updatePackageState(ArrayList&lt;PackageInstallInfo&gt; installInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +        public void updatePackageBadge(String packageName);</span>
 212          public void bindComponentsRemoved(ArrayList&lt;String&gt; packageNames,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 213 -                        ArrayList&lt;AppInfo&gt; appInfos);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +                        ArrayList&lt;AppInfo&gt; appInfos, UserHandleCompat user);</span>
 215          public void bindPackagesUpdated(ArrayList&lt;Object&gt; widgetsAndShortcuts);
 216          public void bindSearchablesChanged();
 217          public boolean isAllAppsButtonRank(int rank);
 218          public void onPageBoundSynchronously(int page);
 219          public void dumpLogsToLocalData();
 220      }
 221  
 222      public interface ItemInfoFilter {
 223          public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn);
 224      }
 225  
 226      LauncherModel(LauncherAppState app, IconCache iconCache, AppFilter appFilter) {
 227          Context context = app.getContext();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 228 -        ContentResolver contentResolver = context.getContentResolver();</span>
 229  
 230          mAppsCanBeOnRemoveableStorage = Environment.isExternalStorageRemovable();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 231 -        mOldContentProviderExists = (contentResolver.acquireContentProviderClient(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 232 -                LauncherSettings.Favorites.OLD_CONTENT_URI) != null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 233 +        String oldProvider = context.getString(R.string.old_launcher_provider_uri);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +        // This may be the same as MIGRATE_AUTHORITY, or it may be replaced by a different</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +        // resource string.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 236 +        String redirectAuthority = Uri.parse(oldProvider).getAuthority();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +        ProviderInfo providerInfo =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +                context.getPackageManager().resolveContentProvider(MIGRATE_AUTHORITY, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +        ProviderInfo redirectProvider =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +                context.getPackageManager().resolveContentProvider(redirectAuthority, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +        Log.d(TAG, &quot;Old launcher provider: &quot; + oldProvider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +        mOldContentProviderExists = (providerInfo != null) &amp;&amp; (redirectProvider != null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 245 +        if (mOldContentProviderExists) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 246 +            Log.d(TAG, &quot;Old launcher provider exists.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 247 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +            Log.d(TAG, &quot;Old launcher provider does not exist.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +</span>
 251          mApp = app;
 252          mBgAllAppsList = new AllAppsList(iconCache, appFilter);
 253          mIconCache = iconCache;
 254  
 255          final Resources res = context.getResources();
 256          Configuration config = res.getConfiguration();
 257          mPreviousConfigMcc = config.mcc;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +        mLauncherApps = LauncherAppsCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +        mUserManager = UserManagerCompat.getInstance(context);</span>
 260      }
 261  
 262      /** Runs the specified runnable immediately if called from the main thread, otherwise it is
 263       * posted on the main thread handler. */
 264      private void runOnMainThread(Runnable r) {
 265          runOnMainThread(r, 0);
 266      }
 267      private void runOnMainThread(Runnable r, int type) {
 268          if (sWorkerThread.getThreadId() == Process.myTid()) {
 269              // If we are on the worker thread, post onto the main handler
 270              mHandler.post(r);
 271          } else {
 272              r.run();
 273          }
 274      }
 275  
 276      /** Runs the specified runnable immediately if called from the worker thread, otherwise it is
 277       * posted on the worker thread handler. */
 278      private static void runOnWorkerThread(Runnable r) {
 279          if (sWorkerThread.getThreadId() == Process.myTid()) {
 280              r.run();
 281          } else {
 282              // If we are not on the worker thread, then post to the worker handler
 283              sWorker.post(r);
 284          }
 285      }
 286  
 287      boolean canMigrateFromOldLauncherDb(Launcher launcher) {
 288          return mOldContentProviderExists &amp;&amp; !launcher.isLauncherPreinstalled() ;
 289      }
 290  
 291      static boolean findNextAvailableIconSpaceInScreen(ArrayList&lt;ItemInfo&gt; items, int[] xy,
 292                                   long screen) {
 293          LauncherAppState app = LauncherAppState.getInstance();
 294          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 295          final int xCount = (int) grid.numColumns;
 296          final int yCount = (int) grid.numRows;
 297          boolean[][] occupied = new boolean[xCount][yCount];
 298  
 299          int cellX, cellY, spanX, spanY;
 300          for (int i = 0; i &lt; items.size(); ++i) {
 301              final ItemInfo item = items.get(i);
 302              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 303                  if (item.screenId == screen) {
 304                      cellX = item.cellX;
 305                      cellY = item.cellY;
 306                      spanX = item.spanX;
 307                      spanY = item.spanY;
 308                      for (int x = cellX; 0 &lt;= x &amp;&amp; x &lt; cellX + spanX &amp;&amp; x &lt; xCount; x++) {
 309                          for (int y = cellY; 0 &lt;= y &amp;&amp; y &lt; cellY + spanY &amp;&amp; y &lt; yCount; y++) {
 310                              occupied[x][y] = true;
 311                          }
 312                      }
 313                  }
 314              }
 315          }
 316  
 317          return CellLayout.findVacantCell(xy, 1, 1, xCount, yCount, occupied);
 318      }
 319      static Pair&lt;Long, int[]&gt; findNextAvailableIconSpace(Context context, String name,
 320                                                          Intent launchIntent,
 321                                                          int firstScreenIndex,
 322                                                          ArrayList&lt;Long&gt; workspaceScreens) {
 323          // Lock on the app so that we don&#x27;t try and get the items while apps are being added
 324          LauncherAppState app = LauncherAppState.getInstance();
 325          LauncherModel model = app.getModel();
 326          boolean found = false;
 327          synchronized (app) {
 328              if (sWorkerThread.getThreadId() != Process.myTid()) {
 329                  // Flush the LauncherModel worker thread, so that if we just did another
 330                  // processInstallShortcut, we give it time for its shortcut to get added to the
 331                  // database (getItemsInLocalCoordinates reads the database)
 332                  model.flushWorkerThread();
 333              }
 334              final ArrayList&lt;ItemInfo&gt; items = LauncherModel.getItemsInLocalCoordinates(context);
 335  
 336              // Try adding to the workspace screens incrementally, starting at the default or center
 337              // screen and alternating between +1, -1, +2, -2, etc. (using ~ ceil(i/2f)*(-1)^(i-1))
 338              firstScreenIndex = Math.min(firstScreenIndex, workspaceScreens.size());
 339              int count = workspaceScreens.size();
 340              for (int screen = firstScreenIndex; screen &lt; count &amp;&amp; !found; screen++) {
 341                  int[] tmpCoordinates = new int[2];
 342                  if (findNextAvailableIconSpaceInScreen(items, tmpCoordinates,
 343                          workspaceScreens.get(screen))) {
 344                      // Update the Launcher db
 345                      return new Pair&lt;Long, int[]&gt;(workspaceScreens.get(screen), tmpCoordinates);
 346                  }
 347              }
 348          }
 349          return null;
 350      }
 351  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 352 -    public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 353 -                                    final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 354 -        Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 355 -        addAndBindAddedApps(context, workspaceApps, cb, allAppsApps);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 356 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 357 -    public void addAndBindAddedApps(final Context context, final ArrayList&lt;ItemInfo&gt; workspaceApps,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 358 -                                final Callbacks callbacks, final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 359 -        if (workspaceApps == null || allAppsApps == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 360 +    public void setPackageState(final ArrayList&lt;PackageInstallInfo&gt; installInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 361 +        // Process the updated package state</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 362 +        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 363 +            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 364 +                Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 365 +                if (callbacks != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 366 +                    callbacks.updatePackageState(installInfo);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 367 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 368 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 369 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 370 +        mHandler.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 371 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 372 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 373 +    public void updatePackageBadge(final String packageName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 374 +        // Process the updated package badge</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 375 +        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 376 +            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 377 +                Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 378 +                if (callbacks != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 379 +                    callbacks.updatePackageBadge(packageName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 380 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 381 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 382 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 383 +        mHandler.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 384 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 385 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 386 +    public void addAppsToAllApps(final Context ctx, final ArrayList&lt;AppInfo&gt; allAppsApps) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 387 +        final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 388 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 389 +        if (allAppsApps == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 390 +            throw new RuntimeException(&quot;allAppsApps must not be null&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 391 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 392 +        if (allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 393 +            return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 394 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 395 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 396 +        final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 397 +        Iterator&lt;AppInfo&gt; iter = allAppsApps.iterator();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 398 +        while (iter.hasNext()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 399 +            ItemInfo a = iter.next();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 400 +            if (LauncherModel.appWasPromise(ctx, a.getIntent(), a.user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 401 +                restoredAppsFinal.add((AppInfo) a);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 402 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 403 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 404 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 405 +        // Process the newly added applications and add them to the database first</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 406 +        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 407 +            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 408 +                runOnMainThread(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 409 +                    public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 410 +                        Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 411 +                        if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 412 +                            if (!restoredAppsFinal.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 413 +                                for (AppInfo info : restoredAppsFinal) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 414 +                                    final Intent intent = info.getIntent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 415 +                                    if (intent != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 416 +                                        mIconCache.deletePreloadedIcon(intent.getComponent(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 417 +                                                info.user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 418 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 419 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 420 +                                callbacks.bindAppsUpdated(restoredAppsFinal);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 421 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 422 +                            callbacks.bindAppsAdded(null, null, null, allAppsApps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 423 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 424 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 425 +                });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 426 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 427 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 428 +        runOnWorkerThread(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 429 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 430 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 431 +    public void addAndBindAddedWorkspaceApps(final Context context,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 432 +            final ArrayList&lt;ItemInfo&gt; workspaceApps) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 433 +        final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 434 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 435 +        if (workspaceApps == null) {</span>
 436              throw new RuntimeException(&quot;workspaceApps and allAppsApps must not be null&quot;);
 437          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 438 -        if (workspaceApps.isEmpty() &amp;&amp; allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 439 +        if (workspaceApps.isEmpty()) {</span>
 440              return;
 441          }
 442          // Process the newly added applications and add them to the database first
 443          Runnable r = new Runnable() {
 444              public void run() {
 445                  final ArrayList&lt;ItemInfo&gt; addedShortcutsFinal = new ArrayList&lt;ItemInfo&gt;();
 446                  final ArrayList&lt;Long&gt; addedWorkspaceScreensFinal = new ArrayList&lt;Long&gt;();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 447 +                final ArrayList&lt;AppInfo&gt; restoredAppsFinal = new ArrayList&lt;AppInfo&gt;();</span>
 448  
 449                  // Get the list of workspace screens.  We need to append to this list and
 450                  // can not use sBgWorkspaceScreens because loadWorkspace() may not have been
 451                  // called.
 452                  ArrayList&lt;Long&gt; workspaceScreens = new ArrayList&lt;Long&gt;();
 453                  TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(context);
 454                  for (Integer i : orderedScreens.keySet()) {
 455                      long screenId = orderedScreens.get(i);
 456                      workspaceScreens.add(screenId);
 457                  }
 458  
 459                  synchronized(sBgLock) {
 460                      Iterator&lt;ItemInfo&gt; iter = workspaceApps.iterator();
 461                      while (iter.hasNext()) {
 462                          ItemInfo a = iter.next();
 463                          final String name = a.title.toString();
 464                          final Intent launchIntent = a.getIntent();
 465  
 466                          // Short-circuit this logic if the icon exists somewhere on the workspace
 467                          if (LauncherModel.shortcutExists(context, name, launchIntent)) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 468 +                            // Only InstallShortcutReceiver sends us shortcutInfos, ignore them</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 469 +                            if (a instanceof AppInfo &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 470 +                                    LauncherModel.appWasPromise(context, launchIntent, a.user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 471 +                                restoredAppsFinal.add((AppInfo) a);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 472 +                            }</span>
 473                              continue;
 474                          }
 475  
 476                          // Add this icon to the db, creating a new page if necessary.  If there
 477                          // is only the empty page then we just add items to the first page.
 478                          // Otherwise, we add them to the next pages.
 479                          int startSearchPageIndex = workspaceScreens.isEmpty() ? 0 : 1;
 480                          Pair&lt;Long, int[]&gt; coords = LauncherModel.findNextAvailableIconSpace(context,
 481                                  name, launchIntent, startSearchPageIndex, workspaceScreens);
 482                          if (coords == null) {
 483                              LauncherProvider lp = LauncherAppState.getLauncherProvider();
 484  
 485                              // If we can&#x27;t find a valid position, then just add a new screen.
 486                              // This takes time so we need to re-queue the add until the new
 487                              // page is added.  Create as many screens as necessary to satisfy
 488                              // the startSearchPageIndex.
 489                              int numPagesToAdd = Math.max(1, startSearchPageIndex + 1 -
 490                                      workspaceScreens.size());
 491                              while (numPagesToAdd &gt; 0) {
 492                                  long screenId = lp.generateNewScreenId();
 493                                  // Save the screen id for binding in the workspace
 494                                  workspaceScreens.add(screenId);
 495                                  addedWorkspaceScreensFinal.add(screenId);
 496                                  numPagesToAdd--;
 497                              }
 498  
 499                              // Find the coordinate again
 500                              coords = LauncherModel.findNextAvailableIconSpace(context,
 501                                      name, launchIntent, startSearchPageIndex, workspaceScreens);
 502                          }
 503                          if (coords == null) {
 504                              throw new RuntimeException(&quot;Coordinates should not be null&quot;);
 505                          }
 506  
 507                          ShortcutInfo shortcutInfo;
 508                          if (a instanceof ShortcutInfo) {
 509                              shortcutInfo = (ShortcutInfo) a;
 510                          } else if (a instanceof AppInfo) {
 511                              shortcutInfo = ((AppInfo) a).makeShortcut();
 512                          } else {
 513                              throw new RuntimeException(&quot;Unexpected info type&quot;);
 514                          }
 515  
 516                          // Add the shortcut to the db
 517                          addItemToDatabase(context, shortcutInfo,
 518                                  LauncherSettings.Favorites.CONTAINER_DESKTOP,
 519                                  coords.first, coords.second[0], coords.second[1], false);
 520                          // Save the ShortcutInfo for binding in the workspace
 521                          addedShortcutsFinal.add(shortcutInfo);
 522                      }
 523                  }
 524  
 525                  // Update the workspace screens
 526                  updateWorkspaceScreenOrder(context, workspaceScreens);
 527  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 528 -                if (!addedShortcutsFinal.isEmpty() || !allAppsApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 529 +                if (!addedShortcutsFinal.isEmpty()) {</span>
 530                      runOnMainThread(new Runnable() {
 531                          public void run() {
 532                              Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
 533                              if (callbacks == cb &amp;&amp; cb != null) {
 534                                  final ArrayList&lt;ItemInfo&gt; addAnimated = new ArrayList&lt;ItemInfo&gt;();
 535                                  final ArrayList&lt;ItemInfo&gt; addNotAnimated = new ArrayList&lt;ItemInfo&gt;();
 536                                  if (!addedShortcutsFinal.isEmpty()) {
 537                                      ItemInfo info = addedShortcutsFinal.get(addedShortcutsFinal.size() - 1);
 538                                      long lastScreenId = info.screenId;
 539                                      for (ItemInfo i : addedShortcutsFinal) {
 540                                          if (i.screenId == lastScreenId) {
 541                                              addAnimated.add(i);
 542                                          } else {
 543                                              addNotAnimated.add(i);
 544                                          }
 545                                      }
 546                                  }
 547                                  callbacks.bindAppsAdded(addedWorkspaceScreensFinal,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 548 -                                        addNotAnimated, addAnimated, allAppsApps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 549 +                                        addNotAnimated, addAnimated, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 550 +                                if (!restoredAppsFinal.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 551 +                                    callbacks.bindAppsUpdated(restoredAppsFinal);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 552 +                                }</span>
 553                              }
 554                          }
 555                      });
 556                  }
 557              }
 558          };
 559          runOnWorkerThread(r);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 560 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 561 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 562 -    public Bitmap getFallbackIcon() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 563 -        if (mDefaultIcon == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 564 -            final Context context = LauncherAppState.getInstance().getContext();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 565 -            mDefaultIcon = Utilities.createIconBitmap(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 566 -                    mIconCache.getFullResDefaultActivityIcon(), context);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 567 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 568 -        return Bitmap.createBitmap(mDefaultIcon);</span>
 569      }
 570  
 571      public void unbindItemInfosAndClearQueuedBindRunnables() {
 572          if (sWorkerThread.getThreadId() == Process.myTid()) {
 573              throw new RuntimeException(&quot;Expected unbindLauncherItemInfos() to be called from the &quot; +
 574                      &quot;main thread&quot;);
 575          }
 576  
 577          // Clear any deferred bind runnables
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 578 -        mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 579 +        synchronized (mDeferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 580 +            mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 581 +        }</span>
 582          // Remove any queued bind runnables
 583          mHandler.cancelAllRunnablesOfType(MAIN_THREAD_BINDING_RUNNABLE);
 584          // Unbind all the workspace items
 585          unbindWorkspaceItemsOnMainThread();
 586      }
 587  
 588      /** Unbinds all the sBgWorkspaceItems and sBgAppWidgets on the main thread */
 589      void unbindWorkspaceItemsOnMainThread() {
 590          // Ensure that we don&#x27;t use the same workspace items data structure on the main thread
 591          // by making a copy of workspace items first.
 592          final ArrayList&lt;ItemInfo&gt; tmpWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
 593          final ArrayList&lt;ItemInfo&gt; tmpAppWidgets = new ArrayList&lt;ItemInfo&gt;();
 594          synchronized (sBgLock) {
 595              tmpWorkspaceItems.addAll(sBgWorkspaceItems);
 596              tmpAppWidgets.addAll(sBgAppWidgets);
 597          }
 598          Runnable r = new Runnable() {
 599                  @Override
 600                  public void run() {
 601                     for (ItemInfo item : tmpWorkspaceItems) {
 602                         item.unbind();
 603                     }
 604                     for (ItemInfo item : tmpAppWidgets) {
 605                         item.unbind();
 606                     }
 607                  }
 608              };
 609          runOnMainThread(r);
 610      }
 611  
 612      /**
 613       * Adds an item to the DB if it was not created previously, or move it to a new
 614       * &lt;container, screen, cellX, cellY&gt;
 615       */
 616      static void addOrMoveItemInDatabase(Context context, ItemInfo item, long container,
 617              long screenId, int cellX, int cellY) {
 618          if (item.container == ItemInfo.NO_ID) {
 619              // From all apps
 620              addItemToDatabase(context, item, container, screenId, cellX, cellY, false);
 621          } else {
 622              // From somewhere else
 623              moveItemInDatabase(context, item, container, screenId, cellX, cellY);
 624          }
 625      }
 626  
 627      static void checkItemInfoLocked(
 628              final long itemId, final ItemInfo item, StackTraceElement[] stackTrace) {
 629          ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 630          if (modelItem != null &amp;&amp; item != modelItem) {
 631              // check all the data is consistent
 632              if (modelItem instanceof ShortcutInfo &amp;&amp; item instanceof ShortcutInfo) {
 633                  ShortcutInfo modelShortcut = (ShortcutInfo) modelItem;
 634                  ShortcutInfo shortcut = (ShortcutInfo) item;
 635                  if (modelShortcut.title.toString().equals(shortcut.title.toString()) &amp;&amp;
 636                          modelShortcut.intent.filterEquals(shortcut.intent) &amp;&amp;
 637                          modelShortcut.id == shortcut.id &amp;&amp;
 638                          modelShortcut.itemType == shortcut.itemType &amp;&amp;
 639                          modelShortcut.container == shortcut.container &amp;&amp;
 640                          modelShortcut.screenId == shortcut.screenId &amp;&amp;
 641                          modelShortcut.cellX == shortcut.cellX &amp;&amp;
 642                          modelShortcut.cellY == shortcut.cellY &amp;&amp;
 643                          modelShortcut.spanX == shortcut.spanX &amp;&amp;
 644                          modelShortcut.spanY == shortcut.spanY &amp;&amp;
 645                          ((modelShortcut.dropPos == null &amp;&amp; shortcut.dropPos == null) ||
 646                          (modelShortcut.dropPos != null &amp;&amp;
 647                                  shortcut.dropPos != null &amp;&amp;
 648                                  modelShortcut.dropPos[0] == shortcut.dropPos[0] &amp;&amp;
 649                          modelShortcut.dropPos[1] == shortcut.dropPos[1]))) {
 650                      // For all intents and purposes, this is the same object
 651                      return;
 652                  }
 653              }
 654  
 655              // the modelItem needs to match up perfectly with item if our model is
 656              // to be consistent with the database-- for now, just require
 657              // modelItem == item or the equality check above
 658              String msg = &quot;item: &quot; + ((item != null) ? item.toString() : &quot;null&quot;) +
 659                      &quot;modelItem: &quot; +
 660                      ((modelItem != null) ? modelItem.toString() : &quot;null&quot;) +
 661                      &quot;Error: ItemInfo passed to checkItemInfo doesn&#x27;t match original&quot;;
 662              RuntimeException e = new RuntimeException(msg);
 663              if (stackTrace != null) {
 664                  e.setStackTrace(stackTrace);
 665              }
 666              throw e;
 667          }
 668      }
 669  
 670      static void checkItemInfo(final ItemInfo item) {
 671          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 672          final long itemId = item.id;
 673          Runnable r = new Runnable() {
 674              public void run() {
 675                  synchronized (sBgLock) {
 676                      checkItemInfoLocked(itemId, item, stackTrace);
 677                  }
 678              }
 679          };
 680          runOnWorkerThread(r);
 681      }
 682  
 683      static void updateItemInDatabaseHelper(Context context, final ContentValues values,
 684              final ItemInfo item, final String callingFunction) {
 685          final long itemId = item.id;
 686          final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 687          final ContentResolver cr = context.getContentResolver();
 688  
 689          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 690          Runnable r = new Runnable() {
 691              public void run() {
 692                  cr.update(uri, values, null, null);
 693                  updateItemArrays(item, itemId, stackTrace);
 694              }
 695          };
 696          runOnWorkerThread(r);
 697      }
 698  
 699      static void updateItemsInDatabaseHelper(Context context, final ArrayList&lt;ContentValues&gt; valuesList,
 700              final ArrayList&lt;ItemInfo&gt; items, final String callingFunction) {
 701          final ContentResolver cr = context.getContentResolver();
 702  
 703          final StackTraceElement[] stackTrace = new Throwable().getStackTrace();
 704          Runnable r = new Runnable() {
 705              public void run() {
 706                  ArrayList&lt;ContentProviderOperation&gt; ops =
 707                          new ArrayList&lt;ContentProviderOperation&gt;();
 708                  int count = items.size();
 709                  for (int i = 0; i &lt; count; i++) {
 710                      ItemInfo item = items.get(i);
 711                      final long itemId = item.id;
 712                      final Uri uri = LauncherSettings.Favorites.getContentUri(itemId, false);
 713                      ContentValues values = valuesList.get(i);
 714  
 715                      ops.add(ContentProviderOperation.newUpdate(uri).withValues(values).build());
 716                      updateItemArrays(item, itemId, stackTrace);
 717  
 718                  }
 719                  try {
 720                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
 721                  } catch (Exception e) {
 722                      e.printStackTrace();
 723                  }
 724              }
 725          };
 726          runOnWorkerThread(r);
 727      }
 728  
 729      static void updateItemArrays(ItemInfo item, long itemId, StackTraceElement[] stackTrace) {
 730          // Lock on mBgLock *after* the db operation
 731          synchronized (sBgLock) {
 732              checkItemInfoLocked(itemId, item, stackTrace);
 733  
 734              if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
 735                      item.container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 736                  // Item is in a folder, make sure this folder exists
 737                  if (!sBgFolders.containsKey(item.container)) {
 738                      // An items container is being set to a that of an item which is not in
 739                      // the list of Folders.
 740                      String msg = &quot;item: &quot; + item + &quot; container being set to: &quot; +
 741                              item.container + &quot;, not in the list of folders&quot;;
 742                      Log.e(TAG, msg);
 743                  }
 744              }
 745  
 746              // Items are added/removed from the corresponding FolderInfo elsewhere, such
 747              // as in Workspace.onDrop. Here, we just add/remove them from the list of items
 748              // that are on the desktop, as appropriate
 749              ItemInfo modelItem = sBgItemsIdMap.get(itemId);
 750              if (modelItem != null &amp;&amp;
 751                      (modelItem.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
 752                       modelItem.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT)) {
 753                  switch (modelItem.itemType) {
 754                      case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
 755                      case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
 756                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
 757                          if (!sBgWorkspaceItems.contains(modelItem)) {
 758                              sBgWorkspaceItems.add(modelItem);
 759                          }
 760                          break;
 761                      default:
 762                          break;
 763                  }
 764              } else {
 765                  sBgWorkspaceItems.remove(modelItem);
 766              }
 767          }
 768      }
 769  
 770      public void flushWorkerThread() {
 771          mFlushingWorkerThread = true;
 772          Runnable waiter = new Runnable() {
 773                  public void run() {
 774                      synchronized (this) {
 775                          notifyAll();
 776                          mFlushingWorkerThread = false;
 777                      }
 778                  }
 779              };
 780  
 781          synchronized(waiter) {
 782              runOnWorkerThread(waiter);
 783              if (mLoaderTask != null) {
 784                  synchronized(mLoaderTask) {
 785                      mLoaderTask.notify();
 786                  }
 787              }
 788              boolean success = false;
 789              while (!success) {
 790                  try {
 791                      waiter.wait();
 792                      success = true;
 793                  } catch (InterruptedException e) {
 794                  }
 795              }
 796          }
 797      }
 798  
 799      /**
 800       * Move an item in the DB to a new &lt;container, screen, cellX, cellY&gt;
 801       */
 802      static void moveItemInDatabase(Context context, final ItemInfo item, final long container,
 803              final long screenId, final int cellX, final int cellY) {
 804          item.container = container;
 805          item.cellX = cellX;
 806          item.cellY = cellY;
 807  
 808          // We store hotseat items in canonical form which is this orientation invariant position
 809          // in the hotseat
 810          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 811                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 812              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 813          } else {
 814              item.screenId = screenId;
 815          }
 816  
 817          final ContentValues values = new ContentValues();
 818          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 819          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 820          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 821          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 822  
 823          updateItemInDatabaseHelper(context, values, item, &quot;moveItemInDatabase&quot;);
 824      }
 825  
 826      /**
 827       * Move items in the DB to a new &lt;container, screen, cellX, cellY&gt;. We assume that the
 828       * cellX, cellY have already been updated on the ItemInfos.
 829       */
 830      static void moveItemsInDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items,
 831              final long container, final int screen) {
 832  
 833          ArrayList&lt;ContentValues&gt; contentValues = new ArrayList&lt;ContentValues&gt;();
 834          int count = items.size();
 835  
 836          for (int i = 0; i &lt; count; i++) {
 837              ItemInfo item = items.get(i);
 838              item.container = container;
 839  
 840              // We store hotseat items in canonical form which is this orientation invariant position
 841              // in the hotseat
 842              if (context instanceof Launcher &amp;&amp; screen &lt; 0 &amp;&amp;
 843                      container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 844                  item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(item.cellX,
 845                          item.cellY);
 846              } else {
 847                  item.screenId = screen;
 848              }
 849  
 850              final ContentValues values = new ContentValues();
 851              values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 852              values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 853              values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 854              values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 855  
 856              contentValues.add(values);
 857          }
 858          updateItemsInDatabaseHelper(context, contentValues, items, &quot;moveItemInDatabase&quot;);
 859      }
 860  
 861      /**
 862       * Move and/or resize item in the DB to a new &lt;container, screen, cellX, cellY, spanX, spanY&gt;
 863       */
 864      static void modifyItemInDatabase(Context context, final ItemInfo item, final long container,
 865              final long screenId, final int cellX, final int cellY, final int spanX, final int spanY) {
 866          item.container = container;
 867          item.cellX = cellX;
 868          item.cellY = cellY;
 869          item.spanX = spanX;
 870          item.spanY = spanY;
 871  
 872          // We store hotseat items in canonical form which is this orientation invariant position
 873          // in the hotseat
 874          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
 875                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 876              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
 877          } else {
 878              item.screenId = screenId;
 879          }
 880  
 881          final ContentValues values = new ContentValues();
 882          values.put(LauncherSettings.Favorites.CONTAINER, item.container);
 883          values.put(LauncherSettings.Favorites.CELLX, item.cellX);
 884          values.put(LauncherSettings.Favorites.CELLY, item.cellY);
 885          values.put(LauncherSettings.Favorites.SPANX, item.spanX);
 886          values.put(LauncherSettings.Favorites.SPANY, item.spanY);
 887          values.put(LauncherSettings.Favorites.SCREEN, item.screenId);
 888  
 889          updateItemInDatabaseHelper(context, values, item, &quot;modifyItemInDatabase&quot;);
 890      }
 891  
 892      /**
 893       * Update an item to the database in a specified container.
 894       */
 895      static void updateItemInDatabase(Context context, final ItemInfo item) {
 896          final ContentValues values = new ContentValues();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 897 -        item.onAddToDatabase(values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 898 +        item.onAddToDatabase(context, values);</span>
 899          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
 900          updateItemInDatabaseHelper(context, values, item, &quot;updateItemInDatabase&quot;);
 901      }
 902  
 903      /**
 904       * Returns true if the shortcuts already exists in the database.
 905       * we identify a shortcut by its title and intent.
 906       */
 907      static boolean shortcutExists(Context context, String title, Intent intent) {
 908          final ContentResolver cr = context.getContentResolver();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 909 +        final Intent intentWithPkg, intentWithoutPkg;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 910 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 911 +        if (intent.getComponent() != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 912 +            // If component is not null, an intent with null package will produce</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 913 +            // the same result and should also be a match.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 914 +            if (intent.getPackage() != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 915 +                intentWithPkg = intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 916 +                intentWithoutPkg = new Intent(intent).setPackage(null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 917 +            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 918 +                intentWithPkg = new Intent(intent).setPackage(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 919 +                        intent.getComponent().getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 920 +                intentWithoutPkg = intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 921 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 922 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 923 +            intentWithPkg = intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 924 +            intentWithoutPkg = intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 925 +        }</span>
 926          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 927 -            new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and intent=?&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 928 -            new String[] { title, intent.toUri(0) }, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 929 +            new String[] { &quot;title&quot;, &quot;intent&quot; }, &quot;title=? and (intent=? or intent=?)&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 930 +            new String[] { title, intentWithPkg.toUri(0), intentWithoutPkg.toUri(0) }, null);</span>
 931          boolean result = false;
 932          try {
 933              result = c.moveToFirst();
 934          } finally {
 935              c.close();
 936          }
 937          return result;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 938 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 939 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 940 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 941 +     * Returns true if the promise shortcuts with the same package name exists on the workspace.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 942 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 943 +    static boolean appWasPromise(Context context, Intent intent, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 944 +        final ComponentName component = intent.getComponent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 945 +        if (component == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 946 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 947 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 948 +        return !getItemsByPackageName(component.getPackageName(), user).isEmpty();</span>
 949      }
 950  
 951      /**
 952       * Returns an ItemInfo array containing all the items in the LauncherModel.
 953       * The ItemInfo.id is not set through this function.
 954       */
 955      static ArrayList&lt;ItemInfo&gt; getItemsInLocalCoordinates(Context context) {
 956          ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();
 957          final ContentResolver cr = context.getContentResolver();
 958          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, new String[] {
 959                  LauncherSettings.Favorites.ITEM_TYPE, LauncherSettings.Favorites.CONTAINER,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 960 -                LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,"> 960 -                LauncherSettings.Favorites.SCREEN, LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CE🔵</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 961 -                LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY }, null, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 962 +                LauncherSettings.Favorites.SCREEN,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 963 +                LauncherSettings.Favorites.CELLX, LauncherSettings.Favorites.CELLY,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 964 +                LauncherSettings.Favorites.SPANX, LauncherSettings.Favorites.SPANY,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 965 +                LauncherSettings.Favorites.PROFILE_ID }, null, null, null);</span>
 966  
 967          final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
 968          final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
 969          final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
 970          final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
 971          final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
 972          final int spanXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANX);
 973          final int spanYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SPANY);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 974 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 975 +        final int profileIdIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.PROFILE_ID);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 976 +        UserManagerCompat userManager = UserManagerCompat.getInstance(context);</span>
 977          try {
 978              while (c.moveToNext()) {
 979                  ItemInfo item = new ItemInfo();
 980                  item.cellX = c.getInt(cellXIndex);
 981                  item.cellY = c.getInt(cellYIndex);
 982                  item.spanX = Math.max(1, c.getInt(spanXIndex));
 983                  item.spanY = Math.max(1, c.getInt(spanYIndex));
 984                  item.container = c.getInt(containerIndex);
 985                  item.itemType = c.getInt(itemTypeIndex);
 986                  item.screenId = c.getInt(screenIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 987 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 988 -                items.add(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 989 +                long serialNumber = c.getInt(profileIdIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 990 +                item.user = userManager.getUserForSerialNumber(serialNumber);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 991 +                // Skip if user has been deleted.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 992 +                if (item.user != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 993 +                    items.add(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 994 +                }</span>
 995              }
 996          } catch (Exception e) {
 997              items.clear();
 998          } finally {
 999              c.close();
1000          }
1001  
1002          return items;
1003      }
1004  
1005      /**
1006       * Find a folder in the db, creating the FolderInfo if necessary, and adding it to folderList.
1007       */
1008      FolderInfo getFolderById(Context context, HashMap&lt;Long,FolderInfo&gt; folderList, long id) {
1009          final ContentResolver cr = context.getContentResolver();
1010          Cursor c = cr.query(LauncherSettings.Favorites.CONTENT_URI, null,
1011                  &quot;_id=? and (itemType=? or itemType=?)&quot;,
1012                  new String[] { String.valueOf(id),
1013                          String.valueOf(LauncherSettings.Favorites.ITEM_TYPE_FOLDER)}, null);
1014  
1015          try {
1016              if (c.moveToFirst()) {
1017                  final int itemTypeIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ITEM_TYPE);
1018                  final int titleIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE);
1019                  final int containerIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CONTAINER);
1020                  final int screenIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.SCREEN);
1021                  final int cellXIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLX);
1022                  final int cellYIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.CELLY);
1023  
1024                  FolderInfo folderInfo = null;
1025                  switch (c.getInt(itemTypeIndex)) {
1026                      case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1027                          folderInfo = findOrMakeFolder(folderList, id);
1028                          break;
1029                  }
1030  
1031                  folderInfo.title = c.getString(titleIndex);
1032                  folderInfo.id = id;
1033                  folderInfo.container = c.getInt(containerIndex);
1034                  folderInfo.screenId = c.getInt(screenIndex);
1035                  folderInfo.cellX = c.getInt(cellXIndex);
1036                  folderInfo.cellY = c.getInt(cellYIndex);
1037  
1038                  return folderInfo;
1039              }
1040          } finally {
1041              c.close();
1042          }
1043  
1044          return null;
1045      }
1046  
1047      /**
1048       * Add an item to the database in a specified container. Sets the container, screen, cellX and
1049       * cellY fields of the item. Also assigns an ID to the item.
1050       */
1051      static void addItemToDatabase(Context context, final ItemInfo item, final long container,
1052              final long screenId, final int cellX, final int cellY, final boolean notify) {
1053          item.container = container;
1054          item.cellX = cellX;
1055          item.cellY = cellY;
1056          // We store hotseat items in canonical form which is this orientation invariant position
1057          // in the hotseat
1058          if (context instanceof Launcher &amp;&amp; screenId &lt; 0 &amp;&amp;
1059                  container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1060              item.screenId = ((Launcher) context).getHotseat().getOrderInHotseat(cellX, cellY);
1061          } else {
1062              item.screenId = screenId;
1063          }
1064  
1065          final ContentValues values = new ContentValues();
1066          final ContentResolver cr = context.getContentResolver();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1067 -        item.onAddToDatabase(values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1068 +        item.onAddToDatabase(context, values);</span>
1069  
1070          item.id = LauncherAppState.getLauncherProvider().generateNewItemId();
1071          values.put(LauncherSettings.Favorites._ID, item.id);
1072          item.updateValuesWithCoordinates(values, item.cellX, item.cellY);
1073  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1074 +        final StackTraceElement[] stackTrace = new Throwable().getStackTrace();</span>
1075          Runnable r = new Runnable() {
1076              public void run() {
1077                  cr.insert(notify ? LauncherSettings.Favorites.CONTENT_URI :
1078                          LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION, values);
1079  
1080                  // Lock on mBgLock *after* the db operation
1081                  synchronized (sBgLock) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1082 -                    checkItemInfoLocked(item.id, item, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1083 +                    checkItemInfoLocked(item.id, item, stackTrace);</span>
1084                      sBgItemsIdMap.put(item.id, item);
1085                      switch (item.itemType) {
1086                          case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
1087                              sBgFolders.put(item.id, (FolderInfo) item);
1088                              // Fall through
1089                          case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
1090                          case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
1091                              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP ||
1092                                      item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1093                                  sBgWorkspaceItems.add(item);
1094                              } else {
1095                                  if (!sBgFolders.containsKey(item.container)) {
1096                                      // Adding an item to a folder that doesn&#x27;t exist.
1097                                      String msg = &quot;adding item: &quot; + item + &quot; to a folder that &quot; +
1098                                              &quot; doesn&#x27;t exist&quot;;
1099                                      Log.e(TAG, msg);
1100                                  }
1101                              }
1102                              break;
1103                          case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
1104                              sBgAppWidgets.add((LauncherAppWidgetInfo) item);
1105                              break;
1106                      }
1107                  }
1108              }
1109          };
1110          runOnWorkerThread(r);
1111      }
1112  
1113      /**
1114       * Creates a new unique child id, for a given cell span across all layouts.
1115       */
1116      static int getCellLayoutChildId(
1117              long container, long screen, int localCellX, int localCellY, int spanX, int spanY) {
1118          return (((int) container &amp; 0xFF) &lt;&lt; 24)
1119                  | ((int) screen &amp; 0xFF) &lt;&lt; 16 | (localCellX &amp; 0xFF) &lt;&lt; 8 | (localCellY &amp; 0xFF);
1120      }
1121  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1122 +    private static ArrayList&lt;ItemInfo&gt; getItemsByPackageName(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1123 +            final String pn, final UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1124 +        ItemInfoFilter filter  = new ItemInfoFilter() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1125 +            @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1126 +            public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1127 +                return cn.getPackageName().equals(pn) &amp;&amp; info.user.equals(user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1128 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1129 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1130 +        return filterItemInfos(sBgItemsIdMap.values(), filter);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1131 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1132 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1133 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1134 +     * Removes all the items from the database corresponding to the specified package.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1135 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1136 +    static void deletePackageFromDatabase(Context context, final String pn,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1137 +            final UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1138 +        deleteItemsFromDatabase(context, getItemsByPackageName(pn, user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1139 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1140 +</span>
1141      /**
1142       * Removes the specified item from the database
1143       * @param context
1144       * @param item
1145       */
1146      static void deleteItemFromDatabase(Context context, final ItemInfo item) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1147 +        ArrayList&lt;ItemInfo&gt; items = new ArrayList&lt;ItemInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1148 +        items.add(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1149 +        deleteItemsFromDatabase(context, items);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1150 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1151 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1152 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1153 +     * Removes the specified items from the database</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1154 +     * @param context</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1155 +     * @param item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1156 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1157 +    static void deleteItemsFromDatabase(Context context, final ArrayList&lt;ItemInfo&gt; items) {</span>
1158          final ContentResolver cr = context.getContentResolver();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1159 -        final Uri uriToDelete = LauncherSettings.Favorites.getContentUri(item.id, false);</span>
1160  
1161          Runnable r = new Runnable() {
1162              public void run() {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1163 -                cr.delete(uriToDelete, null, null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1164 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1165 -                // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1166 -                synchronized (sBgLock) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1167 -                    switch (item.itemType) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1168 -                        case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1169 -                            sBgFolders.remove(item.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1170 -                            for (ItemInfo info: sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1171 -                                if (info.container == item.id) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1172 -                                    // We are deleting a folder which still contains items that</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1173 -                                    // think they are contained by that folder.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1174 -                                    String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1175 -                                            &quot;contains items (&quot; + info + &quot;)&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1176 -                                    Log.e(TAG, msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1177 +                for (ItemInfo item : items) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1178 +                    final Uri uri = LauncherSettings.Favorites.getContentUri(item.id, false);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1179 +                    cr.delete(uri, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1180 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1181 +                    // Lock on mBgLock *after* the db operation</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1182 +                    synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1183 +                        switch (item.itemType) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1184 +                            case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1185 +                                sBgFolders.remove(item.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1186 +                                for (ItemInfo info: sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1187 +                                    if (info.container == item.id) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1188 +                                        // We are deleting a folder which still contains items that</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1189 +                                        // think they are contained by that folder.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1190 +                                        String msg = &quot;deleting a folder (&quot; + item + &quot;) which still &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1191 +                                                &quot;contains items (&quot; + info + &quot;)&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1192 +                                        Log.e(TAG, msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1193 +                                    }</span>
1194                                  }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1195 -                            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1196 -                            sBgWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1197 -                            break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1198 -                        case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1199 -                        case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1200 -                            sBgWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1201 -                            break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1202 -                        case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1203 -                            sBgAppWidgets.remove((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1204 -                            break;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1205 -                    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1206 -                    sBgItemsIdMap.remove(item.id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1207 -                    sBgDbIconCache.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1208 +                                sBgWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1209 +                                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1210 +                            case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1211 +                            case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1212 +                                sBgWorkspaceItems.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1213 +                                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1214 +                            case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1215 +                                sBgAppWidgets.remove((LauncherAppWidgetInfo) item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1216 +                                break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1217 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1218 +                        sBgItemsIdMap.remove(item.id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1219 +                        sBgDbIconCache.remove(item);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1220 +                    }</span>
1221                  }
1222              }
1223          };
1224          runOnWorkerThread(r);
1225      }
1226  
1227      /**
1228       * Update the order of the workspace screens in the database. The array list contains
1229       * a list of screen ids in the order that they should appear.
1230       */
1231      void updateWorkspaceScreenOrder(Context context, final ArrayList&lt;Long&gt; screens) {
1232          // Log to disk
1233          Launcher.addDumpLog(TAG, &quot;11683562 - updateWorkspaceScreenOrder()&quot;, true);
1234          Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; + TextUtils.join(&quot;, &quot;, screens), true);
1235  
1236          final ArrayList&lt;Long&gt; screensCopy = new ArrayList&lt;Long&gt;(screens);
1237          final ContentResolver cr = context.getContentResolver();
1238          final Uri uri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1239  
1240          // Remove any negative screen ids -- these aren&#x27;t persisted
1241          Iterator&lt;Long&gt; iter = screensCopy.iterator();
1242          while (iter.hasNext()) {
1243              long id = iter.next();
1244              if (id &lt; 0) {
1245                  iter.remove();
1246              }
1247          }
1248  
1249          Runnable r = new Runnable() {
1250              @Override
1251              public void run() {
1252                  ArrayList&lt;ContentProviderOperation&gt; ops = new ArrayList&lt;ContentProviderOperation&gt;();
1253                  // Clear the table
1254                  ops.add(ContentProviderOperation.newDelete(uri).build());
1255                  int count = screensCopy.size();
1256                  for (int i = 0; i &lt; count; i++) {
1257                      ContentValues v = new ContentValues();
1258                      long screenId = screensCopy.get(i);
1259                      v.put(LauncherSettings.WorkspaceScreens._ID, screenId);
1260                      v.put(LauncherSettings.WorkspaceScreens.SCREEN_RANK, i);
1261                      ops.add(ContentProviderOperation.newInsert(uri).withValues(v).build());
1262                  }
1263  
1264                  try {
1265                      cr.applyBatch(LauncherProvider.AUTHORITY, ops);
1266                  } catch (Exception ex) {
1267                      throw new RuntimeException(ex);
1268                  }
1269  
1270                  synchronized (sBgLock) {
1271                      sBgWorkspaceScreens.clear();
1272                      sBgWorkspaceScreens.addAll(screensCopy);
1273                  }
1274              }
1275          };
1276          runOnWorkerThread(r);
1277      }
1278  
1279      /**
1280       * Remove the contents of the specified folder from the database
1281       */
1282      static void deleteFolderContentsFromDatabase(Context context, final FolderInfo info) {
1283          final ContentResolver cr = context.getContentResolver();
1284  
1285          Runnable r = new Runnable() {
1286              public void run() {
1287                  cr.delete(LauncherSettings.Favorites.getContentUri(info.id, false), null, null);
1288                  // Lock on mBgLock *after* the db operation
1289                  synchronized (sBgLock) {
1290                      sBgItemsIdMap.remove(info.id);
1291                      sBgFolders.remove(info.id);
1292                      sBgDbIconCache.remove(info);
1293                      sBgWorkspaceItems.remove(info);
1294                  }
1295  
1296                  cr.delete(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,
1297                          LauncherSettings.Favorites.CONTAINER + &quot;=&quot; + info.id, null);
1298                  // Lock on mBgLock *after* the db operation
1299                  synchronized (sBgLock) {
1300                      for (ItemInfo childInfo : info.contents) {
1301                          sBgItemsIdMap.remove(childInfo.id);
1302                          sBgDbIconCache.remove(childInfo);
1303                      }
1304                  }
1305              }
1306          };
1307          runOnWorkerThread(r);
1308      }
1309  
1310      /**
1311       * Set this as the current Launcher activity object for the loader.
1312       */
1313      public void initialize(Callbacks callbacks) {
1314          synchronized (mLock) {
1315              mCallbacks = new WeakReference&lt;Callbacks&gt;(callbacks);
1316          }
1317      }
1318  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1319 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1320 +    public void onPackageChanged(String packageName, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1321 +        int op = PackageUpdatedTask.OP_UPDATE;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1322 +        enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1323 +                user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1324 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1325 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1326 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1327 +    public void onPackageRemoved(String packageName, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1328 +        int op = PackageUpdatedTask.OP_REMOVE;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1329 +        enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1330 +                user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1331 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1332 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1333 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1334 +    public void onPackageAdded(String packageName, UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1335 +        int op = PackageUpdatedTask.OP_ADD;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1336 +        enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName },</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1337 +                user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1338 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1339 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1340 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1341 +    public void onPackagesAvailable(String[] packageNames, UserHandleCompat user,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1342 +            boolean replacing) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1343 +        if (!replacing) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1344 +            enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packageNames,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1345 +                    user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1346 +            if (mAppsCanBeOnRemoveableStorage) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1347 +                // Only rebind if we support removable storage. It catches the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1348 +                // case where</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1349 +                // apps on the external sd card need to be reloaded</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1350 +                startLoaderFromBackground();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1351 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1352 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1353 +            // If we are replacing then just update the packages in the list</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1354 +            enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1355 +                    packageNames, user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1356 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1357 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1358 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1359 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1360 +    public void onPackagesUnavailable(String[] packageNames, UserHandleCompat user,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1361 +            boolean replacing) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1362 +        if (!replacing) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1363 +            enqueuePackageUpdated(new PackageUpdatedTask(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1364 +                    PackageUpdatedTask.OP_UNAVAILABLE, packageNames,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1365 +                    user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1366 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1367 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1368 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1369 +</span>
1370      /**
1371       * Call from the handler for ACTION_PACKAGE_ADDED, ACTION_PACKAGE_REMOVED and
1372       * ACTION_PACKAGE_CHANGED.
1373       */
1374      @Override
1375      public void onReceive(Context context, Intent intent) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1376 -        if (DEBUG_LOADERS) Log.d(TAG, &quot;onReceive intent=&quot; + intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1377 +        if (DEBUG_RECEIVER) Log.d(TAG, &quot;onReceive intent=&quot; + intent);</span>
1378  
1379          final String action = intent.getAction();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1380 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1381 -        if (Intent.ACTION_PACKAGE_CHANGED.equals(action)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1382 -                || Intent.ACTION_PACKAGE_REMOVED.equals(action)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1383 -                || Intent.ACTION_PACKAGE_ADDED.equals(action)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1384 -            final String packageName = intent.getData().getSchemeSpecificPart();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1385 -            final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1386 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1387 -            int op = PackageUpdatedTask.OP_NONE;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1388 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1389 -            if (packageName == null || packageName.length() == 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1390 -                // they sent us a bad intent</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1391 -                return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1392 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1393 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1394 -            if (Intent.ACTION_PACKAGE_CHANGED.equals(action)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1395 -                op = PackageUpdatedTask.OP_UPDATE;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1396 -            } else if (Intent.ACTION_PACKAGE_REMOVED.equals(action)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1397 -                if (!replacing) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1398 -                    op = PackageUpdatedTask.OP_REMOVE;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1399 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1400 -                // else, we are replacing the package, so a PACKAGE_ADDED will be sent</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1401 -                // later, we will update the package at this time</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1402 -            } else if (Intent.ACTION_PACKAGE_ADDED.equals(action)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1403 -                if (!replacing) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1404 -                    op = PackageUpdatedTask.OP_ADD;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1405 -                } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1406 -                    op = PackageUpdatedTask.OP_UPDATE;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1407 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1408 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1409 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1410 -            if (op != PackageUpdatedTask.OP_NONE) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1411 -                enqueuePackageUpdated(new PackageUpdatedTask(op, new String[] { packageName }));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1412 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1413 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1414 -        } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(action)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1415 -            final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1416 -            String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1417 -            if (!replacing) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1418 -                enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_ADD, packages));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1419 -                if (mAppsCanBeOnRemoveableStorage) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1420 -                    // Only rebind if we support removable storage.  It catches the case where</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1421 -                    // apps on the external sd card need to be reloaded</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1422 -                    startLoaderFromBackground();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1423 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1424 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1425 -                // If we are replacing then just update the packages in the list</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1426 -                enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_UPDATE,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1427 -                        packages));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1428 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1429 -        } else if (Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE.equals(action)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1430 -            final boolean replacing = intent.getBooleanExtra(Intent.EXTRA_REPLACING, false);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1431 -            if (!replacing) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1432 -                String[] packages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1433 -                enqueuePackageUpdated(new PackageUpdatedTask(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1434 -                            PackageUpdatedTask.OP_UNAVAILABLE, packages));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1435 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1436 -            // else, we are replacing the packages, so ignore this event and wait for</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1437 -            // EXTERNAL_APPLICATIONS_AVAILABLE to update the packages at that time</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1438 -        } else if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1439 +        if (Intent.ACTION_LOCALE_CHANGED.equals(action)) {</span>
1440              // If we have changed locale we need to clear out the labels in all apps/workspace.
1441              forceReload();
1442          } else if (Intent.ACTION_CONFIGURATION_CHANGED.equals(action)) {
1443               // Check if configuration change was an mcc/mnc change which would affect app resources
1444               // and we would need to clear out the labels in all apps/workspace. Same handling as
1445               // above for ACTION_LOCALE_CHANGED
1446               Configuration currentConfig = context.getResources().getConfiguration();
1447               if (mPreviousConfigMcc != currentConfig.mcc) {
1448                     Log.d(TAG, &quot;Reload apps on config change. curr_mcc:&quot;
1449                         + currentConfig.mcc + &quot; prevmcc:&quot; + mPreviousConfigMcc);
1450                     forceReload();
1451               }
1452               // Update previousConfig
1453               mPreviousConfigMcc = currentConfig.mcc;
1454          } else if (SearchManager.INTENT_GLOBAL_SEARCH_ACTIVITY_CHANGED.equals(action) ||
1455                     SearchManager.INTENT_ACTION_SEARCHABLES_CHANGED.equals(action)) {
1456              if (mCallbacks != null) {
1457                  Callbacks callbacks = mCallbacks.get();
1458                  if (callbacks != null) {
1459                      callbacks.bindSearchablesChanged();
1460                  }
1461              }
1462          }
1463      }
1464  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1465 -    private void forceReload() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1466 +    void forceReload() {</span>
1467          resetLoadedState(true, true);
1468  
1469          // Do this here because if the launcher activity is running it will be restarted.
1470          // If it&#x27;s not running startLoaderFromBackground will merely tell it that it needs
1471          // to reload.
1472          startLoaderFromBackground();
1473      }
1474  
1475      public void resetLoadedState(boolean resetAllAppsLoaded, boolean resetWorkspaceLoaded) {
1476          synchronized (mLock) {
1477              // Stop any existing loaders first, so they don&#x27;t set mAllAppsLoaded or
1478              // mWorkspaceLoaded to true later
1479              stopLoaderLocked();
1480              if (resetAllAppsLoaded) mAllAppsLoaded = false;
1481              if (resetWorkspaceLoaded) mWorkspaceLoaded = false;
1482          }
1483      }
1484  
1485      /**
1486       * When the launcher is in the background, it&#x27;s possible for it to miss paired
1487       * configuration changes.  So whenever we trigger the loader from the background
1488       * tell the launcher that it needs to re-run the loader when it comes back instead
1489       * of doing it now.
1490       */
1491      public void startLoaderFromBackground() {
1492          boolean runLoader = false;
1493          if (mCallbacks != null) {
1494              Callbacks callbacks = mCallbacks.get();
1495              if (callbacks != null) {
1496                  // Only actually run the loader if they&#x27;re not paused.
1497                  if (!callbacks.setLoadOnResume()) {
1498                      runLoader = true;
1499                  }
1500              }
1501          }
1502          if (runLoader) {
1503              startLoader(false, PagedView.INVALID_RESTORE_PAGE);
1504          }
1505      }
1506  
1507      // If there is already a loader task running, tell it to stop.
1508      // returns true if isLaunching() was true on the old task
1509      private boolean stopLoaderLocked() {
1510          boolean isLaunching = false;
1511          LoaderTask oldTask = mLoaderTask;
1512          if (oldTask != null) {
1513              if (oldTask.isLaunching()) {
1514                  isLaunching = true;
1515              }
1516              oldTask.stopLocked();
1517          }
1518          return isLaunching;
1519      }
1520  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1521 +    public boolean isCurrentCallbacks(Callbacks callbacks) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1522 +        return (mCallbacks != null &amp;&amp; mCallbacks.get() == callbacks);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1523 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1524 +</span>
1525      public void startLoader(boolean isLaunching, int synchronousBindPage) {
1526          startLoader(isLaunching, synchronousBindPage, LOADER_FLAG_NONE);
1527      }
1528  
1529      public void startLoader(boolean isLaunching, int synchronousBindPage, int loadFlags) {
1530          synchronized (mLock) {
1531              if (DEBUG_LOADERS) {
1532                  Log.d(TAG, &quot;startLoader isLaunching=&quot; + isLaunching);
1533              }
1534  
1535              // Clear any deferred bind-runnables from the synchronized load process
1536              // We must do this before any loading/binding is scheduled below.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1537 -            mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1538 +            synchronized (mDeferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1539 +                mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1540 +            }</span>
1541  
1542              // Don&#x27;t bother to start the thread if we know it&#x27;s not going to do anything
1543              if (mCallbacks != null &amp;&amp; mCallbacks.get() != null) {
1544                  // If there is already one running, tell it to stop.
1545                  // also, don&#x27;t downgrade isLaunching if we&#x27;re already running
1546                  isLaunching = isLaunching || stopLoaderLocked();
1547                  mLoaderTask = new LoaderTask(mApp.getContext(), isLaunching, loadFlags);
1548                  if (synchronousBindPage != PagedView.INVALID_RESTORE_PAGE
1549                          &amp;&amp; mAllAppsLoaded &amp;&amp; mWorkspaceLoaded) {
1550                      mLoaderTask.runBindSynchronousPage(synchronousBindPage);
1551                  } else {
1552                      sWorkerThread.setPriority(Thread.NORM_PRIORITY);
1553                      sWorker.post(mLoaderTask);
1554                  }
1555              }
1556          }
1557      }
1558  
1559      void bindRemainingSynchronousPages() {
1560          // Post the remaining side pages to be loaded
1561          if (!mDeferredBindRunnables.isEmpty()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1562 -            for (final Runnable r : mDeferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1563 +            Runnable[] deferredBindRunnables = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1564 +            synchronized (mDeferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1565 +                deferredBindRunnables = mDeferredBindRunnables.toArray(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1566 +                        new Runnable[mDeferredBindRunnables.size()]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1567 +                mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1568 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1569 +            for (final Runnable r : deferredBindRunnables) {</span>
1570                  mHandler.post(r, MAIN_THREAD_BINDING_RUNNABLE);
1571              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1572 -            mDeferredBindRunnables.clear();</span>
1573          }
1574      }
1575  
1576      public void stopLoader() {
1577          synchronized (mLock) {
1578              if (mLoaderTask != null) {
1579                  mLoaderTask.stopLocked();
1580              }
1581          }
1582      }
1583  
1584      /** Loads the workspace screens db into a map of Rank -&gt; ScreenId */
1585      private static TreeMap&lt;Integer, Long&gt; loadWorkspaceScreensDb(Context context) {
1586          final ContentResolver contentResolver = context.getContentResolver();
1587          final Uri screensUri = LauncherSettings.WorkspaceScreens.CONTENT_URI;
1588          final Cursor sc = contentResolver.query(screensUri, null, null, null, null);
1589          TreeMap&lt;Integer, Long&gt; orderedScreens = new TreeMap&lt;Integer, Long&gt;();
1590  
1591          try {
1592              final int idIndex = sc.getColumnIndexOrThrow(
1593                      LauncherSettings.WorkspaceScreens._ID);
1594              final int rankIndex = sc.getColumnIndexOrThrow(
1595                      LauncherSettings.WorkspaceScreens.SCREEN_RANK);
1596              while (sc.moveToNext()) {
1597                  try {
1598                      long screenId = sc.getLong(idIndex);
1599                      int rank = sc.getInt(rankIndex);
1600                      orderedScreens.put(rank, screenId);
1601                  } catch (Exception e) {
1602                      Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted - invalid screens: &quot; + e, true);
1603                  }
1604              }
1605          } finally {
1606              sc.close();
1607          }
1608  
1609          // Log to disk
1610          Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspaceScreensDb()&quot;, true);
1611          ArrayList&lt;String&gt; orderedScreensPairs= new ArrayList&lt;String&gt;();
1612          for (Integer i : orderedScreens.keySet()) {
1613              orderedScreensPairs.add(&quot;{ &quot; + i + &quot;: &quot; + orderedScreens.get(i) + &quot; }&quot;);
1614          }
1615          Launcher.addDumpLog(TAG, &quot;11683562 -   screens: &quot; +
1616                  TextUtils.join(&quot;, &quot;, orderedScreensPairs), true);
1617          return orderedScreens;
1618      }
1619  
1620      public boolean isAllAppsLoaded() {
1621          return mAllAppsLoaded;
1622      }
1623  
1624      boolean isLoadingWorkspace() {
1625          synchronized (mLock) {
1626              if (mLoaderTask != null) {
1627                  return mLoaderTask.isLoadingWorkspace();
1628              }
1629          }
1630          return false;
1631      }
1632  
1633      /**
1634       * Runnable for the thread that loads the contents of the launcher:
1635       *   - workspace icons
1636       *   - widgets
1637       *   - all apps icons
1638       */
1639      private class LoaderTask implements Runnable {
1640          private Context mContext;
1641          private boolean mIsLaunching;
1642          private boolean mIsLoadingAndBindingWorkspace;
1643          private boolean mStopped;
1644          private boolean mLoadAndBindStepFinished;
1645          private int mFlags;
1646  
1647          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
1648  
1649          LoaderTask(Context context, boolean isLaunching, int flags) {
1650              mContext = context;
1651              mIsLaunching = isLaunching;
1652              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
1653              mFlags = flags;
1654          }
1655  
1656          boolean isLaunching() {
1657              return mIsLaunching;
1658          }
1659  
1660          boolean isLoadingWorkspace() {
1661              return mIsLoadingAndBindingWorkspace;
1662          }
1663  
1664          /** Returns whether this is an upgrade path */
1665          private boolean loadAndBindWorkspace() {
1666              mIsLoadingAndBindingWorkspace = true;
1667  
1668              // Load the workspace
1669              if (DEBUG_LOADERS) {
1670                  Log.d(TAG, &quot;loadAndBindWorkspace mWorkspaceLoaded=&quot; + mWorkspaceLoaded);
1671              }
1672  
1673              boolean isUpgradePath = false;
1674              if (!mWorkspaceLoaded) {
1675                  isUpgradePath = loadWorkspace();
1676                  synchronized (LoaderTask.this) {
1677                      if (mStopped) {
1678                          return isUpgradePath;
1679                      }
1680                      mWorkspaceLoaded = true;
1681                  }
1682              }
1683  
1684              // Bind the workspace
1685              bindWorkspace(-1, isUpgradePath);
1686              return isUpgradePath;
1687          }
1688  
1689          private void waitForIdle() {
1690              // Wait until the either we&#x27;re stopped or the other threads are done.
1691              // This way we don&#x27;t start loading all apps until the workspace has settled
1692              // down.
1693              synchronized (LoaderTask.this) {
1694                  final long workspaceWaitTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
1695  
1696                  mHandler.postIdle(new Runnable() {
1697                          public void run() {
1698                              synchronized (LoaderTask.this) {
1699                                  mLoadAndBindStepFinished = true;
1700                                  if (DEBUG_LOADERS) {
1701                                      Log.d(TAG, &quot;done with previous binding step&quot;);
1702                                  }
1703                                  LoaderTask.this.notify();
1704                              }
1705                          }
1706                      });
1707  
1708                  while (!mStopped &amp;&amp; !mLoadAndBindStepFinished &amp;&amp; !mFlushingWorkerThread) {
1709                      try {
1710                          // Just in case mFlushingWorkerThread changes but we aren&#x27;t woken up,
1711                          // wait no longer than 1sec at a time
1712                          this.wait(1000);
1713                      } catch (InterruptedException ex) {
1714                          // Ignore
1715                      }
1716                  }
1717                  if (DEBUG_LOADERS) {
1718                      Log.d(TAG, &quot;waited &quot;
1719                              + (SystemClock.uptimeMillis()-workspaceWaitTime)
1720                              + &quot;ms for previous step to finish binding&quot;);
1721                  }
1722              }
1723          }
1724  
1725          void runBindSynchronousPage(int synchronousBindPage) {
1726              if (synchronousBindPage == PagedView.INVALID_RESTORE_PAGE) {
1727                  // Ensure that we have a valid page index to load synchronously
1728                  throw new RuntimeException(&quot;Should not call runBindSynchronousPage() without &quot; +
1729                          &quot;valid page index&quot;);
1730              }
1731              if (!mAllAppsLoaded || !mWorkspaceLoaded) {
1732                  // Ensure that we don&#x27;t try and bind a specified page when the pages have not been
1733                  // loaded already (we should load everything asynchronously in that case)
1734                  throw new RuntimeException(&quot;Expecting AllApps and Workspace to be loaded&quot;);
1735              }
1736              synchronized (mLock) {
1737                  if (mIsLoaderTaskRunning) {
1738                      // Ensure that we are never running the background loading at this point since
1739                      // we also touch the background collections
1740                      throw new RuntimeException(&quot;Error! Background loading is already running&quot;);
1741                  }
1742              }
1743  
1744              // XXX: Throw an exception if we are already loading (since we touch the worker thread
1745              //      data structures, we can&#x27;t allow any other thread to touch that data, but because
1746              //      this call is synchronous, we can get away with not locking).
1747  
1748              // The LauncherModel is static in the LauncherAppState and mHandler may have queued
1749              // operations from the previous activity.  We need to ensure that all queued operations
1750              // are executed before any synchronous binding work is done.
1751              mHandler.flush();
1752  
1753              // Divide the set of loaded items into those that we are binding synchronously, and
1754              // everything else that is to be bound normally (asynchronously).
1755              bindWorkspace(synchronousBindPage, false);
1756              // XXX: For now, continue posting the binding of AllApps as there are other issues that
1757              //      arise from that.
1758              onlyBindAllApps();
1759          }
1760  
1761          public void run() {
1762              boolean isUpgrade = false;
1763  
1764              synchronized (mLock) {
1765                  mIsLoaderTaskRunning = true;
1766              }
1767              // Optimize for end-user experience: if the Launcher is up and // running with the
1768              // All Apps interface in the foreground, load All Apps first. Otherwise, load the
1769              // workspace first (default).
1770              keep_running: {
1771                  // Elevate priority when Home launches for the first time to avoid
1772                  // starving at boot time. Staring at a blank home is not cool.
1773                  synchronized (mLock) {
1774                      if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to &quot; +
1775                              (mIsLaunching ? &quot;DEFAULT&quot; : &quot;BACKGROUND&quot;));
1776                      android.os.Process.setThreadPriority(mIsLaunching
1777                              ? Process.THREAD_PRIORITY_DEFAULT : Process.THREAD_PRIORITY_BACKGROUND);
1778                  }
1779                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 1: loading workspace&quot;);
1780                  isUpgrade = loadAndBindWorkspace();
1781  
1782                  if (mStopped) {
1783                      break keep_running;
1784                  }
1785  
1786                  // Whew! Hard work done.  Slow us down, and wait until the UI thread has
1787                  // settled down.
1788                  synchronized (mLock) {
1789                      if (mIsLaunching) {
1790                          if (DEBUG_LOADERS) Log.d(TAG, &quot;Setting thread priority to BACKGROUND&quot;);
1791                          android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);
1792                      }
1793                  }
1794                  waitForIdle();
1795  
1796                  // second step
1797                  if (DEBUG_LOADERS) Log.d(TAG, &quot;step 2: loading all apps&quot;);
1798                  loadAndBindAllApps();
1799  
1800                  // Restore the default thread priority after we are done loading items
1801                  synchronized (mLock) {
1802                      android.os.Process.setThreadPriority(Process.THREAD_PRIORITY_DEFAULT);
1803                  }
1804              }
1805  
1806              // Update the saved icons if necessary
1807              if (DEBUG_LOADERS) Log.d(TAG, &quot;Comparing loaded icons to database icons&quot;);
1808              synchronized (sBgLock) {
1809                  for (Object key : sBgDbIconCache.keySet()) {
1810                      updateSavedIcon(mContext, (ShortcutInfo) key, sBgDbIconCache.get(key));
1811                  }
1812                  sBgDbIconCache.clear();
1813              }
1814  
1815              if (LauncherAppState.isDisableAllApps()) {
1816                  // Ensure that all the applications that are in the system are
1817                  // represented on the home screen.
1818                  if (!UPGRADE_USE_MORE_APPS_FOLDER || !isUpgrade) {
1819                      verifyApplications();
1820                  }
1821              }
1822  
1823              // Clear out this reference, otherwise we end up holding it until all of the
1824              // callback runnables are done.
1825              mContext = null;
1826  
1827              synchronized (mLock) {
1828                  // If we are still the last one to be scheduled, remove ourselves.
1829                  if (mLoaderTask == this) {
1830                      mLoaderTask = null;
1831                  }
1832                  mIsLoaderTaskRunning = false;
1833              }
1834          }
1835  
1836          public void stopLocked() {
1837              synchronized (LoaderTask.this) {
1838                  mStopped = true;
1839                  this.notify();
1840              }
1841          }
1842  
1843          /**
1844           * Gets the callbacks object.  If we&#x27;ve been stopped, or if the launcher object
1845           * has somehow been garbage collected, return null instead.  Pass in the Callbacks
1846           * object that was around when the deferred message was scheduled, and if there&#x27;s
1847           * a new Callbacks object around then also return null.  This will save us from
1848           * calling onto it with data that will be ignored.
1849           */
1850          Callbacks tryGetCallbacks(Callbacks oldCallbacks) {
1851              synchronized (mLock) {
1852                  if (mStopped) {
1853                      return null;
1854                  }
1855  
1856                  if (mCallbacks == null) {
1857                      return null;
1858                  }
1859  
1860                  final Callbacks callbacks = mCallbacks.get();
1861                  if (callbacks != oldCallbacks) {
1862                      return null;
1863                  }
1864                  if (callbacks == null) {
1865                      Log.w(TAG, &quot;no mCallbacks&quot;);
1866                      return null;
1867                  }
1868  
1869                  return callbacks;
1870              }
1871          }
1872  
1873          private void verifyApplications() {
1874              final Context context = mApp.getContext();
1875  
1876              // Cross reference all the applications in our apps list with items in the workspace
1877              ArrayList&lt;ItemInfo&gt; tmpInfos;
1878              ArrayList&lt;ItemInfo&gt; added = new ArrayList&lt;ItemInfo&gt;();
1879              synchronized (sBgLock) {
1880                  for (AppInfo app : mBgAllAppsList.data) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1881 -                    tmpInfos = getItemInfoForComponentName(app.componentName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1882 +                    tmpInfos = getItemInfoForComponentName(app.componentName, app.user);</span>
1883                      if (tmpInfos.isEmpty()) {
1884                          // We are missing an application icon, so add this to the workspace
1885                          added.add(app);
1886                          // This is a rare event, so lets log it
1887                          Log.e(TAG, &quot;Missing Application on load: &quot; + app);
1888                      }
1889                  }
1890              }
1891              if (!added.isEmpty()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1892 -                Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1893 -                addAndBindAddedApps(context, added, cb, new ArrayList&lt;AppInfo&gt;());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1894 +                addAndBindAddedWorkspaceApps(context, added);</span>
1895              }
1896          }
1897  
1898          // check &amp; update map of what&#x27;s occupied; used to discard overlapping/invalid items
1899          private boolean checkItemPlacement(HashMap&lt;Long, ItemInfo[][]&gt; occupied, ItemInfo item,
1900                                             AtomicBoolean deleteOnInvalidPlacement) {
1901              LauncherAppState app = LauncherAppState.getInstance();
1902              DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
1903              final int countX = (int) grid.numColumns;
1904              final int countY = (int) grid.numRows;
1905  
1906              long containerIndex = item.screenId;
1907              if (item.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
1908                  // Return early if we detect that an item is under the hotseat button
1909                  if (mCallbacks == null ||
1910                          mCallbacks.get().isAllAppsButtonRank((int) item.screenId)) {
1911                      deleteOnInvalidPlacement.set(true);
1912                      Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1913                              + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1914                              + item.cellY + &quot;) occupied by all apps&quot;);
1915                      return false;
1916                  }
1917  
1918                  final ItemInfo[][] hotseatItems =
1919                          occupied.get((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT);
1920  
1921                  if (item.screenId &gt;= grid.numHotseatIcons) {
1922                      Log.e(TAG, &quot;Error loading shortcut &quot; + item
1923                              + &quot; into hotseat position &quot; + item.screenId
1924                              + &quot;, position out of bounds: (0 to &quot; + (grid.numHotseatIcons - 1)
1925                              + &quot;)&quot;);
1926                      return false;
1927                  }
1928  
1929                  if (hotseatItems != null) {
1930                      if (hotseatItems[(int) item.screenId][0] != null) {
1931                          Log.e(TAG, &quot;Error loading shortcut into hotseat &quot; + item
1932                                  + &quot; into position (&quot; + item.screenId + &quot;:&quot; + item.cellX + &quot;,&quot;
1933                                  + item.cellY + &quot;) occupied by &quot;
1934                                  + occupied.get(LauncherSettings.Favorites.CONTAINER_HOTSEAT)
1935                                  [(int) item.screenId][0]);
1936                              return false;
1937                      } else {
1938                          hotseatItems[(int) item.screenId][0] = item;
1939                          return true;
1940                      }
1941                  } else {
1942                      final ItemInfo[][] items = new ItemInfo[(int) grid.numHotseatIcons][1];
1943                      items[(int) item.screenId][0] = item;
1944                      occupied.put((long) LauncherSettings.Favorites.CONTAINER_HOTSEAT, items);
1945                      return true;
1946                  }
1947              } else if (item.container != LauncherSettings.Favorites.CONTAINER_DESKTOP) {
1948                  // Skip further checking if it is not the hotseat or workspace container
1949                  return true;
1950              }
1951  
1952              if (!occupied.containsKey(item.screenId)) {
1953                  ItemInfo[][] items = new ItemInfo[countX + 1][countY + 1];
1954                  occupied.put(item.screenId, items);
1955              }
1956  
1957              final ItemInfo[][] screens = occupied.get(item.screenId);
1958              if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
1959                      item.cellX &lt; 0 || item.cellY &lt; 0 ||
1960                      item.cellX + item.spanX &gt; countX || item.cellY + item.spanY &gt; countY) {
1961                  Log.e(TAG, &quot;Error loading shortcut &quot; + item
1962                          + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1963                          + item.cellX + &quot;,&quot; + item.cellY
1964                          + &quot;) out of screen bounds ( &quot; + countX + &quot;x&quot; + countY + &quot;)&quot;);
1965                  return false;
1966              }
1967  
1968              // Check if any workspace icons overlap with each other
1969              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1970                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1971                      if (screens[x][y] != null) {
1972                          Log.e(TAG, &quot;Error loading shortcut &quot; + item
1973                              + &quot; into cell (&quot; + containerIndex + &quot;-&quot; + item.screenId + &quot;:&quot;
1974                              + x + &quot;,&quot; + y
1975                              + &quot;) occupied by &quot;
1976                              + screens[x][y]);
1977                          return false;
1978                      }
1979                  }
1980              }
1981              for (int x = item.cellX; x &lt; (item.cellX+item.spanX); x++) {
1982                  for (int y = item.cellY; y &lt; (item.cellY+item.spanY); y++) {
1983                      screens[x][y] = item;
1984                  }
1985              }
1986  
1987              return true;
1988          }
1989  
1990          /** Clears all the sBg data structures */
1991          private void clearSBgDataStructures() {
1992              synchronized (sBgLock) {
1993                  sBgWorkspaceItems.clear();
1994                  sBgAppWidgets.clear();
1995                  sBgFolders.clear();
1996                  sBgItemsIdMap.clear();
1997                  sBgDbIconCache.clear();
1998                  sBgWorkspaceScreens.clear();
1999              }
2000          }
2001  
2002          /** Returns whether this is an upgrade path */
2003          private boolean loadWorkspace() {
2004              // Log to disk
2005              Launcher.addDumpLog(TAG, &quot;11683562 - loadWorkspace()&quot;, true);
2006  
2007              final long t = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
2008  
2009              final Context context = mContext;
2010              final ContentResolver contentResolver = context.getContentResolver();
2011              final PackageManager manager = context.getPackageManager();
2012              final AppWidgetManager widgets = AppWidgetManager.getInstance(context);
2013              final boolean isSafeMode = manager.isSafeMode();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2014 +            final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2015 +            final boolean isSdCardReady = context.registerReceiver(null,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2016 +                    new IntentFilter(StartupReceiver.SYSTEM_READY)) != null;</span>
2017  
2018              LauncherAppState app = LauncherAppState.getInstance();
2019              DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2020              int countX = (int) grid.numColumns;
2021              int countY = (int) grid.numRows;
2022  
2023              if ((mFlags &amp; LOADER_FLAG_CLEAR_WORKSPACE) != 0) {
2024                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: resetting launcher database&quot;, true);
2025                  LauncherAppState.getLauncherProvider().deleteDatabase();
2026              }
2027  
2028              if ((mFlags &amp; LOADER_FLAG_MIGRATE_SHORTCUTS) != 0) {
2029                  // append the user&#x27;s Launcher2 shortcuts
2030                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: migrating from launcher2&quot;, true);
2031                  LauncherAppState.getLauncherProvider().migrateLauncher2Shortcuts();
2032              } else {
2033                  // Make sure the default workspace is loaded
2034                  Launcher.addDumpLog(TAG, &quot;loadWorkspace: loading default favorites&quot;, false);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2035 -                LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary(0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2036 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2037 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2038 -            // Check if we need to do any upgrade-path logic</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2039 -            // (Includes having just imported default favorites)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2040 -            boolean loadedOldDb = LauncherAppState.getLauncherProvider().justLoadedOldDb();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2041 +                LauncherAppState.getLauncherProvider().loadDefaultFavoritesIfNecessary();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2042 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2043 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2044 +            // This code path is for our old migration code and should no longer be exercised</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2045 +            boolean loadedOldDb = false;</span>
2046  
2047              // Log to disk
2048              Launcher.addDumpLog(TAG, &quot;11683562 -   loadedOldDb: &quot; + loadedOldDb, true);
2049  
2050              synchronized (sBgLock) {
2051                  clearSBgDataStructures();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2052 +                final HashSet&lt;String&gt; installingPkgs = PackageInstallerCompat</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2053 +                        .getInstance(mContext).updateAndGetActiveSessionCache();</span>
2054  
2055                  final ArrayList&lt;Long&gt; itemsToRemove = new ArrayList&lt;Long&gt;();
2056                  final ArrayList&lt;Long&gt; restoredRows = new ArrayList&lt;Long&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2057 -                final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2058 +                final Uri contentUri = LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION;</span>
2059                  if (DEBUG_LOADERS) Log.d(TAG, &quot;loading model from &quot; + contentUri);
2060                  final Cursor c = contentResolver.query(contentUri, null, null, null, null);
2061  
2062                  // +1 for the hotseat (it can be larger than the workspace)
2063                  // Load workspace in reverse order to ensure that latest items are loaded first (and
2064                  // before any earlier duplicates)
2065                  final HashMap&lt;Long, ItemInfo[][]&gt; occupied = new HashMap&lt;Long, ItemInfo[][]&gt;();
2066  
2067                  try {
2068                      final int idIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites._ID);
2069                      final int intentIndex = c.getColumnIndexOrThrow
2070                              (LauncherSettings.Favorites.INTENT);
2071                      final int titleIndex = c.getColumnIndexOrThrow
2072                              (LauncherSettings.Favorites.TITLE);
2073                      final int iconTypeIndex = c.getColumnIndexOrThrow(
2074                              LauncherSettings.Favorites.ICON_TYPE);
2075                      final int iconIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.ICON);
2076                      final int iconPackageIndex = c.getColumnIndexOrThrow(
2077                              LauncherSettings.Favorites.ICON_PACKAGE);
2078                      final int iconResourceIndex = c.getColumnIndexOrThrow(
2079                              LauncherSettings.Favorites.ICON_RESOURCE);
2080                      final int containerIndex = c.getColumnIndexOrThrow(
2081                              LauncherSettings.Favorites.CONTAINER);
2082                      final int itemTypeIndex = c.getColumnIndexOrThrow(
2083                              LauncherSettings.Favorites.ITEM_TYPE);
2084                      final int appWidgetIdIndex = c.getColumnIndexOrThrow(
2085                              LauncherSettings.Favorites.APPWIDGET_ID);
2086                      final int appWidgetProviderIndex = c.getColumnIndexOrThrow(
2087                              LauncherSettings.Favorites.APPWIDGET_PROVIDER);
2088                      final int screenIndex = c.getColumnIndexOrThrow(
2089                              LauncherSettings.Favorites.SCREEN);
2090                      final int cellXIndex = c.getColumnIndexOrThrow
2091                              (LauncherSettings.Favorites.CELLX);
2092                      final int cellYIndex = c.getColumnIndexOrThrow
2093                              (LauncherSettings.Favorites.CELLY);
2094                      final int spanXIndex = c.getColumnIndexOrThrow
2095                              (LauncherSettings.Favorites.SPANX);
2096                      final int spanYIndex = c.getColumnIndexOrThrow(
2097                              LauncherSettings.Favorites.SPANY);
2098                      final int restoredIndex = c.getColumnIndexOrThrow(
2099                              LauncherSettings.Favorites.RESTORED);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2100 +                    final int profileIdIndex = c.getColumnIndexOrThrow(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2101 +                            LauncherSettings.Favorites.PROFILE_ID);</span>
2102                      //final int uriIndex = c.getColumnIndexOrThrow(LauncherSettings.Favorites.URI);
2103                      //final int displayModeIndex = c.getColumnIndexOrThrow(
2104                      //        LauncherSettings.Favorites.DISPLAY_MODE);
2105  
2106                      ShortcutInfo info;
2107                      String intentDescription;
2108                      LauncherAppWidgetInfo appWidgetInfo;
2109                      int container;
2110                      long id;
2111                      Intent intent;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2112 +                    UserHandleCompat user;</span>
2113  
2114                      while (!mStopped &amp;&amp; c.moveToNext()) {
2115                          AtomicBoolean deleteOnInvalidPlacement = new AtomicBoolean(false);
2116                          try {
2117                              int itemType = c.getInt(itemTypeIndex);
2118                              boolean restored = 0 != c.getInt(restoredIndex);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2119 +                            boolean allowMissingTarget = false;</span>
2120  
2121                              switch (itemType) {
2122                              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
2123                              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
2124                                  id = c.getLong(idIndex);
2125                                  intentDescription = c.getString(intentIndex);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2126 +                                long serialNumber = c.getInt(profileIdIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2127 +                                user = mUserManager.getUserForSerialNumber(serialNumber);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2128 +                                int promiseType = c.getInt(restoredIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2129 +                                if (user == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2130 +                                    // User has been deleted remove the item.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2131 +                                    itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2132 +                                    continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2133 +                                }</span>
2134                                  try {
2135                                      intent = Intent.parseUri(intentDescription, 0);
2136                                      ComponentName cn = intent.getComponent();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2137 -                                    if (cn != null &amp;&amp; !isValidPackageComponent(manager, cn)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2138 -                                        if (restored) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2139 -                                            // might be installed later</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2140 +                                    if (cn != null &amp;&amp; cn.getPackageName() != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2141 +                                        boolean validPkg = launcherApps.isPackageEnabledForProfile(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2142 +                                                cn.getPackageName(), user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2143 +                                        boolean validComponent = validPkg &amp;&amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2144 +                                                launcherApps.isActivityEnabledForProfile(cn, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2145 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2146 +                                        if (validComponent) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2147 +                                            if (restored) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2148 +                                                // no special handling necessary for this item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2149 +                                                restoredRows.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2150 +                                                restored = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2151 +                                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2152 +                                        } else if (validPkg) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2153 +                                            intent = null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2154 +                                            if ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2155 +                                                // We allow auto install apps to have their intent</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2156 +                                                // updated after an install.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2157 +                                                intent = manager.getLaunchIntentForPackage(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2158 +                                                        cn.getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2159 +                                                if (intent != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2160 +                                                    ContentValues values = new ContentValues();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2161 +                                                    values.put(LauncherSettings.Favorites.INTENT,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2162 +                                                            intent.toUri(0));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2163 +                                                    String where = BaseColumns._ID + &quot;= ?&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2164 +                                                    String[] args = {Long.toString(id)};</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2165 +                                                    contentResolver.update(contentUri, values, where, args);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2166 +                                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2167 +                                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2168 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2169 +                                            if (intent == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2170 +                                                // The app is installed but the component is no</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2171 +                                                // longer available.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2172 +                                                Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2173 +                                                        &quot;Invalid component removed: &quot; + cn, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2174 +                                                itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2175 +                                                continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2176 +                                            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2177 +                                                // no special handling necessary for this item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2178 +                                                restoredRows.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2179 +                                                restored = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2180 +                                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2181 +                                        } else if (restored) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2182 +                                            // Package is not yet available but might be</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2183 +                                            // installed later.</span>
2184                                              Launcher.addDumpLog(TAG,
2185                                                      &quot;package not yet restored: &quot; + cn, true);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2186 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2187 +                                            if ((promiseType &amp; ShortcutInfo.FLAG_RESTORE_STARTED) != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2188 +                                                // Restore has started once.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2189 +                                            } else if (installingPkgs.contains(cn.getPackageName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2190 +                                                // App restore has started. Update the flag</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2191 +                                                promiseType |= ShortcutInfo.FLAG_RESTORE_STARTED;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2192 +                                                ContentValues values = new ContentValues();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2193 +                                                values.put(LauncherSettings.Favorites.RESTORED,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2194 +                                                        promiseType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2195 +                                                String where = BaseColumns._ID + &quot;= ?&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2196 +                                                String[] args = {Long.toString(id)};</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2197 +                                                contentResolver.update(contentUri, values, where, args);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2198 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2199 +                                            } else if (REMOVE_UNRESTORED_ICONS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2200 +                                                Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2201 +                                                        &quot;Unrestored package removed: &quot; + cn, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2202 +                                                itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2203 +                                                continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2204 +                                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2205 +                                        } else if (isSdCardReady) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2206 +                                            // Do not wait for external media load anymore.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2207 +                                            // Log the invalid package, and remove it</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2208 +                                            Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2209 +                                                    &quot;Invalid package removed: &quot; + cn, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2210 +                                            itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2211 +                                            continue;</span>
2212                                          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2213 -                                            if (!mAppsCanBeOnRemoveableStorage) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2214 -                                                // Log the invalid package, and remove it</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2215 -                                                Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2216 -                                                        &quot;Invalid package removed: &quot; + cn, true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2217 -                                                itemsToRemove.add(id);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2218 -                                            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2219 -                                                // If apps can be on external storage, then we just</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2220 -                                                // leave them for the user to remove (maybe add</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2221 -                                                // visual treatment to it)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2222 -                                                Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2223 -                                                        &quot;Invalid package found: &quot; + cn, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2224 +                                            // SdCard is not ready yet. Package might get available,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2225 +                                            // once it is ready.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2226 +                                            Launcher.addDumpLog(TAG, &quot;Invalid package: &quot; + cn</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2227 +                                                    + &quot; (check again later)&quot;, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2228 +                                            HashSet&lt;String&gt; pkgs = sPendingPackages.get(user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2229 +                                            if (pkgs == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2230 +                                                pkgs = new HashSet&lt;String&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2231 +                                                sPendingPackages.put(user, pkgs);</span>
2232                                              }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2233 -                                            continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2234 +                                            pkgs.add(cn.getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2235 +                                            allowMissingTarget = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2236 +                                            // Add the icon on the workspace anyway.</span>
2237                                          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2238 -                                    } else if (restored) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2239 -                                        // no special handling necessary for this restored item</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2240 +                                    } else if (cn == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2241 +                                        // For shortcuts with no component, keep them as they are</span>
2242                                          restoredRows.add(id);
2243                                          restored = false;
2244                                      }
2245                                  } catch (URISyntaxException e) {
2246                                      Launcher.addDumpLog(TAG,
2247                                              &quot;Invalid uri: &quot; + intentDescription, true);
2248                                      continue;
2249                                  }
2250  
2251                                  if (restored) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2252 -                                    Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2253 -                                            &quot;constructing info for partially restored package&quot;,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2254 -                                            true);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2255 -                                    info = getRestoredItemInfo(c, titleIndex);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2256 -                                    intent = getRestoredItemIntent(c, context, intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2257 +                                    if (user.equals(UserHandleCompat.myUserHandle())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2258 +                                        Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2259 +                                                &quot;constructing info for partially restored package&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2260 +                                                true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2261 +                                        info = getRestoredItemInfo(c, titleIndex, intent, promiseType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2262 +                                        intent = getRestoredItemIntent(c, context, intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2263 +                                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2264 +                                        // Don&#x27;t restore items for other profiles.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2265 +                                        itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2266 +                                        continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2267 +                                    }</span>
2268                                  } else if (itemType ==
2269                                          LauncherSettings.Favorites.ITEM_TYPE_APPLICATION) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2270 -                                    info = getShortcutInfo(manager, intent, context, c, iconIndex,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2271 -                                            titleIndex, mLabelCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2272 +                                    info = getShortcutInfo(manager, intent, user, context, c,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2273 +                                            iconIndex, titleIndex, mLabelCache, allowMissingTarget);</span>
2274                                  } else {
2275                                      info = getShortcutInfo(c, context, iconTypeIndex,
2276                                              iconPackageIndex, iconResourceIndex, iconIndex,
2277                                              titleIndex);
2278  
2279                                      // App shortcuts that used to be automatically added to Launcher
2280                                      // didn&#x27;t always have the correct intent flags set, so do that
2281                                      // here
2282                                      if (intent.getAction() != null &amp;&amp;
2283                                          intent.getCategories() != null &amp;&amp;
2284                                          intent.getAction().equals(Intent.ACTION_MAIN) &amp;&amp;
2285                                          intent.getCategories().contains(Intent.CATEGORY_LAUNCHER)) {
2286                                          intent.addFlags(
2287                                              Intent.FLAG_ACTIVITY_NEW_TASK |
2288                                              Intent.FLAG_ACTIVITY_RESET_TASK_IF_NEEDED);
2289                                      }
2290                                  }
2291  
2292                                  if (info != null) {
2293                                      info.id = id;
2294                                      info.intent = intent;
2295                                      container = c.getInt(containerIndex);
2296                                      info.container = container;
2297                                      info.screenId = c.getInt(screenIndex);
2298                                      info.cellX = c.getInt(cellXIndex);
2299                                      info.cellY = c.getInt(cellYIndex);
2300                                      info.spanX = 1;
2301                                      info.spanY = 1;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2302 +                                    info.intent.putExtra(ItemInfo.EXTRA_PROFILE, serialNumber);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2303 +                                    info.isDisabled = isSafeMode</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2304 +                                            &amp;&amp; !Utilities.isSystemApp(context, intent);</span>
2305  
2306                                      // check &amp; update map of what&#x27;s occupied
2307                                      deleteOnInvalidPlacement.set(false);
2308                                      if (!checkItemPlacement(occupied, info, deleteOnInvalidPlacement)) {
2309                                          if (deleteOnInvalidPlacement.get()) {
2310                                              itemsToRemove.add(id);
2311                                          }
2312                                          break;
2313                                      }
2314  
2315                                      switch (container) {
2316                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2317                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2318                                          sBgWorkspaceItems.add(info);
2319                                          break;
2320                                      default:
2321                                          // Item is in a user folder
2322                                          FolderInfo folderInfo =
2323                                                  findOrMakeFolder(sBgFolders, container);
2324                                          folderInfo.add(info);
2325                                          break;
2326                                      }
2327                                      sBgItemsIdMap.put(info.id, info);
2328  
2329                                      // now that we&#x27;ve loaded everthing re-save it with the
2330                                      // icon in case it disappears somehow.
2331                                      queueIconToBeChecked(sBgDbIconCache, info, c, iconIndex);
2332                                  } else {
2333                                      throw new RuntimeException(&quot;Unexpected null ShortcutInfo&quot;);
2334                                  }
2335                                  break;
2336  
2337                              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
2338                                  id = c.getLong(idIndex);
2339                                  FolderInfo folderInfo = findOrMakeFolder(sBgFolders, id);
2340  
2341                                  folderInfo.title = c.getString(titleIndex);
2342                                  folderInfo.id = id;
2343                                  container = c.getInt(containerIndex);
2344                                  folderInfo.container = container;
2345                                  folderInfo.screenId = c.getInt(screenIndex);
2346                                  folderInfo.cellX = c.getInt(cellXIndex);
2347                                  folderInfo.cellY = c.getInt(cellYIndex);
2348                                  folderInfo.spanX = 1;
2349                                  folderInfo.spanY = 1;
2350  
2351                                  // check &amp; update map of what&#x27;s occupied
2352                                  deleteOnInvalidPlacement.set(false);
2353                                  if (!checkItemPlacement(occupied, folderInfo,
2354                                          deleteOnInvalidPlacement)) {
2355                                      if (deleteOnInvalidPlacement.get()) {
2356                                          itemsToRemove.add(id);
2357                                      }
2358                                      break;
2359                                  }
2360  
2361                                  switch (container) {
2362                                      case LauncherSettings.Favorites.CONTAINER_DESKTOP:
2363                                      case LauncherSettings.Favorites.CONTAINER_HOTSEAT:
2364                                          sBgWorkspaceItems.add(folderInfo);
2365                                          break;
2366                                  }
2367  
2368                                  if (restored) {
2369                                      // no special handling required for restored folders
2370                                      restoredRows.add(id);
2371                                  }
2372  
2373                                  sBgItemsIdMap.put(folderInfo.id, folderInfo);
2374                                  sBgFolders.put(folderInfo.id, folderInfo);
2375                                  break;
2376  
2377                              case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
2378                                  // Read all Launcher-specific widget details
2379                                  int appWidgetId = c.getInt(appWidgetIdIndex);
2380                                  String savedProvider = c.getString(appWidgetProviderIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2381 -</span>
2382                                  id = c.getLong(idIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2383 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2384 -                                final AppWidgetProviderInfo provider =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2385 -                                        widgets.getAppWidgetInfo(appWidgetId);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2386 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2387 -                                if (!isSafeMode &amp;&amp; (provider == null || provider.provider == null ||</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2388 -                                        provider.provider.getPackageName() == null)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2389 -                                    String log = &quot;Deleting widget that isn&#x27;t installed anymore: id=&quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2390 -                                        + id + &quot; appWidgetId=&quot; + appWidgetId;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2391 +                                final ComponentName component =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2392 +                                        ComponentName.unflattenFromString(savedProvider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2393 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2394 +                                final int restoreStatus = c.getInt(restoredIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2395 +                                final boolean isIdValid = (restoreStatus &amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2396 +                                        LauncherAppWidgetInfo.FLAG_ID_NOT_VALID) == 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2397 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2398 +                                final boolean wasProviderReady = (restoreStatus &amp;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2399 +                                        LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) == 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2400 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2401 +                                final AppWidgetProviderInfo provider = isIdValid</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2402 +                                        ? widgets.getAppWidgetInfo(appWidgetId)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2403 +                                        : findAppWidgetProviderInfoWithComponent(context, component);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2404 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2405 +                                final boolean isProviderReady = isValidProvider(provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2406 +                                if (!isSafeMode &amp;&amp; wasProviderReady &amp;&amp; !isProviderReady) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2407 +                                    String log = &quot;Deleting widget that isn&#x27;t installed anymore: &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2408 +                                            + &quot;id=&quot; + id + &quot; appWidgetId=&quot; + appWidgetId;</span>
2409                                      Log.e(TAG, log);
2410                                      Launcher.addDumpLog(TAG, log, false);
2411                                      itemsToRemove.add(id);
2412                                  } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2413 -                                    appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2414 -                                            provider.provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2415 +                                    if (isProviderReady) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2416 +                                        appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2417 +                                                provider.provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2418 +                                        int[] minSpan =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2419 +                                                Launcher.getMinSpanForWidget(context, provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2420 +                                        appWidgetInfo.minSpanX = minSpan[0];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2421 +                                        appWidgetInfo.minSpanY = minSpan[1];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2422 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2423 +                                        int status = restoreStatus;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2424 +                                        if (!wasProviderReady) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2425 +                                            // If provider was not previously ready, update the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2426 +                                            // status and UI flag.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2427 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="2428 +                                            // Id would be valid only if the widget restore broadcast was received.">2428 +                                            // Id would be valid only if the widget restore broadcast was received🔵</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2429 +                                            if (isIdValid) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2430 +                                                status = LauncherAppWidgetInfo.RESTORE_COMPLETED;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2431 +                                            } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2432 +                                                status &amp;= ~LauncherAppWidgetInfo</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2433 +                                                        .FLAG_PROVIDER_NOT_READY;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2434 +                                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2435 +                                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2436 +                                        appWidgetInfo.restoreStatus = status;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2437 +                                    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2438 +                                        Log.v(TAG, &quot;Widget restore pending id=&quot; + id</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2439 +                                                + &quot; appWidgetId=&quot; + appWidgetId</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2440 +                                                + &quot; status =&quot; + restoreStatus);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2441 +                                        appWidgetInfo = new LauncherAppWidgetInfo(appWidgetId,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2442 +                                                component);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2443 +                                        appWidgetInfo.restoreStatus = restoreStatus;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2444 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2445 +                                        if ((restoreStatus &amp; LauncherAppWidgetInfo.FLAG_RESTORE_STARTED) != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2446 +                                            // Restore has started once.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2447 +                                        } else if (installingPkgs.contains(component.getPackageName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2448 +                                            // App restore has started. Update the flag</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2449 +                                            appWidgetInfo.restoreStatus |=</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2450 +                                                    LauncherAppWidgetInfo.FLAG_RESTORE_STARTED;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2451 +                                        } else if (REMOVE_UNRESTORED_ICONS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2452 +                                            Launcher.addDumpLog(TAG,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2453 +                                                    &quot;Unrestored widget removed: &quot; + component, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2454 +                                            itemsToRemove.add(id);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2455 +                                            continue;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2456 +                                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2457 +                                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2458 +</span>
2459                                      appWidgetInfo.id = id;
2460                                      appWidgetInfo.screenId = c.getInt(screenIndex);
2461                                      appWidgetInfo.cellX = c.getInt(cellXIndex);
2462                                      appWidgetInfo.cellY = c.getInt(cellYIndex);
2463                                      appWidgetInfo.spanX = c.getInt(spanXIndex);
2464                                      appWidgetInfo.spanY = c.getInt(spanYIndex);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2465 -                                    int[] minSpan = Launcher.getMinSpanForWidget(context, provider);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2466 -                                    appWidgetInfo.minSpanX = minSpan[0];</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2467 -                                    appWidgetInfo.minSpanY = minSpan[1];</span>
2468  
2469                                      container = c.getInt(containerIndex);
2470                                      if (container != LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2471                                          container != LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2472                                          Log.e(TAG, &quot;Widget found where container != &quot; +
2473                                              &quot;CONTAINER_DESKTOP nor CONTAINER_HOTSEAT - ignoring!&quot;);
2474                                          continue;
2475                                      }
2476  
2477                                      appWidgetInfo.container = c.getInt(containerIndex);
2478                                      // check &amp; update map of what&#x27;s occupied
2479                                      deleteOnInvalidPlacement.set(false);
2480                                      if (!checkItemPlacement(occupied, appWidgetInfo,
2481                                              deleteOnInvalidPlacement)) {
2482                                          if (deleteOnInvalidPlacement.get()) {
2483                                              itemsToRemove.add(id);
2484                                          }
2485                                          break;
2486                                      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2487 -                                    String providerName = provider.provider.flattenToString();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2488 -                                    if (!providerName.equals(savedProvider)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2489 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2490 +                                    String providerName = appWidgetInfo.providerName.flattenToString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2491 +                                    if (!providerName.equals(savedProvider) ||</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2492 +                                            (appWidgetInfo.restoreStatus != restoreStatus)) {</span>
2493                                          ContentValues values = new ContentValues();
2494                                          values.put(LauncherSettings.Favorites.APPWIDGET_PROVIDER,
2495                                                  providerName);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2496 +                                        values.put(LauncherSettings.Favorites.RESTORED,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2497 +                                                appWidgetInfo.restoreStatus);</span>
2498                                          String where = BaseColumns._ID + &quot;= ?&quot;;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2499 -                                        String[] args = {Integer.toString(c.getInt(idIndex))};</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2500 +                                        String[] args = {Long.toString(id)};</span>
2501                                          contentResolver.update(contentUri, values, where, args);
2502                                      }
2503                                      sBgItemsIdMap.put(appWidgetInfo.id, appWidgetInfo);
2504                                      sBgAppWidgets.add(appWidgetInfo);
2505                                  }
2506                                  break;
2507                              }
2508                          } catch (Exception e) {
2509                              Launcher.addDumpLog(TAG, &quot;Desktop items loading interrupted&quot;, e, true);
2510                          }
2511                      }
2512                  } finally {
2513                      if (c != null) {
2514                          c.close();
2515                      }
2516                  }
2517  
2518                  // Break early if we&#x27;ve stopped loading
2519                  if (mStopped) {
2520                      clearSBgDataStructures();
2521                      return false;
2522                  }
2523  
2524                  if (itemsToRemove.size() &gt; 0) {
2525                      ContentProviderClient client = contentResolver.acquireContentProviderClient(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2526 -                            LauncherSettings.Favorites.CONTENT_URI);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2527 +                            contentUri);</span>
2528                      // Remove dead items
2529                      for (long id : itemsToRemove) {
2530                          if (DEBUG_LOADERS) {
2531                              Log.d(TAG, &quot;Removed id = &quot; + id);
2532                          }
2533                          // Don&#x27;t notify content observers
2534                          try {
2535                              client.delete(LauncherSettings.Favorites.getContentUri(id, false),
2536                                      null, null);
2537                          } catch (RemoteException e) {
2538                              Log.w(TAG, &quot;Could not remove id = &quot; + id);
2539                          }
2540                      }
2541                  }
2542  
2543                  if (restoredRows.size() &gt; 0) {
2544                      ContentProviderClient updater = contentResolver.acquireContentProviderClient(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2545 -                            LauncherSettings.Favorites.CONTENT_URI);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2546 +                            contentUri);</span>
2547                      // Update restored items that no longer require special handling
2548                      try {
2549                          StringBuilder selectionBuilder = new StringBuilder();
2550                          selectionBuilder.append(LauncherSettings.Favorites._ID);
2551                          selectionBuilder.append(&quot; IN (&quot;);
2552                          selectionBuilder.append(TextUtils.join(&quot;, &quot;, restoredRows));
2553                          selectionBuilder.append(&quot;)&quot;);
2554                          ContentValues values = new ContentValues();
2555                          values.put(LauncherSettings.Favorites.RESTORED, 0);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2556 -                        updater.update(LauncherSettings.Favorites.CONTENT_URI,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2557 +                        updater.update(LauncherSettings.Favorites.CONTENT_URI_NO_NOTIFICATION,</span>
2558                                  values, selectionBuilder.toString(), null);
2559                      } catch (RemoteException e) {
2560                          Log.w(TAG, &quot;Could not update restored rows&quot;);
2561                      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2562 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2563 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2564 +                if (!isSdCardReady &amp;&amp; !sPendingPackages.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2565 +                    context.registerReceiver(new AppsAvailabilityCheck(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2566 +                            new IntentFilter(StartupReceiver.SYSTEM_READY),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2567 +                            null, sWorker);</span>
2568                  }
2569  
2570                  if (loadedOldDb) {
2571                      long maxScreenId = 0;
2572                      // If we&#x27;re importing we use the old screen order.
2573                      for (ItemInfo item: sBgItemsIdMap.values()) {
2574                          long screenId = item.screenId;
2575                          if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2576                                  !sBgWorkspaceScreens.contains(screenId)) {
2577                              sBgWorkspaceScreens.add(screenId);
2578                              if (screenId &gt; maxScreenId) {
2579                                  maxScreenId = screenId;
2580                              }
2581                          }
2582                      }
2583                      Collections.sort(sBgWorkspaceScreens);
2584                      // Log to disk
2585                      Launcher.addDumpLog(TAG, &quot;11683562 -   maxScreenId: &quot; + maxScreenId, true);
2586                      Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2587                              TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2588  
2589                      LauncherAppState.getLauncherProvider().updateMaxScreenId(maxScreenId);
2590                      updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2591  
2592                      // Update the max item id after we load an old db
2593                      long maxItemId = 0;
2594                      // If we&#x27;re importing we use the old screen order.
2595                      for (ItemInfo item: sBgItemsIdMap.values()) {
2596                          maxItemId = Math.max(maxItemId, item.id);
2597                      }
2598                      LauncherAppState.getLauncherProvider().updateMaxItemId(maxItemId);
2599                  } else {
2600                      TreeMap&lt;Integer, Long&gt; orderedScreens = loadWorkspaceScreensDb(mContext);
2601                      for (Integer i : orderedScreens.keySet()) {
2602                          sBgWorkspaceScreens.add(orderedScreens.get(i));
2603                      }
2604                      // Log to disk
2605                      Launcher.addDumpLog(TAG, &quot;11683562 -   sBgWorkspaceScreens: &quot; +
2606                              TextUtils.join(&quot;, &quot;, sBgWorkspaceScreens), true);
2607  
2608                      // Remove any empty screens
2609                      ArrayList&lt;Long&gt; unusedScreens = new ArrayList&lt;Long&gt;(sBgWorkspaceScreens);
2610                      for (ItemInfo item: sBgItemsIdMap.values()) {
2611                          long screenId = item.screenId;
2612                          if (item.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2613                                  unusedScreens.contains(screenId)) {
2614                              unusedScreens.remove(screenId);
2615                          }
2616                      }
2617  
2618                      // If there are any empty screens remove them, and update.
2619                      if (unusedScreens.size() != 0) {
2620                          // Log to disk
2621                          Launcher.addDumpLog(TAG, &quot;11683562 -   unusedScreens (to be removed): &quot; +
2622                                  TextUtils.join(&quot;, &quot;, unusedScreens), true);
2623  
2624                          sBgWorkspaceScreens.removeAll(unusedScreens);
2625                          updateWorkspaceScreenOrder(context, sBgWorkspaceScreens);
2626                      }
2627                  }
2628  
2629                  if (DEBUG_LOADERS) {
2630                      Log.d(TAG, &quot;loaded workspace in &quot; + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2631                      Log.d(TAG, &quot;workspace layout: &quot;);
2632                      int nScreens = occupied.size();
2633                      for (int y = 0; y &lt; countY; y++) {
2634                          String line = &quot;&quot;;
2635  
2636                          Iterator&lt;Long&gt; iter = occupied.keySet().iterator();
2637                          while (iter.hasNext()) {
2638                              long screenId = iter.next();
2639                              if (screenId &gt; 0) {
2640                                  line += &quot; | &quot;;
2641                              }
2642                              for (int x = 0; x &lt; countX; x++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2643 -                                line += ((occupied.get(screenId)[x][y] != null) ? &quot;#&quot; : &quot;.&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2644 +                                ItemInfo[][] screen = occupied.get(screenId);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2645 +                                if (x &lt; screen.length &amp;&amp; y &lt; screen[x].length) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2646 +                                    line += (screen[x][y] != null) ? &quot;#&quot; : &quot;.&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2647 +                                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2648 +                                    line += &quot;!&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2649 +                                }</span>
2650                              }
2651                          }
2652                          Log.d(TAG, &quot;[ &quot; + line + &quot; ]&quot;);
2653                      }
2654                  }
2655              }
2656              return loadedOldDb;
2657          }
2658  
2659          /** Filters the set of items who are directly or indirectly (via another container) on the
2660           * specified screen. */
2661          private void filterCurrentWorkspaceItems(long currentScreenId,
2662                  ArrayList&lt;ItemInfo&gt; allWorkspaceItems,
2663                  ArrayList&lt;ItemInfo&gt; currentScreenItems,
2664                  ArrayList&lt;ItemInfo&gt; otherScreenItems) {
2665              // Purge any null ItemInfos
2666              Iterator&lt;ItemInfo&gt; iter = allWorkspaceItems.iterator();
2667              while (iter.hasNext()) {
2668                  ItemInfo i = iter.next();
2669                  if (i == null) {
2670                      iter.remove();
2671                  }
2672              }
2673  
2674              // Order the set of items by their containers first, this allows use to walk through the
2675              // list sequentially, build up a list of containers that are in the specified screen,
2676              // as well as all items in those containers.
2677              Set&lt;Long&gt; itemsOnScreen = new HashSet&lt;Long&gt;();
2678              Collections.sort(allWorkspaceItems, new Comparator&lt;ItemInfo&gt;() {
2679                  @Override
2680                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2681                      return (int) (lhs.container - rhs.container);
2682                  }
2683              });
2684              for (ItemInfo info : allWorkspaceItems) {
2685                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
2686                      if (info.screenId == currentScreenId) {
2687                          currentScreenItems.add(info);
2688                          itemsOnScreen.add(info.id);
2689                      } else {
2690                          otherScreenItems.add(info);
2691                      }
2692                  } else if (info.container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
2693                      currentScreenItems.add(info);
2694                      itemsOnScreen.add(info.id);
2695                  } else {
2696                      if (itemsOnScreen.contains(info.container)) {
2697                          currentScreenItems.add(info);
2698                          itemsOnScreen.add(info.id);
2699                      } else {
2700                          otherScreenItems.add(info);
2701                      }
2702                  }
2703              }
2704          }
2705  
2706          /** Filters the set of widgets which are on the specified screen. */
2707          private void filterCurrentAppWidgets(long currentScreenId,
2708                  ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2709                  ArrayList&lt;LauncherAppWidgetInfo&gt; currentScreenWidgets,
2710                  ArrayList&lt;LauncherAppWidgetInfo&gt; otherScreenWidgets) {
2711  
2712              for (LauncherAppWidgetInfo widget : appWidgets) {
2713                  if (widget == null) continue;
2714                  if (widget.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2715                          widget.screenId == currentScreenId) {
2716                      currentScreenWidgets.add(widget);
2717                  } else {
2718                      otherScreenWidgets.add(widget);
2719                  }
2720              }
2721          }
2722  
2723          /** Filters the set of folders which are on the specified screen. */
2724          private void filterCurrentFolders(long currentScreenId,
2725                  HashMap&lt;Long, ItemInfo&gt; itemsIdMap,
2726                  HashMap&lt;Long, FolderInfo&gt; folders,
2727                  HashMap&lt;Long, FolderInfo&gt; currentScreenFolders,
2728                  HashMap&lt;Long, FolderInfo&gt; otherScreenFolders) {
2729  
2730              for (long id : folders.keySet()) {
2731                  ItemInfo info = itemsIdMap.get(id);
2732                  FolderInfo folder = folders.get(id);
2733                  if (info == null || folder == null) continue;
2734                  if (info.container == LauncherSettings.Favorites.CONTAINER_DESKTOP &amp;&amp;
2735                          info.screenId == currentScreenId) {
2736                      currentScreenFolders.put(id, folder);
2737                  } else {
2738                      otherScreenFolders.put(id, folder);
2739                  }
2740              }
2741          }
2742  
2743          /** Sorts the set of items by hotseat, workspace (spatially from top to bottom, left to
2744           * right) */
2745          private void sortWorkspaceItemsSpatially(ArrayList&lt;ItemInfo&gt; workspaceItems) {
2746              final LauncherAppState app = LauncherAppState.getInstance();
2747              final DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2748              // XXX: review this
2749              Collections.sort(workspaceItems, new Comparator&lt;ItemInfo&gt;() {
2750                  @Override
2751                  public int compare(ItemInfo lhs, ItemInfo rhs) {
2752                      int cellCountX = (int) grid.numColumns;
2753                      int cellCountY = (int) grid.numRows;
2754                      int screenOffset = cellCountX * cellCountY;
2755                      int containerOffset = screenOffset * (Launcher.SCREEN_COUNT + 1); // +1 hotseat
2756                      long lr = (lhs.container * containerOffset + lhs.screenId * screenOffset +
2757                              lhs.cellY * cellCountX + lhs.cellX);
2758                      long rr = (rhs.container * containerOffset + rhs.screenId * screenOffset +
2759                              rhs.cellY * cellCountX + rhs.cellX);
2760                      return (int) (lr - rr);
2761                  }
2762              });
2763          }
2764  
2765          private void bindWorkspaceScreens(final Callbacks oldCallbacks,
2766                  final ArrayList&lt;Long&gt; orderedScreens) {
2767              final Runnable r = new Runnable() {
2768                  @Override
2769                  public void run() {
2770                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2771                      if (callbacks != null) {
2772                          callbacks.bindScreens(orderedScreens);
2773                      }
2774                  }
2775              };
2776              runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2777          }
2778  
2779          private void bindWorkspaceItems(final Callbacks oldCallbacks,
2780                  final ArrayList&lt;ItemInfo&gt; workspaceItems,
2781                  final ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets,
2782                  final HashMap&lt;Long, FolderInfo&gt; folders,
2783                  ArrayList&lt;Runnable&gt; deferredBindRunnables) {
2784  
2785              final boolean postOnMainThread = (deferredBindRunnables != null);
2786  
2787              // Bind the workspace items
2788              int N = workspaceItems.size();
2789              for (int i = 0; i &lt; N; i += ITEMS_CHUNK) {
2790                  final int start = i;
2791                  final int chunkSize = (i+ITEMS_CHUNK &lt;= N) ? ITEMS_CHUNK : (N-i);
2792                  final Runnable r = new Runnable() {
2793                      @Override
2794                      public void run() {
2795                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2796                          if (callbacks != null) {
2797                              callbacks.bindItems(workspaceItems, start, start+chunkSize,
2798                                      false);
2799                          }
2800                      }
2801                  };
2802                  if (postOnMainThread) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2803 -                    deferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2804 +                    synchronized (deferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2805 +                        deferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2806 +                    }</span>
2807                  } else {
2808                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2809                  }
2810              }
2811  
2812              // Bind the folders
2813              if (!folders.isEmpty()) {
2814                  final Runnable r = new Runnable() {
2815                      public void run() {
2816                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2817                          if (callbacks != null) {
2818                              callbacks.bindFolders(folders);
2819                          }
2820                      }
2821                  };
2822                  if (postOnMainThread) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2823 -                    deferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2824 +                    synchronized (deferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2825 +                        deferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2826 +                    }</span>
2827                  } else {
2828                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2829                  }
2830              }
2831  
2832              // Bind the widgets, one at a time
2833              N = appWidgets.size();
2834              for (int i = 0; i &lt; N; i++) {
2835                  final LauncherAppWidgetInfo widget = appWidgets.get(i);
2836                  final Runnable r = new Runnable() {
2837                      public void run() {
2838                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2839                          if (callbacks != null) {
2840                              callbacks.bindAppWidget(widget);
2841                          }
2842                      }
2843                  };
2844                  if (postOnMainThread) {
2845                      deferredBindRunnables.add(r);
2846                  } else {
2847                      runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2848                  }
2849              }
2850          }
2851  
2852          /**
2853           * Binds all loaded data to actual views on the main thread.
2854           */
2855          private void bindWorkspace(int synchronizeBindPage, final boolean isUpgradePath) {
2856              final long t = SystemClock.uptimeMillis();
2857              Runnable r;
2858  
2859              // Don&#x27;t use these two variables in any of the callback runnables.
2860              // Otherwise we hold a reference to them.
2861              final Callbacks oldCallbacks = mCallbacks.get();
2862              if (oldCallbacks == null) {
2863                  // This launcher has exited and nobody bothered to tell us.  Just bail.
2864                  Log.w(TAG, &quot;LoaderTask running with no launcher&quot;);
2865                  return;
2866              }
2867  
2868              // Save a copy of all the bg-thread collections
2869              ArrayList&lt;ItemInfo&gt; workspaceItems = new ArrayList&lt;ItemInfo&gt;();
2870              ArrayList&lt;LauncherAppWidgetInfo&gt; appWidgets =
2871                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2872              HashMap&lt;Long, FolderInfo&gt; folders = new HashMap&lt;Long, FolderInfo&gt;();
2873              HashMap&lt;Long, ItemInfo&gt; itemsIdMap = new HashMap&lt;Long, ItemInfo&gt;();
2874              ArrayList&lt;Long&gt; orderedScreenIds = new ArrayList&lt;Long&gt;();
2875              synchronized (sBgLock) {
2876                  workspaceItems.addAll(sBgWorkspaceItems);
2877                  appWidgets.addAll(sBgAppWidgets);
2878                  folders.putAll(sBgFolders);
2879                  itemsIdMap.putAll(sBgItemsIdMap);
2880                  orderedScreenIds.addAll(sBgWorkspaceScreens);
2881              }
2882  
2883              final boolean isLoadingSynchronously =
2884                      synchronizeBindPage != PagedView.INVALID_RESTORE_PAGE;
2885              int currScreen = isLoadingSynchronously ? synchronizeBindPage :
2886                  oldCallbacks.getCurrentWorkspaceScreen();
2887              if (currScreen &gt;= orderedScreenIds.size()) {
2888                  // There may be no workspace screens (just hotseat items and an empty page).
2889                  currScreen = PagedView.INVALID_RESTORE_PAGE;
2890              }
2891              final int currentScreen = currScreen;
2892              final long currentScreenId = currentScreen &lt; 0
2893                      ? INVALID_SCREEN_ID : orderedScreenIds.get(currentScreen);
2894  
2895              // Load all the items that are on the current page first (and in the process, unbind
2896              // all the existing workspace items before we call startBinding() below.
2897              unbindWorkspaceItemsOnMainThread();
2898  
2899              // Separate the items that are on the current screen, and all the other remaining items
2900              ArrayList&lt;ItemInfo&gt; currentWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2901              ArrayList&lt;ItemInfo&gt; otherWorkspaceItems = new ArrayList&lt;ItemInfo&gt;();
2902              ArrayList&lt;LauncherAppWidgetInfo&gt; currentAppWidgets =
2903                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2904              ArrayList&lt;LauncherAppWidgetInfo&gt; otherAppWidgets =
2905                      new ArrayList&lt;LauncherAppWidgetInfo&gt;();
2906              HashMap&lt;Long, FolderInfo&gt; currentFolders = new HashMap&lt;Long, FolderInfo&gt;();
2907              HashMap&lt;Long, FolderInfo&gt; otherFolders = new HashMap&lt;Long, FolderInfo&gt;();
2908  
2909              filterCurrentWorkspaceItems(currentScreenId, workspaceItems, currentWorkspaceItems,
2910                      otherWorkspaceItems);
2911              filterCurrentAppWidgets(currentScreenId, appWidgets, currentAppWidgets,
2912                      otherAppWidgets);
2913              filterCurrentFolders(currentScreenId, itemsIdMap, folders, currentFolders,
2914                      otherFolders);
2915              sortWorkspaceItemsSpatially(currentWorkspaceItems);
2916              sortWorkspaceItemsSpatially(otherWorkspaceItems);
2917  
2918              // Tell the workspace that we&#x27;re about to start binding items
2919              r = new Runnable() {
2920                  public void run() {
2921                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2922                      if (callbacks != null) {
2923                          callbacks.startBinding();
2924                      }
2925                  }
2926              };
2927              runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2928  
2929              bindWorkspaceScreens(oldCallbacks, orderedScreenIds);
2930  
2931              // Load items on the current page
2932              bindWorkspaceItems(oldCallbacks, currentWorkspaceItems, currentAppWidgets,
2933                      currentFolders, null);
2934              if (isLoadingSynchronously) {
2935                  r = new Runnable() {
2936                      public void run() {
2937                          Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2938                          if (callbacks != null &amp;&amp; currentScreen != PagedView.INVALID_RESTORE_PAGE) {
2939                              callbacks.onPageBoundSynchronously(currentScreen);
2940                          }
2941                      }
2942                  };
2943                  runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2944              }
2945  
2946              // Load all the remaining pages (if we are loading synchronously, we want to defer this
2947              // work until after the first render)
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2948 -            mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2949 +            synchronized (mDeferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2950 +                mDeferredBindRunnables.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2951 +            }</span>
2952              bindWorkspaceItems(oldCallbacks, otherWorkspaceItems, otherAppWidgets, otherFolders,
2953                      (isLoadingSynchronously ? mDeferredBindRunnables : null));
2954  
2955              // Tell the workspace that we&#x27;re done binding items
2956              r = new Runnable() {
2957                  public void run() {
2958                      Callbacks callbacks = tryGetCallbacks(oldCallbacks);
2959                      if (callbacks != null) {
2960                          callbacks.finishBindingItems(isUpgradePath);
2961                      }
2962  
2963                      // If we&#x27;re profiling, ensure this is the last thing in the queue.
2964                      if (DEBUG_LOADERS) {
2965                          Log.d(TAG, &quot;bound workspace in &quot;
2966                              + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
2967                      }
2968  
2969                      mIsLoadingAndBindingWorkspace = false;
2970                  }
2971              };
2972              if (isLoadingSynchronously) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2973 -                mDeferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2974 +                synchronized (mDeferredBindRunnables) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2975 +                    mDeferredBindRunnables.add(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2976 +                }</span>
2977              } else {
2978                  runOnMainThread(r, MAIN_THREAD_BINDING_RUNNABLE);
2979              }
2980          }
2981  
2982          private void loadAndBindAllApps() {
2983              if (DEBUG_LOADERS) {
2984                  Log.d(TAG, &quot;loadAndBindAllApps mAllAppsLoaded=&quot; + mAllAppsLoaded);
2985              }
2986              if (!mAllAppsLoaded) {
2987                  loadAllApps();
2988                  synchronized (LoaderTask.this) {
2989                      if (mStopped) {
2990                          return;
2991                      }
2992                      mAllAppsLoaded = true;
2993                  }
2994              } else {
2995                  onlyBindAllApps();
2996              }
2997          }
2998  
2999          private void onlyBindAllApps() {
3000              final Callbacks oldCallbacks = mCallbacks.get();
3001              if (oldCallbacks == null) {
3002                  // This launcher has exited and nobody bothered to tell us.  Just bail.
3003                  Log.w(TAG, &quot;LoaderTask running with no launcher (onlyBindAllApps)&quot;);
3004                  return;
3005              }
3006  
3007              // shallow copy
3008              @SuppressWarnings(&quot;unchecked&quot;)
3009              final ArrayList&lt;AppInfo&gt; list
3010                      = (ArrayList&lt;AppInfo&gt;) mBgAllAppsList.data.clone();
3011              Runnable r = new Runnable() {
3012                  public void run() {
3013                      final long t = SystemClock.uptimeMillis();
3014                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3015                      if (callbacks != null) {
3016                          callbacks.bindAllApplications(list);
3017                      }
3018                      if (DEBUG_LOADERS) {
3019                          Log.d(TAG, &quot;bound all &quot; + list.size() + &quot; apps from cache in &quot;
3020                                  + (SystemClock.uptimeMillis()-t) + &quot;ms&quot;);
3021                      }
3022                  }
3023              };
3024              boolean isRunningOnMainThread = !(sWorkerThread.getThreadId() == Process.myTid());
3025              if (isRunningOnMainThread) {
3026                  r.run();
3027              } else {
3028                  mHandler.post(r);
3029              }
3030          }
3031  
3032          private void loadAllApps() {
3033              final long loadTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;
3034  
3035              final Callbacks oldCallbacks = mCallbacks.get();
3036              if (oldCallbacks == null) {
3037                  // This launcher has exited and nobody bothered to tell us.  Just bail.
3038                  Log.w(TAG, &quot;LoaderTask running with no launcher (loadAllApps)&quot;);
3039                  return;
3040              }
3041  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3042 -            final PackageManager packageManager = mContext.getPackageManager();</span>
3043              final Intent mainIntent = new Intent(Intent.ACTION_MAIN, null);
3044              mainIntent.addCategory(Intent.CATEGORY_LAUNCHER);
3045  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3046 +            final List&lt;UserHandleCompat&gt; profiles = mUserManager.getUserProfiles();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3047 +</span>
3048              // Clear the list of apps
3049              mBgAllAppsList.clear();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3050 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3051 -            // Query for the set of apps</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3052 -            final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3053 -            List&lt;ResolveInfo&gt; apps = packageManager.queryIntentActivities(mainIntent, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3054 -            if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3055 -                Log.d(TAG, &quot;queryIntentActivities took &quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3056 -                        + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3057 -                Log.d(TAG, &quot;queryIntentActivities got &quot; + apps.size() + &quot; apps&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3058 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3059 -            // Fail if we don&#x27;t have any apps</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3060 -            if (apps == null || apps.isEmpty()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3061 -                return;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3062 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3063 -            // Sort the applications by name</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3064 -            final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3065 -            Collections.sort(apps,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3066 -                    new LauncherModel.ShortcutNameComparator(packageManager, mLabelCache));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3067 -            if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3068 -                Log.d(TAG, &quot;sort took &quot;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3069 -                        + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3070 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3071 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3072 -            // Create the ApplicationInfos</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3073 -            for (int i = 0; i &lt; apps.size(); i++) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3074 -                ResolveInfo app = apps.get(i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3075 -                // This builds the icon bitmaps.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3076 -                mBgAllAppsList.add(new AppInfo(packageManager, app,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3077 -                        mIconCache, mLabelCache));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3078 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3079 -</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3080 +            for (UserHandleCompat user : profiles) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3081 +                // Query for the set of apps</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3082 +                final long qiaTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3083 +                List&lt;LauncherActivityInfoCompat&gt; apps = mLauncherApps.getActivityList(null, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3084 +                if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3085 +                    Log.d(TAG, &quot;getActivityList took &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3086 +                            + (SystemClock.uptimeMillis()-qiaTime) + &quot;ms for user &quot; + user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3087 +                    Log.d(TAG, &quot;getActivityList got &quot; + apps.size() + &quot; apps for user &quot; + user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3088 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3089 +                // Fail if we don&#x27;t have any apps</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3090 +                if (apps == null || apps.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3091 +                    return;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3092 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3093 +                // Sort the applications by name</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3094 +                final long sortTime = DEBUG_LOADERS ? SystemClock.uptimeMillis() : 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3095 +                Collections.sort(apps,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3096 +                        new LauncherModel.ShortcutNameComparator(mLabelCache));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3097 +                if (DEBUG_LOADERS) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3098 +                    Log.d(TAG, &quot;sort took &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3099 +                            + (SystemClock.uptimeMillis()-sortTime) + &quot;ms&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3100 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3101 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3102 +                // Create the ApplicationInfos</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3103 +                for (int i = 0; i &lt; apps.size(); i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3104 +                    LauncherActivityInfoCompat app = apps.get(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3105 +                    // This builds the icon bitmaps.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3106 +                    mBgAllAppsList.add(new AppInfo(mContext, app, user, mIconCache, mLabelCache));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3107 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3108 +            }</span>
3109              // Huh? Shouldn&#x27;t this be inside the Runnable below?
3110              final ArrayList&lt;AppInfo&gt; added = mBgAllAppsList.added;
3111              mBgAllAppsList.added = new ArrayList&lt;AppInfo&gt;();
3112  
3113              // Post callback on main thread
3114              mHandler.post(new Runnable() {
3115                  public void run() {
3116                      final long bindTime = SystemClock.uptimeMillis();
3117                      final Callbacks callbacks = tryGetCallbacks(oldCallbacks);
3118                      if (callbacks != null) {
3119                          callbacks.bindAllApplications(added);
3120                          if (DEBUG_LOADERS) {
3121                              Log.d(TAG, &quot;bound &quot; + added.size() + &quot; apps in &quot;
3122                                  + (SystemClock.uptimeMillis() - bindTime) + &quot;ms&quot;);
3123                          }
3124                      } else {
3125                          Log.i(TAG, &quot;not binding apps: no Launcher activity&quot;);
3126                      }
3127                  }
3128              });
3129  
3130              if (DEBUG_LOADERS) {
3131                  Log.d(TAG, &quot;Icons processed in &quot;
3132                          + (SystemClock.uptimeMillis() - loadTime) + &quot;ms&quot;);
3133              }
3134          }
3135  
3136          public void dumpState() {
3137              synchronized (sBgLock) {
3138                  Log.d(TAG, &quot;mLoaderTask.mContext=&quot; + mContext);
3139                  Log.d(TAG, &quot;mLoaderTask.mIsLaunching=&quot; + mIsLaunching);
3140                  Log.d(TAG, &quot;mLoaderTask.mStopped=&quot; + mStopped);
3141                  Log.d(TAG, &quot;mLoaderTask.mLoadAndBindStepFinished=&quot; + mLoadAndBindStepFinished);
3142                  Log.d(TAG, &quot;mItems size=&quot; + sBgWorkspaceItems.size());
3143              }
3144          }
3145      }
3146  
3147      void enqueuePackageUpdated(PackageUpdatedTask task) {
3148          sWorker.post(task);
3149      }
3150  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3151 +    private class AppsAvailabilityCheck extends BroadcastReceiver {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3152 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3153 +        @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3154 +        public void onReceive(Context context, Intent intent) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3155 +            synchronized (sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3156 +                final LauncherAppsCompat launcherApps = LauncherAppsCompat</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3157 +                        .getInstance(mApp.getContext());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3158 +                ArrayList&lt;String&gt; packagesRemoved;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3159 +                for (Entry&lt;UserHandleCompat, HashSet&lt;String&gt;&gt; entry : sPendingPackages.entrySet()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3160 +                    UserHandleCompat user = entry.getKey();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3161 +                    packagesRemoved = new ArrayList&lt;String&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3162 +                    for (String pkg : entry.getValue()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3163 +                        if (!launcherApps.isPackageEnabledForProfile(pkg, user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3164 +                            Launcher.addDumpLog(TAG, &quot;Package not found: &quot; + pkg, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3165 +                            packagesRemoved.add(pkg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3166 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3167 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3168 +                    if (!packagesRemoved.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3169 +                        enqueuePackageUpdated(new PackageUpdatedTask(PackageUpdatedTask.OP_REMOVE,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3170 +                                packagesRemoved.toArray(new String[packagesRemoved.size()]), user));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3171 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3172 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3173 +                sPendingPackages.clear();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3174 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3175 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3176 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3177 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3178 +    /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3179 +     * Workaround to re-check unrestored items, in-case they were installed but the Package-ADD</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3180 +     * runnable was missed by the launcher.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3181 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3182 +    public void recheckRestoredItems(final Context context) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3183 +        Runnable r = new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3184 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3185 +            @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3186 +            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3187 +                LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3188 +                HashSet&lt;String&gt; installedPackages = new HashSet&lt;String&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3189 +                UserHandleCompat user = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3190 +                synchronized(sBgLock) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3191 +                    for (ItemInfo info : sBgItemsIdMap.values()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3192 +                        if (info instanceof ShortcutInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3193 +                            ShortcutInfo si = (ShortcutInfo) info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3194 +                            if (si.isPromise() &amp;&amp; si.getTargetComponent() != null</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3195 +                                    &amp;&amp; launcherApps.isPackageEnabledForProfile(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3196 +                                            si.getTargetComponent().getPackageName(), user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3197 +                                installedPackages.add(si.getTargetComponent().getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3198 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3199 +                        } else if (info instanceof LauncherAppWidgetInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3200 +                            LauncherAppWidgetInfo widget = (LauncherAppWidgetInfo) info;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3201 +                            if (widget.hasRestoreFlag(LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3202 +                                    &amp;&amp; launcherApps.isPackageEnabledForProfile(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3203 +                                            widget.providerName.getPackageName(), user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3204 +                                installedPackages.add(widget.providerName.getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3205 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3206 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3207 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3208 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3209 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3210 +                if (!installedPackages.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3211 +                    final ArrayList&lt;AppInfo&gt; restoredApps = new ArrayList&lt;AppInfo&gt;();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3212 +                    for (String pkg : installedPackages) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3213 +                        for (LauncherActivityInfoCompat info : launcherApps.getActivityList(pkg, user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3214 +                            restoredApps.add(new AppInfo(context, info, user, mIconCache, null));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3215 +                        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3216 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3217 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3218 +                    final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3219 +                    if (!restoredApps.isEmpty()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3220 +                        mHandler.post(new Runnable() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3221 +                            public void run() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3222 +                                Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3223 +                                if (callbacks == cb &amp;&amp; cb != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3224 +                                    callbacks.bindAppsRestored(restoredApps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3225 +                                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3226 +                            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3227 +                        });</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3228 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3229 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3230 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3231 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3232 +        };</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3233 +        sWorker.post(r);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3234 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3235 +</span>
3236      private class PackageUpdatedTask implements Runnable {
3237          int mOp;
3238          String[] mPackages;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3239 +        UserHandleCompat mUser;</span>
3240  
3241          public static final int OP_NONE = 0;
3242          public static final int OP_ADD = 1;
3243          public static final int OP_UPDATE = 2;
3244          public static final int OP_REMOVE = 3; // uninstlled
3245          public static final int OP_UNAVAILABLE = 4; // external media unmounted
3246  
3247  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3248 -        public PackageUpdatedTask(int op, String[] packages) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3249 +        public PackageUpdatedTask(int op, String[] packages, UserHandleCompat user) {</span>
3250              mOp = op;
3251              mPackages = packages;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3252 +            mUser = user;</span>
3253          }
3254  
3255          public void run() {
3256              final Context context = mApp.getContext();
3257  
3258              final String[] packages = mPackages;
3259              final int N = packages.length;
3260              switch (mOp) {
3261                  case OP_ADD:
3262                      for (int i=0; i&lt;N; i++) {
3263                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.addPackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3264 -                        mBgAllAppsList.addPackage(context, packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3265 +                        mIconCache.remove(packages[i], mUser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3266 +                        mBgAllAppsList.addPackage(context, packages[i], mUser);</span>
3267                      }
3268                      break;
3269                  case OP_UPDATE:
3270                      for (int i=0; i&lt;N; i++) {
3271                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.updatePackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3272 -                        mBgAllAppsList.updatePackage(context, packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3273 +                        mBgAllAppsList.updatePackage(context, packages[i], mUser);</span>
3274                          WidgetPreviewLoader.removePackageFromDb(
3275                                  mApp.getWidgetPreviewCacheDb(), packages[i]);
3276                      }
3277                      break;
3278                  case OP_REMOVE:
3279                  case OP_UNAVAILABLE:
3280                      for (int i=0; i&lt;N; i++) {
3281                          if (DEBUG_LOADERS) Log.d(TAG, &quot;mAllAppsList.removePackage &quot; + packages[i]);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3282 -                        mBgAllAppsList.removePackage(packages[i]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3283 +                        mBgAllAppsList.removePackage(packages[i], mUser);</span>
3284                          WidgetPreviewLoader.removePackageFromDb(
3285                                  mApp.getWidgetPreviewCacheDb(), packages[i]);
3286                      }
3287                      break;
3288              }
3289  
3290              ArrayList&lt;AppInfo&gt; added = null;
3291              ArrayList&lt;AppInfo&gt; modified = null;
3292              final ArrayList&lt;AppInfo&gt; removedApps = new ArrayList&lt;AppInfo&gt;();
3293  
3294              if (mBgAllAppsList.added.size() &gt; 0) {
3295                  added = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.added);
3296                  mBgAllAppsList.added.clear();
3297              }
3298              if (mBgAllAppsList.modified.size() &gt; 0) {
3299                  modified = new ArrayList&lt;AppInfo&gt;(mBgAllAppsList.modified);
3300                  mBgAllAppsList.modified.clear();
3301              }
3302              if (mBgAllAppsList.removed.size() &gt; 0) {
3303                  removedApps.addAll(mBgAllAppsList.removed);
3304                  mBgAllAppsList.removed.clear();
3305              }
3306  
3307              final Callbacks callbacks = mCallbacks != null ? mCallbacks.get() : null;
3308              if (callbacks == null) {
3309                  Log.w(TAG, &quot;Nobody to tell about the new app.  Launcher is probably loading.&quot;);
3310                  return;
3311              }
3312  
3313              if (added != null) {
3314                  // Ensure that we add all the workspace applications to the db
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3315 -                Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3316 -                if (!LauncherAppState.isDisableAllApps()) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3317 -                    addAndBindAddedApps(context, new ArrayList&lt;ItemInfo&gt;(), cb, added);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3318 +                if (LauncherAppState.isDisableAllApps()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3319 +                    final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3320 +                    addAndBindAddedWorkspaceApps(context, addedInfos);</span>
3321                  } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3322 -                    final ArrayList&lt;ItemInfo&gt; addedInfos = new ArrayList&lt;ItemInfo&gt;(added);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3323 -                    addAndBindAddedApps(context, addedInfos, cb, added);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3324 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3325 -            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3326 +                    addAppsToAllApps(context, added);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3327 +                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3328 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3329 +</span>
3330              if (modified != null) {
3331                  final ArrayList&lt;AppInfo&gt; modifiedFinal = modified;
3332  
3333                  // Update the launcher db to reflect the changes
3334                  for (AppInfo a : modifiedFinal) {
3335                      ArrayList&lt;ItemInfo&gt; infos =
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3336 -                            getItemInfoForComponentName(a.componentName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3337 +                            getItemInfoForComponentName(a.componentName, mUser);</span>
3338                      for (ItemInfo i : infos) {
3339                          if (isShortcutInfoUpdateable(i)) {
3340                              ShortcutInfo info = (ShortcutInfo) i;
3341                              info.title = a.title.toString();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3342 +                            info.contentDescription = a.contentDescription;</span>
3343                              updateItemInDatabase(context, info);
3344                          }
3345                      }
3346                  }
3347  
3348                  mHandler.post(new Runnable() {
3349                      public void run() {
3350                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3351                          if (callbacks == cb &amp;&amp; cb != null) {
3352                              callbacks.bindAppsUpdated(modifiedFinal);
3353                          }
3354                      }
3355                  });
3356              }
3357  
3358              final ArrayList&lt;String&gt; removedPackageNames =
3359                      new ArrayList&lt;String&gt;();
3360              if (mOp == OP_REMOVE) {
3361                  // Mark all packages in the broadcast to be removed
3362                  removedPackageNames.addAll(Arrays.asList(packages));
3363              } else if (mOp == OP_UPDATE) {
3364                  // Mark disabled packages in the broadcast to be removed
3365                  final PackageManager pm = context.getPackageManager();
3366                  for (int i=0; i&lt;N; i++) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3367 -                    if (isPackageDisabled(pm, packages[i])) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3368 +                    if (isPackageDisabled(context, packages[i], mUser)) {</span>
3369                          removedPackageNames.add(packages[i]);
3370                      }
3371                  }
3372              }
3373              // Remove all the components associated with this package
3374              for (String pn : removedPackageNames) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3375 -                ArrayList&lt;ItemInfo&gt; infos = getItemInfoForPackageName(pn);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3376 -                for (ItemInfo i : infos) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3377 -                    deleteItemFromDatabase(context, i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3378 -                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3379 +                deletePackageFromDatabase(context, pn, mUser);</span>
3380              }
3381              // Remove all the specific components
3382              for (AppInfo a : removedApps) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3383 -                ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3384 -                for (ItemInfo i : infos) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3385 -                    deleteItemFromDatabase(context, i);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3386 -                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3387 +                ArrayList&lt;ItemInfo&gt; infos = getItemInfoForComponentName(a.componentName, mUser);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3388 +                deleteItemsFromDatabase(context, infos);</span>
3389              }
3390              if (!removedPackageNames.isEmpty() || !removedApps.isEmpty()) {
3391                  // Remove any queued items from the install queue
3392                  String spKey = LauncherAppState.getSharedPreferencesKey();
3393                  SharedPreferences sp =
3394                          context.getSharedPreferences(spKey, Context.MODE_PRIVATE);
3395                  InstallShortcutReceiver.removeFromInstallQueue(sp, removedPackageNames);
3396                  // Call the components-removed callback
3397                  mHandler.post(new Runnable() {
3398                      public void run() {
3399                          Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3400                          if (callbacks == cb &amp;&amp; cb != null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3401 -                            callbacks.bindComponentsRemoved(removedPackageNames, removedApps);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3402 +                            callbacks.bindComponentsRemoved(removedPackageNames, removedApps, mUser);</span>
3403                          }
3404                      }
3405                  });
3406              }
3407  
3408              final ArrayList&lt;Object&gt; widgetsAndShortcuts =
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3409 -                getSortedWidgetsAndShortcuts(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3410 +                    getSortedWidgetsAndShortcuts(context);</span>
3411              mHandler.post(new Runnable() {
3412                  @Override
3413                  public void run() {
3414                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3415                      if (callbacks == cb &amp;&amp; cb != null) {
3416                          callbacks.bindPackagesUpdated(widgetsAndShortcuts);
3417                      }
3418                  }
3419              });
3420  
3421              // Write all the logs to disk
3422              mHandler.post(new Runnable() {
3423                  public void run() {
3424                      Callbacks cb = mCallbacks != null ? mCallbacks.get() : null;
3425                      if (callbacks == cb &amp;&amp; cb != null) {
3426                          callbacks.dumpLogsToLocalData();
3427                      }
3428                  }
3429              });
3430          }
3431      }
3432  
3433      // Returns a list of ResolveInfos/AppWindowInfos in sorted order
3434      public static ArrayList&lt;Object&gt; getSortedWidgetsAndShortcuts(Context context) {
3435          PackageManager packageManager = context.getPackageManager();
3436          final ArrayList&lt;Object&gt; widgetsAndShortcuts = new ArrayList&lt;Object&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3437 -        widgetsAndShortcuts.addAll(AppWidgetManager.getInstance(context).getInstalledProviders());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3438 +        widgetsAndShortcuts.addAll(AppWidgetManagerCompat.getInstance(context).getAllProviders());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3439 +</span>
3440          Intent shortcutsIntent = new Intent(Intent.ACTION_CREATE_SHORTCUT);
3441          widgetsAndShortcuts.addAll(packageManager.queryIntentActivities(shortcutsIntent, 0));
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3442 -        Collections.sort(widgetsAndShortcuts,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3443 -            new LauncherModel.WidgetAndShortcutNameComparator(packageManager));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3444 +        Collections.sort(widgetsAndShortcuts, new WidgetAndShortcutNameComparator(context));</span>
3445          return widgetsAndShortcuts;
3446      }
3447  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3448 -    private static boolean isPackageDisabled(PackageManager pm, String packageName) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3449 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3450 -            PackageInfo pi = pm.getPackageInfo(packageName, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3451 -            return !pi.applicationInfo.enabled;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3452 -        } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3453 -            // Fall through</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3454 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3455 -        return false;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3456 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3457 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3458 -    public static boolean isValidPackageComponent(PackageManager pm, ComponentName cn) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3459 +    private static boolean isPackageDisabled(Context context, String packageName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3460 +            UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3461 +        final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3462 +        return !launcherApps.isPackageEnabledForProfile(packageName, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3463 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3464 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3465 +    public static boolean isValidPackageActivity(Context context, ComponentName cn,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3466 +            UserHandleCompat user) {</span>
3467          if (cn == null) {
3468              return false;
3469          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3470 -        if (isPackageDisabled(pm, cn.getPackageName())) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3471 +        final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3472 +        if (!launcherApps.isPackageEnabledForProfile(cn.getPackageName(), user)) {</span>
3473              return false;
3474          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3475 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3476 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3477 -            // Check the activity</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3478 -            PackageInfo pi = pm.getPackageInfo(cn.getPackageName(), 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3479 -            return (pm.getActivityInfo(cn, 0) != null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3480 -        } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3481 +        return launcherApps.isActivityEnabledForProfile(cn, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3482 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3483 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3484 +    public static boolean isValidPackage(Context context, String packageName,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3485 +            UserHandleCompat user) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3486 +        if (packageName == null) {</span>
3487              return false;
3488          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3489 +        final LauncherAppsCompat launcherApps = LauncherAppsCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3490 +        return launcherApps.isPackageEnabledForProfile(packageName, user);</span>
3491      }
3492  
3493      /**
3494       * Make an ShortcutInfo object for a restored application or shortcut item that points
3495       * to a package that is not yet installed on the system.
3496       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3497 -    public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3498 +    public ShortcutInfo getRestoredItemInfo(Cursor cursor, int titleIndex, Intent intent,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3499 +            int promiseType) {</span>
3500          final ShortcutInfo info = new ShortcutInfo();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3501 -        info.usingFallbackIcon = true;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3502 -        info.setIcon(getFallbackIcon());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3503 -        if (cursor != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3504 -            info.title =  cursor.getString(titleIndex);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3505 +        info.user = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3506 +        mIconCache.getTitleAndIcon(info, intent, info.user, true);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3507 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3508 +        if ((promiseType &amp; ShortcutInfo.FLAG_RESTORED_ICON) != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3509 +            String title = (cursor != null) ? cursor.getString(titleIndex) : null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3510 +            if (!TextUtils.isEmpty(title)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3511 +                info.title = title;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3512 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3513 +            info.status = ShortcutInfo.FLAG_RESTORED_ICON;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3514 +        } else if  ((promiseType &amp; ShortcutInfo.FLAG_AUTOINTALL_ICON) != 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3515 +            if (TextUtils.isEmpty(info.title)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3516 +                info.title = (cursor != null) ? cursor.getString(titleIndex) : &quot;&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3517 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3518 +            info.status = ShortcutInfo.FLAG_AUTOINTALL_ICON;</span>
3519          } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3520 -            info.title = &quot;&quot;;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3521 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3522 +            throw new InvalidParameterException(&quot;Invalid restoreType &quot; + promiseType);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3523 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3524 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3525 +        info.contentDescription = mUserManager.getBadgedLabelForUser(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3526 +                info.title.toString(), info.user);</span>
3527          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3528 +        info.promisedIntent = intent;</span>
3529          return info;
3530      }
3531  
3532      /**
3533       * Make an Intent object for a restored application or shortcut item that points
3534       * to the market page for the item.
3535       */
3536      private Intent getRestoredItemIntent(Cursor c, Context context, Intent intent) {
3537          ComponentName componentName = intent.getComponent();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3538 -        Intent marketIntent = new Intent(Intent.ACTION_VIEW);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3539 -        Uri marketUri = new Uri.Builder()</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3540 +        return getMarketIntent(componentName.getPackageName());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3541 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3542 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3543 +    static Intent getMarketIntent(String packageName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3544 +        return new Intent(Intent.ACTION_VIEW)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3545 +            .setData(new Uri.Builder()</span>
3546                  .scheme(&quot;market&quot;)
3547                  .authority(&quot;details&quot;)
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3548 -                .appendQueryParameter(&quot;id&quot;, componentName.getPackageName())</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3549 -                .build();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3550 -        Log.d(TAG, &quot;manufactured intent uri: &quot; + marketUri.toString());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3551 -        marketIntent.setData(marketUri);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3552 -        return marketIntent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3553 +                .appendQueryParameter(&quot;id&quot;, packageName)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3554 +                .build());</span>
3555      }
3556  
3557      /**
3558       * This is called from the code that adds shortcuts from the intent receiver.  This
3559       * doesn&#x27;t have a Cursor, but
3560       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3561 -    public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3562 -        return getShortcutInfo(manager, intent, context, null, -1, -1, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3563 +    public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3564 +            UserHandleCompat user, Context context) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3565 +        return getShortcutInfo(manager, intent, user, context, null, -1, -1, null, false);</span>
3566      }
3567  
3568      /**
3569       * Make an ShortcutInfo object for a shortcut that is an application.
3570       *
3571       * If c is not null, then it will be used to fill in missing data like the title and icon.
3572       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3573 -    public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent, Context context,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3574 -            Cursor c, int iconIndex, int titleIndex, HashMap&lt;Object, CharSequence&gt; labelCache) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3575 +    public ShortcutInfo getShortcutInfo(PackageManager manager, Intent intent,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3576 +            UserHandleCompat user, Context context, Cursor c, int iconIndex, int titleIndex,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3577 +            HashMap&lt;Object, CharSequence&gt; labelCache, boolean allowMissingTarget) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3578 +        if (user == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3579 +            Log.d(TAG, &quot;Null user found in getShortcutInfo&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3580 +            return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3581 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3582 +</span>
3583          ComponentName componentName = intent.getComponent();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3584 +        if (componentName == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3585 +            Log.d(TAG, &quot;Missing component found in getShortcutInfo: &quot; + componentName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3586 +            return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3587 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3588 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3589 +        Intent newIntent = new Intent(intent.getAction(), null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3590 +        newIntent.addCategory(Intent.CATEGORY_LAUNCHER);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3591 +        newIntent.setComponent(componentName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3592 +        LauncherActivityInfoCompat lai = mLauncherApps.resolveActivity(newIntent, user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3593 +        if ((lai == null) &amp;&amp; !allowMissingTarget) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3594 +            Log.d(TAG, &quot;Missing activity found in getShortcutInfo: &quot; + componentName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3595 +            return null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3596 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3597 +</span>
3598          final ShortcutInfo info = new ShortcutInfo();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3599 -        if (componentName != null &amp;&amp; !isValidPackageComponent(manager, componentName)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3600 -            Log.d(TAG, &quot;Invalid package found in getShortcutInfo: &quot; + componentName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3601 -            return null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3602 -        } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3603 -            try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3604 -                PackageInfo pi = manager.getPackageInfo(componentName.getPackageName(), 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3605 -                info.initFlagsAndFirstInstallTime(pi);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3606 -            } catch (NameNotFoundException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3607 -                Log.d(TAG, &quot;getPackInfo failed for package &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3608 -                        componentName.getPackageName());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3609 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3610 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3611 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3612 -        // TODO: See if the PackageManager knows about this case.  If it doesn&#x27;t</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3613 -        // then return null &amp; delete this.</span>
3614  
3615          // the resource -- This may implicitly give us back the fallback icon,
3616          // but don&#x27;t worry about that.  All we&#x27;re doing with usingFallbackIcon is
3617          // to avoid saving lots of copies of that in the database, and most apps
3618          // have icons anyway.
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3619 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3620 -        // Attempt to use queryIntentActivities to get the ResolveInfo (with IntentFilter info) and</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3621 -        // if that fails, or is ambiguious, fallback to the standard way of getting the resolve info</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3622 -        // via resolveActivity().</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3623 -        Bitmap icon = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3624 -        ResolveInfo resolveInfo = null;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3625 -        ComponentName oldComponent = intent.getComponent();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3626 -        Intent newIntent = new Intent(intent.getAction(), null);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3627 -        newIntent.addCategory(Intent.CATEGORY_LAUNCHER);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3628 -        newIntent.setPackage(oldComponent.getPackageName());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3629 -        List&lt;ResolveInfo&gt; infos = manager.queryIntentActivities(newIntent, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3630 -        for (ResolveInfo i : infos) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3631 -            ComponentName cn = new ComponentName(i.activityInfo.packageName,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3632 -                    i.activityInfo.name);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3633 -            if (cn.equals(oldComponent)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3634 -                resolveInfo = i;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3635 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3636 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3637 -        if (resolveInfo == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3638 -            resolveInfo = manager.resolveActivity(intent, 0);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3639 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3640 -        if (resolveInfo != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3641 -            icon = mIconCache.getIcon(componentName, resolveInfo, labelCache);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3642 -        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3643 +        Bitmap icon = mIconCache.getIcon(componentName, lai, labelCache);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3644 +</span>
3645          // the db
3646          if (icon == null) {
3647              if (c != null) {
3648                  icon = getIconFromCursor(c, iconIndex, context);
3649              }
3650          }
3651          // the fallback icon
3652          if (icon == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3653 -            icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3654 +            icon = mIconCache.getDefaultIcon(user);</span>
3655              info.usingFallbackIcon = true;
3656          }
3657          info.setIcon(icon);
3658  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3659 +        // From the cache.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3660 +        if (labelCache != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3661 +            info.title = labelCache.get(componentName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3662 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3663 +</span>
3664          // from the resource
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3665 -        if (resolveInfo != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3666 -            ComponentName key = LauncherModel.getComponentNameFromResolveInfo(resolveInfo);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3667 -            if (labelCache != null &amp;&amp; labelCache.containsKey(key)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3668 -                info.title = labelCache.get(key);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3669 -            } else {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3670 -                info.title = resolveInfo.activityInfo.loadLabel(manager);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3671 -                if (labelCache != null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3672 -                    labelCache.put(key, info.title);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3673 -                }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3674 +        if (info.title == null &amp;&amp; lai != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3675 +            info.title = lai.getLabel();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3676 +            if (labelCache != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3677 +                labelCache.put(componentName, info.title);</span>
3678              }
3679          }
3680          // from the db
3681          if (info.title == null) {
3682              if (c != null) {
3683                  info.title =  c.getString(titleIndex);
3684              }
3685          }
3686          // fall back to the class name of the activity
3687          if (info.title == null) {
3688              info.title = componentName.getClassName();
3689          }
3690          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_APPLICATION;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3691 +        info.user = user;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3692 +        info.contentDescription = mUserManager.getBadgedLabelForUser(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3693 +                info.title.toString(), info.user);</span>
3694          return info;
3695      }
3696  
3697      static ArrayList&lt;ItemInfo&gt; filterItemInfos(Collection&lt;ItemInfo&gt; infos,
3698              ItemInfoFilter f) {
3699          HashSet&lt;ItemInfo&gt; filtered = new HashSet&lt;ItemInfo&gt;();
3700          for (ItemInfo i : infos) {
3701              if (i instanceof ShortcutInfo) {
3702                  ShortcutInfo info = (ShortcutInfo) i;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3703 -                ComponentName cn = info.intent.getComponent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3704 +                ComponentName cn = info.getTargetComponent();</span>
3705                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3706                      filtered.add(info);
3707                  }
3708              } else if (i instanceof FolderInfo) {
3709                  FolderInfo info = (FolderInfo) i;
3710                  for (ShortcutInfo s : info.contents) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3711 -                    ComponentName cn = s.intent.getComponent();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3712 +                    ComponentName cn = s.getTargetComponent();</span>
3713                      if (cn != null &amp;&amp; f.filterItem(info, s, cn)) {
3714                          filtered.add(s);
3715                      }
3716                  }
3717              } else if (i instanceof LauncherAppWidgetInfo) {
3718                  LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) i;
3719                  ComponentName cn = info.providerName;
3720                  if (cn != null &amp;&amp; f.filterItem(null, info, cn)) {
3721                      filtered.add(info);
3722                  }
3723              }
3724          }
3725          return new ArrayList&lt;ItemInfo&gt;(filtered);
3726      }
3727  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3728 -    private ArrayList&lt;ItemInfo&gt; getItemInfoForPackageName(final String pn) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3729 +    private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3730 +            final UserHandleCompat user) {</span>
3731          ItemInfoFilter filter  = new ItemInfoFilter() {
3732              @Override
3733              public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3734 -                return cn.getPackageName().equals(pn);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3735 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3736 -        };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3737 -        return filterItemInfos(sBgItemsIdMap.values(), filter);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3738 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3739 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3740 -    private ArrayList&lt;ItemInfo&gt; getItemInfoForComponentName(final ComponentName cname) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3741 -        ItemInfoFilter filter  = new ItemInfoFilter() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3742 -            @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3743 -            public boolean filterItem(ItemInfo parent, ItemInfo info, ComponentName cn) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3744 -                return cn.equals(cname);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3745 +                if (info.user == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3746 +                    return cn.equals(cname);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3747 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3748 +                    return cn.equals(cname) &amp;&amp; info.user.equals(user);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3749 +                }</span>
3750              }
3751          };
3752          return filterItemInfos(sBgItemsIdMap.values(), filter);
3753      }
3754  
3755      public static boolean isShortcutInfoUpdateable(ItemInfo i) {
3756          if (i instanceof ShortcutInfo) {
3757              ShortcutInfo info = (ShortcutInfo) i;
3758              // We need to check for ACTION_MAIN otherwise getComponent() might
3759              // return null for some shortcuts (for instance, for shortcuts to
3760              // web pages.)
3761              Intent intent = info.intent;
3762              ComponentName name = intent.getComponent();
3763              if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION &amp;&amp;
3764                      Intent.ACTION_MAIN.equals(intent.getAction()) &amp;&amp; name != null) {
3765                  return true;
3766              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3767 +            // placeholder shortcuts get special treatment, let them through too.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3768 +            if (info.isPromise()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3769 +                return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3770 +            }</span>
3771          }
3772          return false;
3773      }
3774  
3775      /**
3776       * Make an ShortcutInfo object for a shortcut that isn&#x27;t an application.
3777       */
3778      private ShortcutInfo getShortcutInfo(Cursor c, Context context,
3779              int iconTypeIndex, int iconPackageIndex, int iconResourceIndex, int iconIndex,
3780              int titleIndex) {
3781  
3782          Bitmap icon = null;
3783          final ShortcutInfo info = new ShortcutInfo();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3784 +        // Non-app shortcuts are only supported for current user.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3785 +        info.user = UserHandleCompat.myUserHandle();</span>
3786          info.itemType = LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT;
3787  
3788          // TODO: If there&#x27;s an explicit component and we can&#x27;t install that, delete it.
3789  
3790          info.title = c.getString(titleIndex);
3791  
3792          int iconType = c.getInt(iconTypeIndex);
3793          switch (iconType) {
3794          case LauncherSettings.Favorites.ICON_TYPE_RESOURCE:
3795              String packageName = c.getString(iconPackageIndex);
3796              String resourceName = c.getString(iconResourceIndex);
3797              PackageManager packageManager = context.getPackageManager();
3798              info.customIcon = false;
3799              // the resource
3800              try {
3801                  Resources resources = packageManager.getResourcesForApplication(packageName);
3802                  if (resources != null) {
3803                      final int id = resources.getIdentifier(resourceName, null, null);
3804                      icon = Utilities.createIconBitmap(
3805                              mIconCache.getFullResIcon(resources, id), context);
3806                  }
3807              } catch (Exception e) {
3808                  // drop this.  we have other places to look for icons
3809              }
3810              // the db
3811              if (icon == null) {
3812                  icon = getIconFromCursor(c, iconIndex, context);
3813              }
3814              // the fallback icon
3815              if (icon == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3816 -                icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3817 +                icon = mIconCache.getDefaultIcon(info.user);</span>
3818                  info.usingFallbackIcon = true;
3819              }
3820              break;
3821          case LauncherSettings.Favorites.ICON_TYPE_BITMAP:
3822              icon = getIconFromCursor(c, iconIndex, context);
3823              if (icon == null) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3824 -                icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3825 +                icon = mIconCache.getDefaultIcon(info.user);</span>
3826                  info.customIcon = false;
3827                  info.usingFallbackIcon = true;
3828              } else {
3829                  info.customIcon = true;
3830              }
3831              break;
3832          default:
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3833 -            icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3834 +            icon = mIconCache.getDefaultIcon(info.user);</span>
3835              info.usingFallbackIcon = true;
3836              info.customIcon = false;
3837              break;
3838          }
3839          info.setIcon(icon);
3840          return info;
3841      }
3842  
3843      Bitmap getIconFromCursor(Cursor c, int iconIndex, Context context) {
3844          @SuppressWarnings(&quot;all&quot;) // suppress dead code warning
3845          final boolean debug = false;
3846          if (debug) {
3847              Log.d(TAG, &quot;getIconFromCursor app=&quot;
3848                      + c.getString(c.getColumnIndexOrThrow(LauncherSettings.Favorites.TITLE)));
3849          }
3850          byte[] data = c.getBlob(iconIndex);
3851          try {
3852              return Utilities.createIconBitmap(
3853                      BitmapFactory.decodeByteArray(data, 0, data.length), context);
3854          } catch (Exception e) {
3855              return null;
3856          }
3857      }
3858  
3859      ShortcutInfo addShortcut(Context context, Intent data, long container, int screen,
3860              int cellX, int cellY, boolean notify) {
3861          final ShortcutInfo info = infoFromShortcutIntent(context, data, null);
3862          if (info == null) {
3863              return null;
3864          }
3865          addItemToDatabase(context, info, container, screen, cellX, cellY, notify);
3866  
3867          return info;
3868      }
3869  
3870      /**
3871       * Attempts to find an AppWidgetProviderInfo that matches the given component.
3872       */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3873 -    AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3874 +    static AppWidgetProviderInfo findAppWidgetProviderInfoWithComponent(Context context,</span>
3875              ComponentName component) {
3876          List&lt;AppWidgetProviderInfo&gt; widgets =
3877              AppWidgetManager.getInstance(context).getInstalledProviders();
3878          for (AppWidgetProviderInfo info : widgets) {
3879              if (info.provider.equals(component)) {
3880                  return info;
3881              }
3882          }
3883          return null;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3884 -    }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3885 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3886 -    /**</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3887 -     * Returns a list of all the widgets that can handle configuration with a particular mimeType.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3888 -     */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3889 -    List&lt;WidgetMimeTypeHandlerData&gt; resolveWidgetsForMimeType(Context context, String mimeType) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3890 -        final PackageManager packageManager = context.getPackageManager();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3891 -        final List&lt;WidgetMimeTypeHandlerData&gt; supportedConfigurationActivities =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3892 -            new ArrayList&lt;WidgetMimeTypeHandlerData&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3893 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3894 -        final Intent supportsIntent =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3895 -            new Intent(InstallWidgetReceiver.ACTION_SUPPORTS_CLIPDATA_MIMETYPE);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3896 -        supportsIntent.setType(mimeType);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3897 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3898 -        // Create a set of widget configuration components that we can test against</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3899 -        final List&lt;AppWidgetProviderInfo&gt; widgets =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3900 -            AppWidgetManager.getInstance(context).getInstalledProviders();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3901 -        final HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; configurationComponentToWidget =</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3902 -            new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3903 -        for (AppWidgetProviderInfo info : widgets) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3904 -            configurationComponentToWidget.put(info.configure, info);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3905 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3906 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3907 -        // Run through each of the intents that can handle this type of clip data, and cross</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3908 -        // reference them with the components that are actual configuration components</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3909 -        final List&lt;ResolveInfo&gt; activities = packageManager.queryIntentActivities(supportsIntent,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3910 -                PackageManager.MATCH_DEFAULT_ONLY);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3911 -        for (ResolveInfo info : activities) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3912 -            final ActivityInfo activityInfo = info.activityInfo;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3913 -            final ComponentName infoComponent = new ComponentName(activityInfo.packageName,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3914 -                    activityInfo.name);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3915 -            if (configurationComponentToWidget.containsKey(infoComponent)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3916 -                supportedConfigurationActivities.add(</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3917 -                        new InstallWidgetReceiver.WidgetMimeTypeHandlerData(info,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3918 -                                configurationComponentToWidget.get(infoComponent)));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3919 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3920 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3921 -        return supportedConfigurationActivities;</span>
3922      }
3923  
3924      ShortcutInfo infoFromShortcutIntent(Context context, Intent data, Bitmap fallbackIcon) {
3925          Intent intent = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_INTENT);
3926          String name = data.getStringExtra(Intent.EXTRA_SHORTCUT_NAME);
3927          Parcelable bitmap = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON);
3928  
3929          if (intent == null) {
3930              // If the intent is null, we can&#x27;t construct a valid ShortcutInfo, so we return null
3931              Log.e(TAG, &quot;Can&#x27;t construct ShorcutInfo with null intent&quot;);
3932              return null;
3933          }
3934  
3935          Bitmap icon = null;
3936          boolean customIcon = false;
3937          ShortcutIconResource iconResource = null;
3938  
3939          if (bitmap != null &amp;&amp; bitmap instanceof Bitmap) {
3940              icon = Utilities.createIconBitmap(new FastBitmapDrawable((Bitmap)bitmap), context);
3941              customIcon = true;
3942          } else {
3943              Parcelable extra = data.getParcelableExtra(Intent.EXTRA_SHORTCUT_ICON_RESOURCE);
3944              if (extra != null &amp;&amp; extra instanceof ShortcutIconResource) {
3945                  try {
3946                      iconResource = (ShortcutIconResource) extra;
3947                      final PackageManager packageManager = context.getPackageManager();
3948                      Resources resources = packageManager.getResourcesForApplication(
3949                              iconResource.packageName);
3950                      final int id = resources.getIdentifier(iconResource.resourceName, null, null);
3951                      icon = Utilities.createIconBitmap(
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3952 -                            mIconCache.getFullResIcon(resources, id), context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3953 +                            mIconCache.getFullResIcon(resources, id),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3954 +                            context);</span>
3955                  } catch (Exception e) {
3956                      Log.w(TAG, &quot;Could not load shortcut icon: &quot; + extra);
3957                  }
3958              }
3959          }
3960  
3961          final ShortcutInfo info = new ShortcutInfo();
3962  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3963 +        // Only support intents for current user for now. Intents sent from other</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3964 +        // users wouldn&#x27;t get here without intent forwarding anyway.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3965 +        info.user = UserHandleCompat.myUserHandle();</span>
3966          if (icon == null) {
3967              if (fallbackIcon != null) {
3968                  icon = fallbackIcon;
3969              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">3970 -                icon = getFallbackIcon();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3971 +                icon = mIconCache.getDefaultIcon(info.user);</span>
3972                  info.usingFallbackIcon = true;
3973              }
3974          }
3975          info.setIcon(icon);
3976  
3977          info.title = name;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3978 +        info.contentDescription = mUserManager.getBadgedLabelForUser(</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">3979 +                info.title.toString(), info.user);</span>
3980          info.intent = intent;
3981          info.customIcon = customIcon;
3982          info.iconResource = iconResource;
3983  
3984          return info;
3985      }
3986  
3987      boolean queueIconToBeChecked(HashMap&lt;Object, byte[]&gt; cache, ShortcutInfo info, Cursor c,
3988              int iconIndex) {
3989          // If apps can&#x27;t be on SD, don&#x27;t even bother.
3990          if (!mAppsCanBeOnRemoveableStorage) {
3991              return false;
3992          }
3993          // If this icon doesn&#x27;t have a custom icon, check to see
3994          // what&#x27;s stored in the DB, and if it doesn&#x27;t match what
3995          // we&#x27;re going to show, store what we are going to show back
3996          // into the DB.  We do this so when we&#x27;re loading, if the
3997          // package manager can&#x27;t find an icon (for example because
3998          // the app is on SD) then we can use that instead.
3999          if (!info.customIcon &amp;&amp; !info.usingFallbackIcon) {
4000              cache.put(info, c.getBlob(iconIndex));
4001              return true;
4002          }
4003          return false;
4004      }
4005      void updateSavedIcon(Context context, ShortcutInfo info, byte[] data) {
4006          boolean needSave = false;
4007          try {
4008              if (data != null) {
4009                  Bitmap saved = BitmapFactory.decodeByteArray(data, 0, data.length);
4010                  Bitmap loaded = info.getIcon(mIconCache);
4011                  needSave = !saved.sameAs(loaded);
4012              } else {
4013                  needSave = true;
4014              }
4015          } catch (Exception e) {
4016              needSave = true;
4017          }
4018          if (needSave) {
4019              Log.d(TAG, &quot;going to save icon bitmap for info=&quot; + info);
4020              // This is slower than is ideal, but this only happens once
4021              // or when the app is updated with a new icon.
4022              updateItemInDatabase(context, info);
4023          }
4024      }
4025  
4026      /**
4027       * Return an existing FolderInfo object if we have encountered this ID previously,
4028       * or make a new one.
4029       */
4030      private static FolderInfo findOrMakeFolder(HashMap&lt;Long, FolderInfo&gt; folders, long id) {
4031          // See if a placeholder was created for us already
4032          FolderInfo folderInfo = folders.get(id);
4033          if (folderInfo == null) {
4034              // No placeholder -- create a new instance
4035              folderInfo = new FolderInfo();
4036              folders.put(id, folderInfo);
4037          }
4038          return folderInfo;
4039      }
4040  
4041      public static final Comparator&lt;AppInfo&gt; getAppNameComparator() {
4042          final Collator collator = Collator.getInstance();
4043          return new Comparator&lt;AppInfo&gt;() {
4044              public final int compare(AppInfo a, AppInfo b) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4045 -                int result = collator.compare(a.title.toString().trim(),</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4046 -                        b.title.toString().trim());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4047 -                if (result == 0) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4048 -                    result = a.componentName.compareTo(b.componentName);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4049 -                }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4050 -                return result;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4051 +                if (a.user.equals(b.user)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4052 +                    int result = collator.compare(a.title.toString().trim(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4053 +                            b.title.toString().trim());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4054 +                    if (result == 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4055 +                        result = a.componentName.compareTo(b.componentName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4056 +                    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4057 +                    return result;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4058 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4059 +                    // TODO Need to figure out rules for sorting</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4060 +                    // profiles, this puts work second.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4061 +                    return a.user.toString().compareTo(b.user.toString());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4062 +                }</span>
4063              }
4064          };
4065      }
4066      public static final Comparator&lt;AppInfo&gt; APP_INSTALL_TIME_COMPARATOR
4067              = new Comparator&lt;AppInfo&gt;() {
4068          public final int compare(AppInfo a, AppInfo b) {
4069              if (a.firstInstallTime &lt; b.firstInstallTime) return 1;
4070              if (a.firstInstallTime &gt; b.firstInstallTime) return -1;
4071              return 0;
4072          }
4073      };
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4074 -    public static final Comparator&lt;AppWidgetProviderInfo&gt; getWidgetNameComparator() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4075 -        final Collator collator = Collator.getInstance();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4076 -        return new Comparator&lt;AppWidgetProviderInfo&gt;() {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4077 -            public final int compare(AppWidgetProviderInfo a, AppWidgetProviderInfo b) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4078 -                return collator.compare(a.label.toString().trim(), b.label.toString().trim());</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4079 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4080 -        };</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4081 -    }</span>
4082      static ComponentName getComponentNameFromResolveInfo(ResolveInfo info) {
4083          if (info.activityInfo != null) {
4084              return new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
4085          } else {
4086              return new ComponentName(info.serviceInfo.packageName, info.serviceInfo.name);
4087          }
4088      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4089 -    public static class ShortcutNameComparator implements Comparator&lt;ResolveInfo&gt; {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4090 +    public static class ShortcutNameComparator implements Comparator&lt;LauncherActivityInfoCompat&gt; {</span>
4091          private Collator mCollator;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4092 -        private PackageManager mPackageManager;</span>
4093          private HashMap&lt;Object, CharSequence&gt; mLabelCache;
4094          ShortcutNameComparator(PackageManager pm) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4095 -            mPackageManager = pm;</span>
4096              mLabelCache = new HashMap&lt;Object, CharSequence&gt;();
4097              mCollator = Collator.getInstance();
4098          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4099 -        ShortcutNameComparator(PackageManager pm, HashMap&lt;Object, CharSequence&gt; labelCache) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4100 -            mPackageManager = pm;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4101 +        ShortcutNameComparator(HashMap&lt;Object, CharSequence&gt; labelCache) {</span>
4102              mLabelCache = labelCache;
4103              mCollator = Collator.getInstance();
4104          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4105 -        public final int compare(ResolveInfo a, ResolveInfo b) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4106 -            CharSequence labelA, labelB;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4107 -            ComponentName keyA = LauncherModel.getComponentNameFromResolveInfo(a);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4108 -            ComponentName keyB = LauncherModel.getComponentNameFromResolveInfo(b);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4109 +        public final int compare(LauncherActivityInfoCompat a, LauncherActivityInfoCompat b) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4110 +            String labelA, labelB;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4111 +            ComponentName keyA = a.getComponentName();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4112 +            ComponentName keyB = b.getComponentName();</span>
4113              if (mLabelCache.containsKey(keyA)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4114 -                labelA = mLabelCache.get(keyA);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4115 +                labelA = mLabelCache.get(keyA).toString();</span>
4116              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4117 -                labelA = a.loadLabel(mPackageManager).toString().trim();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4118 +                labelA = a.getLabel().toString().trim();</span>
4119  
4120                  mLabelCache.put(keyA, labelA);
4121              }
4122              if (mLabelCache.containsKey(keyB)) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4123 -                labelB = mLabelCache.get(keyB);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4124 +                labelB = mLabelCache.get(keyB).toString();</span>
4125              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4126 -                labelB = b.loadLabel(mPackageManager).toString().trim();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4127 +                labelB = b.getLabel().toString().trim();</span>
4128  
4129                  mLabelCache.put(keyB, labelB);
4130              }
4131              return mCollator.compare(labelA, labelB);
4132          }
4133      };
4134      public static class WidgetAndShortcutNameComparator implements Comparator&lt;Object&gt; {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4135 -        private Collator mCollator;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4136 -        private PackageManager mPackageManager;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4137 -        private HashMap&lt;Object, String&gt; mLabelCache;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4138 -        WidgetAndShortcutNameComparator(PackageManager pm) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4139 -            mPackageManager = pm;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4140 +        private final AppWidgetManagerCompat mManager;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4141 +        private final PackageManager mPackageManager;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4142 +        private final HashMap&lt;Object, String&gt; mLabelCache;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4143 +        private final Collator mCollator;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4144 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4145 +        WidgetAndShortcutNameComparator(Context context) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4146 +            mManager = AppWidgetManagerCompat.getInstance(context);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4147 +            mPackageManager = context.getPackageManager();</span>
4148              mLabelCache = new HashMap&lt;Object, String&gt;();
4149              mCollator = Collator.getInstance();
4150          }
4151          public final int compare(Object a, Object b) {
4152              String labelA, labelB;
4153              if (mLabelCache.containsKey(a)) {
4154                  labelA = mLabelCache.get(a);
4155              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4156 -                labelA = (a instanceof AppWidgetProviderInfo) ?</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4157 -                    ((AppWidgetProviderInfo) a).label :</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4158 -                    ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4159 +                labelA = (a instanceof AppWidgetProviderInfo)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4160 +                        ? mManager.loadLabel((AppWidgetProviderInfo) a)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4161 +                        : ((ResolveInfo) a).loadLabel(mPackageManager).toString().trim();</span>
4162                  mLabelCache.put(a, labelA);
4163              }
4164              if (mLabelCache.containsKey(b)) {
4165                  labelB = mLabelCache.get(b);
4166              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4167 -                labelB = (b instanceof AppWidgetProviderInfo) ?</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4168 -                    ((AppWidgetProviderInfo) b).label :</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">4169 -                    ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4170 +                labelB = (b instanceof AppWidgetProviderInfo)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4171 +                        ? mManager.loadLabel((AppWidgetProviderInfo) b)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4172 +                        : ((ResolveInfo) b).loadLabel(mPackageManager).toString().trim();</span>
4173                  mLabelCache.put(b, labelB);
4174              }
4175              return mCollator.compare(labelA, labelB);
4176          }
4177      };
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4178 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4179 +    static boolean isValidProvider(AppWidgetProviderInfo provider) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4180 +        return (provider != null) &amp;&amp; (provider.provider != null)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4181 +                &amp;&amp; (provider.provider.getPackageName() != null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4182 +    }</span>
4183  
4184      public void dumpState() {
4185          Log.d(TAG, &quot;mCallbacks=&quot; + mCallbacks);
4186          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.data&quot;, mBgAllAppsList.data);
4187          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.added&quot;, mBgAllAppsList.added);
4188          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.removed&quot;, mBgAllAppsList.removed);
4189          AppInfo.dumpApplicationInfoList(TAG, &quot;mAllAppsList.modified&quot;, mBgAllAppsList.modified);
4190          if (mLoaderTask != null) {
4191              mLoaderTask.dumpState();
4192          } else {
4193              Log.d(TAG, &quot;mLoaderTask=null&quot;);
4194          }
4195      }
4196  }</pre></td>
                            <td><pre></pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            