<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>449 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one or more\n&#x27;
                           &#x27; * contributor license agreements.  See the NOTICE &#x27;
                           &#x27;file distributed with\n&#x27;
                           &#x27; * this work for additional information regarding &#x27;
                           &#x27;copyright ownership.\n&#x27;
                           &#x27; * The ASF licenses this file to You under the &#x27;
                           &#x27;Apache License, Version 2.0\n&#x27;
                           &#x27; * (the &quot;License&quot;); you may not use this file &#x27;
                           &#x27;except in compliance with\n&#x27;
                           &#x27; * the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *    http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package &#x27;
                           &#x27;com.dtstack.flink.sql.sink.kafka.serialization;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.EUpdateMode;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.serialization.SerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.Types;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.json.JsonRowSchemaConverter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ContainerNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;\n&#x27;
                           &#x27;import org.apache.flink.table.runtime.types.CRow;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.runtime.types.CRowTypeInfo;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.apache.flink.util.Preconditions;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.math.BigDecimal;\n&#x27;
                           &#x27;import java.math.BigInteger;\n&#x27;
                           &#x27;import java.sql.Time;\n&#x27;
                           &#x27;import java.sql.Timestamp;\n&#x27;
                           &#x27;import java.text.SimpleDateFormat;\n&#x27;
                           &#x27;import java.util.Objects;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Serialization schema that serializes an object &#x27;
                           &#x27;of Flink types into a JSON bytes.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Serializes the input Flink object into a &#x27;
                           &#x27;JSON string and\n&#x27;
                           &#x27; * converts it into &lt;code&gt;byte[]&lt;/code&gt;.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class JsonCRowSerializationSchema &#x27;
                           &#x27;implements SerializationSchema&lt;CRow&gt; {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final long serialVersionUID = &#x27;
                           &#x27;-2885556750743978636L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Type information describing the input &#x27;
                           &#x27;type. */\n&#x27;
                           &#x27;    private final TypeInformation&lt;CRow&gt; typeInfo;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Object mapper that is used to create &#x27;
                           &#x27;output JSON objects. */\n&#x27;
                           &#x27;    private final ObjectMapper mapper = new &#x27;
                           &#x27;ObjectMapper();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a time value (with UTC timezone, &#x27;
                           &#x27;without milliseconds). */\n&#x27;
                           &#x27;    private SimpleDateFormat timeFormat = new &#x27;
                           &#x27;SimpleDateFormat(&quot;HH:mm:ss\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a time value (with UTC &#x27;
                           &#x27;timezone). */\n&#x27;
                           &#x27;    private SimpleDateFormat timeFormatWithMillis &#x27;
                           &#x27;= new SimpleDateFormat(&quot;HH:mm:ss.SSS\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a timestamp value (with UTC &#x27;
                           &#x27;timezone). */\n&#x27;
                           &#x27;    private SimpleDateFormat timestampFormat = new &#x27;
                           &#x27;SimpleDateFormat(&quot;yyyy-MM-dd\&#x27;T\&#x27;HH:mm:ss.SSS\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Reusable object node. */\n&#x27;
                           &#x27;    private transient ObjectNode node;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final String retractKey = &quot;retract&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public JsonCRowSerializationSchema(String &#x27;
                           &#x27;jsonSchema, String updateMode) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;this(JsonRowSchemaConverter.convert(jsonSchema), &#x27;
                           &#x27;updateMode);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Creates a JSON serialization schema for the &#x27;
                           &#x27;given type information.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param typeInfo The field names of {@link &#x27;
                           &#x27;Row} are used to map to JSON properties.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public &#x27;
                           &#x27;JsonCRowSerializationSchema(TypeInformation&lt;CRow&gt; &#x27;
                           &#x27;typeInfo, String updateMode) {\n&#x27;
                           &#x27;        Preconditions.checkNotNull(typeInfo, &quot;Type &#x27;
                           &#x27;information&quot;);\n&#x27;
                           &#x27;        this.typeInfo = typeInfo;\n&#x27;
                           &#x27;        this.updateMode = updateMode;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public byte[] serialize(CRow crow) {\n&#x27;
                           &#x27;        Row row = crow.row();\n&#x27;
                           &#x27;        boolean change = crow.change();\n&#x27;
                           &#x27;        if (node == null) {\n&#x27;
                           &#x27;            node = mapper.createObjectNode();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        RowTypeInfo rowTypeInfo = ((CRowTypeInfo) &#x27;
                           &#x27;typeInfo).rowType();\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            convertRow(node, rowTypeInfo, row);\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(StringUtils.equalsIgnoreCase(updateMode, &#x27;
                           &#x27;EUpdateMode.UPSERT.name())) {\n&#x27;
                           &#x27;                node.put(retractKey, change);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;mapper.writeValueAsBytes(node);\n&#x27;
                           &#x27;        } catch (Throwable t) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;Could not &#x27;
                           &#x27;serialize row \&#x27;&quot; + row + &quot;\&#x27;. &quot; +\n&#x27;
                           &#x27;                    &quot;Make sure that the schema &#x27;
                           &#x27;matches the input.&quot;, t);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public boolean equals(Object o) {\n&#x27;
                           &#x27;        if (this == o) {\n&#x27;
                           &#x27;            return true;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (o == null || getClass() != &#x27;
                           &#x27;o.getClass()) {\n&#x27;
                           &#x27;            return false;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        final JsonCRowSerializationSchema that = &#x27;
                           &#x27;(JsonCRowSerializationSchema) o;\n&#x27;
                           &#x27;        return Objects.equals(typeInfo, &#x27;
                           &#x27;that.typeInfo);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public int hashCode() {\n&#x27;
                           &#x27;        return Objects.hash(typeInfo);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;--------------------------------------------------------------------------------------------\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private ObjectNode convertRow(ObjectNode &#x27;
                           &#x27;reuse, RowTypeInfo info, Row row) {\n&#x27;
                           &#x27;        if (reuse == null) {\n&#x27;
                           &#x27;            reuse = mapper.createObjectNode();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        final String[] fieldNames = &#x27;
                           &#x27;info.getFieldNames();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        final TypeInformation&lt;?&gt;[] fieldTypes = &#x27;
                           &#x27;info.getFieldTypes();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // validate the row\n&#x27;
                           &#x27;        if (row.getArity() != fieldNames.length) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalStateException(String.format(\n&#x27;
                           &#x27;                    &quot;Number of elements in the row &#x27;
                           &quot;&#x27;%s&#x27; is different from number of field names: &quot;
                           &#x27;%d&quot;, row, fieldNames.length));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (int i = 0; i &lt; fieldNames.length; &#x27;
                           &#x27;i++) {\n&#x27;
                           &#x27;            final String name = fieldNames[i];\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            final JsonNode fieldConverted = &#x27;
                           &#x27;convert(reuse, reuse.get(name), fieldTypes[i], &#x27;
                           &#x27;row.getField(i));\n&#x27;
                           &#x27;            reuse.set(name, fieldConverted);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return reuse;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private JsonNode convert(ContainerNode&lt;?&gt; &#x27;
                           &#x27;container, JsonNode reuse, TypeInformation&lt;?&gt; &#x27;
                           &#x27;info, Object object) {\n&#x27;
                           &#x27;        if (info.equals(Types.VOID) || object == &#x27;
                           &#x27;null) {\n&#x27;
                           &#x27;            return container.nullNode();\n&#x27;
                           &#x27;        } else if (info.equals(Types.BOOLEAN)) {\n&#x27;
                           &#x27;            return container.booleanNode((Boolean) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else if (info.equals(Types.STRING)) {\n&#x27;
                           &#x27;            return container.textNode((String) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else if (info.equals(Types.BIG_DEC)) {\n&#x27;
                           &#x27;            // convert decimal if necessary\n&#x27;
                           &#x27;            if (object instanceof BigDecimal) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.numberNode((BigDecimal) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.numberNode(BigDecimal.valueOf(((Number) &#x27;
                           &#x27;object).doubleValue()));\n&#x27;
                           &#x27;        } else if (info.equals(Types.BIG_INT)) {\n&#x27;
                           &#x27;            // convert integer if necessary\n&#x27;
                           &#x27;            if (object instanceof BigInteger) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.numberNode((BigInteger) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.numberNode(BigInteger.valueOf(((Number) &#x27;
                           &#x27;object).longValue()));\n&#x27;
                           &#x27;        } else if (info.equals(Types.SQL_DATE)) {\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(object.toString());\n&#x27;
                           &#x27;        } else if (info.equals(Types.SQL_TIME)) {\n&#x27;
                           &#x27;            final Time time = (Time) object;\n&#x27;
                           &#x27;            // strip milliseconds if possible\n&#x27;
                           &#x27;            if (time.getTime() % 1000 &gt; 0) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.textNode(timeFormatWithMillis.format(time));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(timeFormat.format(time));\n&#x27;
                           &#x27;        } else if &#x27;
                           &#x27;(info.equals(Types.SQL_TIMESTAMP)) {\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(timestampFormat.format((Timestamp) &#x27;
                           &#x27;object));\n&#x27;
                           &#x27;        } else if (info instanceof RowTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ObjectNode) {\n&#x27;
                           &#x27;                return convertRow((ObjectNode) &#x27;
                           &#x27;reuse, (RowTypeInfo) info, (Row) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertRow(null, &#x27;
                           &#x27;(RowTypeInfo) info, (Row) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;ObjectArrayTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ArrayNode) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;convertObjectArray((ArrayNode) reuse, &#x27;
                           &#x27;((ObjectArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertObjectArray(null, &#x27;
                           &#x27;((ObjectArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;BasicArrayTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ArrayNode) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;convertObjectArray((ArrayNode) reuse, &#x27;
                           &#x27;((BasicArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertObjectArray(null, &#x27;
                           &#x27;((BasicArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;PrimitiveArrayTypeInfo &amp;&amp; &#x27;
                           &#x27;((PrimitiveArrayTypeInfo) info).getComponentType() &#x27;
                           &#x27;== Types.BYTE) {\n&#x27;
                           &#x27;            return container.binaryNode((byte[]) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            // for types that were specified &#x27;
                           &#x27;without JSON schema\n&#x27;
                           &#x27;            // e.g. POJOs\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;mapper.valueToTree(object);\n&#x27;
                           &#x27;            } catch (IllegalArgumentException e) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                throw new &#x27;
                           &#x27;IllegalStateException(&quot;Unsupported type &#x27;
                           &#x27;information \&#x27;&quot; + info + &quot;\&#x27; for object: &quot; + &#x27;
                           &#x27;object, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private ArrayNode convertObjectArray(ArrayNode &#x27;
                           &#x27;reuse, TypeInformation&lt;?&gt; info, Object[] array) {\n&#x27;
                           &#x27;        if (reuse == null) {\n&#x27;
                           &#x27;            reuse = mapper.createArrayNode();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            reuse.removeAll();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (Object object : array) {\n&#x27;
                           &#x27;            reuse.add(convert(reuse, null, info, &#x27;
                           &#x27;object));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return reuse;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one or more\n&#x27;
                           &#x27; * contributor license agreements.  See the NOTICE &#x27;
                           &#x27;file distributed with\n&#x27;
                           &#x27; * this work for additional information regarding &#x27;
                           &#x27;copyright ownership.\n&#x27;
                           &#x27; * The ASF licenses this file to You under the &#x27;
                           &#x27;Apache License, Version 2.0\n&#x27;
                           &#x27; * (the &quot;License&quot;); you may not use this file &#x27;
                           &#x27;except in compliance with\n&#x27;
                           &#x27; * the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *    http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package &#x27;
                           &#x27;com.dtstack.flink.sql.sink.kafka.serialization;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.EUpdateMode;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.serialization.SerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.Types;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.json.JsonRowSchemaConverter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ContainerNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;\n&#x27;
                           &#x27;import org.apache.flink.table.runtime.types.CRow;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.runtime.types.CRowTypeInfo;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.apache.flink.util.Preconditions;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.math.BigDecimal;\n&#x27;
                           &#x27;import java.math.BigInteger;\n&#x27;
                           &#x27;import java.sql.Time;\n&#x27;
                           &#x27;import java.sql.Timestamp;\n&#x27;
                           &#x27;import java.text.SimpleDateFormat;\n&#x27;
                           &#x27;import java.util.Objects;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Serialization schema that serializes an object &#x27;
                           &#x27;of Flink types into a JSON bytes.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Serializes the input Flink object into a &#x27;
                           &#x27;JSON string and\n&#x27;
                           &#x27; * converts it into &lt;code&gt;byte[]&lt;/code&gt;.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class JsonCRowSerializationSchema &#x27;
                           &#x27;implements SerializationSchema&lt;CRow&gt; {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final long serialVersionUID = &#x27;
                           &#x27;-2885556750743978636L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Type information describing the input &#x27;
                           &#x27;type. */\n&#x27;
                           &#x27;    private final TypeInformation&lt;CRow&gt; typeInfo;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Object mapper that is used to create &#x27;
                           &#x27;output JSON objects. */\n&#x27;
                           &#x27;    private final ObjectMapper mapper = new &#x27;
                           &#x27;ObjectMapper();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a time value (with UTC timezone, &#x27;
                           &#x27;without milliseconds). */\n&#x27;
                           &#x27;    private SimpleDateFormat timeFormat = new &#x27;
                           &#x27;SimpleDateFormat(&quot;HH:mm:ss\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a time value (with UTC &#x27;
                           &#x27;timezone). */\n&#x27;
                           &#x27;    private SimpleDateFormat timeFormatWithMillis &#x27;
                           &#x27;= new SimpleDateFormat(&quot;HH:mm:ss.SSS\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a timestamp value (with UTC &#x27;
                           &#x27;timezone). */\n&#x27;
                           &#x27;    private SimpleDateFormat timestampFormat = new &#x27;
                           &#x27;SimpleDateFormat(&quot;yyyy-MM-dd\&#x27;T\&#x27;HH:mm:ss.SSS\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Reusable object node. */\n&#x27;
                           &#x27;    private transient ObjectNode node;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final String retractKey = &quot;retract&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public JsonCRowSerializationSchema(String &#x27;
                           &#x27;jsonSchema, String updateMode) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;this(JsonRowSchemaConverter.convert(jsonSchema), &#x27;
                           &#x27;updateMode);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Creates a JSON serialization schema for the &#x27;
                           &#x27;given type information.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param typeInfo The field names of {@link &#x27;
                           &#x27;Row} are used to map to JSON properties.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public &#x27;
                           &#x27;JsonCRowSerializationSchema(TypeInformation&lt;CRow&gt; &#x27;
                           &#x27;typeInfo, String updateMode) {\n&#x27;
                           &#x27;        Preconditions.checkNotNull(typeInfo, &quot;Type &#x27;
                           &#x27;information&quot;);\n&#x27;
                           &#x27;        this.typeInfo = typeInfo;\n&#x27;
                           &#x27;        this.updateMode = updateMode;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public byte[] serialize(CRow crow) {\n&#x27;
                           &#x27;        Row row = crow.row();\n&#x27;
                           &#x27;        boolean change = crow.change();\n&#x27;
                           &#x27;        if (node == null) {\n&#x27;
                           &#x27;            node = mapper.createObjectNode();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        RowTypeInfo rowTypeInfo = ((CRowTypeInfo) &#x27;
                           &#x27;typeInfo).rowType();\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            convertRow(node, rowTypeInfo, row);\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(StringUtils.equalsIgnoreCase(updateMode, &#x27;
                           &#x27;EUpdateMode.UPSERT.name())) {\n&#x27;
                           &#x27;                node.put(retractKey, change);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;mapper.writeValueAsBytes(node);\n&#x27;
                           &#x27;        } catch (Throwable t) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;Could not &#x27;
                           &#x27;serialize row \&#x27;&quot; + row + &quot;\&#x27;. &quot; +\n&#x27;
                           &#x27;                    &quot;Make sure that the schema &#x27;
                           &#x27;matches the input.&quot;, t);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public boolean equals(Object o) {\n&#x27;
                           &#x27;        if (this == o) {\n&#x27;
                           &#x27;            return true;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (o == null || getClass() != &#x27;
                           &#x27;o.getClass()) {\n&#x27;
                           &#x27;            return false;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        final JsonCRowSerializationSchema that = &#x27;
                           &#x27;(JsonCRowSerializationSchema) o;\n&#x27;
                           &#x27;        return Objects.equals(typeInfo, &#x27;
                           &#x27;that.typeInfo);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public int hashCode() {\n&#x27;
                           &#x27;        return Objects.hash(typeInfo);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;--------------------------------------------------------------------------------------------\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private ObjectNode convertRow(ObjectNode &#x27;
                           &#x27;reuse, RowTypeInfo info, Row row) {\n&#x27;
                           &#x27;        if (reuse == null) {\n&#x27;
                           &#x27;            reuse = mapper.createObjectNode();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        final String[] fieldNames = &#x27;
                           &#x27;info.getFieldNames();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        final TypeInformation&lt;?&gt;[] fieldTypes = &#x27;
                           &#x27;info.getFieldTypes();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // validate the row\n&#x27;
                           &#x27;        if (row.getArity() != fieldNames.length) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalStateException(String.format(\n&#x27;
                           &#x27;                    &quot;Number of elements in the row &#x27;
                           &quot;&#x27;%s&#x27; is different from number of field names: &quot;
                           &#x27;%d&quot;, row, fieldNames.length));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (int i = 0; i &lt; fieldNames.length; &#x27;
                           &#x27;i++) {\n&#x27;
                           &#x27;            final String name = fieldNames[i];\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            final JsonNode fieldConverted = &#x27;
                           &#x27;convert(reuse, reuse.get(name), fieldTypes[i], &#x27;
                           &#x27;row.getField(i));\n&#x27;
                           &#x27;            reuse.set(name, fieldConverted);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return reuse;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private JsonNode convert(ContainerNode&lt;?&gt; &#x27;
                           &#x27;container, JsonNode reuse, TypeInformation&lt;?&gt; &#x27;
                           &#x27;info, Object object) {\n&#x27;
                           &#x27;        if (info.equals(Types.VOID) || object == &#x27;
                           &#x27;null) {\n&#x27;
                           &#x27;            return container.nullNode();\n&#x27;
                           &#x27;        } else if (info.equals(Types.BOOLEAN)) {\n&#x27;
                           &#x27;            return container.booleanNode((Boolean) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else if (info.equals(Types.STRING)) {\n&#x27;
                           &#x27;            return container.textNode((String) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else if (info.equals(Types.BIG_DEC)) {\n&#x27;
                           &#x27;            // convert decimal if necessary\n&#x27;
                           &#x27;            if (object instanceof BigDecimal) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.numberNode((BigDecimal) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.numberNode(BigDecimal.valueOf(((Number) &#x27;
                           &#x27;object).doubleValue()));\n&#x27;
                           &#x27;        } else if (info.equals(Types.BIG_INT)) {\n&#x27;
                           &#x27;            // convert integer if necessary\n&#x27;
                           &#x27;            if (object instanceof BigInteger) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.numberNode((BigInteger) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.numberNode(BigInteger.valueOf(((Number) &#x27;
                           &#x27;object).longValue()));\n&#x27;
                           &#x27;        } else if (info.equals(Types.SQL_DATE)) {\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(object.toString());\n&#x27;
                           &#x27;        } else if (info.equals(Types.SQL_TIME)) {\n&#x27;
                           &#x27;            final Time time = (Time) object;\n&#x27;
                           &#x27;            // strip milliseconds if possible\n&#x27;
                           &#x27;            if (time.getTime() % 1000 &gt; 0) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.textNode(timeFormatWithMillis.format(time));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(timeFormat.format(time));\n&#x27;
                           &#x27;        } else if &#x27;
                           &#x27;(info.equals(Types.SQL_TIMESTAMP)) {\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(timestampFormat.format((Timestamp) &#x27;
                           &#x27;object));\n&#x27;
                           &#x27;        } else if (info instanceof RowTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ObjectNode) {\n&#x27;
                           &#x27;                return convertRow((ObjectNode) &#x27;
                           &#x27;reuse, (RowTypeInfo) info, (Row) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertRow(null, &#x27;
                           &#x27;(RowTypeInfo) info, (Row) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;ObjectArrayTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ArrayNode) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;convertObjectArray((ArrayNode) reuse, &#x27;
                           &#x27;((ObjectArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertObjectArray(null, &#x27;
                           &#x27;((ObjectArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;BasicArrayTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ArrayNode) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;convertObjectArray((ArrayNode) reuse, &#x27;
                           &#x27;((BasicArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertObjectArray(null, &#x27;
                           &#x27;((BasicArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;PrimitiveArrayTypeInfo &amp;&amp; &#x27;
                           &#x27;((PrimitiveArrayTypeInfo) info).getComponentType() &#x27;
                           &#x27;== Types.BYTE) {\n&#x27;
                           &#x27;            return container.binaryNode((byte[]) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            // for types that were specified &#x27;
                           &#x27;without JSON schema\n&#x27;
                           &#x27;            // e.g. POJOs\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;mapper.valueToTree(object);\n&#x27;
                           &#x27;            } catch (IllegalArgumentException e) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                throw new &#x27;
                           &#x27;IllegalStateException(&quot;Unsupported type &#x27;
                           &#x27;information \&#x27;&quot; + info + &quot;\&#x27; for object: &quot; + &#x27;
                           &#x27;object, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private ArrayNode convertObjectArray(ArrayNode &#x27;
                           &#x27;reuse, TypeInformation&lt;?&gt; info, Object[] array) {\n&#x27;
                           &#x27;        if (reuse == null) {\n&#x27;
                           &#x27;            reuse = mapper.createArrayNode();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            reuse.removeAll();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (Object object : array) {\n&#x27;
                           &#x27;            reuse.add(convert(reuse, null, info, &#x27;
                           &#x27;object));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return reuse;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one or more\n&#x27;
                           &#x27; * contributor license agreements.  See the NOTICE &#x27;
                           &#x27;file distributed with\n&#x27;
                           &#x27; * this work for additional information regarding &#x27;
                           &#x27;copyright ownership.\n&#x27;
                           &#x27; * The ASF licenses this file to You under the &#x27;
                           &#x27;Apache License, Version 2.0\n&#x27;
                           &#x27; * (the &quot;License&quot;); you may not use this file &#x27;
                           &#x27;except in compliance with\n&#x27;
                           &#x27; * the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *    http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package &#x27;
                           &#x27;com.dtstack.flink.sql.sink.kafka.serialization;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.EUpdateMode;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.serialization.SerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.Types;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.json.JsonRowSchemaConverter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ContainerNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;\n&#x27;
                           &#x27;import org.apache.flink.table.runtime.types.CRow;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.runtime.types.CRowTypeInfo;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.apache.flink.util.Preconditions;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.math.BigDecimal;\n&#x27;
                           &#x27;import java.math.BigInteger;\n&#x27;
                           &#x27;import java.sql.Time;\n&#x27;
                           &#x27;import java.sql.Timestamp;\n&#x27;
                           &#x27;import java.text.SimpleDateFormat;\n&#x27;
                           &#x27;import java.util.Objects;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Serialization schema that serializes an object &#x27;
                           &#x27;of Flink types into a JSON bytes.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Serializes the input Flink object into a &#x27;
                           &#x27;JSON string and\n&#x27;
                           &#x27; * converts it into &lt;code&gt;byte[]&lt;/code&gt;.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class JsonCRowSerializationSchema &#x27;
                           &#x27;implements SerializationSchema&lt;CRow&gt; {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final long serialVersionUID = &#x27;
                           &#x27;-2885556750743978636L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Type information describing the input &#x27;
                           &#x27;type. */\n&#x27;
                           &#x27;    private final TypeInformation&lt;CRow&gt; typeInfo;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Object mapper that is used to create &#x27;
                           &#x27;output JSON objects. */\n&#x27;
                           &#x27;    private final ObjectMapper mapper = new &#x27;
                           &#x27;ObjectMapper();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a time value (with UTC timezone, &#x27;
                           &#x27;without milliseconds). */\n&#x27;
                           &#x27;    private SimpleDateFormat timeFormat = new &#x27;
                           &#x27;SimpleDateFormat(&quot;HH:mm:ss\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a time value (with UTC &#x27;
                           &#x27;timezone). */\n&#x27;
                           &#x27;    private SimpleDateFormat timeFormatWithMillis &#x27;
                           &#x27;= new SimpleDateFormat(&quot;HH:mm:ss.SSS\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a timestamp value (with UTC &#x27;
                           &#x27;timezone). */\n&#x27;
                           &#x27;    private SimpleDateFormat timestampFormat = new &#x27;
                           &#x27;SimpleDateFormat(&quot;yyyy-MM-dd\&#x27;T\&#x27;HH:mm:ss.SSS\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Reusable object node. */\n&#x27;
                           &#x27;    private transient ObjectNode node;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final String retractKey = &quot;retract&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public JsonCRowSerializationSchema(String &#x27;
                           &#x27;jsonSchema, String updateMode) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;this(JsonRowSchemaConverter.convert(jsonSchema), &#x27;
                           &#x27;updateMode);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Creates a JSON serialization schema for the &#x27;
                           &#x27;given type information.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param typeInfo The field names of {@link &#x27;
                           &#x27;Row} are used to map to JSON properties.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public &#x27;
                           &#x27;JsonCRowSerializationSchema(TypeInformation&lt;CRow&gt; &#x27;
                           &#x27;typeInfo, String updateMode) {\n&#x27;
                           &#x27;        Preconditions.checkNotNull(typeInfo, &quot;Type &#x27;
                           &#x27;information&quot;);\n&#x27;
                           &#x27;        this.typeInfo = typeInfo;\n&#x27;
                           &#x27;        this.updateMode = updateMode;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public byte[] serialize(CRow crow) {\n&#x27;
                           &#x27;        Row row = crow.row();\n&#x27;
                           &#x27;        boolean change = crow.change();\n&#x27;
                           &#x27;        if (node == null) {\n&#x27;
                           &#x27;            node = mapper.createObjectNode();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        RowTypeInfo rowTypeInfo = ((CRowTypeInfo) &#x27;
                           &#x27;typeInfo).rowType();\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            convertRow(node, rowTypeInfo, row);\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(StringUtils.equalsIgnoreCase(updateMode, &#x27;
                           &#x27;EUpdateMode.UPSERT.name())) {\n&#x27;
                           &#x27;                node.put(retractKey, change);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;mapper.writeValueAsBytes(node);\n&#x27;
                           &#x27;        } catch (Throwable t) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;Could not &#x27;
                           &#x27;serialize row \&#x27;&quot; + row + &quot;\&#x27;. &quot; +\n&#x27;
                           &#x27;                    &quot;Make sure that the schema &#x27;
                           &#x27;matches the input.&quot;, t);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public boolean equals(Object o) {\n&#x27;
                           &#x27;        if (this == o) {\n&#x27;
                           &#x27;            return true;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (o == null || getClass() != &#x27;
                           &#x27;o.getClass()) {\n&#x27;
                           &#x27;            return false;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        final JsonCRowSerializationSchema that = &#x27;
                           &#x27;(JsonCRowSerializationSchema) o;\n&#x27;
                           &#x27;        return Objects.equals(typeInfo, &#x27;
                           &#x27;that.typeInfo);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public int hashCode() {\n&#x27;
                           &#x27;        return Objects.hash(typeInfo);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;--------------------------------------------------------------------------------------------\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private ObjectNode convertRow(ObjectNode &#x27;
                           &#x27;reuse, RowTypeInfo info, Row row) {\n&#x27;
                           &#x27;        if (reuse == null) {\n&#x27;
                           &#x27;            reuse = mapper.createObjectNode();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        final String[] fieldNames = &#x27;
                           &#x27;info.getFieldNames();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        final TypeInformation&lt;?&gt;[] fieldTypes = &#x27;
                           &#x27;info.getFieldTypes();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // validate the row\n&#x27;
                           &#x27;        if (row.getArity() != fieldNames.length) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalStateException(String.format(\n&#x27;
                           &#x27;                    &quot;Number of elements in the row &#x27;
                           &quot;&#x27;%s&#x27; is different from number of field names: &quot;
                           &#x27;%d&quot;, row, fieldNames.length));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (int i = 0; i &lt; fieldNames.length; &#x27;
                           &#x27;i++) {\n&#x27;
                           &#x27;            final String name = fieldNames[i];\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            final JsonNode fieldConverted = &#x27;
                           &#x27;convert(reuse, reuse.get(name), fieldTypes[i], &#x27;
                           &#x27;row.getField(i));\n&#x27;
                           &#x27;            reuse.set(name, fieldConverted);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return reuse;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private JsonNode convert(ContainerNode&lt;?&gt; &#x27;
                           &#x27;container, JsonNode reuse, TypeInformation&lt;?&gt; &#x27;
                           &#x27;info, Object object) {\n&#x27;
                           &#x27;        if (info.equals(Types.VOID) || object == &#x27;
                           &#x27;null) {\n&#x27;
                           &#x27;            return container.nullNode();\n&#x27;
                           &#x27;        } else if (info.equals(Types.BOOLEAN)) {\n&#x27;
                           &#x27;            return container.booleanNode((Boolean) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else if (info.equals(Types.STRING)) {\n&#x27;
                           &#x27;            return container.textNode((String) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else if (info.equals(Types.BIG_DEC)) {\n&#x27;
                           &#x27;            // convert decimal if necessary\n&#x27;
                           &#x27;            if (object instanceof BigDecimal) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.numberNode((BigDecimal) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.numberNode(BigDecimal.valueOf(((Number) &#x27;
                           &#x27;object).doubleValue()));\n&#x27;
                           &#x27;        } else if (info.equals(Types.BIG_INT)) {\n&#x27;
                           &#x27;            // convert integer if necessary\n&#x27;
                           &#x27;            if (object instanceof BigInteger) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.numberNode((BigInteger) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.numberNode(BigInteger.valueOf(((Number) &#x27;
                           &#x27;object).longValue()));\n&#x27;
                           &#x27;        } else if (info.equals(Types.SQL_DATE)) {\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(object.toString());\n&#x27;
                           &#x27;        } else if (info.equals(Types.SQL_TIME)) {\n&#x27;
                           &#x27;            final Time time = (Time) object;\n&#x27;
                           &#x27;            // strip milliseconds if possible\n&#x27;
                           &#x27;            if (time.getTime() % 1000 &gt; 0) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.textNode(timeFormatWithMillis.format(time));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(timeFormat.format(time));\n&#x27;
                           &#x27;        } else if &#x27;
                           &#x27;(info.equals(Types.SQL_TIMESTAMP)) {\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(timestampFormat.format((Timestamp) &#x27;
                           &#x27;object));\n&#x27;
                           &#x27;        } else if (info instanceof RowTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ObjectNode) {\n&#x27;
                           &#x27;                return convertRow((ObjectNode) &#x27;
                           &#x27;reuse, (RowTypeInfo) info, (Row) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertRow(null, &#x27;
                           &#x27;(RowTypeInfo) info, (Row) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;ObjectArrayTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ArrayNode) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;convertObjectArray((ArrayNode) reuse, &#x27;
                           &#x27;((ObjectArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertObjectArray(null, &#x27;
                           &#x27;((ObjectArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;BasicArrayTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ArrayNode) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;convertObjectArray((ArrayNode) reuse, &#x27;
                           &#x27;((BasicArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertObjectArray(null, &#x27;
                           &#x27;((BasicArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;PrimitiveArrayTypeInfo &amp;&amp; &#x27;
                           &#x27;((PrimitiveArrayTypeInfo) info).getComponentType() &#x27;
                           &#x27;== Types.BYTE) {\n&#x27;
                           &#x27;            return container.binaryNode((byte[]) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            // for types that were specified &#x27;
                           &#x27;without JSON schema\n&#x27;
                           &#x27;            // e.g. POJOs\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;mapper.valueToTree(object);\n&#x27;
                           &#x27;            } catch (IllegalArgumentException e) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                throw new &#x27;
                           &#x27;IllegalStateException(&quot;Unsupported type &#x27;
                           &#x27;information \&#x27;&quot; + info + &quot;\&#x27; for object: &quot; + &#x27;
                           &#x27;object, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private ArrayNode convertObjectArray(ArrayNode &#x27;
                           &#x27;reuse, TypeInformation&lt;?&gt; info, Object[] array) {\n&#x27;
                           &#x27;        if (reuse == null) {\n&#x27;
                           &#x27;            reuse = mapper.createArrayNode();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            reuse.removeAll();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (Object object : array) {\n&#x27;
                           &#x27;            reuse.add(convert(reuse, null, info, &#x27;
                           &#x27;object));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return reuse;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one or more\n&#x27;
                           &#x27; * contributor license agreements.  See the NOTICE &#x27;
                           &#x27;file distributed with\n&#x27;
                           &#x27; * this work for additional information regarding &#x27;
                           &#x27;copyright ownership.\n&#x27;
                           &#x27; * The ASF licenses this file to You under the &#x27;
                           &#x27;Apache License, Version 2.0\n&#x27;
                           &#x27; * (the &quot;License&quot;); you may not use this file &#x27;
                           &#x27;except in compliance with\n&#x27;
                           &#x27; * the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *    http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package &#x27;
                           &#x27;com.dtstack.flink.sql.sink.kafka.serialization;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.EUpdateMode;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.serialization.SerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.Types;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.json.JsonRowSchemaConverter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ContainerNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;\n&#x27;
                           &#x27;import org.apache.flink.table.runtime.types.CRow;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.runtime.types.CRowTypeInfo;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.apache.flink.util.Preconditions;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.math.BigDecimal;\n&#x27;
                           &#x27;import java.math.BigInteger;\n&#x27;
                           &#x27;import java.sql.Time;\n&#x27;
                           &#x27;import java.sql.Timestamp;\n&#x27;
                           &#x27;import java.text.SimpleDateFormat;\n&#x27;
                           &#x27;import java.util.Objects;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Serialization schema that serializes an object &#x27;
                           &#x27;of Flink types into a JSON bytes.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Serializes the input Flink object into a &#x27;
                           &#x27;JSON string and\n&#x27;
                           &#x27; * converts it into &lt;code&gt;byte[]&lt;/code&gt;.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class JsonCRowSerializationSchema &#x27;
                           &#x27;implements SerializationSchema&lt;CRow&gt; {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final long serialVersionUID = &#x27;
                           &#x27;-2885556750743978636L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Type information describing the input &#x27;
                           &#x27;type. */\n&#x27;
                           &#x27;    private final TypeInformation&lt;CRow&gt; typeInfo;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Object mapper that is used to create &#x27;
                           &#x27;output JSON objects. */\n&#x27;
                           &#x27;    private final ObjectMapper mapper = new &#x27;
                           &#x27;ObjectMapper();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a time value (with UTC timezone, &#x27;
                           &#x27;without milliseconds). */\n&#x27;
                           &#x27;    private SimpleDateFormat timeFormat = new &#x27;
                           &#x27;SimpleDateFormat(&quot;HH:mm:ss\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a time value (with UTC &#x27;
                           &#x27;timezone). */\n&#x27;
                           &#x27;    private SimpleDateFormat timeFormatWithMillis &#x27;
                           &#x27;= new SimpleDateFormat(&quot;HH:mm:ss.SSS\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a timestamp value (with UTC &#x27;
                           &#x27;timezone). */\n&#x27;
                           &#x27;    private SimpleDateFormat timestampFormat = new &#x27;
                           &#x27;SimpleDateFormat(&quot;yyyy-MM-dd\&#x27;T\&#x27;HH:mm:ss.SSS\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Reusable object node. */\n&#x27;
                           &#x27;    private transient ObjectNode node;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final String retractKey = &quot;retract&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public JsonCRowSerializationSchema(String &#x27;
                           &#x27;jsonSchema, String updateMode) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;this(JsonRowSchemaConverter.convert(jsonSchema), &#x27;
                           &#x27;updateMode);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Creates a JSON serialization schema for the &#x27;
                           &#x27;given type information.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param typeInfo The field names of {@link &#x27;
                           &#x27;Row} are used to map to JSON properties.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public &#x27;
                           &#x27;JsonCRowSerializationSchema(TypeInformation&lt;CRow&gt; &#x27;
                           &#x27;typeInfo, String updateMode) {\n&#x27;
                           &#x27;        Preconditions.checkNotNull(typeInfo, &quot;Type &#x27;
                           &#x27;information&quot;);\n&#x27;
                           &#x27;        this.typeInfo = typeInfo;\n&#x27;
                           &#x27;        this.updateMode = updateMode;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public byte[] serialize(CRow crow) {\n&#x27;
                           &#x27;        Row row = crow.row();\n&#x27;
                           &#x27;        boolean change = crow.change();\n&#x27;
                           &#x27;        if (node == null) {\n&#x27;
                           &#x27;            node = mapper.createObjectNode();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        RowTypeInfo rowTypeInfo = ((CRowTypeInfo) &#x27;
                           &#x27;typeInfo).rowType();\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            convertRow(node, rowTypeInfo, row);\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(StringUtils.equalsIgnoreCase(updateMode, &#x27;
                           &#x27;EUpdateMode.UPSERT.name())) {\n&#x27;
                           &#x27;                node.put(retractKey, change);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;mapper.writeValueAsBytes(node);\n&#x27;
                           &#x27;        } catch (Throwable t) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;Could not &#x27;
                           &#x27;serialize row \&#x27;&quot; + row + &quot;\&#x27;. &quot; +\n&#x27;
                           &#x27;                    &quot;Make sure that the schema &#x27;
                           &#x27;matches the input.&quot;, t);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public boolean equals(Object o) {\n&#x27;
                           &#x27;        if (this == o) {\n&#x27;
                           &#x27;            return true;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (o == null || getClass() != &#x27;
                           &#x27;o.getClass()) {\n&#x27;
                           &#x27;            return false;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        final JsonCRowSerializationSchema that = &#x27;
                           &#x27;(JsonCRowSerializationSchema) o;\n&#x27;
                           &#x27;        return Objects.equals(typeInfo, &#x27;
                           &#x27;that.typeInfo);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public int hashCode() {\n&#x27;
                           &#x27;        return Objects.hash(typeInfo);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;--------------------------------------------------------------------------------------------\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private ObjectNode convertRow(ObjectNode &#x27;
                           &#x27;reuse, RowTypeInfo info, Row row) {\n&#x27;
                           &#x27;        if (reuse == null) {\n&#x27;
                           &#x27;            reuse = mapper.createObjectNode();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        final String[] fieldNames = &#x27;
                           &#x27;info.getFieldNames();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        final TypeInformation&lt;?&gt;[] fieldTypes = &#x27;
                           &#x27;info.getFieldTypes();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // validate the row\n&#x27;
                           &#x27;        if (row.getArity() != fieldNames.length) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalStateException(String.format(\n&#x27;
                           &#x27;                    &quot;Number of elements in the row &#x27;
                           &quot;&#x27;%s&#x27; is different from number of field names: &quot;
                           &#x27;%d&quot;, row, fieldNames.length));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (int i = 0; i &lt; fieldNames.length; &#x27;
                           &#x27;i++) {\n&#x27;
                           &#x27;            final String name = fieldNames[i];\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            final JsonNode fieldConverted = &#x27;
                           &#x27;convert(reuse, reuse.get(name), fieldTypes[i], &#x27;
                           &#x27;row.getField(i));\n&#x27;
                           &#x27;            reuse.set(name, fieldConverted);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return reuse;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private JsonNode convert(ContainerNode&lt;?&gt; &#x27;
                           &#x27;container, JsonNode reuse, TypeInformation&lt;?&gt; &#x27;
                           &#x27;info, Object object) {\n&#x27;
                           &#x27;        if (info.equals(Types.VOID) || object == &#x27;
                           &#x27;null) {\n&#x27;
                           &#x27;            return container.nullNode();\n&#x27;
                           &#x27;        } else if (info.equals(Types.BOOLEAN)) {\n&#x27;
                           &#x27;            return container.booleanNode((Boolean) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else if (info.equals(Types.STRING)) {\n&#x27;
                           &#x27;            return container.textNode((String) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else if (info.equals(Types.BIG_DEC)) {\n&#x27;
                           &#x27;            // convert decimal if necessary\n&#x27;
                           &#x27;            if (object instanceof BigDecimal) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.numberNode((BigDecimal) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.numberNode(BigDecimal.valueOf(((Number) &#x27;
                           &#x27;object).doubleValue()));\n&#x27;
                           &#x27;        } else if (info.equals(Types.BIG_INT)) {\n&#x27;
                           &#x27;            // convert integer if necessary\n&#x27;
                           &#x27;            if (object instanceof BigInteger) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.numberNode((BigInteger) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.numberNode(BigInteger.valueOf(((Number) &#x27;
                           &#x27;object).longValue()));\n&#x27;
                           &#x27;        } else if (info.equals(Types.SQL_DATE)) {\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(object.toString());\n&#x27;
                           &#x27;        } else if (info.equals(Types.SQL_TIME)) {\n&#x27;
                           &#x27;            final Time time = (Time) object;\n&#x27;
                           &#x27;            // strip milliseconds if possible\n&#x27;
                           &#x27;            if (time.getTime() % 1000 &gt; 0) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.textNode(timeFormatWithMillis.format(time));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(timeFormat.format(time));\n&#x27;
                           &#x27;        } else if &#x27;
                           &#x27;(info.equals(Types.SQL_TIMESTAMP)) {\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(timestampFormat.format((Timestamp) &#x27;
                           &#x27;object));\n&#x27;
                           &#x27;        } else if (info instanceof RowTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ObjectNode) {\n&#x27;
                           &#x27;                return convertRow((ObjectNode) &#x27;
                           &#x27;reuse, (RowTypeInfo) info, (Row) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertRow(null, &#x27;
                           &#x27;(RowTypeInfo) info, (Row) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;ObjectArrayTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ArrayNode) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;convertObjectArray((ArrayNode) reuse, &#x27;
                           &#x27;((ObjectArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertObjectArray(null, &#x27;
                           &#x27;((ObjectArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;BasicArrayTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ArrayNode) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;convertObjectArray((ArrayNode) reuse, &#x27;
                           &#x27;((BasicArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertObjectArray(null, &#x27;
                           &#x27;((BasicArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;PrimitiveArrayTypeInfo &amp;&amp; &#x27;
                           &#x27;((PrimitiveArrayTypeInfo) info).getComponentType() &#x27;
                           &#x27;== Types.BYTE) {\n&#x27;
                           &#x27;            return container.binaryNode((byte[]) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            // for types that were specified &#x27;
                           &#x27;without JSON schema\n&#x27;
                           &#x27;            // e.g. POJOs\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;mapper.valueToTree(object);\n&#x27;
                           &#x27;            } catch (IllegalArgumentException e) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                throw new &#x27;
                           &#x27;IllegalStateException(&quot;Unsupported type &#x27;
                           &#x27;information \&#x27;&quot; + info + &quot;\&#x27; for object: &quot; + &#x27;
                           &#x27;object, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private ArrayNode convertObjectArray(ArrayNode &#x27;
                           &#x27;reuse, TypeInformation&lt;?&gt; info, Object[] array) {\n&#x27;
                           &#x27;        if (reuse == null) {\n&#x27;
                           &#x27;            reuse = mapper.createArrayNode();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            reuse.removeAll();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (Object object : array) {\n&#x27;
                           &#x27;            reuse.add(convert(reuse, null, info, &#x27;
                           &#x27;object));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return reuse;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one or more\n&#x27;
                           &#x27; * contributor license agreements.  See the NOTICE &#x27;
                           &#x27;file distributed with\n&#x27;
                           &#x27; * this work for additional information regarding &#x27;
                           &#x27;copyright ownership.\n&#x27;
                           &#x27; * The ASF licenses this file to You under the &#x27;
                           &#x27;Apache License, Version 2.0\n&#x27;
                           &#x27; * (the &quot;License&quot;); you may not use this file &#x27;
                           &#x27;except in compliance with\n&#x27;
                           &#x27; * the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *    http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package &#x27;
                           &#x27;com.dtstack.flink.sql.sink.kafka.serialization;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.EUpdateMode;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.serialization.SerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.Types;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.json.JsonRowSchemaConverter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ContainerNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;\n&#x27;
                           &#x27;import org.apache.flink.table.runtime.types.CRow;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.runtime.types.CRowTypeInfo;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.apache.flink.util.Preconditions;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.math.BigDecimal;\n&#x27;
                           &#x27;import java.math.BigInteger;\n&#x27;
                           &#x27;import java.sql.Time;\n&#x27;
                           &#x27;import java.sql.Timestamp;\n&#x27;
                           &#x27;import java.text.SimpleDateFormat;\n&#x27;
                           &#x27;import java.util.Objects;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Serialization schema that serializes an object &#x27;
                           &#x27;of Flink types into a JSON bytes.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Serializes the input Flink object into a &#x27;
                           &#x27;JSON string and\n&#x27;
                           &#x27; * converts it into &lt;code&gt;byte[]&lt;/code&gt;.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class JsonCRowSerializationSchema &#x27;
                           &#x27;implements SerializationSchema&lt;CRow&gt; {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final long serialVersionUID = &#x27;
                           &#x27;-2885556750743978636L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Type information describing the input &#x27;
                           &#x27;type. */\n&#x27;
                           &#x27;    private final TypeInformation&lt;CRow&gt; typeInfo;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Object mapper that is used to create &#x27;
                           &#x27;output JSON objects. */\n&#x27;
                           &#x27;    private final ObjectMapper mapper = new &#x27;
                           &#x27;ObjectMapper();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a time value (with UTC timezone, &#x27;
                           &#x27;without milliseconds). */\n&#x27;
                           &#x27;    private SimpleDateFormat timeFormat = new &#x27;
                           &#x27;SimpleDateFormat(&quot;HH:mm:ss\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a time value (with UTC &#x27;
                           &#x27;timezone). */\n&#x27;
                           &#x27;    private SimpleDateFormat timeFormatWithMillis &#x27;
                           &#x27;= new SimpleDateFormat(&quot;HH:mm:ss.SSS\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a timestamp value (with UTC &#x27;
                           &#x27;timezone). */\n&#x27;
                           &#x27;    private SimpleDateFormat timestampFormat = new &#x27;
                           &#x27;SimpleDateFormat(&quot;yyyy-MM-dd\&#x27;T\&#x27;HH:mm:ss.SSS\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Reusable object node. */\n&#x27;
                           &#x27;    private transient ObjectNode node;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final String retractKey = &quot;retract&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public JsonCRowSerializationSchema(String &#x27;
                           &#x27;jsonSchema, String updateMode) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;this(JsonRowSchemaConverter.convert(jsonSchema), &#x27;
                           &#x27;updateMode);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Creates a JSON serialization schema for the &#x27;
                           &#x27;given type information.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param typeInfo The field names of {@link &#x27;
                           &#x27;Row} are used to map to JSON properties.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public &#x27;
                           &#x27;JsonCRowSerializationSchema(TypeInformation&lt;CRow&gt; &#x27;
                           &#x27;typeInfo, String updateMode) {\n&#x27;
                           &#x27;        Preconditions.checkNotNull(typeInfo, &quot;Type &#x27;
                           &#x27;information&quot;);\n&#x27;
                           &#x27;        this.typeInfo = typeInfo;\n&#x27;
                           &#x27;        this.updateMode = updateMode;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public byte[] serialize(CRow crow) {\n&#x27;
                           &#x27;        Row row = crow.row();\n&#x27;
                           &#x27;        boolean change = crow.change();\n&#x27;
                           &#x27;        if (node == null) {\n&#x27;
                           &#x27;            node = mapper.createObjectNode();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        RowTypeInfo rowTypeInfo = ((CRowTypeInfo) &#x27;
                           &#x27;typeInfo).rowType();\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            convertRow(node, rowTypeInfo, row);\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(StringUtils.equalsIgnoreCase(updateMode, &#x27;
                           &#x27;EUpdateMode.UPSERT.name())) {\n&#x27;
                           &#x27;                node.put(retractKey, change);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;mapper.writeValueAsBytes(node);\n&#x27;
                           &#x27;        } catch (Throwable t) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;Could not &#x27;
                           &#x27;serialize row \&#x27;&quot; + row + &quot;\&#x27;. &quot; +\n&#x27;
                           &#x27;                    &quot;Make sure that the schema &#x27;
                           &#x27;matches the input.&quot;, t);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public boolean equals(Object o) {\n&#x27;
                           &#x27;        if (this == o) {\n&#x27;
                           &#x27;            return true;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (o == null || getClass() != &#x27;
                           &#x27;o.getClass()) {\n&#x27;
                           &#x27;            return false;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        final JsonCRowSerializationSchema that = &#x27;
                           &#x27;(JsonCRowSerializationSchema) o;\n&#x27;
                           &#x27;        return Objects.equals(typeInfo, &#x27;
                           &#x27;that.typeInfo);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public int hashCode() {\n&#x27;
                           &#x27;        return Objects.hash(typeInfo);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;--------------------------------------------------------------------------------------------\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private ObjectNode convertRow(ObjectNode &#x27;
                           &#x27;reuse, RowTypeInfo info, Row row) {\n&#x27;
                           &#x27;        if (reuse == null) {\n&#x27;
                           &#x27;            reuse = mapper.createObjectNode();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        final String[] fieldNames = &#x27;
                           &#x27;info.getFieldNames();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        final TypeInformation&lt;?&gt;[] fieldTypes = &#x27;
                           &#x27;info.getFieldTypes();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // validate the row\n&#x27;
                           &#x27;        if (row.getArity() != fieldNames.length) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalStateException(String.format(\n&#x27;
                           &#x27;                    &quot;Number of elements in the row &#x27;
                           &quot;&#x27;%s&#x27; is different from number of field names: &quot;
                           &#x27;%d&quot;, row, fieldNames.length));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (int i = 0; i &lt; fieldNames.length; &#x27;
                           &#x27;i++) {\n&#x27;
                           &#x27;            final String name = fieldNames[i];\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            final JsonNode fieldConverted = &#x27;
                           &#x27;convert(reuse, reuse.get(name), fieldTypes[i], &#x27;
                           &#x27;row.getField(i));\n&#x27;
                           &#x27;            reuse.set(name, fieldConverted);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return reuse;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private JsonNode convert(ContainerNode&lt;?&gt; &#x27;
                           &#x27;container, JsonNode reuse, TypeInformation&lt;?&gt; &#x27;
                           &#x27;info, Object object) {\n&#x27;
                           &#x27;        if (info.equals(Types.VOID) || object == &#x27;
                           &#x27;null) {\n&#x27;
                           &#x27;            return container.nullNode();\n&#x27;
                           &#x27;        } else if (info.equals(Types.BOOLEAN)) {\n&#x27;
                           &#x27;            return container.booleanNode((Boolean) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else if (info.equals(Types.STRING)) {\n&#x27;
                           &#x27;            return container.textNode((String) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else if (info.equals(Types.BIG_DEC)) {\n&#x27;
                           &#x27;            // convert decimal if necessary\n&#x27;
                           &#x27;            if (object instanceof BigDecimal) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.numberNode((BigDecimal) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.numberNode(BigDecimal.valueOf(((Number) &#x27;
                           &#x27;object).doubleValue()));\n&#x27;
                           &#x27;        } else if (info.equals(Types.BIG_INT)) {\n&#x27;
                           &#x27;            // convert integer if necessary\n&#x27;
                           &#x27;            if (object instanceof BigInteger) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.numberNode((BigInteger) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.numberNode(BigInteger.valueOf(((Number) &#x27;
                           &#x27;object).longValue()));\n&#x27;
                           &#x27;        } else if (info.equals(Types.SQL_DATE)) {\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(object.toString());\n&#x27;
                           &#x27;        } else if (info.equals(Types.SQL_TIME)) {\n&#x27;
                           &#x27;            final Time time = (Time) object;\n&#x27;
                           &#x27;            // strip milliseconds if possible\n&#x27;
                           &#x27;            if (time.getTime() % 1000 &gt; 0) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.textNode(timeFormatWithMillis.format(time));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(timeFormat.format(time));\n&#x27;
                           &#x27;        } else if &#x27;
                           &#x27;(info.equals(Types.SQL_TIMESTAMP)) {\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(timestampFormat.format((Timestamp) &#x27;
                           &#x27;object));\n&#x27;
                           &#x27;        } else if (info instanceof RowTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ObjectNode) {\n&#x27;
                           &#x27;                return convertRow((ObjectNode) &#x27;
                           &#x27;reuse, (RowTypeInfo) info, (Row) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertRow(null, &#x27;
                           &#x27;(RowTypeInfo) info, (Row) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;ObjectArrayTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ArrayNode) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;convertObjectArray((ArrayNode) reuse, &#x27;
                           &#x27;((ObjectArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertObjectArray(null, &#x27;
                           &#x27;((ObjectArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;BasicArrayTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ArrayNode) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;convertObjectArray((ArrayNode) reuse, &#x27;
                           &#x27;((BasicArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertObjectArray(null, &#x27;
                           &#x27;((BasicArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;PrimitiveArrayTypeInfo &amp;&amp; &#x27;
                           &#x27;((PrimitiveArrayTypeInfo) info).getComponentType() &#x27;
                           &#x27;== Types.BYTE) {\n&#x27;
                           &#x27;            return container.binaryNode((byte[]) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            // for types that were specified &#x27;
                           &#x27;without JSON schema\n&#x27;
                           &#x27;            // e.g. POJOs\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;mapper.valueToTree(object);\n&#x27;
                           &#x27;            } catch (IllegalArgumentException e) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                throw new &#x27;
                           &#x27;IllegalStateException(&quot;Unsupported type &#x27;
                           &#x27;information \&#x27;&quot; + info + &quot;\&#x27; for object: &quot; + &#x27;
                           &#x27;object, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private ArrayNode convertObjectArray(ArrayNode &#x27;
                           &#x27;reuse, TypeInformation&lt;?&gt; info, Object[] array) {\n&#x27;
                           &#x27;        if (reuse == null) {\n&#x27;
                           &#x27;            reuse = mapper.createArrayNode();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            reuse.removeAll();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (Object object : array) {\n&#x27;
                           &#x27;            reuse.add(convert(reuse, null, info, &#x27;
                           &#x27;object));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return reuse;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;/*\n&#x27;
                           &#x27; * Licensed to the Apache Software Foundation &#x27;
                           &#x27;(ASF) under one or more\n&#x27;
                           &#x27; * contributor license agreements.  See the NOTICE &#x27;
                           &#x27;file distributed with\n&#x27;
                           &#x27; * this work for additional information regarding &#x27;
                           &#x27;copyright ownership.\n&#x27;
                           &#x27; * The ASF licenses this file to You under the &#x27;
                           &#x27;Apache License, Version 2.0\n&#x27;
                           &#x27; * (the &quot;License&quot;); you may not use this file &#x27;
                           &#x27;except in compliance with\n&#x27;
                           &#x27; * the License.  You may obtain a copy of the &#x27;
                           &#x27;License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *    http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;package &#x27;
                           &#x27;com.dtstack.flink.sql.sink.kafka.serialization;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.dtstack.flink.sql.enums.EUpdateMode;\n&#x27;
                           &#x27;import org.apache.commons.lang3.StringUtils;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.serialization.SerializationSchema;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.BasicArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.PrimitiveArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.TypeInformation;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.common.typeinfo.Types;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.ObjectArrayTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.api.java.typeutils.RowTypeInfo;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.formats.json.JsonRowSchemaConverter;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.JsonNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.ObjectMapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ArrayNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ContainerNode;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.shaded.jackson2.com.fasterxml.jackson.databind.node.ObjectNode;\n&#x27;
                           &#x27;import org.apache.flink.table.runtime.types.CRow;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.apache.flink.table.runtime.types.CRowTypeInfo;\n&#x27;
                           &#x27;import org.apache.flink.types.Row;\n&#x27;
                           &#x27;import org.apache.flink.util.Preconditions;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import java.math.BigDecimal;\n&#x27;
                           &#x27;import java.math.BigInteger;\n&#x27;
                           &#x27;import java.sql.Time;\n&#x27;
                           &#x27;import java.sql.Timestamp;\n&#x27;
                           &#x27;import java.text.SimpleDateFormat;\n&#x27;
                           &#x27;import java.util.Objects;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Serialization schema that serializes an object &#x27;
                           &#x27;of Flink types into a JSON bytes.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * &lt;p&gt;Serializes the input Flink object into a &#x27;
                           &#x27;JSON string and\n&#x27;
                           &#x27; * converts it into &lt;code&gt;byte[]&lt;/code&gt;.\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class JsonCRowSerializationSchema &#x27;
                           &#x27;implements SerializationSchema&lt;CRow&gt; {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private static final long serialVersionUID = &#x27;
                           &#x27;-2885556750743978636L;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Type information describing the input &#x27;
                           &#x27;type. */\n&#x27;
                           &#x27;    private final TypeInformation&lt;CRow&gt; typeInfo;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Object mapper that is used to create &#x27;
                           &#x27;output JSON objects. */\n&#x27;
                           &#x27;    private final ObjectMapper mapper = new &#x27;
                           &#x27;ObjectMapper();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a time value (with UTC timezone, &#x27;
                           &#x27;without milliseconds). */\n&#x27;
                           &#x27;    private SimpleDateFormat timeFormat = new &#x27;
                           &#x27;SimpleDateFormat(&quot;HH:mm:ss\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a time value (with UTC &#x27;
                           &#x27;timezone). */\n&#x27;
                           &#x27;    private SimpleDateFormat timeFormatWithMillis &#x27;
                           &#x27;= new SimpleDateFormat(&quot;HH:mm:ss.SSS\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Formatter for RFC 3339-compliant string &#x27;
                           &#x27;representation of a timestamp value (with UTC &#x27;
                           &#x27;timezone). */\n&#x27;
                           &#x27;    private SimpleDateFormat timestampFormat = new &#x27;
                           &#x27;SimpleDateFormat(&quot;yyyy-MM-dd\&#x27;T\&#x27;HH:mm:ss.SSS\&#x27;Z\&#x27;&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /** Reusable object node. */\n&#x27;
                           &#x27;    private transient ObjectNode node;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private String updateMode;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private final String retractKey = &quot;retract&quot;;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    public JsonCRowSerializationSchema(String &#x27;
                           &#x27;jsonSchema, String updateMode) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;this(JsonRowSchemaConverter.convert(jsonSchema), &#x27;
                           &#x27;updateMode);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    /**\n&#x27;
                           &#x27;     * Creates a JSON serialization schema for the &#x27;
                           &#x27;given type information.\n&#x27;
                           &#x27;     *\n&#x27;
                           &#x27;     * @param typeInfo The field names of {@link &#x27;
                           &#x27;Row} are used to map to JSON properties.\n&#x27;
                           &#x27;     */\n&#x27;
                           &#x27;    public &#x27;
                           &#x27;JsonCRowSerializationSchema(TypeInformation&lt;CRow&gt; &#x27;
                           &#x27;typeInfo, String updateMode) {\n&#x27;
                           &#x27;        Preconditions.checkNotNull(typeInfo, &quot;Type &#x27;
                           &#x27;information&quot;);\n&#x27;
                           &#x27;        this.typeInfo = typeInfo;\n&#x27;
                           &#x27;        this.updateMode = updateMode;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public byte[] serialize(CRow crow) {\n&#x27;
                           &#x27;        Row row = crow.row();\n&#x27;
                           &#x27;        boolean change = crow.change();\n&#x27;
                           &#x27;        if (node == null) {\n&#x27;
                           &#x27;            node = mapper.createObjectNode();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        RowTypeInfo rowTypeInfo = ((CRowTypeInfo) &#x27;
                           &#x27;typeInfo).rowType();\n&#x27;
                           &#x27;        try {\n&#x27;
                           &#x27;            convertRow(node, rowTypeInfo, row);\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(StringUtils.equalsIgnoreCase(updateMode, &#x27;
                           &#x27;EUpdateMode.UPSERT.name())) {\n&#x27;
                           &#x27;                node.put(retractKey, change);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;mapper.writeValueAsBytes(node);\n&#x27;
                           &#x27;        } catch (Throwable t) {\n&#x27;
                           &#x27;            throw new RuntimeException(&quot;Could not &#x27;
                           &#x27;serialize row \&#x27;&quot; + row + &quot;\&#x27;. &quot; +\n&#x27;
                           &#x27;                    &quot;Make sure that the schema &#x27;
                           &#x27;matches the input.&quot;, t);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public boolean equals(Object o) {\n&#x27;
                           &#x27;        if (this == o) {\n&#x27;
                           &#x27;            return true;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        if (o == null || getClass() != &#x27;
                           &#x27;o.getClass()) {\n&#x27;
                           &#x27;            return false;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        final JsonCRowSerializationSchema that = &#x27;
                           &#x27;(JsonCRowSerializationSchema) o;\n&#x27;
                           &#x27;        return Objects.equals(typeInfo, &#x27;
                           &#x27;that.typeInfo);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Override\n&#x27;
                           &#x27;    public int hashCode() {\n&#x27;
                           &#x27;        return Objects.hash(typeInfo);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    // &#x27;
                           &#x27;--------------------------------------------------------------------------------------------\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private ObjectNode convertRow(ObjectNode &#x27;
                           &#x27;reuse, RowTypeInfo info, Row row) {\n&#x27;
                           &#x27;        if (reuse == null) {\n&#x27;
                           &#x27;            reuse = mapper.createObjectNode();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        final String[] fieldNames = &#x27;
                           &#x27;info.getFieldNames();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        final TypeInformation&lt;?&gt;[] fieldTypes = &#x27;
                           &#x27;info.getFieldTypes();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        // validate the row\n&#x27;
                           &#x27;        if (row.getArity() != fieldNames.length) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            throw new &#x27;
                           &#x27;IllegalStateException(String.format(\n&#x27;
                           &#x27;                    &quot;Number of elements in the row &#x27;
                           &quot;&#x27;%s&#x27; is different from number of field names: &quot;
                           &#x27;%d&quot;, row, fieldNames.length));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (int i = 0; i &lt; fieldNames.length; &#x27;
                           &#x27;i++) {\n&#x27;
                           &#x27;            final String name = fieldNames[i];\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            final JsonNode fieldConverted = &#x27;
                           &#x27;convert(reuse, reuse.get(name), fieldTypes[i], &#x27;
                           &#x27;row.getField(i));\n&#x27;
                           &#x27;            reuse.set(name, fieldConverted);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        return reuse;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private JsonNode convert(ContainerNode&lt;?&gt; &#x27;
                           &#x27;container, JsonNode reuse, TypeInformation&lt;?&gt; &#x27;
                           &#x27;info, Object object) {\n&#x27;
                           &#x27;        if (info.equals(Types.VOID) || object == &#x27;
                           &#x27;null) {\n&#x27;
                           &#x27;            return container.nullNode();\n&#x27;
                           &#x27;        } else if (info.equals(Types.BOOLEAN)) {\n&#x27;
                           &#x27;            return container.booleanNode((Boolean) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else if (info.equals(Types.STRING)) {\n&#x27;
                           &#x27;            return container.textNode((String) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else if (info.equals(Types.BIG_DEC)) {\n&#x27;
                           &#x27;            // convert decimal if necessary\n&#x27;
                           &#x27;            if (object instanceof BigDecimal) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.numberNode((BigDecimal) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.numberNode(BigDecimal.valueOf(((Number) &#x27;
                           &#x27;object).doubleValue()));\n&#x27;
                           &#x27;        } else if (info.equals(Types.BIG_INT)) {\n&#x27;
                           &#x27;            // convert integer if necessary\n&#x27;
                           &#x27;            if (object instanceof BigInteger) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.numberNode((BigInteger) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.numberNode(BigInteger.valueOf(((Number) &#x27;
                           &#x27;object).longValue()));\n&#x27;
                           &#x27;        } else if (info.equals(Types.SQL_DATE)) {\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(object.toString());\n&#x27;
                           &#x27;        } else if (info.equals(Types.SQL_TIME)) {\n&#x27;
                           &#x27;            final Time time = (Time) object;\n&#x27;
                           &#x27;            // strip milliseconds if possible\n&#x27;
                           &#x27;            if (time.getTime() % 1000 &gt; 0) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;container.textNode(timeFormatWithMillis.format(time));\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(timeFormat.format(time));\n&#x27;
                           &#x27;        } else if &#x27;
                           &#x27;(info.equals(Types.SQL_TIMESTAMP)) {\n&#x27;
                           &#x27;            return &#x27;
                           &#x27;container.textNode(timestampFormat.format((Timestamp) &#x27;
                           &#x27;object));\n&#x27;
                           &#x27;        } else if (info instanceof RowTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ObjectNode) {\n&#x27;
                           &#x27;                return convertRow((ObjectNode) &#x27;
                           &#x27;reuse, (RowTypeInfo) info, (Row) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertRow(null, &#x27;
                           &#x27;(RowTypeInfo) info, (Row) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;ObjectArrayTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ArrayNode) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;convertObjectArray((ArrayNode) reuse, &#x27;
                           &#x27;((ObjectArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertObjectArray(null, &#x27;
                           &#x27;((ObjectArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;BasicArrayTypeInfo) {\n&#x27;
                           &#x27;            if (reuse != null &amp;&amp; reuse instanceof &#x27;
                           &#x27;ArrayNode) {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;convertObjectArray((ArrayNode) reuse, &#x27;
                           &#x27;((BasicArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                return convertObjectArray(null, &#x27;
                           &#x27;((BasicArrayTypeInfo) info).getComponentInfo(), &#x27;
                           &#x27;(Object[]) object);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else if (info instanceof &#x27;
                           &#x27;PrimitiveArrayTypeInfo &amp;&amp; &#x27;
                           &#x27;((PrimitiveArrayTypeInfo) info).getComponentType() &#x27;
                           &#x27;== Types.BYTE) {\n&#x27;
                           &#x27;            return container.binaryNode((byte[]) &#x27;
                           &#x27;object);\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            // for types that were specified &#x27;
                           &#x27;without JSON schema\n&#x27;
                           &#x27;            // e.g. POJOs\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                return &#x27;
                           &#x27;mapper.valueToTree(object);\n&#x27;
                           &#x27;            } catch (IllegalArgumentException e) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                throw new &#x27;
                           &#x27;IllegalStateException(&quot;Unsupported type &#x27;
                           &#x27;information \&#x27;&quot; + info + &quot;\&#x27; for object: &quot; + &#x27;
                           &#x27;object, e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    private ArrayNode convertObjectArray(ArrayNode &#x27;
                           &#x27;reuse, TypeInformation&lt;?&gt; info, Object[] array) {\n&#x27;
                           &#x27;        if (reuse == null) {\n&#x27;
                           &#x27;            reuse = mapper.createArrayNode();\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            reuse.removeAll();\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        for (Object object : array) {\n&#x27;
                           &#x27;            reuse.add(convert(reuse, null, info, &#x27;
                           &#x27;object));\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;        return reuse;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        