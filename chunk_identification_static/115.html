<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>115</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    115
                    <a href="114.html">prev</a>
                    <a href="116.html">next</a>
                    <a href="115_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    BroadleafCommerce/BroadleafCommerce_4c906659b12b21ea55fd99e9e59d22de6a0133ad_admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;4c906659b12b21ea55fd99e9e59d22de6a0133ad:admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;4c906659b12b21ea55fd99e9e59d22de6a0133ad^1:admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;4c906659b12b21ea55fd99e9e59d22de6a0133ad^2:admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\BroadleafCommerce\BroadleafCommerce show &quot;45c0b30829d70c32661f9bc4b75c7dcb1a7b56a5:admin/broadleaf-contentmanagement-module/src/main/java/org/broadleafcommerce/cms/file/service/StaticAssetServiceImpl.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*-
   2  * #%L
   3  * BroadleafCommerce CMS Module
   4  * %%
   5  * Copyright (C) 2009 - 2023 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  * 
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
  19 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  20 /*</span>
  21 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  22 </span>
  23 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  24 package org.broadleafcommerce.cms.file.service;
  25 
  26 import org.apache.commons.io.FilenameUtils;
  27 import org.apache.commons.lang3.StringUtils;
  28 import org.apache.commons.logging.Log;
  29 import org.apache.commons.logging.LogFactory;
  30 import org.apache.tika.Tika;
  31 import org.apache.tika.mime.MimeType;
  32 import org.apache.tika.mime.MimeTypeException;
  33 import org.apache.tika.mime.MimeTypes;
  34 import org.broadleafcommerce.cms.field.type.StorageType;
  35 import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  36 import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  37 import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  38 import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  39 import org.broadleafcommerce.cms.file.domain.StaticAsset;
  40 import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  41 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  42 import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  43 import org.broadleafcommerce.common.util.StringUtil;
  44 import org.broadleafcommerce.common.util.TransactionUtils;
  45 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  46 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  47 import org.springframework.beans.factory.annotation.Value;
  48 import org.springframework.stereotype.Service;
  49 import org.springframework.transaction.annotation.Transactional;
  50 import org.springframework.web.multipart.MultipartFile;
  51 
  52 import java.io.IOException;
  53 import java.io.InputStream;
  54 import java.io.UnsupportedEncodingException;
  55 import java.net.URLDecoder;
  56 import java.util.Arrays;
  57 import java.util.HashMap;
  58 import java.util.List;
  59 import java.util.Map;
  60 import java.util.Random;
  61 
  62 import javax.annotation.Resource;
  63 
  64 /**
  65  * Created by bpolster.
  66  */
  67 @Service(&quot;blStaticAssetService&quot;)
  68 public class StaticAssetServiceImpl implements StaticAssetService {
  69 
  70     private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
<abbr title="  71     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;">  71     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extensionðŸ”µ</abbr>
  72 
  73     @Resource(name = &quot;blImageArtifactProcessor&quot;)
  74     protected ImageArtifactProcessor imageArtifactProcessor;
  75 
  76     @Value(&quot;${asset.use.filesystem.storage}&quot;)
  77     protected boolean storeAssetsOnFileSystem = false;
  78 
  79     @Resource(name = &quot;blStaticAssetDao&quot;)
  80     protected StaticAssetDao staticAssetDao;
  81 
  82     @Resource(name = &quot;blStaticAssetStorageService&quot;)
  83     protected StaticAssetStorageService staticAssetStorageService;
  84 
  85     @Resource(name = &quot;blStaticAssetPathService&quot;)
  86     protected StaticAssetPathService staticAssetPathService;
  87 
  88     @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
  89     protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
  90 
  91     @Value(&quot;${should.accept.non.image.asset:true}&quot;)
  92     protected boolean shouldAcceptNonImageAsset;
  93 
  94     @Value(&quot;${disabled.file.extensions}&quot;)
  95     protected String disabledFileExtensions;
  96 
  97     private final Random random = new Random();
  98     private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
  99 
 100     @Value(&quot;${static.asset.invalid.chars.in.filename}&quot;)
 101     protected char[] notAllowedCharsInFileName;
 102 
 103     @Value(&quot;${static.asset.exception.on.invalid.char.in.filename:false}&quot;)
 104     protected boolean exceptionOnInvalidChar = false;
 105 
 106     @Value(&quot;${static.asset.invalid.chars.replacement}&quot;)
 107     protected String replacementString;
 108 
 109     @Override
 110     public StaticAsset findStaticAssetById(Long id) {
 111         return staticAssetDao.readStaticAssetById(id);
 112     }
 113 
 114     @Override
 115     public List&lt;StaticAsset&gt; readAllStaticAssets() {
 116         return staticAssetDao.readAllStaticAssets();
 117     }
 118 
 119     @Override
 120     public Long findTotalStaticAssetCount() {
 121         return staticAssetDao.readTotalStaticAssetCount();
 122     }
 123 
 124     protected String getFileExtension(String fileName) {
 125         int pos = fileName.lastIndexOf(&quot;.&quot;);
 126         if (pos &gt; 0) {
 127             return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 128         } else {
 129             LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 130             return null;
 131         }
 132     }
 133 
 134     /**
 135      * Generates a filename as a set of Hex digits.
 136      *
 137      * @param size
 138      * @return
 139      */
 140     protected String generateFileName(int size) {
 141         StringBuilder sb = new StringBuilder();
 142         for (int i = 0; i &lt; size; i++) {
 143             int pos = random.nextInt(FILE_NAME_CHARS.length());
 144             sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 145         }
 146         return sb.toString();
 147     }
 148 
 149     /**
 150      * Will assemble the url from the passed in properties as
 151      * /{entityType}/{fileName}
 152      * /product/7001-ab12
 153      * &lt;p&gt;
 154      * If the properties above are not set, it will generate the fileName randomly.
 155      *
 156      * @param url
 157      * @param asset
 158      * @param assetProperties
 159      * @return
 160      */
 161     protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 162         StringBuilder path = new StringBuilder(&quot;/&quot;);
 163 
 164         String entityType = assetProperties.get(&quot;entityType&quot;);
 165         String entityId = assetProperties.get(&quot;entityId&quot;);
 166         String fileName = assetProperties.get(&quot;fileName&quot;);
 167 
 168         if (entityType != null &amp;&amp; !&quot;null&quot;.equals(entityType)) {
 169             path = path.append(entityType).append(&quot;/&quot;);
 170         }
 171 
 172         if (entityId != null &amp;&amp; !&quot;null&quot;.equals(entityId)) {
 173             path = path.append(entityId).append(&quot;/&quot;);
 174         }
 175 
 176         if (fileName != null) {
 177             int pos = fileName.indexOf(&quot;:&quot;);
 178             if (pos &gt; 0) {
 179                 if (LOG.isTraceEnabled()) {
 180                     LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 181                 }
 182                 fileName = fileName.substring(pos + 1);
 183             }
 184         } else {
 185             fileName = originalFilename;
 186         }
 187 
 188         return path.append(fileName).toString();
 189     }
 190 
 191     private static String normalizeFileExtension(MultipartFile file) {
 192         int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 193         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 193         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(ðŸ”µ</abbr>
 194     }
 195 
 196     private static String getFileExtension(MultipartFile file) {
 197         String tikaExtension = null;
 198         try {
 199             final Tika tika = new Tika();
 200             final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 201             final String detectedType;
 202             detectedType = tika.detect(file.getBytes());
 203             if (detectedType != null &amp;&amp; !detectedType.isEmpty()) {
 204                 final MimeType mimeType = allTypes.forName(detectedType);
 205                 tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 206             }
 207         } catch (IOException | MimeTypeException ignored) {
 208         }
<abbr title=" 209         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 209         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtðŸ”µ</abbr>
 210     }
 211 
 212     public void validateFileExtension(MultipartFile file) throws IOException {
 213         final String extension = getFileExtension(file);
 214         if (disabledFileExtensions != null &amp;&amp; !disabledFileExtensions.isEmpty()) {
<abbr title=" 215             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 215             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\sðŸ”µ</abbr>
 216             LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 217             if (extensions.contains(extension)) {
 218                 LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 219                 throw new IOException(&quot;Invalid extension type of file.&quot;);
 220             }
 221         }
 222     }
 223 
 224     @Override
 225     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 226     public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 227         try {
 228             validateFileExtension(file);
 229             staticAssetStorageService.validateFileSize(file);
 230             String fileName = normalizeFileExtension(file);
 231             boolean b = validateFileName(fileName);
 232             if(b){
<abbr title=" 233                 fileName = fileName.replaceAll(&quot;[&quot; + String.valueOf(notAllowedCharsInFileName) + &quot;]&quot;, replacementString);"> 233                 fileName = fileName.replaceAll(&quot;[&quot; + String.valueOf(notAllowedCharsInFileName) + &quot;]&quot;, repðŸ”µ</abbr>
 234             }
 235             return createStaticAsset(file.getInputStream(), fileName, file.getSize(), properties);
 236         } catch (IOException e) {
 237             throw new RuntimeException(e);
 238         }
 239     }
 240 
 241     protected boolean validateFileName(String fileName) {
 242         boolean result = StringUtils.containsAny(fileName, notAllowedCharsInFileName);
 243         if(exceptionOnInvalidChar &amp;&amp; result){
<abbr title=" 244             throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOf(notAllowedCharsInFileName)+&quot;]&quot;);"> 244             throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOðŸ”µ</abbr>
 245         }
 246         return result;
 247     }
 248 
 249     @Override
 250     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 251     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 251     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;StrðŸ”µ</abbr>
 252         if (properties == null) {
 253             properties = new HashMap&lt;String, String&gt;();
 254         }
 255 
 256         String fullUrl = buildAssetURL(properties, fileName);
 257         StringBuilder urlBuilder = new StringBuilder();
 258         urlBuilder.append(fullUrl);
<abbr title=" 259         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 259         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicaðŸ”µ</abbr>
 260         fullUrl = urlBuilder.toString();
 261         StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 262         // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 263         // logic for handling duplicate files.
 264         if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 265             int count = 0;
 266             while (newAsset != null) {
 267                 count++;
 268                 //try the new format first, then the old
 269                 newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 270                 if (newAsset == null) {
<abbr title=" 271                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));"> 271                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true))ðŸ”µ</abbr>
 272                 }
 273             }
 274 
 275             if (count &gt; 0) {
 276                 fullUrl = getCountUrl(fullUrl, count, false);
 277             }
 278         }
 279 
 280         try {
 281             ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 282             newAsset = new ImageStaticAssetImpl();
 283             ((ImageStaticAsset) newAsset).setWidth(metadata.getWidth());
 284             ((ImageStaticAsset) newAsset).setHeight(metadata.getHeight());
 285         } catch (Exception e) {
 286             //must not be an image stream
 287             LOG.warn(&quot;unable to convert asset:&quot; + fileName + &quot; into Image&quot;);
 288             LOG.debug(e);
 289 
 290             if (getShouldAcceptNonImageAsset()) {
 291                 newAsset = createNonImageAsset(inputStream, fileName, properties);
 292             } else {
 293                 throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 294             }
 295         }
 296         if (storeAssetsOnFileSystem) {
 297             newAsset.setStorageType(StorageType.FILESYSTEM);
 298         } else {
 299             newAsset.setStorageType(StorageType.DATABASE);
 300         }
 301 
 302         newAsset.setName(fileName);
 303         getMimeType(inputStream, fileName, newAsset);
 304         newAsset.setFileExtension(getFileExtension(fileName));
 305         newAsset.setFileSize(fileSize);
 306         newAsset.setFullUrl(fullUrl);
 307 
 308         return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 309     }
 310 
 311     /**
 312      * Hook-point for implementors to add custom business logic for handling files that are non-images
 313      *
 314      * @param inputStream
 315      * @param fileName
 316      * @param properties
 317      * @return
 318      */
<abbr title=" 319     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 319     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, StrinðŸ”µ</abbr>
 320         return new StaticAssetImpl();
 321     }
 322 
 323     /**
<abbr title=" 324      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:"> 324      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return UðŸ”µ</abbr>
 325      * &lt;p&gt;
 326      * /path/to/image.jpg-1
 327      * /path/to/image.jpg-2
 328      * &lt;p&gt;
 329      * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 330      * &lt;p&gt;
 331      * /path/to/image-1.jpg
 332      * /path/to/image-2.jpg
 333      * &lt;p&gt;
 334      * Used to deal with duplicate URLs of uploaded assets
 335      */
 336     protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 337         String countUrl = fullUrl + &#x27;-&#x27; + count;
 338         int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 339         if (dotIndex != -1 &amp;&amp; !legacyFormat) {
<abbr title=" 340             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + 1);"> 340             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + ðŸ”µ</abbr>
 341         }
 342 
 343         return countUrl;
 344     }
 345 
 346     protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 347         Tika tika = new Tika();
 348         String tikaMimeType = tika.detect(fileName);
 349         if (tikaMimeType == null) {
 350             try {
 351                 tikaMimeType = tika.detect(inputStream);
 352             } catch (IOException e) {
 353                 //if tika can&#x27;t resolve, don&#x27;t throw exception
 354             }
 355         }
 356         if (tikaMimeType != null) {
 357             newAsset.setMimeType(tikaMimeType);
 358         }
 359     }
 360 
 361     @Override
 362     public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 363         try {
 364             fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 365             //strip out the jsessionid if it&#x27;s there
 366             fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 367         } catch (UnsupportedEncodingException e) {
 368             throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 369         }
 370         return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 371     }
 372 
 373     @Override
 374     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 375     public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 376         StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 377         return newAsset;
 378     }
 379 
 380     @Override
 381     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 382     public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 383         return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 384     }
 385 
 386     @Override
 387     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 388     public void deleteStaticAsset(StaticAsset staticAsset) {
 389         staticAssetDao.delete(staticAsset);
 390     }
 391 
 392     @Override
 393     public String getStaticAssetUrlPrefix() {
 394         return staticAssetPathService.getStaticAssetUrlPrefix();
 395     }
 396 
 397     @Override
 398     public String getPrefixedStaticAssetUrl(String assetUrl) {
 399         String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 400         if (staticAssetUrlPrefix != null &amp;&amp; !staticAssetUrlPrefix.startsWith(&quot;/&quot;)) {
 401             staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 402         }
 403         if (staticAssetUrlPrefix != null) {
 404             return staticAssetUrlPrefix + assetUrl;
 405         }
 406         return assetUrl;
 407     }
 408 
 409     @Override
 410     public String getStaticAssetEnvironmentUrlPrefix() {
 411         return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 412     }
 413 
 414     @Override
 415     public String getStaticAssetEnvironmentSecureUrlPrefix() {
 416         return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 417     }
 418 
 419     @Override
 420     public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 421         return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 422     }
 423 
 424     public boolean getShouldAcceptNonImageAsset() {
 425         return shouldAcceptNonImageAsset;
 426     }
 427 
 428     public void setShouldAcceptNonImageAsset(boolean accept) {
 429         shouldAcceptNonImageAsset = accept;
 430     }
 431 }</pre></td>
                            <td><pre>   1 /*-
   2  * #%L
   3  * BroadleafCommerce CMS Module
   4  * %%
   5  * Copyright (C) 2009 - 2023 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.cms.file.service;
  19 
  20 import org.apache.commons.io.FilenameUtils;
  21 import org.apache.commons.lang3.StringUtils;
  22 import org.apache.commons.logging.Log;
  23 import org.apache.commons.logging.LogFactory;
  24 import org.apache.tika.Tika;
  25 import org.apache.tika.mime.MimeType;
  26 import org.apache.tika.mime.MimeTypeException;
  27 import org.apache.tika.mime.MimeTypes;
  28 import org.broadleafcommerce.cms.field.type.StorageType;
  29 import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  30 import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  31 import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  32 import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  33 import org.broadleafcommerce.cms.file.domain.StaticAsset;
  34 import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  35 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  36 import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  37 import org.broadleafcommerce.common.util.StringUtil;
  38 import org.broadleafcommerce.common.util.TransactionUtils;
  39 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  40 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  41 import org.springframework.beans.factory.annotation.Value;
  42 import org.springframework.stereotype.Service;
  43 import org.springframework.transaction.annotation.Transactional;
  44 import org.springframework.web.multipart.MultipartFile;
  45 
  46 import java.io.IOException;
  47 import java.io.InputStream;
  48 import java.io.UnsupportedEncodingException;
  49 import java.net.URLDecoder;
  50 import java.util.Arrays;
  51 import java.util.HashMap;
  52 import java.util.List;
  53 import java.util.Map;
  54 import java.util.Random;
  55 
  56 import javax.annotation.Resource;
  57 
  58 /**
  59  * Created by bpolster.
  60  */
  61 @Service(&quot;blStaticAssetService&quot;)
  62 public class StaticAssetServiceImpl implements StaticAssetService {
  63 
  64     private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
<abbr title="  65     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;">  65     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extensionðŸ”µ</abbr>
  66 
  67     @Resource(name = &quot;blImageArtifactProcessor&quot;)
  68     protected ImageArtifactProcessor imageArtifactProcessor;
  69 
  70     @Value(&quot;${asset.use.filesystem.storage}&quot;)
  71     protected boolean storeAssetsOnFileSystem = false;
  72 
  73     @Resource(name = &quot;blStaticAssetDao&quot;)
  74     protected StaticAssetDao staticAssetDao;
  75 
  76     @Resource(name = &quot;blStaticAssetStorageService&quot;)
  77     protected StaticAssetStorageService staticAssetStorageService;
  78 
  79     @Resource(name = &quot;blStaticAssetPathService&quot;)
  80     protected StaticAssetPathService staticAssetPathService;
  81 
  82     @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
  83     protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
  84 
  85     @Value(&quot;${should.accept.non.image.asset:true}&quot;)
  86     protected boolean shouldAcceptNonImageAsset;
  87 
  88     @Value(&quot;${disabled.file.extensions}&quot;)
  89     protected String disabledFileExtensions;
  90 
  91     private final Random random = new Random();
  92     private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
  93 
  94     @Value(&quot;${static.asset.invalid.chars.in.filename}&quot;)
  95     protected char[] notAllowedCharsInFileName;
  96 
  97     @Value(&quot;${static.asset.exception.on.invalid.char.in.filename:false}&quot;)
  98     protected boolean exceptionOnInvalidChar = false;
  99 
 100     @Value(&quot;${static.asset.invalid.chars.replacement}&quot;)
 101     protected String replacementString;
 102 
 103     @Override
 104     public StaticAsset findStaticAssetById(Long id) {
 105         return staticAssetDao.readStaticAssetById(id);
 106     }
 107 
 108     @Override
 109     public List&lt;StaticAsset&gt; readAllStaticAssets() {
 110         return staticAssetDao.readAllStaticAssets();
 111     }
 112 
 113     @Override
 114     public Long findTotalStaticAssetCount() {
 115         return staticAssetDao.readTotalStaticAssetCount();
 116     }
 117 
 118     protected String getFileExtension(String fileName) {
 119         int pos = fileName.lastIndexOf(&quot;.&quot;);
 120         if (pos &gt; 0) {
 121             return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 122         } else {
 123             LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 124             return null;
 125         }
 126     }
 127 
 128     /**
 129      * Generates a filename as a set of Hex digits.
 130      *
 131      * @param size
 132      * @return
 133      */
 134     protected String generateFileName(int size) {
 135         StringBuilder sb = new StringBuilder();
 136         for (int i = 0; i &lt; size; i++) {
 137             int pos = random.nextInt(FILE_NAME_CHARS.length());
 138             sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 139         }
 140         return sb.toString();
 141     }
 142 
 143     /**
 144      * Will assemble the url from the passed in properties as
 145      * /{entityType}/{fileName}
 146      * /product/7001-ab12
 147      * &lt;p&gt;
 148      * If the properties above are not set, it will generate the fileName randomly.
 149      *
 150      * @param url
 151      * @param asset
 152      * @param assetProperties
 153      * @return
 154      */
 155     protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 156         StringBuilder path = new StringBuilder(&quot;/&quot;);
 157 
 158         String entityType = assetProperties.get(&quot;entityType&quot;);
 159         String entityId = assetProperties.get(&quot;entityId&quot;);
 160         String fileName = assetProperties.get(&quot;fileName&quot;);
 161 
 162         if (entityType != null &amp;&amp; !&quot;null&quot;.equals(entityType)) {
 163             path = path.append(entityType).append(&quot;/&quot;);
 164         }
 165 
 166         if (entityId != null &amp;&amp; !&quot;null&quot;.equals(entityId)) {
 167             path = path.append(entityId).append(&quot;/&quot;);
 168         }
 169 
 170         if (fileName != null) {
 171             int pos = fileName.indexOf(&quot;:&quot;);
 172             if (pos &gt; 0) {
 173                 if (LOG.isTraceEnabled()) {
 174                     LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 175                 }
 176                 fileName = fileName.substring(pos + 1);
 177             }
 178         } else {
 179             fileName = originalFilename;
 180         }
 181 
 182         return path.append(fileName).toString();
 183     }
 184 
 185     private static String normalizeFileExtension(MultipartFile file) {
 186         int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 187         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 187         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(ðŸ”µ</abbr>
 188     }
 189 
 190     private static String getFileExtension(MultipartFile file) {
 191         String tikaExtension = null;
 192         try {
 193             final Tika tika = new Tika();
 194             final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 195             final String detectedType;
 196             detectedType = tika.detect(file.getBytes());
 197             if (detectedType != null &amp;&amp; !detectedType.isEmpty()) {
 198                 final MimeType mimeType = allTypes.forName(detectedType);
 199                 tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 200             }
 201         } catch (IOException | MimeTypeException ignored) {
 202         }
<abbr title=" 203         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 203         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtðŸ”µ</abbr>
 204     }
 205 
 206     public void validateFileExtension(MultipartFile file) throws IOException {
 207         final String extension = getFileExtension(file);
 208         if (disabledFileExtensions != null &amp;&amp; !disabledFileExtensions.isEmpty()) {
<abbr title=" 209             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 209             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\sðŸ”µ</abbr>
 210             LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 211             if (extensions.contains(extension)) {
 212                 LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 213                 throw new IOException(&quot;Invalid extension type of file.&quot;);
 214             }
 215         }
 216     }
 217 
 218     @Override
 219     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 220     public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 221         try {
 222             validateFileExtension(file);
 223             staticAssetStorageService.validateFileSize(file);
 224             String fileName = normalizeFileExtension(file);
 225             boolean b = validateFileName(fileName);
 226             if(b){
<abbr title=" 227                 fileName = fileName.replaceAll(&quot;[&quot; + String.valueOf(notAllowedCharsInFileName) + &quot;]&quot;, replacementString);"> 227                 fileName = fileName.replaceAll(&quot;[&quot; + String.valueOf(notAllowedCharsInFileName) + &quot;]&quot;, repðŸ”µ</abbr>
 228             }
 229             return createStaticAsset(file.getInputStream(), fileName, file.getSize(), properties);
 230         } catch (IOException e) {
 231             throw new RuntimeException(e);
 232         }
 233     }
 234 
 235     protected boolean validateFileName(String fileName) {
 236         boolean result = StringUtils.containsAny(fileName, notAllowedCharsInFileName);
 237         if(exceptionOnInvalidChar &amp;&amp; result){
<abbr title=" 238             throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOf(notAllowedCharsInFileName)+&quot;]&quot;);"> 238             throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOðŸ”µ</abbr>
 239         }
 240         return result;
 241     }
 242 
 243     @Override
 244     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 245     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 245     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;StrðŸ”µ</abbr>
 246         if (properties == null) {
 247             properties = new HashMap&lt;String, String&gt;();
 248         }
 249 
 250         String fullUrl = buildAssetURL(properties, fileName);
 251         StringBuilder urlBuilder = new StringBuilder();
 252         urlBuilder.append(fullUrl);
<abbr title=" 253         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 253         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicaðŸ”µ</abbr>
 254         fullUrl = urlBuilder.toString();
 255         StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 256         // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 257         // logic for handling duplicate files.
 258         if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 259             int count = 0;
 260             while (newAsset != null) {
 261                 count++;
 262                 //try the new format first, then the old
 263                 newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 264                 if (newAsset == null) {
<abbr title=" 265                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));"> 265                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true))ðŸ”µ</abbr>
 266                 }
 267             }
 268 
 269             if (count &gt; 0) {
 270                 fullUrl = getCountUrl(fullUrl, count, false);
 271             }
 272         }
 273 
 274         try {
 275             ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 276             newAsset = new ImageStaticAssetImpl();
 277             ((ImageStaticAsset) newAsset).setWidth(metadata.getWidth());
 278             ((ImageStaticAsset) newAsset).setHeight(metadata.getHeight());
 279         } catch (Exception e) {
 280             //must not be an image stream
 281             LOG.warn(&quot;unable to convert asset:&quot; + fileName + &quot; into Image&quot;);
 282             LOG.debug(e);
 283 
 284             if (getShouldAcceptNonImageAsset()) {
 285                 newAsset = createNonImageAsset(inputStream, fileName, properties);
 286             } else {
 287                 throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 288             }
 289         }
 290         if (storeAssetsOnFileSystem) {
 291             newAsset.setStorageType(StorageType.FILESYSTEM);
 292         } else {
 293             newAsset.setStorageType(StorageType.DATABASE);
 294         }
 295 
 296         newAsset.setName(fileName);
 297         getMimeType(inputStream, fileName, newAsset);
 298         newAsset.setFileExtension(getFileExtension(fileName));
 299         newAsset.setFileSize(fileSize);
 300         newAsset.setFullUrl(fullUrl);
 301 
 302         return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 303     }
 304 
 305     /**
 306      * Hook-point for implementors to add custom business logic for handling files that are non-images
 307      *
 308      * @param inputStream
 309      * @param fileName
 310      * @param properties
 311      * @return
 312      */
<abbr title=" 313     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 313     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, StrinðŸ”µ</abbr>
 314         return new StaticAssetImpl();
 315     }
 316 
 317     /**
<abbr title=" 318      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:"> 318      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return UðŸ”µ</abbr>
 319      * &lt;p&gt;
 320      * /path/to/image.jpg-1
 321      * /path/to/image.jpg-2
 322      * &lt;p&gt;
 323      * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 324      * &lt;p&gt;
 325      * /path/to/image-1.jpg
 326      * /path/to/image-2.jpg
 327      * &lt;p&gt;
 328      * Used to deal with duplicate URLs of uploaded assets
 329      */
 330     protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 331         String countUrl = fullUrl + &#x27;-&#x27; + count;
 332         int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 333         if (dotIndex != -1 &amp;&amp; !legacyFormat) {
<abbr title=" 334             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + 1);"> 334             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + ðŸ”µ</abbr>
 335         }
 336 
 337         return countUrl;
 338     }
 339 
 340     protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 341         Tika tika = new Tika();
 342         String tikaMimeType = tika.detect(fileName);
 343         if (tikaMimeType == null) {
 344             try {
 345                 tikaMimeType = tika.detect(inputStream);
 346             } catch (IOException e) {
 347                 //if tika can&#x27;t resolve, don&#x27;t throw exception
 348             }
 349         }
 350         if (tikaMimeType != null) {
 351             newAsset.setMimeType(tikaMimeType);
 352         }
 353     }
 354 
 355     @Override
 356     public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 357         try {
 358             fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 359             //strip out the jsessionid if it&#x27;s there
 360             fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 361         } catch (UnsupportedEncodingException e) {
 362             throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 363         }
 364         return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 365     }
 366 
 367     @Override
 368     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 369     public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 370         StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 371         return newAsset;
 372     }
 373 
 374     @Override
 375     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 376     public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 377         return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 378     }
 379 
 380     @Override
 381     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 382     public void deleteStaticAsset(StaticAsset staticAsset) {
 383         staticAssetDao.delete(staticAsset);
 384     }
 385 
 386     @Override
 387     public String getStaticAssetUrlPrefix() {
 388         return staticAssetPathService.getStaticAssetUrlPrefix();
 389     }
 390 
 391     @Override
 392     public String getPrefixedStaticAssetUrl(String assetUrl) {
 393         String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 394         if (staticAssetUrlPrefix != null &amp;&amp; !staticAssetUrlPrefix.startsWith(&quot;/&quot;)) {
 395             staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 396         }
 397         if (staticAssetUrlPrefix != null) {
 398             return staticAssetUrlPrefix + assetUrl;
 399         }
 400         return assetUrl;
 401     }
 402 
 403     @Override
 404     public String getStaticAssetEnvironmentUrlPrefix() {
 405         return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 406     }
 407 
 408     @Override
 409     public String getStaticAssetEnvironmentSecureUrlPrefix() {
 410         return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 411     }
 412 
 413     @Override
 414     public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 415         return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 416     }
 417 
 418     public boolean getShouldAcceptNonImageAsset() {
 419         return shouldAcceptNonImageAsset;
 420     }
 421 
 422     public void setShouldAcceptNonImageAsset(boolean accept) {
 423         shouldAcceptNonImageAsset = accept;
 424     }
 425 }
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*-
   2  * #%L
   3  * BroadleafCommerce CMS Module
   4  * %%
   5  * Copyright (C) 2009 - 2023 Broadleaf Commerce
   6  * %%
   7  * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
   8  * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
   9  * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  10  * the Broadleaf End User License Agreement (EULA), Version 1.1
  11  * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  12  * shall apply.
  13  *
<abbr title="  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  14  * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;CustomðŸ”µ</abbr>
<abbr title="  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.">  15  * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicableðŸ”µ</abbr>
  16  * #L%
  17  */
  18 package org.broadleafcommerce.cms.file.service;
  19 
  20 import java.io.IOException;
  21 import java.io.InputStream;
  22 import java.io.UnsupportedEncodingException;
  23 import java.net.URLDecoder;
  24 import java.util.Arrays;
  25 import java.util.HashMap;
  26 import java.util.List;
  27 import java.util.Map;
  28 import java.util.Random;
  29 import javax.annotation.Resource;
  30 import org.apache.commons.io.FilenameUtils;
  31 import org.apache.commons.lang3.StringUtils;
  32 import org.apache.commons.logging.Log;
  33 import org.apache.commons.logging.LogFactory;
  34 import org.apache.tika.Tika;
  35 import org.apache.tika.mime.MimeType;
  36 import org.apache.tika.mime.MimeTypeException;
  37 import org.apache.tika.mime.MimeTypes;
  38 import org.broadleafcommerce.cms.field.type.StorageType;
  39 import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  40 import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  41 import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  42 import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  43 import org.broadleafcommerce.cms.file.domain.StaticAsset;
  44 import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  45 import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  46 import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  47 import org.broadleafcommerce.common.util.StringUtil;
  48 import org.broadleafcommerce.common.util.TransactionUtils;
  49 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  50 import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  51 import org.springframework.beans.factory.annotation.Value;
  52 import org.springframework.stereotype.Service;
  53 import org.springframework.transaction.annotation.Transactional;
  54 import org.springframework.web.multipart.MultipartFile;
  55 
  56 
  57 /**
  58  * Created by bpolster.
  59  */
  60 @Service(&quot;blStaticAssetService&quot;)
  61 public class StaticAssetServiceImpl implements StaticAssetService {
  62     private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
  63 
<abbr title="  64     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;">  64     private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extensionðŸ”µ</abbr>
  65 
  66     @Resource(name = &quot;blImageArtifactProcessor&quot;)
  67     protected ImageArtifactProcessor imageArtifactProcessor;
  68 
  69     @Value(&quot;${asset.use.filesystem.storage}&quot;)
  70     protected boolean storeAssetsOnFileSystem = false;
  71 
  72     @Resource(name = &quot;blStaticAssetDao&quot;)
  73     protected StaticAssetDao staticAssetDao;
  74 
  75     @Resource(name = &quot;blStaticAssetStorageService&quot;)
  76     protected StaticAssetStorageService staticAssetStorageService;
  77 
  78     @Resource(name = &quot;blStaticAssetPathService&quot;)
  79     protected StaticAssetPathService staticAssetPathService;
  80 
  81     @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
  82     protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
  83 
  84     @Value(&quot;${should.accept.non.image.asset:true}&quot;)
  85     protected boolean shouldAcceptNonImageAsset;
  86 
  87     @Value(&quot;${disabled.file.extensions}&quot;)
  88     protected String disabledFileExtensions;
  89 
  90     private final Random random = new Random();
  91 
  92     private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
  93 
  94     @Value(&quot;${static.asset.invalid.chars.in.filename}&quot;)
  95     protected char[] notAllowedCharsInFileName;
  96 
  97     @Value(&quot;${static.asset.exception.on.invalid.char.in.filename:false}&quot;)
  98     protected boolean exceptionOnInvalidChar = false;
  99 
 100     @Value(&quot;${static.asset.invalid.chars.replacement}&quot;)
 101     protected String replacementString;
 102 
 103     @Override
 104     public StaticAsset findStaticAssetById(Long id) {
 105         return staticAssetDao.readStaticAssetById(id);
 106     }
 107 
 108     @Override
 109     public List&lt;StaticAsset&gt; readAllStaticAssets() {
 110         return staticAssetDao.readAllStaticAssets();
 111     }
 112 
 113     @Override
 114     public Long findTotalStaticAssetCount() {
 115         return staticAssetDao.readTotalStaticAssetCount();
 116     }
 117 
 118     protected String getFileExtension(String fileName) {
 119         int pos = fileName.lastIndexOf(&quot;.&quot;);
 120         if (pos &gt; 0) {
 121             return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 122         } else {
 123             LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 124             return null;
 125         }
 126     }
 127 
 128     /**
 129      * Generates a filename as a set of Hex digits.
 130      *
 131      * @param size
 132      * @return
 133      */
 134     protected String generateFileName(int size) {
 135         StringBuilder sb = new StringBuilder();
 136         for (int i = 0; i &lt; size; i++) {
 137             int pos = random.nextInt(FILE_NAME_CHARS.length());
 138             sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 139         }
 140         return sb.toString();
 141     }
 142 
 143     /**
 144      * Will assemble the url from the passed in properties as
 145      * /{entityType}/{fileName}
 146      * /product/7001-ab12
 147      * &lt;p&gt;
 148      * If the properties above are not set, it will generate the fileName randomly.
 149      *
 150      * @param url
 151      * @param asset
 152      * @param assetProperties
 153      * @return
 154      */
 155     protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 156         StringBuilder path = new StringBuilder(&quot;/&quot;);
 157 
 158         String entityType = assetProperties.get(&quot;entityType&quot;);
 159         String entityId = assetProperties.get(&quot;entityId&quot;);
 160         String fileName = assetProperties.get(&quot;fileName&quot;);
 161 
 162         if (entityType != null &amp;&amp; !&quot;null&quot;.equals(entityType)) {
 163             path = path.append(entityType).append(&quot;/&quot;);
 164         }
 165 
 166         if (entityId != null &amp;&amp; !&quot;null&quot;.equals(entityId)) {
 167             path = path.append(entityId).append(&quot;/&quot;);
 168         }
 169 
 170         if (fileName != null) {
 171             int pos = fileName.indexOf(&quot;:&quot;);
 172             if (pos &gt; 0) {
 173                 if (LOG.isTraceEnabled()) {
 174                     LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 175                 }
 176                 fileName = fileName.substring(pos + 1);
 177             }
 178         } else {
 179             fileName = originalFilename;
 180         }
 181 
 182         return path.append(fileName).toString();
 183     }
 184 
 185     private static String normalizeFileExtension(MultipartFile file) {
 186         int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 187         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 187         return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(ðŸ”µ</abbr>
 188     }
 189 
 190     private static String getFileExtension(MultipartFile file) {
 191         String tikaExtension = null;
 192         try {
 193             final Tika tika = new Tika();
 194             final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 195             final String detectedType;
 196             detectedType = tika.detect(file.getBytes());
 197             if (detectedType != null &amp;&amp; !detectedType.isEmpty()) {
 198                 final MimeType mimeType = allTypes.forName(detectedType);
 199                 tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 200             }
 201         } catch (IOException | MimeTypeException ignored) {
 202         }
<abbr title=" 203         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 203         return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtðŸ”µ</abbr>
 204     }
 205 
 206     public void validateFileExtension(MultipartFile file) throws IOException {
 207         final String extension = getFileExtension(file);
 208         if (disabledFileExtensions != null &amp;&amp; !disabledFileExtensions.isEmpty()) {
<abbr title=" 209             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 209             final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\sðŸ”µ</abbr>
 210             LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 211             if (extensions.contains(extension)) {
 212                 LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 213                 throw new IOException(&quot;Invalid extension type of file.&quot;);
 214             }
 215         }
 216     }
 217 
 218     @Override
 219     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 220     public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 221         try {
 222             validateFileExtension(file);
 223             staticAssetStorageService.validateFileSize(file);
 224             String fileName = normalizeFileExtension(file);
 225             boolean b = validateFileName(fileName);
 226             if (b) {
<abbr title=" 227                 fileName = fileName.replaceAll((&quot;[&quot; + String.valueOf(notAllowedCharsInFileName)) + &quot;]&quot;, replacementString);"> 227                 fileName = fileName.replaceAll((&quot;[&quot; + String.valueOf(notAllowedCharsInFileName)) + &quot;]&quot;, rðŸ”µ</abbr>
 228             }
 229             return createStaticAsset(file.getInputStream(), fileName, file.getSize(), properties);
 230         } catch (IOException e) {
 231             throw new RuntimeException(e);
 232         }
 233     }
 234 
 235     protected boolean validateFileName(String fileName) {
 236         boolean result = StringUtils.containsAny(fileName, notAllowedCharsInFileName);
 237         if(exceptionOnInvalidChar &amp;&amp; result){
<abbr title=" 238             throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOf(notAllowedCharsInFileName)+&quot;]&quot;);"> 238             throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOðŸ”µ</abbr>
 239         }
 240         return result;
 241     }
 242 
 243     @Override
 244     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 245     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 245     public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;StrðŸ”µ</abbr>
 246         if (properties == null) {
 247             properties = new HashMap&lt;String, String&gt;();
 248         }
 249 
 250         String fullUrl = buildAssetURL(properties, fileName);
 251         StringBuilder urlBuilder = new StringBuilder();
 252         urlBuilder.append(fullUrl);
<abbr title=" 253         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 253         ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicaðŸ”µ</abbr>
 254         fullUrl = urlBuilder.toString();
 255         StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 256         // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 257         // logic for handling duplicate files.
 258         if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 259             int count = 0;
 260             while (newAsset != null) {
 261                 count++;
 262                 //try the new format first, then the old
 263                 newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 264                 if (newAsset == null) {
<abbr title=" 265                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));"> 265                     newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true))ðŸ”µ</abbr>
 266                 }
 267             }
 268 
 269             if (count &gt; 0) {
 270                 fullUrl = getCountUrl(fullUrl, count, false);
 271             }
 272         }
 273 
 274         try {
 275             ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 276             newAsset = new ImageStaticAssetImpl();
 277             ((ImageStaticAsset) newAsset).setWidth(metadata.getWidth());
 278             ((ImageStaticAsset) newAsset).setHeight(metadata.getHeight());
 279         } catch (Exception e) {
 280             //must not be an image stream
 281             LOG.warn(&quot;unable to convert asset:&quot; + fileName + &quot; into Image&quot;);
 282             LOG.debug(e);
 283 
 284             if (getShouldAcceptNonImageAsset()) {
 285                 newAsset = createNonImageAsset(inputStream, fileName, properties);
 286             } else {
 287                 throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 288             }
 289         }
 290         if (storeAssetsOnFileSystem) {
 291             newAsset.setStorageType(StorageType.FILESYSTEM);
 292         } else {
 293             newAsset.setStorageType(StorageType.DATABASE);
 294         }
 295 
 296         newAsset.setName(fileName);
 297         getMimeType(inputStream, fileName, newAsset);
 298         newAsset.setFileExtension(getFileExtension(fileName));
 299         newAsset.setFileSize(fileSize);
 300         newAsset.setFullUrl(fullUrl);
 301 
 302         return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 303     }
 304 
 305     /**
 306      * Hook-point for implementors to add custom business logic for handling files that are non-images
 307      *
 308      * @param inputStream
 309      * @param fileName
 310      * @param properties
 311      * @return
 312      */
<abbr title=" 313     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 313     protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, StrinðŸ”µ</abbr>
 314         return new StaticAssetImpl();
 315     }
 316 
 317     /**
<abbr title=" 318      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:"> 318      * Gets the count URL based on the original fullUrl. If requested in legacy format this will return UðŸ”µ</abbr>
 319      * &lt;p&gt;
 320      * /path/to/image.jpg-1
 321      * /path/to/image.jpg-2
 322      * &lt;p&gt;
 323      * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 324      * &lt;p&gt;
 325      * /path/to/image-1.jpg
 326      * /path/to/image-2.jpg
 327      * &lt;p&gt;
 328      * Used to deal with duplicate URLs of uploaded assets
 329      */
 330     protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 331         String countUrl = fullUrl + &#x27;-&#x27; + count;
 332         int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 333         if (dotIndex != -1 &amp;&amp; !legacyFormat) {
<abbr title=" 334             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + 1);"> 334             countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + ðŸ”µ</abbr>
 335         }
 336 
 337         return countUrl;
 338     }
 339 
 340     protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 341         Tika tika = new Tika();
 342         String tikaMimeType = tika.detect(fileName);
 343         if (tikaMimeType == null) {
 344             try {
 345                 tikaMimeType = tika.detect(inputStream);
 346             } catch (IOException e) {
 347                 //if tika can&#x27;t resolve, don&#x27;t throw exception
 348             }
 349         }
 350         if (tikaMimeType != null) {
 351             newAsset.setMimeType(tikaMimeType);
 352         }
 353     }
 354 
 355     @Override
 356     public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 357         try {
 358             fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 359             //strip out the jsessionid if it&#x27;s there
 360             fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 361         } catch (UnsupportedEncodingException e) {
 362             throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 363         }
 364         return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 365     }
 366 
 367     @Override
 368     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 369     public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 370         StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 371         return newAsset;
 372     }
 373 
 374     @Override
 375     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 376     public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 377         return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 378     }
 379 
 380     @Override
 381     @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 382     public void deleteStaticAsset(StaticAsset staticAsset) {
 383         staticAssetDao.delete(staticAsset);
 384     }
 385 
 386     @Override
 387     public String getStaticAssetUrlPrefix() {
 388         return staticAssetPathService.getStaticAssetUrlPrefix();
 389     }
 390 
 391     @Override
 392     public String getPrefixedStaticAssetUrl(String assetUrl) {
 393         String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 394         if (staticAssetUrlPrefix != null &amp;&amp; !staticAssetUrlPrefix.startsWith(&quot;/&quot;)) {
 395             staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 396         }
 397         if (staticAssetUrlPrefix != null) {
 398             return staticAssetUrlPrefix + assetUrl;
 399         }
 400         return assetUrl;
 401     }
 402 
 403     @Override
 404     public String getStaticAssetEnvironmentUrlPrefix() {
 405         return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 406     }
 407 
 408     @Override
 409     public String getStaticAssetEnvironmentSecureUrlPrefix() {
 410         return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 411     }
 412 
 413     @Override
 414     public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 415         return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 416     }
 417 
 418     public boolean getShouldAcceptNonImageAsset() {
 419         return shouldAcceptNonImageAsset;
 420     }
 421 
 422     public void setShouldAcceptNonImageAsset(boolean accept) {
 423         shouldAcceptNonImageAsset = accept;
 424     }
 425 }
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre><span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   1 -/*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   2 +/*-</span>
   3   * #%L
   4   * BroadleafCommerce CMS Module
   5   * %%
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   6 - * Copyright (C) 2009 - 2018 Broadleaf Commerce</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   7 - * %%</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   8 - * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   9 - * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  10 - * unless the restrictions on use therein are violated and require payment to Broadleaf in which case</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  11 - * the Broadleaf End User License Agreement (EULA), Version 1.1</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  12 - * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  13 - * shall apply.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  14 - *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  15 - * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  15 - * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  16 - * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  17 - * #L%</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  18 - */</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  19 -/*</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  20 - * BroadleafCommerce CMS Module</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  21 - * %%</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 - * Copyright (C) 2009 - 2016 Broadleaf Commerce</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 + * Copyright (C) 2009 - 2023 Broadleaf Commerce</span>
  24   * %%
  25   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
  26   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
  27   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  28   * the Broadleaf End User License Agreement (EULA), Version 1.1
  29   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  30   * shall apply.
  31   *
<abbr title="  32   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  32   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  33   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  34   * #L%
  35   */

  36  package org.broadleafcommerce.cms.file.service;
  37  
  38  import org.apache.commons.io.FilenameUtils;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  39 +import org.apache.commons.lang3.StringUtils;</span>
  40  import org.apache.commons.logging.Log;
  41  import org.apache.commons.logging.LogFactory;
  42  import org.apache.tika.Tika;
  43  import org.apache.tika.mime.MimeType;
  44  import org.apache.tika.mime.MimeTypeException;
  45  import org.apache.tika.mime.MimeTypes;
  46  import org.broadleafcommerce.cms.field.type.StorageType;
  47  import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  48  import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  49  import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  50  import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  51  import org.broadleafcommerce.cms.file.domain.StaticAsset;
  52  import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  53  import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  54  import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  55  import org.broadleafcommerce.common.util.StringUtil;
  56  import org.broadleafcommerce.common.util.TransactionUtils;
  57  import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  58  import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  59  import org.springframework.beans.factory.annotation.Value;
  60  import org.springframework.stereotype.Service;
  61  import org.springframework.transaction.annotation.Transactional;
  62  import org.springframework.web.multipart.MultipartFile;
  63  
  64  import java.io.IOException;
  65  import java.io.InputStream;
  66  import java.io.UnsupportedEncodingException;
  67  import java.net.URLDecoder;
  68  import java.util.Arrays;
  69  import java.util.HashMap;
  70  import java.util.List;
  71  import java.util.Map;
  72  import java.util.Random;
  73  
  74  import javax.annotation.Resource;
  75  
  76  /**
  77   * Created by bpolster.
  78   */
  79  @Service(&quot;blStaticAssetService&quot;)
  80  public class StaticAssetServiceImpl implements StaticAssetService {
  81  
  82      private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
<abbr title="  83      private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;">  83      private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of ðŸ”µ</abbr>
  84  
  85      @Resource(name = &quot;blImageArtifactProcessor&quot;)
  86      protected ImageArtifactProcessor imageArtifactProcessor;
  87  
  88      @Value(&quot;${asset.use.filesystem.storage}&quot;)
  89      protected boolean storeAssetsOnFileSystem = false;
  90  
  91      @Resource(name = &quot;blStaticAssetDao&quot;)
  92      protected StaticAssetDao staticAssetDao;
  93  
  94      @Resource(name = &quot;blStaticAssetStorageService&quot;)
  95      protected StaticAssetStorageService staticAssetStorageService;
  96  
  97      @Resource(name = &quot;blStaticAssetPathService&quot;)
  98      protected StaticAssetPathService staticAssetPathService;
  99  
 100      @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
 101      protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
 102  
 103      @Value(&quot;${should.accept.non.image.asset:true}&quot;)
 104      protected boolean shouldAcceptNonImageAsset;
 105  
 106      @Value(&quot;${disabled.file.extensions}&quot;)
 107      protected String disabledFileExtensions;
 108  
 109      private final Random random = new Random();
 110      private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
 111  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 112 +    @Value(&quot;${static.asset.invalid.chars.in.filename}&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +    protected char[] notAllowedCharsInFileName;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 115 +    @Value(&quot;${static.asset.exception.on.invalid.char.in.filename:false}&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 116 +    protected boolean exceptionOnInvalidChar = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +    @Value(&quot;${static.asset.invalid.chars.replacement}&quot;)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +    protected String replacementString;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +</span>
 121      @Override
 122      public StaticAsset findStaticAssetById(Long id) {
 123          return staticAssetDao.readStaticAssetById(id);
 124      }
 125  
 126      @Override
 127      public List&lt;StaticAsset&gt; readAllStaticAssets() {
 128          return staticAssetDao.readAllStaticAssets();
 129      }
 130  
 131      @Override
 132      public Long findTotalStaticAssetCount() {
 133          return staticAssetDao.readTotalStaticAssetCount();
 134      }
 135  
 136      protected String getFileExtension(String fileName) {
 137          int pos = fileName.lastIndexOf(&quot;.&quot;);
 138          if (pos &gt; 0) {
 139              return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 140          } else {
 141              LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 142              return null;
 143          }
 144      }
 145  
 146      /**
 147       * Generates a filename as a set of Hex digits.
 148       *
 149       * @param size
 150       * @return
 151       */
 152      protected String generateFileName(int size) {
 153          StringBuilder sb = new StringBuilder();
 154          for (int i = 0; i &lt; size; i++) {
 155              int pos = random.nextInt(FILE_NAME_CHARS.length());
 156              sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 157          }
 158          return sb.toString();
 159      }
 160  
 161      /**
 162       * Will assemble the url from the passed in properties as
 163       * /{entityType}/{fileName}
 164       * /product/7001-ab12
 165       * &lt;p&gt;
 166       * If the properties above are not set, it will generate the fileName randomly.
 167       *
 168       * @param url
 169       * @param asset
 170       * @param assetProperties
 171       * @return
 172       */
 173      protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 174          StringBuilder path = new StringBuilder(&quot;/&quot;);
 175  
 176          String entityType = assetProperties.get(&quot;entityType&quot;);
 177          String entityId = assetProperties.get(&quot;entityId&quot;);
 178          String fileName = assetProperties.get(&quot;fileName&quot;);
 179  
 180          if (entityType != null &amp;&amp; !&quot;null&quot;.equals(entityType)) {
 181              path = path.append(entityType).append(&quot;/&quot;);
 182          }
 183  
 184          if (entityId != null &amp;&amp; !&quot;null&quot;.equals(entityId)) {
 185              path = path.append(entityId).append(&quot;/&quot;);
 186          }
 187  
 188          if (fileName != null) {
 189              int pos = fileName.indexOf(&quot;:&quot;);
 190              if (pos &gt; 0) {
 191                  if (LOG.isTraceEnabled()) {
 192                      LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 193                  }
 194                  fileName = fileName.substring(pos + 1);
 195              }
 196          } else {
 197              fileName = originalFilename;
 198          }
 199  
 200          return path.append(fileName).toString();
 201      }
 202  
 203      private static String normalizeFileExtension(MultipartFile file) {
 204          int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 205          return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 205          return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1ðŸ”µ</abbr>
 206      }
 207  
 208      private static String getFileExtension(MultipartFile file) {
 209          String tikaExtension = null;
 210          try {
 211              final Tika tika = new Tika();
 212              final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 213              final String detectedType;
 214              detectedType = tika.detect(file.getBytes());
 215              if (detectedType != null &amp;&amp; !detectedType.isEmpty()) {
 216                  final MimeType mimeType = allTypes.forName(detectedType);
 217                  tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 218              }
 219          } catch (IOException | MimeTypeException ignored) {
 220          }
<abbr title=" 221          return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 221          return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(fiðŸ”µ</abbr>
 222      }
 223  
 224      public void validateFileExtension(MultipartFile file) throws IOException {
 225          final String extension = getFileExtension(file);
 226          if (disabledFileExtensions != null &amp;&amp; !disabledFileExtensions.isEmpty()) {
<abbr title=" 227              final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 227              final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;))ðŸ”µ</abbr>
 228              LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 229              if (extensions.contains(extension)) {
 230                  LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 231                  throw new IOException(&quot;Invalid extension type of file.&quot;);
 232              }
 233          }
 234      }
 235  
 236      @Override
 237      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 238      public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 239          try {
 240              validateFileExtension(file);
 241              staticAssetStorageService.validateFileSize(file);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title=" 242 -            return createStaticAsset(file.getInputStream(), normalizeFileExtension(file), file.getSize(), properties);"> 242 -            return createStaticAsset(file.getInputStream(), normalizeFileExtension(file), file.getSize(), propertiðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +            String fileName = normalizeFileExtension(file);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +            boolean b = validateFileName(fileName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 245 +            if(b){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 246 +                fileName = fileName.replaceAll(&quot;[&quot; + String.valueOf(notAllowedCharsInFileName) + &quot;]&quot;, replacementString);"> 246 +                fileName = fileName.replaceAll(&quot;[&quot; + String.valueOf(notAllowedCharsInFileName) + &quot;]&quot;, replacementSðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 247 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +            return createStaticAsset(file.getInputStream(), fileName, file.getSize(), properties);</span>
 249          } catch (IOException e) {
 250              throw new RuntimeException(e);
 251          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +    protected boolean validateFileName(String fileName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 255 +        boolean result = StringUtils.containsAny(fileName, notAllowedCharsInFileName);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 256 +        if(exceptionOnInvalidChar &amp;&amp; result){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title=" 257 +            throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOf(notAllowedCharsInFileName)+&quot;]&quot;);"> 257 +            throw new RuntimeException(&quot;File contains illegal chars. Illegal chars are:[&quot; + String.valueOf(notAlloðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +        return result;</span>
 260      }
 261  
 262      @Override
 263      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 264      public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 264      public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, StriðŸ”µ</abbr>
 265          if (properties == null) {
 266              properties = new HashMap&lt;String, String&gt;();
 267          }
 268  
 269          String fullUrl = buildAssetURL(properties, fileName);
 270          StringBuilder urlBuilder = new StringBuilder();
 271          urlBuilder.append(fullUrl);
<abbr title=" 272          ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 272          ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURðŸ”µ</abbr>
 273          fullUrl = urlBuilder.toString();
 274          StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 275          // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 276          // logic for handling duplicate files.
 277          if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 278              int count = 0;
 279              while (newAsset != null) {
 280                  count++;
 281                  //try the new format first, then the old
 282                  newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 283                  if (newAsset == null) {
 284                      newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));
 285                  }
 286              }
 287  
 288              if (count &gt; 0) {
 289                  fullUrl = getCountUrl(fullUrl, count, false);
 290              }
 291          }
 292  
 293          try {
 294              ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 295              newAsset = new ImageStaticAssetImpl();
 296              ((ImageStaticAsset) newAsset).setWidth(metadata.getWidth());
 297              ((ImageStaticAsset) newAsset).setHeight(metadata.getHeight());
 298          } catch (Exception e) {
 299              //must not be an image stream
 300              LOG.warn(&quot;unable to convert asset:&quot; + fileName + &quot; into Image&quot;);
 301              LOG.debug(e);
 302  
 303              if (getShouldAcceptNonImageAsset()) {
 304                  newAsset = createNonImageAsset(inputStream, fileName, properties);
 305              } else {
 306                  throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 307              }
 308          }
 309          if (storeAssetsOnFileSystem) {
 310              newAsset.setStorageType(StorageType.FILESYSTEM);
 311          } else {
 312              newAsset.setStorageType(StorageType.DATABASE);
 313          }
 314  
 315          newAsset.setName(fileName);
 316          getMimeType(inputStream, fileName, newAsset);
 317          newAsset.setFileExtension(getFileExtension(fileName));
 318          newAsset.setFileSize(fileSize);
 319          newAsset.setFullUrl(fullUrl);
 320  
 321          return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 322      }
 323  
 324      /**
 325       * Hook-point for implementors to add custom business logic for handling files that are non-images
 326       *
 327       * @param inputStream
 328       * @param fileName
 329       * @param properties
 330       * @return
 331       */
<abbr title=" 332      protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 332      protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properðŸ”µ</abbr>
 333          return new StaticAssetImpl();
 334      }
 335  
 336      /**
 337       * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:
 338       * &lt;p&gt;
 339       * /path/to/image.jpg-1
 340       * /path/to/image.jpg-2
 341       * &lt;p&gt;
 342       * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 343       * &lt;p&gt;
 344       * /path/to/image-1.jpg
 345       * /path/to/image-2.jpg
 346       * &lt;p&gt;
 347       * Used to deal with duplicate URLs of uploaded assets
 348       */
 349      protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 350          String countUrl = fullUrl + &#x27;-&#x27; + count;
 351          int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 352          if (dotIndex != -1 &amp;&amp; !legacyFormat) {
 353              countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + 1);
 354          }
 355  
 356          return countUrl;
 357      }
 358  
 359      protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 360          Tika tika = new Tika();
 361          String tikaMimeType = tika.detect(fileName);
 362          if (tikaMimeType == null) {
 363              try {
 364                  tikaMimeType = tika.detect(inputStream);
 365              } catch (IOException e) {
 366                  //if tika can&#x27;t resolve, don&#x27;t throw exception
 367              }
 368          }
 369          if (tikaMimeType != null) {
 370              newAsset.setMimeType(tikaMimeType);
 371          }
 372      }
 373  
 374      @Override
 375      public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 376          try {
 377              fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 378              //strip out the jsessionid if it&#x27;s there
 379              fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 380          } catch (UnsupportedEncodingException e) {
 381              throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 382          }
 383          return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 384      }
 385  
 386      @Override
 387      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 388      public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 389          StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 390          return newAsset;
 391      }
 392  
 393      @Override
 394      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 395      public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 396          return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 397      }
 398  
 399      @Override
 400      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 401      public void deleteStaticAsset(StaticAsset staticAsset) {
 402          staticAssetDao.delete(staticAsset);
 403      }
 404  
 405      @Override
 406      public String getStaticAssetUrlPrefix() {
 407          return staticAssetPathService.getStaticAssetUrlPrefix();
 408      }
 409  
 410      @Override
 411      public String getPrefixedStaticAssetUrl(String assetUrl) {
 412          String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 413          if (staticAssetUrlPrefix != null &amp;&amp; !staticAssetUrlPrefix.startsWith(&quot;/&quot;)) {
 414              staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 415          }
 416          if (staticAssetUrlPrefix != null) {
 417              return staticAssetUrlPrefix + assetUrl;
 418          }
 419          return assetUrl;
 420      }
 421  
 422      @Override
 423      public String getStaticAssetEnvironmentUrlPrefix() {
 424          return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 425      }
 426  
 427      @Override
 428      public String getStaticAssetEnvironmentSecureUrlPrefix() {
 429          return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 430      }
 431  
 432      @Override
 433      public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 434          return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 435      }
 436  
 437      public boolean getShouldAcceptNonImageAsset() {
 438          return shouldAcceptNonImageAsset;
 439      }
 440  
 441      public void setShouldAcceptNonImageAsset(boolean accept) {
 442          shouldAcceptNonImageAsset = accept;
 443      }
 444  }</pre></td>
                            <td><pre><span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   1 -/*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   2 +/*-</span>
   3   * #%L
   4   * BroadleafCommerce CMS Module
   5   * %%
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">   6 - * Copyright (C) 2009 - 2018 Broadleaf Commerce</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   7 + * Copyright (C) 2009 - 2023 Broadleaf Commerce</span>
   8   * %%
   9   * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0
  10   * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)
  11   * unless the restrictions on use therein are violated and require payment to Broadleaf in which case
  12   * the Broadleaf End User License Agreement (EULA), Version 1.1
  13   * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)
  14   * shall apply.
  15   *
<abbr title="  16   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  16   * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr>
  17   * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.
  18   * #L%
  19   */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  20 -/*</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  21 - * BroadleafCommerce CMS Module</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  22 - * %%</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  23 - * Copyright (C) 2009 - 2016 Broadleaf Commerce</span>

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  24 - * %%</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  25 - * Licensed under the Broadleaf Fair Use License Agreement, Version 1.0</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  26 - * (the &quot;Fair Use License&quot; located  at http://license.broadleafcommerce.org/fair_use_license-1.0.txt)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  27 - * unless the restrictions on use therein are violated and require payment to Broadleaf in which case</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  28 - * the Broadleaf End User License Agreement (EULA), Version 1.1</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  29 - * (the &quot;Commercial License&quot; located at http://license.broadleafcommerce.org/commercial_license-1.1.txt)</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  30 - * shall apply.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  31 - *</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  32 - * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;)">  32 - * Alternatively, the Commercial License may be replaced with a mutually agreed upon license (the &quot;Custom License&quot;ðŸ”µ</abbr></span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  33 - * between you and Broadleaf Commerce. You may not use this file except in compliance with the applicable license.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  34 - * #L%</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  35 - */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 +</span>
  37  package org.broadleafcommerce.cms.file.service;
  38  
  39  import org.apache.commons.io.FilenameUtils;

  40  import org.apache.commons.logging.Log;
  41  import org.apache.commons.logging.LogFactory;
  42  import org.apache.tika.Tika;
  43  import org.apache.tika.mime.MimeType;
  44  import org.apache.tika.mime.MimeTypeException;
  45  import org.apache.tika.mime.MimeTypes;
  46  import org.broadleafcommerce.cms.field.type.StorageType;
  47  import org.broadleafcommerce.cms.file.StaticAssetMultiTenantExtensionManager;
  48  import org.broadleafcommerce.cms.file.dao.StaticAssetDao;
  49  import org.broadleafcommerce.cms.file.domain.ImageStaticAsset;
  50  import org.broadleafcommerce.cms.file.domain.ImageStaticAssetImpl;
  51  import org.broadleafcommerce.cms.file.domain.StaticAsset;
  52  import org.broadleafcommerce.cms.file.domain.StaticAssetImpl;
  53  import org.broadleafcommerce.common.extension.ExtensionResultStatusType;
  54  import org.broadleafcommerce.common.file.service.StaticAssetPathService;
  55  import org.broadleafcommerce.common.util.StringUtil;
  56  import org.broadleafcommerce.common.util.TransactionUtils;
  57  import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageArtifactProcessor;
  58  import org.broadleafcommerce.openadmin.server.service.artifact.image.ImageMetadata;
  59  import org.springframework.beans.factory.annotation.Value;
  60  import org.springframework.stereotype.Service;
  61  import org.springframework.transaction.annotation.Transactional;
  62  import org.springframework.web.multipart.MultipartFile;
  63  
  64  import java.io.IOException;
  65  import java.io.InputStream;
  66  import java.io.UnsupportedEncodingException;
  67  import java.net.URLDecoder;
  68  import java.util.Arrays;
  69  import java.util.HashMap;
  70  import java.util.List;
  71  import java.util.Map;
  72  import java.util.Random;
  73  
  74  import javax.annotation.Resource;
  75  
  76  /**
  77   * Created by bpolster.
  78   */
  79  @Service(&quot;blStaticAssetService&quot;)
  80  public class StaticAssetServiceImpl implements StaticAssetService {
  81  
  82      private static final Log LOG = LogFactory.getLog(StaticAssetServiceImpl.class);
<abbr title="  83      private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of file.&quot;;">  83      private static final String UPLOAD_FILE_EXTENSION_EXCEPTION = &quot;java.io.IOException: Invalid extension type of ðŸ”µ</abbr>
  84  
  85      @Resource(name = &quot;blImageArtifactProcessor&quot;)
  86      protected ImageArtifactProcessor imageArtifactProcessor;
  87  
  88      @Value(&quot;${asset.use.filesystem.storage}&quot;)
  89      protected boolean storeAssetsOnFileSystem = false;
  90  
  91      @Resource(name = &quot;blStaticAssetDao&quot;)
  92      protected StaticAssetDao staticAssetDao;
  93  
  94      @Resource(name = &quot;blStaticAssetStorageService&quot;)
  95      protected StaticAssetStorageService staticAssetStorageService;
  96  
  97      @Resource(name = &quot;blStaticAssetPathService&quot;)
  98      protected StaticAssetPathService staticAssetPathService;
  99  
 100      @Resource(name = &quot;blStaticAssetMultiTenantExtensionManager&quot;)
 101      protected StaticAssetMultiTenantExtensionManager staticAssetExtensionManager;
 102  
 103      @Value(&quot;${should.accept.non.image.asset:true}&quot;)
 104      protected boolean shouldAcceptNonImageAsset;
 105  
 106      @Value(&quot;${disabled.file.extensions}&quot;)
 107      protected String disabledFileExtensions;
 108  
 109      private final Random random = new Random();
 110      private final String FILE_NAME_CHARS = &quot;0123456789abcdef&quot;;
 111  









 112      @Override
 113      public StaticAsset findStaticAssetById(Long id) {
 114          return staticAssetDao.readStaticAssetById(id);
 115      }
 116  
 117      @Override
 118      public List&lt;StaticAsset&gt; readAllStaticAssets() {
 119          return staticAssetDao.readAllStaticAssets();
 120      }
 121  
 122      @Override
 123      public Long findTotalStaticAssetCount() {
 124          return staticAssetDao.readTotalStaticAssetCount();
 125      }
 126  
 127      protected String getFileExtension(String fileName) {
 128          int pos = fileName.lastIndexOf(&quot;.&quot;);
 129          if (pos &gt; 0) {
 130              return fileName.substring(pos + 1, fileName.length()).toLowerCase();
 131          } else {
 132              LOG.warn(&quot;No extension provided for asset : &quot; + StringUtil.sanitize(fileName));
 133              return null;
 134          }
 135      }
 136  
 137      /**
 138       * Generates a filename as a set of Hex digits.
 139       *
 140       * @param size
 141       * @return
 142       */
 143      protected String generateFileName(int size) {
 144          StringBuilder sb = new StringBuilder();
 145          for (int i = 0; i &lt; size; i++) {
 146              int pos = random.nextInt(FILE_NAME_CHARS.length());
 147              sb = sb.append(FILE_NAME_CHARS.charAt(pos));
 148          }
 149          return sb.toString();
 150      }
 151  
 152      /**
 153       * Will assemble the url from the passed in properties as
 154       * /{entityType}/{fileName}
 155       * /product/7001-ab12
 156       * &lt;p&gt;
 157       * If the properties above are not set, it will generate the fileName randomly.
 158       *
 159       * @param url
 160       * @param asset
 161       * @param assetProperties
 162       * @return
 163       */
 164      protected String buildAssetURL(Map&lt;String, String&gt; assetProperties, String originalFilename) {
 165          StringBuilder path = new StringBuilder(&quot;/&quot;);
 166  
 167          String entityType = assetProperties.get(&quot;entityType&quot;);
 168          String entityId = assetProperties.get(&quot;entityId&quot;);
 169          String fileName = assetProperties.get(&quot;fileName&quot;);
 170  
 171          if (entityType != null &amp;&amp; !&quot;null&quot;.equals(entityType)) {
 172              path = path.append(entityType).append(&quot;/&quot;);
 173          }
 174  
 175          if (entityId != null &amp;&amp; !&quot;null&quot;.equals(entityId)) {
 176              path = path.append(entityId).append(&quot;/&quot;);
 177          }
 178  
 179          if (fileName != null) {
 180              int pos = fileName.indexOf(&quot;:&quot;);
 181              if (pos &gt; 0) {
 182                  if (LOG.isTraceEnabled()) {
 183                      LOG.trace(&quot;Removing protocol from URL name&quot; + StringUtil.sanitize(fileName));
 184                  }
 185                  fileName = fileName.substring(pos + 1);
 186              }
 187          } else {
 188              fileName = originalFilename;
 189          }
 190  
 191          return path.append(fileName).toString();
 192      }
 193  
 194      private static String normalizeFileExtension(MultipartFile file) {
 195          int index = file.getOriginalFilename().lastIndexOf(&quot;.&quot;);
<abbr title=" 196          return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1, file.getOriginalFilename().length()).toLowerCase();"> 196          return file.getOriginalFilename().substring(0, index + 1) + file.getOriginalFilename().substring(index + 1ðŸ”µ</abbr>
 197      }
 198  
 199      private static String getFileExtension(MultipartFile file) {
 200          String tikaExtension = null;
 201          try {
 202              final Tika tika = new Tika();
 203              final MimeTypes allTypes = MimeTypes.getDefaultMimeTypes();
 204              final String detectedType;
 205              detectedType = tika.detect(file.getBytes());
 206              if (detectedType != null &amp;&amp; !detectedType.isEmpty()) {
 207                  final MimeType mimeType = allTypes.forName(detectedType);
 208                  tikaExtension = mimeType.getExtension().replace(&quot;.&quot;, &quot;&quot;).toLowerCase();
 209              }
 210          } catch (IOException | MimeTypeException ignored) {
 211          }
<abbr title=" 212          return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(file.getOriginalFilename());"> 212          return (tikaExtension != null &amp;&amp; !tikaExtension.isEmpty()) ? tikaExtension : FilenameUtils.getExtension(fiðŸ”µ</abbr>
 213      }
 214  
 215      public void validateFileExtension(MultipartFile file) throws IOException {
 216          final String extension = getFileExtension(file);
 217          if (disabledFileExtensions != null &amp;&amp; !disabledFileExtensions.isEmpty()) {
<abbr title=" 218              final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;));"> 218              final List&lt;String&gt; extensions = Arrays.asList(disabledFileExtensions.toLowerCase().split(&quot;\\s*,\\s*&quot;))ðŸ”µ</abbr>
 219              LOG.info(&quot;Disabled file extensions:&quot; + disabledFileExtensions);
 220              if (extensions.contains(extension)) {
 221                  LOG.error(&quot;Invalid extension type of file &quot; + file.getName());
 222                  throw new IOException(&quot;Invalid extension type of file.&quot;);
 223              }
 224          }
 225      }
 226  
 227      @Override
 228      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 229      public StaticAsset createStaticAssetFromFile(MultipartFile file, Map&lt;String, String&gt; properties) {
 230          try {
 231              validateFileExtension(file);
 232              staticAssetStorageService.validateFileSize(file);
<abbr title=" 233              return createStaticAsset(file.getInputStream(), normalizeFileExtension(file), file.getSize(), properties);"> 233              return createStaticAsset(file.getInputStream(), normalizeFileExtension(file), file.getSize(), propertiðŸ”µ</abbr>






 234          } catch (IOException e) {
 235              throw new RuntimeException(e);
 236          }








 237      }
 238  
 239      @Override
 240      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
<abbr title=" 241      public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, String&gt; properties) {"> 241      public StaticAsset createStaticAsset(InputStream inputStream, String fileName, long fileSize, Map&lt;String, StriðŸ”µ</abbr>
 242          if (properties == null) {
 243              properties = new HashMap&lt;String, String&gt;();
 244          }
 245  
 246          String fullUrl = buildAssetURL(properties, fileName);
 247          StringBuilder urlBuilder = new StringBuilder();
 248          urlBuilder.append(fullUrl);
<abbr title=" 249          ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURL(urlBuilder);"> 249          ExtensionResultStatusType resultStatusType = staticAssetExtensionManager.getProxy().modifyDuplicateAssetURðŸ”µ</abbr>
 250          fullUrl = urlBuilder.toString();
 251          StaticAsset newAsset = staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 252          // If no ExtensionManager modified the URL to handle duplicates, then go ahead and run default
 253          // logic for handling duplicate files.
 254          if (resultStatusType != ExtensionResultStatusType.HANDLED) {
 255              int count = 0;
 256              while (newAsset != null) {
 257                  count++;
 258                  //try the new format first, then the old
 259                  newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, false));
 260                  if (newAsset == null) {
 261                      newAsset = staticAssetDao.readStaticAssetByFullUrl(getCountUrl(fullUrl, count, true));
 262                  }
 263              }
 264  
 265              if (count &gt; 0) {
 266                  fullUrl = getCountUrl(fullUrl, count, false);
 267              }
 268          }
 269  
 270          try {
 271              ImageMetadata metadata = imageArtifactProcessor.getImageMetadata(inputStream);
 272              newAsset = new ImageStaticAssetImpl();
 273              ((ImageStaticAsset) newAsset).setWidth(metadata.getWidth());
 274              ((ImageStaticAsset) newAsset).setHeight(metadata.getHeight());
 275          } catch (Exception e) {
 276              //must not be an image stream
 277              LOG.warn(&quot;unable to convert asset:&quot; + fileName + &quot; into Image&quot;);
 278              LOG.debug(e);
 279  
 280              if (getShouldAcceptNonImageAsset()) {
 281                  newAsset = createNonImageAsset(inputStream, fileName, properties);
 282              } else {
 283                  throw new RuntimeException(&quot;Selected Asset/File was not valid image.&quot;);
 284              }
 285          }
 286          if (storeAssetsOnFileSystem) {
 287              newAsset.setStorageType(StorageType.FILESYSTEM);
 288          } else {
 289              newAsset.setStorageType(StorageType.DATABASE);
 290          }
 291  
 292          newAsset.setName(fileName);
 293          getMimeType(inputStream, fileName, newAsset);
 294          newAsset.setFileExtension(getFileExtension(fileName));
 295          newAsset.setFileSize(fileSize);
 296          newAsset.setFullUrl(fullUrl);
 297  
 298          return staticAssetDao.addOrUpdateStaticAsset(newAsset, false);
 299      }
 300  
 301      /**
 302       * Hook-point for implementors to add custom business logic for handling files that are non-images
 303       *
 304       * @param inputStream
 305       * @param fileName
 306       * @param properties
 307       * @return
 308       */
<abbr title=" 309      protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properties) {"> 309      protected StaticAsset createNonImageAsset(InputStream inputStream, String fileName, Map&lt;String, String&gt; properðŸ”µ</abbr>
 310          return new StaticAssetImpl();
 311      }
 312  
 313      /**
 314       * Gets the count URL based on the original fullUrl. If requested in legacy format this will return URLs like:
 315       * &lt;p&gt;
 316       * /path/to/image.jpg-1
 317       * /path/to/image.jpg-2
 318       * &lt;p&gt;
 319       * Whereas if this is in non-legacy format (&lt;b&gt;legacy&lt;/b&gt; == false):
 320       * &lt;p&gt;
 321       * /path/to/image-1.jpg
 322       * /path/to/image-2.jpg
 323       * &lt;p&gt;
 324       * Used to deal with duplicate URLs of uploaded assets
 325       */
 326      protected String getCountUrl(String fullUrl, int count, boolean legacyFormat) {
 327          String countUrl = fullUrl + &#x27;-&#x27; + count;
 328          int dotIndex = fullUrl.lastIndexOf(&#x27;.&#x27;);
 329          if (dotIndex != -1 &amp;&amp; !legacyFormat) {
 330              countUrl = fullUrl.substring(0, dotIndex) + &#x27;-&#x27; + count + &#x27;.&#x27; + fullUrl.substring(dotIndex + 1);
 331          }
 332  
 333          return countUrl;
 334      }
 335  
 336      protected void getMimeType(InputStream inputStream, String fileName, StaticAsset newAsset) {
 337          Tika tika = new Tika();
 338          String tikaMimeType = tika.detect(fileName);
 339          if (tikaMimeType == null) {
 340              try {
 341                  tikaMimeType = tika.detect(inputStream);
 342              } catch (IOException e) {
 343                  //if tika can&#x27;t resolve, don&#x27;t throw exception
 344              }
 345          }
 346          if (tikaMimeType != null) {
 347              newAsset.setMimeType(tikaMimeType);
 348          }
 349      }
 350  
 351      @Override
 352      public StaticAsset findStaticAssetByFullUrl(String fullUrl) {
 353          try {
 354              fullUrl = URLDecoder.decode(fullUrl, &quot;UTF-8&quot;);
 355              //strip out the jsessionid if it&#x27;s there
 356              fullUrl = fullUrl.replaceAll(&quot;(?i);jsessionid.*?=.*?(?=\\?|$)&quot;, &quot;&quot;);
 357          } catch (UnsupportedEncodingException e) {
 358              throw new RuntimeException(&quot;Unsupported encoding to decode fullUrl&quot;, e);
 359          }
 360          return staticAssetDao.readStaticAssetByFullUrl(fullUrl);
 361      }
 362  
 363      @Override
 364      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 365      public StaticAsset addStaticAsset(StaticAsset staticAsset) {
 366          StaticAsset newAsset = staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 367          return newAsset;
 368      }
 369  
 370      @Override
 371      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 372      public StaticAsset updateStaticAsset(StaticAsset staticAsset) {
 373          return staticAssetDao.addOrUpdateStaticAsset(staticAsset, true);
 374      }
 375  
 376      @Override
 377      @Transactional(TransactionUtils.DEFAULT_TRANSACTION_MANAGER)
 378      public void deleteStaticAsset(StaticAsset staticAsset) {
 379          staticAssetDao.delete(staticAsset);
 380      }
 381  
 382      @Override
 383      public String getStaticAssetUrlPrefix() {
 384          return staticAssetPathService.getStaticAssetUrlPrefix();
 385      }
 386  
 387      @Override
 388      public String getPrefixedStaticAssetUrl(String assetUrl) {
 389          String staticAssetUrlPrefix = getStaticAssetUrlPrefix();
 390          if (staticAssetUrlPrefix != null &amp;&amp; !staticAssetUrlPrefix.startsWith(&quot;/&quot;)) {
 391              staticAssetUrlPrefix = &quot;/&quot; + staticAssetUrlPrefix;
 392          }
 393          if (staticAssetUrlPrefix != null) {
 394              return staticAssetUrlPrefix + assetUrl;
 395          }
 396          return assetUrl;
 397      }
 398  
 399      @Override
 400      public String getStaticAssetEnvironmentUrlPrefix() {
 401          return staticAssetPathService.getStaticAssetEnvironmentUrlPrefix();
 402      }
 403  
 404      @Override
 405      public String getStaticAssetEnvironmentSecureUrlPrefix() {
 406          return staticAssetPathService.getStaticAssetEnvironmentSecureUrlPrefix();
 407      }
 408  
 409      @Override
 410      public String convertAssetPath(String assetPath, String contextPath, boolean secureRequest) {
 411          return staticAssetPathService.convertAssetPath(assetPath, contextPath, secureRequest);
 412      }
 413  
 414      public boolean getShouldAcceptNonImageAsset() {
 415          return shouldAcceptNonImageAsset;
 416      }
 417  
 418      public void setShouldAcceptNonImageAsset(boolean accept) {
 419          shouldAcceptNonImageAsset = accept;
 420      }
 421  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            