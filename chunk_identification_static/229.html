<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>229</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    229
                    <a href="228.html">prev</a>
                    <a href="230.html">next</a>
                    <a href="229_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    Automattic/simplenote-android_26c36926e501e51f0f3914978c1b0404faab3421_Simplenote/src/main/java/com/automattic/simplenote/models/Note.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;26c36926e501e51f0f3914978c1b0404faab3421:Simplenote/src/main/java/com/automattic/simplenote/models/Note.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;26c36926e501e51f0f3914978c1b0404faab3421^1:Simplenote/src/main/java/com/automattic/simplenote/models/Note.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;26c36926e501e51f0f3914978c1b0404faab3421^2:Simplenote/src/main/java/com/automattic/simplenote/models/Note.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\Automattic\simplenote-android show &quot;7820fb8e36834e361d4fc7d50aac8cba6d81969e:Simplenote/src/main/java/com/automattic/simplenote/models/Note.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 package com.automattic.simplenote.models;
   2 
   3 import java.text.DateFormat;
   4 import java.text.SimpleDateFormat;
   5 import java.util.ArrayList;
   6 import java.util.Calendar;
   7 import java.util.HashMap;
   8 import java.util.Locale;
   9 import java.util.Map;
  10 import java.util.List;
  11 import java.util.ArrayList;
  12 
  13 import android.content.Context;
  14 import android.util.Log;
  15 
  16 import com.automattic.simplenote.R;
  17 
  18 import com.simperium.client.Bucket;
  19 import com.simperium.client.Query;
  20 import com.simperium.client.Query.ComparisonType;
  21 import com.simperium.client.Query.SortType;
  22 import com.simperium.client.BucketObject;
  23 import com.simperium.client.BucketSchema;
  24 
  25 public class Note extends BucketObject {
  26 	
  27 	public static final String BUCKET_NAME=&quot;note&quot;;
  28     public static final String PINNED_TAG=&quot;pinned&quot;;
  29     public static final String NEW_LINE=&quot;\n&quot;;
  30     
  31     private static final String CONTENT_CONCAT_FORMAT=&quot;%s %s&quot;;
  32     private static final String BLANK_CONTENT=&quot;&quot;;
  33     private static final String SPACE = &quot; &quot;;
  34     
  35     public static final String CONTENT_PROPERTY=&quot;content&quot;;
  36     public static final String TAGS_PROPERTY=&quot;tags&quot;;
  37     public static final String SYSTEM_TAGS_PROPERTY=&quot;systemTags&quot;;
  38     public static final String CREATION_DATE_PROPERTY=&quot;creationDate&quot;;
  39     public static final String MODIFICATION_DATE_PROPERTY=&quot;modificationDate&quot;;
  40     public static final String SHARE_URL_PROPERTY=&quot;shareURL&quot;;
  41     public static final String PUBLISH_URL_PROPERTY=&quot;publishURL&quot;;
  42     public static final String DELETED_PROPERTY=&quot;deleted&quot;;
  43     public static final String TITLE_INDEX_NAME=&quot;title&quot;;
  44     public static final String CONTENT_PREVIEW_INDEX_NAME=&quot;contentPreview&quot;;
  45     public static final String PINNED_INDEX_NAME=&quot;pinned&quot;;
  46     public static final String MODIFIED_INDEX_NAME=&quot;modified&quot;;
  47     public static final String CREATED_INDEX_NAME=&quot;created&quot;;
  48 	
  49 	protected String title = null;
  50 	protected String contentPreview = null;
  51 
  52 
  53 	public static class Schema extends BucketSchema&lt;Note&gt; {
  54 
  55         protected static NoteIndexer sNoteIndexer = new NoteIndexer();
  56 
  57         public Schema(){
  58             autoIndex();
  59 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  60             addIndex(noteIndexer);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  61             setupFullTextIndex(TAGS_PROPERTY, CONTENT_PROPERTY);</span>
  62 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  63             addIndex(noteIndexer);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  64             setDefault(CONTENT_PROPERTY, &quot;&quot;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  65             setDefault(SYSTEM_TAGS_PROPERTY, new ArrayList&lt;Object&gt;());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  66             setDefault(TAGS_PROPERTY, new ArrayList&lt;Object&gt;());</span>
  67 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  68             addIndex(sNoteIndexer);</span>
  69 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  70             setDefault(CONTENT_PROPERTY, &quot;&quot;);
  71             setDefault(SYSTEM_TAGS_PROPERTY, new ArrayList&lt;Object&gt;());
  72             setDefault(TAGS_PROPERTY, new ArrayList&lt;Object&gt;());
  73             setDefault(DELETED_PROPERTY, false);
  74             setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
  75             setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
  76         }
  77 
  78         public String getRemoteName(){
  79             return Note.BUCKET_NAME;
  80         }
  81 
  82 		public Note build(String key, Map&lt;String,Object&gt;properties){
  83 			Note note = new Note(key, properties);
  84 			return note;
  85 		}
  86 
  87         public void update(Note note, Map&lt;String,Object&gt;properties){
  88             note.properties = properties;
  89             note.title = null;
  90             note.contentPreview = null;
  91         }
  92 	}
  93     
  94     public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket){
  95         return noteBucket.query()
  96                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
  97     }
  98 
  99     public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket){
 100         return noteBucket.query()
 101                 .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
 102     }
 103 
 104     public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString){
 105         return noteBucket.query()
 106                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 107                 .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
 108     }
 109 
 110     public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag){
 111         return noteBucket.query()
 112                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 113                 .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
 114     }
 115 
 116 
 117     public Note(String key){
 118         super(key, new HashMap&lt;String,Object&gt;());
 119     }
 120 
 121 	public Note(String key, Map&lt;String,Object&gt;properties) {
 122 		super(key, properties);
 123 	}
 124 
 125     protected void updateTitleAndPreview(){
 126         // try to build a title and preview property out of content
 127         String content = getContent().trim();
 128         // title = &quot;Hello World&quot;;
 129         // contentPreview = &quot;This is a preview&quot;;
 130 
 131         int firstNewLinePosition = content.indexOf(NEW_LINE);
 132         if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 133             title = content.substring(0, firstNewLinePosition).trim();
 134 
 135             if (firstNewLinePosition &lt; content.length()) {
 136                 contentPreview = content.substring(firstNewLinePosition, content.length());
<abbr title=" 137                 contentPreview = contentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trim();"> 137                 contentPreview = contentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trim🔵</abbr>
 138                 if (contentPreview.length() &gt;= 300) {
 139                     contentPreview = contentPreview.substring(0, 300);
 140                 }
 141             }
 142             else {
 143                 contentPreview = content;
 144             }
 145         }
 146         else {
 147             title = content;
 148             contentPreview = content;
 149         }
 150     }
 151 	
 152 	public String getTitle() {
 153         if (title == null) {
 154             updateTitleAndPreview();
 155         }
 156 		return title;
 157 	}
 158     
 159     public String getTitle(String ifBlank){
 160         if (title == null) {
 161             updateTitleAndPreview();
 162         }
 163         if (title.trim().equals(&quot;&quot;)) {
 164             return ifBlank;
 165         } else {
 166             return title;
 167         }
 168     }
 169 
 170 	public String getContent() {
 171         Object content = getProperty(CONTENT_PROPERTY);
 172         if (content == null) {
 173             return BLANK_CONTENT;
 174         }
 175         return (String) content;
 176 	}
 177 
 178 	public void setContent(String content) {
 179         title = null;
 180         contentPreview = null;
 181         setProperty(CONTENT_PROPERTY, content);
 182 	}
 183 	
 184 	public String getContentPreview() {
 185         if (contentPreview == null) {
 186             updateTitleAndPreview();
 187         }
 188 		return contentPreview;
 189 	}
 190 
 191     public String getContentPreview(int lines){
 192         if (contentPreview == null) {
 193             updateTitleAndPreview();
 194         }
 195         return contentPreview;
 196     }
 197 
 198 	public Calendar getCreationDate() {
 199         return numberToDate((Number)getProperty(CREATION_DATE_PROPERTY));
 200 	}
 201 
 202 	public void setCreationDate(Calendar creationDate) {
 203         setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis()/1000);
 204 	}
 205 
 206 	public Calendar getModificationDate() {
 207         return numberToDate((Number)getProperty(MODIFICATION_DATE_PROPERTY));
 208 	}
 209 
 210 	public void setModificationDate(Calendar modificationDate) {
 211         setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis()/1000);
 212 	}
 213 
 214     public boolean hasTag(String tag){
 215         List&lt;String&gt; tags = getTags();
 216         String tagLower = tag.toLowerCase();
 217         for (String tagName : tags) {
 218             if (tagLower.equals(tagName.toLowerCase())) return true;
 219         }
 220         return false;
 221     }
 222 
 223     public boolean hasTag(Tag tag){
 224         return hasTag(tag.getSimperiumKey());
 225     }
 226 
 227 	public List&lt;String&gt; getTags() {
 228         Object tags = getProperty(TAGS_PROPERTY);
 229         if (tags == null) {
 230             tags = new ArrayList&lt;String&gt;();
 231             setProperty(TAGS_PROPERTY, tags);
 232         }
 233         return (ArrayList&lt;String&gt;) tags;
 234 	}
 235 
 236 	public void setTags(List&lt;String&gt; tags) {
 237         setProperty(TAGS_PROPERTY, tags);
 238 	}
 239 
 240     /**
 241      * String of tags delimited by a space
 242      */
 243     public CharSequence getTagString(){
 244         StringBuilder tagString = new StringBuilder();
 245         List&lt;String&gt; tags = getTags();
 246         for(String tag : tags){
 247             if (tagString.length() &gt; 0) {
 248                 tagString.append(SPACE);
 249             }
 250             tagString.append(tag);
 251         }
 252         return tagString;
 253     }
 254 
 255     /**
 256      * Sets the note&#x27;s tags by providing it with a {@link String} of space
 257      * seperated tags. Filters out duplicate tags.
 258      * 
 259      * @param tagString a space delimited list of tags
 260      */
 261     public void setTagString(String tagString){
 262         List&lt;String&gt; tags = getTags();
 263         tags.clear();
 264         if (tagString == null) return;
 265         // Make sure string has a trailing space
 266         if (tagString.length() &gt; 1 &amp;&amp; !tagString.substring(tagString.length() - 1).equals(SPACE))
 267             tagString = tagString + SPACE;
 268         // for comparing case-insensitive strings, would like to find a way to
 269         // do this without allocating a new list and strings
 270         List&lt;String&gt; tagsUpperCase = new ArrayList&lt;String&gt;();
 271         // remove all current tags
 272         int start = 0;
 273         int next = -1;
 274         String possible;
 275         String possibleUpperCase;
 276         // search tag string for space characters and pull out individual tags
 277         do {
 278             next = tagString.indexOf(SPACE, start);
 279             if (next &gt; start) {
 280                 possible = tagString.substring(start, next);
 281                 possibleUpperCase = possible.toUpperCase();
 282                 if (!possible.equals(SPACE) &amp;&amp; !tagsUpperCase.contains(possibleUpperCase)) {
 283                     tagsUpperCase.add(possibleUpperCase);
 284                     tags.add(possible);
 285                 }
 286             }
 287             start = next + 1;
 288         } while(next &gt; -1);
 289     }
 290 
 291 	public List&lt;String&gt; getSystemTags() {
 292         Object tags = getProperty(SYSTEM_TAGS_PROPERTY);
 293         if (tags == null) {
 294             return new ArrayList&lt;String&gt;();
 295         }
 296         return (List&lt;String&gt;) tags;
 297 	}
 298 
 299 	public Boolean isDeleted() {
 300         Object deleted = getProperty(DELETED_PROPERTY);
 301         if (deleted == null) {
 302             return false;
 303         }
 304 		if (deleted instanceof Boolean) {
 305 			return (Boolean) deleted;
 306 		} else if (deleted instanceof Number) {
 307 			return ((Number)deleted).intValue() == 0 ? false : true;
 308         } else {
 309             return false;
 310         }
 311 	}
 312 
 313 	public void setDeleted(boolean deleted) {
 314 		setProperty(DELETED_PROPERTY, deleted);
 315 	}
 316 
 317 	public boolean isPinned() {
 318         return getSystemTags().contains(PINNED_TAG);
 319 	}
 320 
 321 	public void setPinned(boolean isPinned) {
 322         if (isPinned &amp;&amp; !isPinned()) {
 323             getSystemTags().add(PINNED_TAG);
 324         } else if (!isPinned &amp;&amp; isPinned()){
 325             getSystemTags().remove(PINNED_TAG);
 326         }
 327 	}
 328 
 329     public static String dateString(Number time, boolean useShortFormat, Context context){
 330         Calendar c = numberToDate(time);
 331         return dateString(c, useShortFormat, context);
 332     }
 333 
 334 	public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 335 		int year, month, day;
 336 
 337 		String time, date, retVal;
 338 		time = date = &quot;&quot;;
 339 
 340 		Calendar diff = Calendar.getInstance();
 341 		diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 342 
 343 		year = diff.get(Calendar.YEAR);
 344 		month = diff.get(Calendar.MONTH);
 345 		day = diff.get(Calendar.DAY_OF_MONTH);
 346 
 347 		diff.setTimeInMillis(0); // starting time
 348 		time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 349 		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 349 		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calend🔵</abbr>
 350 			date = context.getResources().getString(R.string.today);
 351 			if (useShortFormat)
 352 				retVal = time;
 353 			else
 354 				retVal = date + &quot;, &quot; + time;
 355 		} else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {
 356 			date = context.getResources().getString(R.string.yesterday);
 357 			if (useShortFormat)
 358 				retVal = date;
 359 			else
 360 				retVal = date + &quot;, &quot; + time;
 361 		} else {
 362 			date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 363 			retVal = date + &quot;, &quot; + time;
 364 		}
 365 
 366 		return retVal;
 367 	}
 368 
 369     public static Calendar numberToDate(Number time){
 370         Calendar date = Calendar.getInstance();
 371         if (time != null) {
 372             // Flick Note uses millisecond resolution timestamps Simplenote expects seconds
 373             // since we only deal with create and modify timestamps, they should all have occured
 374             // at the present time or in the past.
 375             float now = date.getTimeInMillis()/1000;
 376             float magnitude = time.floatValue()/now;
 377             if (magnitude &gt;= 2.f) time = time.longValue()/1000;
 378             date.setTimeInMillis(time.longValue()*1000);
 379         }
 380         return date;
 381     }
 382 
 383     /**
 384      * Check if the note has any changes
 385      * @param content the new note content
 386      * @param tagString space separated tags
 387      * @param isPinned note is pinned
 388      * @return true if note has changes, false if it is unchanged.
 389      */
 390     public boolean hasChanges(String content, String tagString, boolean isPinned) {
 391 
<abbr title=" 392         if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagString().toString()))"> 392         if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.get🔵</abbr>
 393             return false;
 394         else
 395             return true;
 396     }
 397 }
 
 </pre></td>
                            <td><pre>   1 package com.automattic.simplenote.models;
   2 
   3 import java.text.DateFormat;
   4 import java.text.SimpleDateFormat;
   5 import java.util.ArrayList;
   6 import java.util.Calendar;
   7 import java.util.HashMap;
   8 import java.util.Locale;
   9 import java.util.Map;
  10 import java.util.List;
  11 import java.util.ArrayList;
  12 
  13 import android.content.Context;
  14 import android.util.Log;
  15 
  16 import com.automattic.simplenote.R;
  17 
  18 import com.simperium.client.Bucket;
  19 import com.simperium.client.Query;
  20 import com.simperium.client.Query.ComparisonType;
  21 import com.simperium.client.Query.SortType;
  22 import com.simperium.client.BucketObject;
  23 import com.simperium.client.BucketSchema;
  24 
  25 public class Note extends BucketObject {
  26 
  27 	public static final String BUCKET_NAME=&quot;note&quot;;
  28     public static final String PINNED_TAG=&quot;pinned&quot;;
  29     public static final String NEW_LINE=&quot;\n&quot;;
  30 
  31     private static final String CONTENT_CONCAT_FORMAT=&quot;%s %s&quot;;
  32     private static final String BLANK_CONTENT=&quot;&quot;;
  33     private static final String SPACE = &quot; &quot;;
  34 
  35     public static final String CONTENT_PROPERTY=&quot;content&quot;;
  36     public static final String TAGS_PROPERTY=&quot;tags&quot;;
  37     public static final String SYSTEM_TAGS_PROPERTY=&quot;systemTags&quot;;
  38     public static final String CREATION_DATE_PROPERTY=&quot;creationDate&quot;;
  39     public static final String MODIFICATION_DATE_PROPERTY=&quot;modificationDate&quot;;
  40     public static final String SHARE_URL_PROPERTY=&quot;shareURL&quot;;
  41     public static final String PUBLISH_URL_PROPERTY=&quot;publishURL&quot;;
  42     public static final String DELETED_PROPERTY=&quot;deleted&quot;;
  43     public static final String TITLE_INDEX_NAME=&quot;title&quot;;
  44     public static final String CONTENT_PREVIEW_INDEX_NAME=&quot;contentPreview&quot;;
  45     public static final String PINNED_INDEX_NAME=&quot;pinned&quot;;
  46     public static final String MODIFIED_INDEX_NAME=&quot;modified&quot;;
  47     public static final String CREATED_INDEX_NAME=&quot;created&quot;;
  48 
  49 	protected String title = null;
  50 	protected String contentPreview = null;
  51 
  52 
  53 	public static class Schema extends BucketSchema&lt;Note&gt; {
  54 
  55         protected static NoteIndexer sNoteIndexer = new NoteIndexer();
  56 
  57         public Schema(){
  58             autoIndex();
  59 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  60             addIndex(noteIndexer);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  61             setupFullTextIndex(TAGS_PROPERTY, CONTENT_PROPERTY);</span>
  62 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  63             addIndex(noteIndexer);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  64             setDefault(CONTENT_PROPERTY, &quot;&quot;);</span>
  65 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  66             addIndex(sNoteIndexer);</span>
  67 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
  68             setDefault(CONTENT_PROPERTY, &quot;&quot;);
  69             setDefault(SYSTEM_TAGS_PROPERTY, new ArrayList&lt;Object&gt;());
  70             setDefault(TAGS_PROPERTY, new ArrayList&lt;Object&gt;());
  71             setDefault(DELETED_PROPERTY, false);
  72             setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
  73             setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
  74         }
  75 
  76         public String getRemoteName(){
  77             return Note.BUCKET_NAME;
  78         }
  79 
  80 		public Note build(String key, Map&lt;String,Object&gt;properties){
  81 			Note note = new Note(key, properties);
  82 			return note;
  83 		}
  84 
  85         public void update(Note note, Map&lt;String,Object&gt;properties){
  86             note.properties = properties;
  87             note.title = null;
  88             note.contentPreview = null;
  89         }
  90 	}
  91 
  92     public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket){
  93         return noteBucket.query()
  94                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
  95     }
  96 
  97     public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket){
  98         return noteBucket.query()
  99                 .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
 100     }
 101 
 102     public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString){
 103         return noteBucket.query()
 104                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 105                 .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
 106     }
 107 
 108     public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag){
 109         return noteBucket.query()
 110                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 111                 .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
 112     }
 113 
 114 
 115     public Note(String key){
 116         super(key, new HashMap&lt;String,Object&gt;());
 117     }
 118 
 119 	public Note(String key, Map&lt;String,Object&gt;properties) {
 120 		super(key, properties);
 121 	}
 122 
 123     protected void updateTitleAndPreview(){
 124         // try to build a title and preview property out of content
 125         String content = getContent().trim();
 126         // title = &quot;Hello World&quot;;
 127         // contentPreview = &quot;This is a preview&quot;;
 128 
 129         int firstNewLinePosition = content.indexOf(NEW_LINE);
 130         if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 131             title = content.substring(0, firstNewLinePosition).trim();
 132 
 133             if (firstNewLinePosition &lt; content.length()) {
 134                 contentPreview = content.substring(firstNewLinePosition, content.length());
<abbr title=" 135                 contentPreview = contentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trim();"> 135                 contentPreview = contentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trim🔵</abbr>
 136                 if (contentPreview.length() &gt;= 300) {
 137                     contentPreview = contentPreview.substring(0, 300);
 138                 }
 139             }
 140             else {
 141                 contentPreview = content;
 142             }
 143         }
 144         else {
 145             title = content;
 146             contentPreview = content;
 147         }
 148     }
 149 
 150 	public String getTitle() {
 151         if (title == null) {
 152             updateTitleAndPreview();
 153         }
 154 		return title;
 155 	}
 156 
 157     public String getTitle(String ifBlank){
 158         if (title == null) {
 159             updateTitleAndPreview();
 160         }
 161         if (title.trim().equals(&quot;&quot;)) {
 162             return ifBlank;
 163         } else {
 164             return title;
 165         }
 166     }
 167 
 168 	public String getContent() {
 169         Object content = getProperty(CONTENT_PROPERTY);
 170         if (content == null) {
 171             return BLANK_CONTENT;
 172         }
 173         return (String) content;
 174 	}
 175 
 176 	public void setContent(String content) {
 177         title = null;
 178         contentPreview = null;
 179         setProperty(CONTENT_PROPERTY, content);
 180 	}
 181 
 182 	public String getContentPreview() {
 183         if (contentPreview == null) {
 184             updateTitleAndPreview();
 185         }
 186 		return contentPreview;
 187 	}
 188 
 189     public String getContentPreview(int lines){
 190         if (contentPreview == null) {
 191             updateTitleAndPreview();
 192         }
 193         return contentPreview;
 194     }
 195 
 196 	public Calendar getCreationDate() {
 197         return numberToDate((Number)getProperty(CREATION_DATE_PROPERTY));
 198 	}
 199 
 200 	public void setCreationDate(Calendar creationDate) {
 201         setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis()/1000);
 202 	}
 203 
 204 	public Calendar getModificationDate() {
 205         return numberToDate((Number)getProperty(MODIFICATION_DATE_PROPERTY));
 206 	}
 207 
 208 	public void setModificationDate(Calendar modificationDate) {
 209         setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis()/1000);
 210 	}
 211 
 212     public boolean hasTag(String tag){
 213         List&lt;String&gt; tags = getTags();
 214         String tagLower = tag.toLowerCase();
 215         for (String tagName : tags) {
 216             if (tagLower.equals(tagName.toLowerCase())) return true;
 217         }
 218         return false;
 219     }
 220 
 221     public boolean hasTag(Tag tag){
 222         return hasTag(tag.getSimperiumKey());
 223     }
 224 
 225 	public List&lt;String&gt; getTags() {
 226         Object tags = getProperty(TAGS_PROPERTY);
 227         if (tags == null) {
 228             tags = new ArrayList&lt;String&gt;();
 229             setProperty(TAGS_PROPERTY, tags);
 230         }
 231         return (ArrayList&lt;String&gt;) tags;
 232 	}
 233 
 234 	public void setTags(List&lt;String&gt; tags) {
 235         setProperty(TAGS_PROPERTY, tags);
 236 	}
 237 
 238     /**
 239      * String of tags delimited by a space
 240      */
 241     public CharSequence getTagString(){
 242         StringBuilder tagString = new StringBuilder();
 243         List&lt;String&gt; tags = getTags();
 244         for(String tag : tags){
 245             if (tagString.length() &gt; 0) {
 246                 tagString.append(SPACE);
 247             }
 248             tagString.append(tag);
 249         }
 250         return tagString;
 251     }
 252 
 253     /**
 254      * Sets the note&#x27;s tags by providing it with a {@link String} of space
 255      * seperated tags. Filters out duplicate tags.
 256      *
 257      * @param tagString a space delimited list of tags
 258      */
 259     public void setTagString(String tagString){
 260         List&lt;String&gt; tags = getTags();
 261         tags.clear();
 262         if (tagString == null) return;
 263         // Make sure string has a trailing space
 264         if (tagString.length() &gt; 1 &amp;&amp; !tagString.substring(tagString.length() - 1).equals(SPACE))
 265             tagString = tagString + SPACE;
 266         // for comparing case-insensitive strings, would like to find a way to
 267         // do this without allocating a new list and strings
 268         List&lt;String&gt; tagsUpperCase = new ArrayList&lt;String&gt;();
 269         // remove all current tags
 270         int start = 0;
 271         int next = -1;
 272         String possible;
 273         String possibleUpperCase;
 274         // search tag string for space characters and pull out individual tags
 275         do {
 276             next = tagString.indexOf(SPACE, start);
 277             if (next &gt; start) {
 278                 possible = tagString.substring(start, next);
 279                 possibleUpperCase = possible.toUpperCase();
 280                 if (!possible.equals(SPACE) &amp;&amp; !tagsUpperCase.contains(possibleUpperCase)) {
 281                     tagsUpperCase.add(possibleUpperCase);
 282                     tags.add(possible);
 283                 }
 284             }
 285             start = next + 1;
 286         } while(next &gt; -1);
 287     }
 288 
 289 	public List&lt;String&gt; getSystemTags() {
 290         Object tags = getProperty(SYSTEM_TAGS_PROPERTY);
 291         if (tags == null) {
 292             return new ArrayList&lt;String&gt;();
 293         }
 294         return (List&lt;String&gt;) tags;
 295 	}
 296 
 297 	public Boolean isDeleted() {
 298         Object deleted = getProperty(DELETED_PROPERTY);
 299         if (deleted == null) {
 300             return false;
 301         }
 302 		if (deleted instanceof Boolean) {
 303 			return (Boolean) deleted;
 304 		} else if (deleted instanceof Number) {
 305 			return ((Number)deleted).intValue() == 0 ? false : true;
 306         } else {
 307             return false;
 308         }
 309 	}
 310 
 311 	public void setDeleted(boolean deleted) {
 312 		setProperty(DELETED_PROPERTY, deleted);
 313 	}
 314 
 315 	public boolean isPinned() {
 316         return getSystemTags().contains(PINNED_TAG);
 317 	}
 318 
 319 	public void setPinned(boolean isPinned) {
 320         if (isPinned &amp;&amp; !isPinned()) {
 321             getSystemTags().add(PINNED_TAG);
 322         } else if (!isPinned &amp;&amp; isPinned()){
 323             getSystemTags().remove(PINNED_TAG);
 324         }
 325 	}
 326 
 327     public static String dateString(Number time, boolean useShortFormat, Context context){
 328         Calendar c = numberToDate(time);
 329         return dateString(c, useShortFormat, context);
 330     }
 331 
 332 	public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 333 		int year, month, day;
 334 
 335 		String time, date, retVal;
 336 		time = date = &quot;&quot;;
 337 
 338 		Calendar diff = Calendar.getInstance();
 339 		diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 340 
 341 		year = diff.get(Calendar.YEAR);
 342 		month = diff.get(Calendar.MONTH);
 343 		day = diff.get(Calendar.DAY_OF_MONTH);
 344 
 345 		diff.setTimeInMillis(0); // starting time
 346 		time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 347 		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 347 		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calend🔵</abbr>
 348 			date = context.getResources().getString(R.string.today);
 349 			if (useShortFormat)
 350 				retVal = time;
 351 			else
 352 				retVal = date + &quot;, &quot; + time;
 353 		} else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {
 354 			date = context.getResources().getString(R.string.yesterday);
 355 			if (useShortFormat)
 356 				retVal = date;
 357 			else
 358 				retVal = date + &quot;, &quot; + time;
 359 		} else {
 360 			date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 361 			retVal = date + &quot;, &quot; + time;
 362 		}
 363 
 364 		return retVal;
 365 	}
 366 
 367     public static Calendar numberToDate(Number time){
 368         Calendar date = Calendar.getInstance();
 369         if (time != null) {
 370             // Flick Note uses millisecond resolution timestamps Simplenote expects seconds
 371             // since we only deal with create and modify timestamps, they should all have occured
 372             // at the present time or in the past.
 373             float now = date.getTimeInMillis()/1000;
 374             float magnitude = time.floatValue()/now;
 375             if (magnitude &gt;= 2.f) time = time.longValue()/1000;
 376             date.setTimeInMillis(time.longValue()*1000);
 377         }
 378         return date;
 379     }
 380 
 381     /**
 382      * Check if the note has any changes
 383      * @param content the new note content
 384      * @param tagString space separated tags
 385      * @param isPinned note is pinned
 386      * @return true if note has changes, false if it is unchanged.
 387      */
 388     public boolean hasChanges(String content, String tagString, boolean isPinned) {
 389 
<abbr title=" 390         if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagString().toString()))"> 390         if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.get🔵</abbr>
 391             return false;
 392         else
 393             return true;
 394     }
 395 }
 
 
 
 </pre></td>
                            <td><pre>   1 package com.automattic.simplenote.models;
   2 
   3 import android.content.Context;
   4 import android.util.Log;
   5 import com.automattic.simplenote.R;
   6 import com.simperium.client.Bucket;
   7 import com.simperium.client.BucketObject;
   8 import com.simperium.client.BucketSchema;
   9 import com.simperium.client.Query.ComparisonType;
  10 import com.simperium.client.Query.SortType;
  11 import com.simperium.client.Query;
  12 import java.text.DateFormat;
  13 import java.text.SimpleDateFormat;
  14 import java.util.ArrayList;
  15 import java.util.Calendar;
  16 import java.util.HashMap;
  17 import java.util.List;
  18 import java.util.Locale;
  19 import java.util.Map;
  20 
  21 
  22 public class Note extends BucketObject {
  23 public static final String BUCKET_NAME=&quot;note&quot;;
  24 
  25     public static final String PINNED_TAG=&quot;pinned&quot;;
  26 
  27     public static final String NEW_LINE=&quot;\n&quot;;
  28 
  29     private static final String CONTENT_CONCAT_FORMAT=&quot;%s %s&quot;;
  30 
  31     private static final String BLANK_CONTENT=&quot;&quot;;
  32 
  33     private static final String SPACE = &quot; &quot;;
  34 
  35     public static final String CONTENT_PROPERTY=&quot;content&quot;;
  36 
  37     public static final String TAGS_PROPERTY=&quot;tags&quot;;
  38 
  39     public static final String SYSTEM_TAGS_PROPERTY=&quot;systemTags&quot;;
  40 
  41     public static final String CREATION_DATE_PROPERTY=&quot;creationDate&quot;;
  42 
  43     public static final String MODIFICATION_DATE_PROPERTY=&quot;modificationDate&quot;;
  44 
  45     public static final String SHARE_URL_PROPERTY=&quot;shareURL&quot;;
  46 
  47     public static final String PUBLISH_URL_PROPERTY=&quot;publishURL&quot;;
  48 
  49     public static final String DELETED_PROPERTY=&quot;deleted&quot;;
  50 
  51     public static final String TITLE_INDEX_NAME=&quot;title&quot;;
  52 
  53     public static final String CONTENT_PREVIEW_INDEX_NAME=&quot;contentPreview&quot;;
  54 
  55     public static final String PINNED_INDEX_NAME=&quot;pinned&quot;;
  56 
  57     public static final String MODIFIED_INDEX_NAME=&quot;modified&quot;;
  58 
  59     public static final String CREATED_INDEX_NAME=&quot;created&quot;;
  60 
  61 protected String title = null;
  62 
  63 protected String contentPreview = null;
  64 
  65     public static class Schema extends BucketSchema&lt;Note&gt; {
  66         protected static NoteIndexer sNoteIndexer = new NoteIndexer();
  67 
  68         public Schema() {
  69             autoIndex();
  70             addIndex(sNoteIndexer);
  71             setupFullTextIndex(TAGS_PROPERTY, CONTENT_PROPERTY);
  72             setDefault(CONTENT_PROPERTY, &quot;&quot;);
  73             setDefault(SYSTEM_TAGS_PROPERTY, new ArrayList&lt;Object&gt;());
  74             setDefault(TAGS_PROPERTY, new ArrayList&lt;Object&gt;());
  75             setDefault(DELETED_PROPERTY, false);
  76             setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
  77             setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
  78         }
  79 
  80         public String getRemoteName(){
  81             return Note.BUCKET_NAME;
  82         }
  83 
  84 public Note build(String key, Map&lt;String,Object&gt;properties){
  85 	Note note = new Note(key, properties);
  86 	return note;
  87 }
  88 
  89         public void update(Note note, Map&lt;String,Object&gt;properties){
  90             note.properties = properties;
  91             note.title = null;
  92             note.contentPreview = null;
  93         }
  94     }
  95 
  96     public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket){
  97         return noteBucket.query()
  98                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
  99     }
 100 
 101     public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket){
 102         return noteBucket.query()
 103                 .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
 104     }
 105 
 106     public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString){
 107         return noteBucket.query()
 108                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 109                 .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
 110     }
 111 
 112     public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag){
 113         return noteBucket.query()
 114                 .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 115                 .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
 116     }
 117 
 118     public Note(String key) {
 119         super(key, new HashMap&lt;String, Object&gt;());
 120     }
 121 
 122     public Note(String key, Map&lt;String, Object&gt; properties) {
 123         super(key, properties);
 124     }
 125 
 126     protected void updateTitleAndPreview(){
 127         // try to build a title and preview property out of content
 128         String content = getContent().trim();
 129         // title = &quot;Hello World&quot;;
 130         // contentPreview = &quot;This is a preview&quot;;
 131 
 132         int firstNewLinePosition = content.indexOf(NEW_LINE);
 133         if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 134             title = content.substring(0, firstNewLinePosition).trim();
 135 
 136             if (firstNewLinePosition &lt; content.length()) {
 137                 contentPreview = content.substring(firstNewLinePosition, content.length());
<abbr title=" 138                 contentPreview = contentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trim();"> 138                 contentPreview = contentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trim🔵</abbr>
 139                 if (contentPreview.length() &gt;= 300) {
 140                     contentPreview = contentPreview.substring(0, 300);
 141                 }
 142             }
 143             else {
 144                 contentPreview = content;
 145             }
 146         }
 147         else {
 148             title = content;
 149             contentPreview = content;
 150         }
 151     }
 152 
 153 public String getTitle() {
 154        if (title == null) {
 155            updateTitleAndPreview();
 156        }
 157 	return title;
 158 }
 159 
 160     public String getTitle(String ifBlank){
 161         if (title == null) {
 162             updateTitleAndPreview();
 163         }
 164         if (title.trim().equals(&quot;&quot;)) {
 165             return ifBlank;
 166         } else {
 167             return title;
 168         }
 169     }
 170 
 171 public String getContent() {
 172        Object content = getProperty(CONTENT_PROPERTY);
 173        if (content == null) {
 174            return BLANK_CONTENT;
 175        }
 176        return (String) content;
 177 }
 178 
 179 public void setContent(String content) {
 180        title = null;
 181        contentPreview = null;
 182        setProperty(CONTENT_PROPERTY, content);
 183 }
 184 
 185 public String getContentPreview() {
 186        if (contentPreview == null) {
 187            updateTitleAndPreview();
 188        }
 189 	return contentPreview;
 190 }
 191 
 192     public String getContentPreview(int lines){
 193         if (contentPreview == null) {
 194             updateTitleAndPreview();
 195         }
 196         return contentPreview;
 197     }
 198 
 199 public Calendar getCreationDate() {
 200        return numberToDate((Number)getProperty(CREATION_DATE_PROPERTY));
 201 }
 202 
 203 public void setCreationDate(Calendar creationDate) {
 204        setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis()/1000);
 205 }
 206 
 207 public Calendar getModificationDate() {
 208        return numberToDate((Number)getProperty(MODIFICATION_DATE_PROPERTY));
 209 }
 210 
 211 public void setModificationDate(Calendar modificationDate) {
 212        setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis()/1000);
 213 }
 214 
 215     public boolean hasTag(String tag){
 216         List&lt;String&gt; tags = getTags();
 217         String tagLower = tag.toLowerCase();
 218         for (String tagName : tags) {
 219             if (tagLower.equals(tagName.toLowerCase())) return true;
 220         }
 221         return false;
 222     }
 223 
 224     public boolean hasTag(Tag tag){
 225         return hasTag(tag.getSimperiumKey());
 226     }
 227 
 228 public List&lt;String&gt; getTags() {
 229        Object tags = getProperty(TAGS_PROPERTY);
 230        if (tags == null) {
 231            tags = new ArrayList&lt;String&gt;();
 232            setProperty(TAGS_PROPERTY, tags);
 233        }
 234        return (ArrayList&lt;String&gt;) tags;
 235 }
 236 
 237 public void setTags(List&lt;String&gt; tags) {
 238        setProperty(TAGS_PROPERTY, tags);
 239 }
 240 
 241     /**
 242      * String of tags delimited by a space
 243      */
 244     public CharSequence getTagString(){
 245         StringBuilder tagString = new StringBuilder();
 246         List&lt;String&gt; tags = getTags();
 247         for(String tag : tags){
 248             if (tagString.length() &gt; 0) {
 249                 tagString.append(SPACE);
 250             }
 251             tagString.append(tag);
 252         }
 253         return tagString;
 254     }
 255 
 256     /**
 257      * Sets the note&#x27;s tags by providing it with a {@link String} of space
 258      * seperated tags. Filters out duplicate tags.
 259      *
 260      * @param tagString a space delimited list of tags
 261      */
 262     public void setTagString(String tagString){
 263         List&lt;String&gt; tags = getTags();
 264         tags.clear();
 265         if (tagString == null) return;
 266         // Make sure string has a trailing space
 267         if (tagString.length() &gt; 1 &amp;&amp; !tagString.substring(tagString.length() - 1).equals(SPACE))
 268             tagString = tagString + SPACE;
 269         // for comparing case-insensitive strings, would like to find a way to
 270         // do this without allocating a new list and strings
 271         List&lt;String&gt; tagsUpperCase = new ArrayList&lt;String&gt;();
 272         // remove all current tags
 273         int start = 0;
 274         int next = -1;
 275         String possible;
 276         String possibleUpperCase;
 277         // search tag string for space characters and pull out individual tags
 278         do {
 279             next = tagString.indexOf(SPACE, start);
 280             if (next &gt; start) {
 281                 possible = tagString.substring(start, next);
 282                 possibleUpperCase = possible.toUpperCase();
 283                 if (!possible.equals(SPACE) &amp;&amp; !tagsUpperCase.contains(possibleUpperCase)) {
 284                     tagsUpperCase.add(possibleUpperCase);
 285                     tags.add(possible);
 286                 }
 287             }
 288             start = next + 1;
 289         } while(next &gt; -1);
 290     }
 291 
 292 public List&lt;String&gt; getSystemTags() {
 293        Object tags = getProperty(SYSTEM_TAGS_PROPERTY);
 294        if (tags == null) {
 295            return new ArrayList&lt;String&gt;();
 296        }
 297        return (List&lt;String&gt;) tags;
 298 }
 299 
 300 public Boolean isDeleted() {
 301        Object deleted = getProperty(DELETED_PROPERTY);
 302        if (deleted == null) {
 303            return false;
 304        }
 305 	if (deleted instanceof Boolean) {
 306 		return (Boolean) deleted;
 307 	} else if (deleted instanceof Number) {
 308 		return ((Number)deleted).intValue() == 0 ? false : true;
 309        } else {
 310            return false;
 311        }
 312 }
 313 
 314 public void setDeleted(boolean deleted) {
 315 	setProperty(DELETED_PROPERTY, deleted);
 316 }
 317 
 318 public boolean isPinned() {
 319        return getSystemTags().contains(PINNED_TAG);
 320 }
 321 
 322 public void setPinned(boolean isPinned) {
 323        if (isPinned &amp;&amp; !isPinned()) {
 324            getSystemTags().add(PINNED_TAG);
 325        } else if (!isPinned &amp;&amp; isPinned()){
 326            getSystemTags().remove(PINNED_TAG);
 327        }
 328 }
 329 
 330     public static String dateString(Number time, boolean useShortFormat, Context context){
 331         Calendar c = numberToDate(time);
 332         return dateString(c, useShortFormat, context);
 333     }
 334 
 335 public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 336 	int year, month, day;
 337 
 338 	String time, date, retVal;
 339 	time = date = &quot;&quot;;
 340 
 341 	Calendar diff = Calendar.getInstance();
 342 	diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 343 
 344 	year = diff.get(Calendar.YEAR);
 345 	month = diff.get(Calendar.MONTH);
 346 	day = diff.get(Calendar.DAY_OF_MONTH);
 347 
 348 	diff.setTimeInMillis(0); // starting time
 349 	time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 350 	if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 350 	if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calenda🔵</abbr>
 351 		date = context.getResources().getString(R.string.today);
 352 		if (useShortFormat)
 353 			retVal = time;
 354 		else
 355 			retVal = date + &quot;, &quot; + time;
 356 	} else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {
 357 		date = context.getResources().getString(R.string.yesterday);
 358 		if (useShortFormat)
 359 			retVal = date;
 360 		else
 361 			retVal = date + &quot;, &quot; + time;
 362 	} else {
 363 		date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 364 		retVal = date + &quot;, &quot; + time;
 365 	}
 366 
 367 	return retVal;
 368 }
 369 
 370     public static Calendar numberToDate(Number time) {
 371         Calendar date = Calendar.getInstance();
 372         if (time != null) {
 373             // Flick Note uses millisecond resolution timestamps Simplenote expects seconds
 374             // since we only deal with create and modify timestamps, they should all have occured
 375             // at the present time or in the past.
 376             float now = date.getTimeInMillis() / 1000;
 377             float magnitude = time.floatValue() / now;
 378             if (magnitude &gt;= 2.0F) {
 379                 time = time.longValue() / 1000;
 380             }
 381             date.setTimeInMillis(time.longValue() * 1000);
 382         }
 383         return date;
 384     }
 385 
 386     /**
 387      * Check if the note has any changes
 388      * @param content the new note content
 389      * @param tagString space separated tags
 390      * @param isPinned note is pinned
 391      * @return true if note has changes, false if it is unchanged.
 392      */
 393     public boolean hasChanges(String content, String tagString, boolean isPinned) {
 394 
<abbr title=" 395         if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagString().toString()))"> 395         if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.get🔵</abbr>
 396             return false;
 397         else
 398             return true;
 399     }
 400 }</pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  package com.automattic.simplenote.models;
   2  
   3  import java.text.DateFormat;
   4  import java.text.SimpleDateFormat;
   5  import java.util.ArrayList;
   6  import java.util.Calendar;
   7  import java.util.HashMap;
   8  import java.util.Locale;
   9  import java.util.Map;
  10  import java.util.List;
  11  import java.util.ArrayList;
  12  
  13  import android.content.Context;
  14  import android.util.Log;
  15  
  16  import com.automattic.simplenote.R;
  17  
  18  import com.simperium.client.Bucket;
  19  import com.simperium.client.Query;
  20  import com.simperium.client.Query.ComparisonType;
  21  import com.simperium.client.Query.SortType;
  22  import com.simperium.client.BucketObject;
  23  import com.simperium.client.BucketSchema;
  24  import com.simperium.client.BucketSchema.Index;
  25  import com.simperium.client.BucketSchema.Indexer;
  26  
  27  public class Note extends BucketObject {
  28  
  29  	public static final String BUCKET_NAME=&quot;note&quot;;
  30      public static final String PINNED_TAG=&quot;pinned&quot;;
  31      public static final String NEW_LINE=&quot;\n&quot;;
  32  
  33      private static final String CONTENT_CONCAT_FORMAT=&quot;%s %s&quot;;
  34      private static final String BLANK_CONTENT=&quot;&quot;;
  35      private static final String SPACE = &quot; &quot;;
  36  
  37      public static final String CONTENT_PROPERTY=&quot;content&quot;;
  38      public static final String TAGS_PROPERTY=&quot;tags&quot;;
  39      public static final String SYSTEM_TAGS_PROPERTY=&quot;systemTags&quot;;
  40      public static final String CREATION_DATE_PROPERTY=&quot;creationDate&quot;;
  41      public static final String MODIFICATION_DATE_PROPERTY=&quot;modificationDate&quot;;
  42      public static final String SHARE_URL_PROPERTY=&quot;shareURL&quot;;
  43      public static final String PUBLISH_URL_PROPERTY=&quot;publishURL&quot;;
  44      public static final String DELETED_PROPERTY=&quot;deleted&quot;;
  45      public static final String TITLE_INDEX_NAME=&quot;title&quot;;
  46      public static final String CONTENT_PREVIEW_INDEX_NAME=&quot;contentPreview&quot;;
  47      public static final String PINNED_INDEX_NAME=&quot;pinned&quot;;


  48  
  49  	protected String title = null;
  50  	protected String contentPreview = null;
  51  

  52  	public static class Schema extends BucketSchema&lt;Note&gt; {


  53  
  54          public Schema(){
  55              autoIndex();
  56              addIndex(noteIndexer);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +            setupFullTextIndex(TAGS_PROPERTY, CONTENT_PROPERTY);</span>
  58              setDefault(CONTENT_PROPERTY, &quot;&quot;);
  59              setDefault(SYSTEM_TAGS_PROPERTY, new ArrayList&lt;Object&gt;());
  60              setDefault(TAGS_PROPERTY, new ArrayList&lt;Object&gt;());
  61              setDefault(DELETED_PROPERTY, false);
  62              setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
  63              setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
  64          }
  65  
  66          private Indexer noteIndexer = new Indexer&lt;Note&gt;(){
  67              @Override
  68              public List&lt;Index&gt; index(Note note){
  69                  List&lt;Index&gt; indexes = new ArrayList&lt;Index&gt;();
  70                  indexes.add(new Index(PINNED_INDEX_NAME, note.isPinned()));
  71                  indexes.add(new Index(CONTENT_PREVIEW_INDEX_NAME, note.getContentPreview()));
  72                  indexes.add(new Index(TITLE_INDEX_NAME, note.getTitle()));
  73                  return indexes;
  74              }
  75          };
  76  
  77          public String getRemoteName(){
  78              return Note.BUCKET_NAME;
  79          }
  80  
  81  		public Note build(String key, Map&lt;String,Object&gt;properties){
  82  			Note note = new Note(key, properties);
  83  			return note;
  84  		}
  85  
  86          public void update(Note note, Map&lt;String,Object&gt;properties){
  87              note.properties = properties;
  88              note.title = null;
  89              note.contentPreview = null;
  90          }
  91  	}
  92  
  93      public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket){
  94          return noteBucket.query()
  95                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
  96      }
  97  
  98      public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket){
  99          return noteBucket.query()
 100                  .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
 101      }
 102  
 103      public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString){
 104          return noteBucket.query()
 105                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 106                  .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
 107      }
 108  
 109      public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag){
 110          return noteBucket.query()
 111                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 112                  .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
 113      }
 114  
 115  
 116      public Note(String key){
 117          super(key, new HashMap&lt;String,Object&gt;());
 118      }
 119  
 120  	public Note(String key, Map&lt;String,Object&gt;properties) {
 121  		super(key, properties);
 122  	}
 123  
 124      protected void updateTitleAndPreview(){
 125          // try to build a title and preview property out of content
 126          String content = getContent().trim();
 127          // title = &quot;Hello World&quot;;
 128          // contentPreview = &quot;This is a preview&quot;;
 129  
 130          int firstNewLinePosition = content.indexOf(NEW_LINE);
 131          if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 132              title = content.substring(0, firstNewLinePosition).trim();
 133  
 134              if (firstNewLinePosition &lt; content.length()) {
 135                  contentPreview = content.substring(firstNewLinePosition, content.length());
 136                  contentPreview = contentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trim();
 137                  if (contentPreview.length() &gt;= 300) {
 138                      contentPreview = contentPreview.substring(0, 300);
 139                  }
 140              }
 141              else {
 142                  contentPreview = content;
 143              }
 144          }
 145          else {
 146              title = content;
 147              contentPreview = content;
 148          }
 149      }
 150  
 151  	public String getTitle() {
 152          if (title == null) {
 153              updateTitleAndPreview();
 154          }
 155  		return title;
 156  	}
 157  
 158      public String getTitle(String ifBlank){
 159          if (title == null) {
 160              updateTitleAndPreview();
 161          }
 162          if (title.trim().equals(&quot;&quot;)) {
 163              return ifBlank;
 164          } else {
 165              return title;
 166          }
 167      }
 168  
 169  	public String getContent() {
 170          Object content = getProperty(CONTENT_PROPERTY);
 171          if (content == null) {
 172              return BLANK_CONTENT;
 173          }
 174          return (String) content;
 175  	}
 176  
 177  	public void setContent(String content) {
 178          title = null;
 179          contentPreview = null;
 180          setProperty(CONTENT_PROPERTY, content);
 181  	}
 182  
 183  	public String getContentPreview() {
 184          if (contentPreview == null) {
 185              updateTitleAndPreview();
 186          }
 187  		return contentPreview;
 188  	}
 189  
 190      public String getContentPreview(int lines){
 191          if (contentPreview == null) {
 192              updateTitleAndPreview();
 193          }
 194          return contentPreview;
 195      }
 196  
 197  	public Calendar getCreationDate() {
 198          return numberToDate((Number)getProperty(CREATION_DATE_PROPERTY));
 199  	}
 200  
 201  	public void setCreationDate(Calendar creationDate) {
 202          setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis()/1000);
 203  	}
 204  
 205  	public Calendar getModificationDate() {
 206          return numberToDate((Number)getProperty(MODIFICATION_DATE_PROPERTY));
 207  	}
 208  
 209  	public void setModificationDate(Calendar modificationDate) {
 210          setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis()/1000);
 211  	}
 212  
 213      public boolean hasTag(String tag){
 214          List&lt;String&gt; tags = getTags();
 215          String tagLower = tag.toLowerCase();
 216          for (String tagName : tags) {
 217              if (tagLower.equals(tagName.toLowerCase())) return true;
 218          }
 219          return false;
 220      }
 221  
 222      public boolean hasTag(Tag tag){
 223          return hasTag(tag.getSimperiumKey());
 224      }
 225  
 226  	public List&lt;String&gt; getTags() {
 227          Object tags = getProperty(TAGS_PROPERTY);
 228          if (tags == null) {
 229              tags = new ArrayList&lt;String&gt;();
 230              setProperty(TAGS_PROPERTY, tags);
 231          }
 232          return (ArrayList&lt;String&gt;) tags;
 233  	}
 234  
 235  	public void setTags(List&lt;String&gt; tags) {
 236          setProperty(TAGS_PROPERTY, tags);
 237  	}
 238  
 239      /**
 240       * String of tags delimited by a space
 241       */
 242      public CharSequence getTagString(){
 243          StringBuilder tagString = new StringBuilder();
 244          List&lt;String&gt; tags = getTags();
 245          for(String tag : tags){
 246              if (tagString.length() &gt; 0) {
 247                  tagString.append(SPACE);
 248              }
 249              tagString.append(tag);
 250          }
 251          return tagString;
 252      }
 253  
 254      /**
 255       * Sets the note&#x27;s tags by providing it with a {@link String} of space
 256       * seperated tags. Filters out duplicate tags.
 257       *
 258       * @param tagString a space delimited list of tags
 259       */
 260      public void setTagString(String tagString){
 261          List&lt;String&gt; tags = getTags();
 262          tags.clear();
 263          if (tagString == null) return;
 264          // Make sure string has a trailing space
 265          if (tagString.length() &gt; 1 &amp;&amp; !tagString.substring(tagString.length() - 1).equals(SPACE))
 266              tagString = tagString + SPACE;
 267          // for comparing case-insensitive strings, would like to find a way to
 268          // do this without allocating a new list and strings
 269          List&lt;String&gt; tagsUpperCase = new ArrayList&lt;String&gt;();
 270          // remove all current tags
 271          int start = 0;
 272          int next = -1;
 273          String possible;
 274          String possibleUpperCase;
 275          // search tag string for space characters and pull out individual tags
 276          do {
 277              next = tagString.indexOf(SPACE, start);
 278              if (next &gt; start) {
 279                  possible = tagString.substring(start, next);
 280                  possibleUpperCase = possible.toUpperCase();
 281                  if (!possible.equals(SPACE) &amp;&amp; !tagsUpperCase.contains(possibleUpperCase)) {
 282                      tagsUpperCase.add(possibleUpperCase);
 283                      tags.add(possible);
 284                  }
 285              }
 286              start = next + 1;
 287          } while(next &gt; -1);
 288      }
 289  
 290  	public List&lt;String&gt; getSystemTags() {
 291          Object tags = getProperty(SYSTEM_TAGS_PROPERTY);
 292          if (tags == null) {
 293              return new ArrayList&lt;String&gt;();
 294          }
 295          return (List&lt;String&gt;) tags;
 296  	}
 297  
 298  	public Boolean isDeleted() {
 299          Object deleted = getProperty(DELETED_PROPERTY);
 300          if (deleted == null) {
 301              return false;
 302          }
 303  		if (deleted instanceof Boolean) {
 304  			return (Boolean) deleted;
 305  		} else if (deleted instanceof Number) {
 306  			return ((Number)deleted).intValue() == 0 ? false : true;
 307          } else {
 308              return false;
 309          }
 310  	}
 311  
 312  	public void setDeleted(boolean deleted) {
 313  		setProperty(DELETED_PROPERTY, deleted);
 314  	}
 315  
 316  	public boolean isPinned() {
 317          return getSystemTags().contains(PINNED_TAG);
 318  	}
 319  
 320  	public void setPinned(boolean isPinned) {
 321          if (isPinned &amp;&amp; !isPinned()) {
 322              getSystemTags().add(PINNED_TAG);
 323          } else if (!isPinned &amp;&amp; isPinned()){
 324              getSystemTags().remove(PINNED_TAG);
 325          }
 326  	}
 327  
 328      public static String dateString(Number time, boolean useShortFormat, Context context){
 329          Calendar c = numberToDate(time);
 330          return dateString(c, useShortFormat, context);
 331      }
 332  
 333  	public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 334  		int year, month, day;
 335  
 336  		String time, date, retVal;
 337  		time = date = &quot;&quot;;
 338  
 339  		Calendar diff = Calendar.getInstance();
 340  		diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 341  
 342  		year = diff.get(Calendar.YEAR);
 343  		month = diff.get(Calendar.MONTH);
 344  		day = diff.get(Calendar.DAY_OF_MONTH);
 345  
 346  		diff.setTimeInMillis(0); // starting time
 347  		time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 348  		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 348  		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF🔵</abbr>
 349  			date = context.getResources().getString(R.string.today);
 350  			if (useShortFormat)
 351  				retVal = time;
 352  			else
 353  				retVal = date + &quot;, &quot; + time;
 354  		} else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {
 355  			date = context.getResources().getString(R.string.yesterday);
 356  			if (useShortFormat)
 357  				retVal = date;
 358  			else
 359  				retVal = date + &quot;, &quot; + time;
 360  		} else {
 361  			date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 362  			retVal = date + &quot;, &quot; + time;
 363  		}
 364  
 365  		return retVal;
 366  	}
 367  
 368      public static Calendar numberToDate(Number time){
 369          Calendar date = Calendar.getInstance();
 370          if (time != null) {






 371              date.setTimeInMillis(time.longValue()*1000);
 372          }
 373          return date;
 374      }
 375  
 376      /**
 377       * Check if the note has any changes
 378       * @param content the new note content
 379       * @param tagString space separated tags
 380       * @param isPinned note is pinned
 381       * @return true if note has changes, false if it is unchanged.
 382       */
 383      public boolean hasChanges(String content, String tagString, boolean isPinned) {
 384  
<abbr title=" 385          if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagString().toString()))"> 385          if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagString🔵</abbr>
 386              return false;
 387          else
 388              return true;
 389      }
 390  }</pre></td>
                            <td><pre>   1  package com.automattic.simplenote.models;
   2  
   3  import java.text.DateFormat;
   4  import java.text.SimpleDateFormat;
   5  import java.util.ArrayList;
   6  import java.util.Calendar;
   7  import java.util.HashMap;
   8  import java.util.Locale;
   9  import java.util.Map;
  10  import java.util.List;
  11  import java.util.ArrayList;
  12  
  13  import android.content.Context;
  14  import android.util.Log;
  15  
  16  import com.automattic.simplenote.R;
  17  
  18  import com.simperium.client.Bucket;
  19  import com.simperium.client.Query;
  20  import com.simperium.client.Query.ComparisonType;
  21  import com.simperium.client.Query.SortType;
  22  import com.simperium.client.BucketObject;
  23  import com.simperium.client.BucketSchema;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  24 -import com.simperium.client.BucketSchema.Index;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  25 -import com.simperium.client.BucketSchema.Indexer;</span>
  26  
  27  public class Note extends BucketObject {
  28  
  29  	public static final String BUCKET_NAME=&quot;note&quot;;
  30      public static final String PINNED_TAG=&quot;pinned&quot;;
  31      public static final String NEW_LINE=&quot;\n&quot;;
  32  
  33      private static final String CONTENT_CONCAT_FORMAT=&quot;%s %s&quot;;
  34      private static final String BLANK_CONTENT=&quot;&quot;;
  35      private static final String SPACE = &quot; &quot;;
  36  
  37      public static final String CONTENT_PROPERTY=&quot;content&quot;;
  38      public static final String TAGS_PROPERTY=&quot;tags&quot;;
  39      public static final String SYSTEM_TAGS_PROPERTY=&quot;systemTags&quot;;
  40      public static final String CREATION_DATE_PROPERTY=&quot;creationDate&quot;;
  41      public static final String MODIFICATION_DATE_PROPERTY=&quot;modificationDate&quot;;
  42      public static final String SHARE_URL_PROPERTY=&quot;shareURL&quot;;
  43      public static final String PUBLISH_URL_PROPERTY=&quot;publishURL&quot;;
  44      public static final String DELETED_PROPERTY=&quot;deleted&quot;;
  45      public static final String TITLE_INDEX_NAME=&quot;title&quot;;
  46      public static final String CONTENT_PREVIEW_INDEX_NAME=&quot;contentPreview&quot;;
  47      public static final String PINNED_INDEX_NAME=&quot;pinned&quot;;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  48 +    public static final String MODIFIED_INDEX_NAME=&quot;modified&quot;;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  49 +    public static final String CREATED_INDEX_NAME=&quot;created&quot;;</span>
  50  
  51  	protected String title = null;
  52  	protected String contentPreview = null;
  53  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  54 +</span>
  55  	public static class Schema extends BucketSchema&lt;Note&gt; {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  56 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +        protected static NoteIndexer sNoteIndexer = new NoteIndexer();</span>
  58  
  59          public Schema(){
  60              autoIndex();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  61 -            addIndex(noteIndexer);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +            addIndex(sNoteIndexer);</span>
  63              setDefault(CONTENT_PROPERTY, &quot;&quot;);
  64              setDefault(SYSTEM_TAGS_PROPERTY, new ArrayList&lt;Object&gt;());
  65              setDefault(TAGS_PROPERTY, new ArrayList&lt;Object&gt;());
  66              setDefault(DELETED_PROPERTY, false);
  67              setDefault(SHARE_URL_PROPERTY, &quot;&quot;);
  68              setDefault(PUBLISH_URL_PROPERTY, &quot;&quot;);
  69          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  70 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  71 -        private Indexer noteIndexer = new Indexer&lt;Note&gt;(){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  72 -            @Override</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  73 -            public List&lt;Index&gt; index(Note note){</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  74 -                List&lt;Index&gt; indexes = new ArrayList&lt;Index&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  75 -                indexes.add(new Index(PINNED_INDEX_NAME, note.isPinned()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  76 -                indexes.add(new Index(CONTENT_PREVIEW_INDEX_NAME, note.getContentPreview()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  77 -                indexes.add(new Index(TITLE_INDEX_NAME, note.getTitle()));</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  78 -                return indexes;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  79 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  80 -        };</span>
  81  
  82          public String getRemoteName(){
  83              return Note.BUCKET_NAME;
  84          }
  85  
  86  		public Note build(String key, Map&lt;String,Object&gt;properties){
  87  			Note note = new Note(key, properties);
  88  			return note;
  89  		}
  90  
  91          public void update(Note note, Map&lt;String,Object&gt;properties){
  92              note.properties = properties;
  93              note.title = null;
  94              note.contentPreview = null;
  95          }
  96  	}
  97  
  98      public static Query&lt;Note&gt; all(Bucket&lt;Note&gt; noteBucket){
  99          return noteBucket.query()
 100                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true);
 101      }
 102  
 103      public static Query&lt;Note&gt; allDeleted(Bucket&lt;Note&gt; noteBucket){
 104          return noteBucket.query()
 105                  .where(DELETED_PROPERTY, ComparisonType.EQUAL_TO, true);
 106      }
 107  
 108      public static Query&lt;Note&gt; search(Bucket&lt;Note&gt; noteBucket, String searchString){
 109          return noteBucket.query()
 110                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 111                  .where(CONTENT_PROPERTY, ComparisonType.LIKE, &quot;%&quot; + searchString + &quot;%&quot;);
 112      }
 113  
 114      public static Query&lt;Note&gt; allInTag(Bucket&lt;Note&gt; noteBucket, String tag){
 115          return noteBucket.query()
 116                  .where(DELETED_PROPERTY, ComparisonType.NOT_EQUAL_TO, true)
 117                  .where(TAGS_PROPERTY, ComparisonType.LIKE, tag);
 118      }
 119  
 120  
 121      public Note(String key){
 122          super(key, new HashMap&lt;String,Object&gt;());
 123      }
 124  
 125  	public Note(String key, Map&lt;String,Object&gt;properties) {
 126  		super(key, properties);
 127  	}
 128  
 129      protected void updateTitleAndPreview(){
 130          // try to build a title and preview property out of content
 131          String content = getContent().trim();
 132          // title = &quot;Hello World&quot;;
 133          // contentPreview = &quot;This is a preview&quot;;
 134  
 135          int firstNewLinePosition = content.indexOf(NEW_LINE);
 136          if (firstNewLinePosition &gt; -1 &amp;&amp; firstNewLinePosition &lt; 200) {
 137              title = content.substring(0, firstNewLinePosition).trim();
 138  
 139              if (firstNewLinePosition &lt; content.length()) {
 140                  contentPreview = content.substring(firstNewLinePosition, content.length());
 141                  contentPreview = contentPreview.replace(NEW_LINE, SPACE).replace(SPACE+SPACE, SPACE).trim();
 142                  if (contentPreview.length() &gt;= 300) {
 143                      contentPreview = contentPreview.substring(0, 300);
 144                  }
 145              }
 146              else {
 147                  contentPreview = content;
 148              }
 149          }
 150          else {
 151              title = content;
 152              contentPreview = content;
 153          }
 154      }
 155  
 156  	public String getTitle() {
 157          if (title == null) {
 158              updateTitleAndPreview();
 159          }
 160  		return title;
 161  	}
 162  
 163      public String getTitle(String ifBlank){
 164          if (title == null) {
 165              updateTitleAndPreview();
 166          }
 167          if (title.trim().equals(&quot;&quot;)) {
 168              return ifBlank;
 169          } else {
 170              return title;
 171          }
 172      }
 173  
 174  	public String getContent() {
 175          Object content = getProperty(CONTENT_PROPERTY);
 176          if (content == null) {
 177              return BLANK_CONTENT;
 178          }
 179          return (String) content;
 180  	}
 181  
 182  	public void setContent(String content) {
 183          title = null;
 184          contentPreview = null;
 185          setProperty(CONTENT_PROPERTY, content);
 186  	}
 187  
 188  	public String getContentPreview() {
 189          if (contentPreview == null) {
 190              updateTitleAndPreview();
 191          }
 192  		return contentPreview;
 193  	}
 194  
 195      public String getContentPreview(int lines){
 196          if (contentPreview == null) {
 197              updateTitleAndPreview();
 198          }
 199          return contentPreview;
 200      }
 201  
 202  	public Calendar getCreationDate() {
 203          return numberToDate((Number)getProperty(CREATION_DATE_PROPERTY));
 204  	}
 205  
 206  	public void setCreationDate(Calendar creationDate) {
 207          setProperty(CREATION_DATE_PROPERTY, creationDate.getTimeInMillis()/1000);
 208  	}
 209  
 210  	public Calendar getModificationDate() {
 211          return numberToDate((Number)getProperty(MODIFICATION_DATE_PROPERTY));
 212  	}
 213  
 214  	public void setModificationDate(Calendar modificationDate) {
 215          setProperty(MODIFICATION_DATE_PROPERTY, modificationDate.getTimeInMillis()/1000);
 216  	}
 217  
 218      public boolean hasTag(String tag){
 219          List&lt;String&gt; tags = getTags();
 220          String tagLower = tag.toLowerCase();
 221          for (String tagName : tags) {
 222              if (tagLower.equals(tagName.toLowerCase())) return true;
 223          }
 224          return false;
 225      }
 226  
 227      public boolean hasTag(Tag tag){
 228          return hasTag(tag.getSimperiumKey());
 229      }
 230  
 231  	public List&lt;String&gt; getTags() {
 232          Object tags = getProperty(TAGS_PROPERTY);
 233          if (tags == null) {
 234              tags = new ArrayList&lt;String&gt;();
 235              setProperty(TAGS_PROPERTY, tags);
 236          }
 237          return (ArrayList&lt;String&gt;) tags;
 238  	}
 239  
 240  	public void setTags(List&lt;String&gt; tags) {
 241          setProperty(TAGS_PROPERTY, tags);
 242  	}
 243  
 244      /**
 245       * String of tags delimited by a space
 246       */
 247      public CharSequence getTagString(){
 248          StringBuilder tagString = new StringBuilder();
 249          List&lt;String&gt; tags = getTags();
 250          for(String tag : tags){
 251              if (tagString.length() &gt; 0) {
 252                  tagString.append(SPACE);
 253              }
 254              tagString.append(tag);
 255          }
 256          return tagString;
 257      }
 258  
 259      /**
 260       * Sets the note&#x27;s tags by providing it with a {@link String} of space
 261       * seperated tags. Filters out duplicate tags.
 262       *
 263       * @param tagString a space delimited list of tags
 264       */
 265      public void setTagString(String tagString){
 266          List&lt;String&gt; tags = getTags();
 267          tags.clear();
 268          if (tagString == null) return;
 269          // Make sure string has a trailing space
 270          if (tagString.length() &gt; 1 &amp;&amp; !tagString.substring(tagString.length() - 1).equals(SPACE))
 271              tagString = tagString + SPACE;
 272          // for comparing case-insensitive strings, would like to find a way to
 273          // do this without allocating a new list and strings
 274          List&lt;String&gt; tagsUpperCase = new ArrayList&lt;String&gt;();
 275          // remove all current tags
 276          int start = 0;
 277          int next = -1;
 278          String possible;
 279          String possibleUpperCase;
 280          // search tag string for space characters and pull out individual tags
 281          do {
 282              next = tagString.indexOf(SPACE, start);
 283              if (next &gt; start) {
 284                  possible = tagString.substring(start, next);
 285                  possibleUpperCase = possible.toUpperCase();
 286                  if (!possible.equals(SPACE) &amp;&amp; !tagsUpperCase.contains(possibleUpperCase)) {
 287                      tagsUpperCase.add(possibleUpperCase);
 288                      tags.add(possible);
 289                  }
 290              }
 291              start = next + 1;
 292          } while(next &gt; -1);
 293      }
 294  
 295  	public List&lt;String&gt; getSystemTags() {
 296          Object tags = getProperty(SYSTEM_TAGS_PROPERTY);
 297          if (tags == null) {
 298              return new ArrayList&lt;String&gt;();
 299          }
 300          return (List&lt;String&gt;) tags;
 301  	}
 302  
 303  	public Boolean isDeleted() {
 304          Object deleted = getProperty(DELETED_PROPERTY);
 305          if (deleted == null) {
 306              return false;
 307          }
 308  		if (deleted instanceof Boolean) {
 309  			return (Boolean) deleted;
 310  		} else if (deleted instanceof Number) {
 311  			return ((Number)deleted).intValue() == 0 ? false : true;
 312          } else {
 313              return false;
 314          }
 315  	}
 316  
 317  	public void setDeleted(boolean deleted) {
 318  		setProperty(DELETED_PROPERTY, deleted);
 319  	}
 320  
 321  	public boolean isPinned() {
 322          return getSystemTags().contains(PINNED_TAG);
 323  	}
 324  
 325  	public void setPinned(boolean isPinned) {
 326          if (isPinned &amp;&amp; !isPinned()) {
 327              getSystemTags().add(PINNED_TAG);
 328          } else if (!isPinned &amp;&amp; isPinned()){
 329              getSystemTags().remove(PINNED_TAG);
 330          }
 331  	}
 332  
 333      public static String dateString(Number time, boolean useShortFormat, Context context){
 334          Calendar c = numberToDate(time);
 335          return dateString(c, useShortFormat, context);
 336      }
 337  
 338  	public static String dateString(Calendar c, boolean useShortFormat, Context context) {
 339  		int year, month, day;
 340  
 341  		String time, date, retVal;
 342  		time = date = &quot;&quot;;
 343  
 344  		Calendar diff = Calendar.getInstance();
 345  		diff.setTimeInMillis(diff.getTimeInMillis() - c.getTimeInMillis());
 346  
 347  		year = diff.get(Calendar.YEAR);
 348  		month = diff.get(Calendar.MONTH);
 349  		day = diff.get(Calendar.DAY_OF_MONTH);
 350  
 351  		diff.setTimeInMillis(0); // starting time
 352  		time = DateFormat.getTimeInstance(DateFormat.SHORT).format(c.getTime());
<abbr title=" 353  		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF_MONTH))) {"> 353  		if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == diff.get(Calendar.DAY_OF🔵</abbr>
 354  			date = context.getResources().getString(R.string.today);
 355  			if (useShortFormat)
 356  				retVal = time;
 357  			else
 358  				retVal = date + &quot;, &quot; + time;
 359  		} else if ((year == diff.get(Calendar.YEAR)) &amp;&amp; (month == diff.get(Calendar.MONTH)) &amp;&amp; (day == 1)) {
 360  			date = context.getResources().getString(R.string.yesterday);
 361  			if (useShortFormat)
 362  				retVal = date;
 363  			else
 364  				retVal = date + &quot;, &quot; + time;
 365  		} else {
 366  			date = new SimpleDateFormat(&quot;MMM dd&quot;, Locale.US).format(c.getTime());
 367  			retVal = date + &quot;, &quot; + time;
 368  		}
 369  
 370  		return retVal;
 371  	}
 372  
 373      public static Calendar numberToDate(Number time){
 374          Calendar date = Calendar.getInstance();
 375          if (time != null) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 376 +            // Flick Note uses millisecond resolution timestamps Simplenote expects seconds</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 377 +            // since we only deal with create and modify timestamps, they should all have occured</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 378 +            // at the present time or in the past.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 379 +            float now = date.getTimeInMillis()/1000;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 380 +            float magnitude = time.floatValue()/now;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 381 +            if (magnitude &gt;= 2.f) time = time.longValue()/1000;</span>
 382              date.setTimeInMillis(time.longValue()*1000);
 383          }
 384          return date;
 385      }
 386  
 387      /**
 388       * Check if the note has any changes
 389       * @param content the new note content
 390       * @param tagString space separated tags
 391       * @param isPinned note is pinned
 392       * @return true if note has changes, false if it is unchanged.
 393       */
 394      public boolean hasChanges(String content, String tagString, boolean isPinned) {
 395  
<abbr title=" 396          if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagString().toString()))"> 396          if (content.equals(this.getContent()) &amp;&amp; this.isPinned() == isPinned &amp;&amp; tagString.equals(this.getTagString🔵</abbr>
 397              return false;
 398          else
 399              return true;
 400      }
 401  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            