<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>508</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    508
                    <a href="507.html">prev</a>
                    <a href="509.html">next</a>
                    <a href="508_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_89ee93e0f8b6ac1ed6aefc2b940d1606f2027491_src/com/android/launcher3/Workspace.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;89ee93e0f8b6ac1ed6aefc2b940d1606f2027491:src/com/android/launcher3/Workspace.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;89ee93e0f8b6ac1ed6aefc2b940d1606f2027491^1:src/com/android/launcher3/Workspace.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;89ee93e0f8b6ac1ed6aefc2b940d1606f2027491^2:src/com/android/launcher3/Workspace.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;e248b83797e6b6ce128085560ad0c5b900413bf2:src/com/android/launcher3/Workspace.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj], [s]], subset: [[sbj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.animation.Animator;
  20 import android.animation.Animator.AnimatorListener;
  21 import android.animation.AnimatorListenerAdapter;
  22 import android.animation.AnimatorSet;
  23 import android.animation.LayoutTransition;
  24 import android.animation.ObjectAnimator;
  25 import android.animation.PropertyValuesHolder;
  26 import android.animation.TimeInterpolator;
  27 import android.animation.ValueAnimator;
  28 import android.animation.ValueAnimator.AnimatorUpdateListener;
  29 import android.app.WallpaperManager;
  30 import android.appwidget.AppWidgetHostView;
  31 import android.appwidget.AppWidgetProviderInfo;
  32 import android.content.ComponentName;
  33 import android.content.Context;
  34 import android.content.Intent;
  35 import android.content.SharedPreferences;
  36 import android.content.res.Resources;
  37 import android.content.res.TypedArray;
  38 import android.graphics.Bitmap;
  39 import android.graphics.Canvas;
  40 import android.graphics.Matrix;
  41 import android.graphics.Point;
  42 import android.graphics.PointF;
  43 import android.graphics.Rect;
  44 import android.graphics.Region.Op;
  45 import android.graphics.drawable.Drawable;
  46 import android.net.Uri;
  47 import android.os.IBinder;
  48 import android.os.Parcelable;
  49 import android.support.v4.view.ViewCompat;
  50 import android.util.AttributeSet;
  51 import android.util.Log;
  52 import android.util.SparseArray;
  53 import android.view.Choreographer;
  54 import android.view.Display;
  55 import android.view.MotionEvent;
  56 import android.view.View;
  57 import android.view.ViewGroup;
  58 import android.view.View.OnClickListener;
  59 import android.view.accessibility.AccessibilityEvent;
  60 import android.view.accessibility.AccessibilityManager;
  61 import android.view.accessibility.AccessibilityNodeInfo;
  62 import android.view.animation.DecelerateInterpolator;
  63 import android.view.animation.Interpolator;
  64 import android.widget.TextView;
  65 
  66 import com.android.launcher3.FolderIcon.FolderRingAnimator;
  67 import com.android.launcher3.Launcher.CustomContentCallbacks;
  68 import com.android.launcher3.LauncherSettings.Favorites;
  69 
  70 import java.util.ArrayList;
  71 import java.util.HashMap;
  72 import java.util.HashSet;
  73 import java.util.Iterator;
  74 
  75 /**
  76  * The workspace is a wide area with a wallpaper and a finite number of pages.
  77  * Each page contains a number of icons, folders or widgets the user can
  78  * interact with. A workspace is meant to be used with a fixed width only.
  79  */
  80 public class Workspace extends SmoothPagedView
  81         implements DropTarget, DragSource, DragScroller, View.OnTouchListener,
  82         DragController.DragListener, LauncherTransitionable, ViewGroup.OnHierarchyChangeListener,
  83         Insettable {
  84     private static final String TAG = &quot;Launcher.Workspace&quot;;
  85 
  86     // Y rotation to apply to the workspace screens
  87     private static final float WORKSPACE_OVERSCROLL_ROTATION = 24f;
  88 
  89     private static final int CHILDREN_OUTLINE_FADE_OUT_DELAY = 0;
  90     private static final int CHILDREN_OUTLINE_FADE_OUT_DURATION = 375;
  91     private static final int CHILDREN_OUTLINE_FADE_IN_DURATION = 100;
  92 
  93     protected static final int SNAP_OFF_EMPTY_SCREEN_DURATION = 400;
  94     protected static final int FADE_EMPTY_SCREEN_DURATION = 150;
  95 
  96     private static final int BACKGROUND_FADE_OUT_DURATION = 350;
  97     private static final int ADJACENT_SCREEN_DROP_DURATION = 300;
  98     private static final int FLING_THRESHOLD_VELOCITY = 500;
  99 
 100     private static final float ALPHA_CUTOFF_THRESHOLD = 0.01f;
 101 
 102     // These animators are used to fade the children&#x27;s outlines
 103     private ObjectAnimator mChildrenOutlineFadeInAnimation;
 104     private ObjectAnimator mChildrenOutlineFadeOutAnimation;
 105     private float mChildrenOutlineAlpha = 0;
 106 
 107     // These properties refer to the background protection gradient used for AllApps and Customize
 108     private ValueAnimator mBackgroundFadeInAnimation;
 109     private ValueAnimator mBackgroundFadeOutAnimation;
 110     private Drawable mBackground;
 111     boolean mDrawBackground = true;
 112     private float mBackgroundAlpha = 0;
 113 
 114     private static final long CUSTOM_CONTENT_GESTURE_DELAY = 200;
 115     private long mTouchDownTime = -1;
 116     private long mCustomContentShowTime = -1;
 117 
 118     private LayoutTransition mLayoutTransition;
 119     private final WallpaperManager mWallpaperManager;
 120     private IBinder mWindowToken;
 121 
 122     private int mOriginalDefaultPage;
 123     private int mDefaultPage;
 124 
 125     private ShortcutAndWidgetContainer mDragSourceInternal;
 126     private static boolean sAccessibilityEnabled;
 127 
 128     // The screen id used for the empty screen always present to the right.
 129     private final static long EXTRA_EMPTY_SCREEN_ID = -201;
 130     private final static long CUSTOM_CONTENT_SCREEN_ID = -301;
 131 
 132     private HashMap&lt;Long, CellLayout&gt; mWorkspaceScreens = new HashMap&lt;Long, CellLayout&gt;();
 133     private ArrayList&lt;Long&gt; mScreenOrder = new ArrayList&lt;Long&gt;();
 134 
 135     private Runnable mRemoveEmptyScreenRunnable;
 136 
 137     /**
 138      * CellInfo for the cell that is currently being dragged
 139      */
 140     private CellLayout.CellInfo mDragInfo;
 141 
 142     /**
 143      * Target drop area calculated during last acceptDrop call.
 144      */
 145     private int[] mTargetCell = new int[2];
 146     private int mDragOverX = -1;
 147     private int mDragOverY = -1;
 148 
 149     static Rect mLandscapeCellLayoutMetrics = null;
 150     static Rect mPortraitCellLayoutMetrics = null;
 151 
 152     CustomContentCallbacks mCustomContentCallbacks;
 153     boolean mCustomContentShowing;
 154     private float mLastCustomContentScrollProgress = -1f;
 155     private String mCustomContentDescription = &quot;&quot;;
 156 
 157     /**
 158      * The CellLayout that is currently being dragged over
 159      */
 160     private CellLayout mDragTargetLayout = null;
 161     /**
 162      * The CellLayout that we will show as glowing
 163      */
 164     private CellLayout mDragOverlappingLayout = null;
 165 
 166     /**
 167      * The CellLayout which will be dropped to
 168      */
 169     private CellLayout mDropToLayout = null;
 170 
 171     private Launcher mLauncher;
 172     private IconCache mIconCache;
 173     private DragController mDragController;
 174 
 175     // These are temporary variables to prevent having to allocate a new object just to
 176     // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
 177     private int[] mTempCell = new int[2];
 178     private int[] mTempPt = new int[2];
 179     private int[] mTempEstimate = new int[2];
 180     private float[] mDragViewVisualCenter = new float[2];
 181     private float[] mTempCellLayoutCenterCoordinates = new float[2];
 182     private Matrix mTempInverseMatrix = new Matrix();
 183 
 184     private SpringLoadedDragController mSpringLoadedDragController;
 185     private float mSpringLoadedShrinkFactor;
 186     private float mOverviewModeShrinkFactor;
 187 
 188     // State variable that indicates whether the pages are small (ie when you&#x27;re
 189     // in all apps or customize mode)
 190 
 191     enum State { NORMAL, SPRING_LOADED, SMALL, OVERVIEW};
 192     private State mState = State.NORMAL;
 193     private boolean mIsSwitchingState = false;
 194 
 195     boolean mAnimatingViewIntoPlace = false;
 196     boolean mIsDragOccuring = false;
 197     boolean mChildrenLayersEnabled = true;
 198 
 199     private boolean mStripScreensOnPageStopMoving = false;
 200 
 201     /** Is the user is dragging an item near the edge of a page? */
 202     private boolean mInScrollArea = false;
 203 
 204     private HolographicOutlineHelper mOutlineHelper;
 205     private Bitmap mDragOutline = null;
 206     private final Rect mTempRect = new Rect();
 207     private final int[] mTempXY = new int[2];
 208     private int[] mTempVisiblePagesRange = new int[2];
 209     private boolean mOverscrollTransformsSet;
 210     private float mLastOverscrollPivotX;
 211     public static final int DRAG_BITMAP_PADDING = 2;
 212     private boolean mWorkspaceFadeInAdjacentScreens;
 213 
 214     WallpaperOffsetInterpolator mWallpaperOffset;
 215     private Runnable mDelayedResizeRunnable;
 216     private Runnable mDelayedSnapToPageRunnable;
 217     private Point mDisplaySize = new Point();
 218     private int mCameraDistance;
 219 
 220     // Variables relating to the creation of user folders by hovering shortcuts over shortcuts
 221     private static final int FOLDER_CREATION_TIMEOUT = 0;
 222     private static final int REORDER_TIMEOUT = 250;
 223     private final Alarm mFolderCreationAlarm = new Alarm();
 224     private final Alarm mReorderAlarm = new Alarm();
 225     private FolderRingAnimator mDragFolderRingAnimator = null;
 226     private FolderIcon mDragOverFolderIcon = null;
 227     private boolean mCreateUserFolderOnDrop = false;
 228     private boolean mAddToExistingFolderOnDrop = false;
 229     private DropTarget.DragEnforcer mDragEnforcer;
 230     private float mMaxDistanceForFolderCreation;
 231 
 232     // Variables relating to touch disambiguation (scrolling workspace vs. scrolling a widget)
 233     private float mXDown;
 234     private float mYDown;
 235     final static float START_DAMPING_TOUCH_SLOP_ANGLE = (float) Math.PI / 6;
 236     final static float MAX_SWIPE_ANGLE = (float) Math.PI / 3;
 237     final static float TOUCH_SLOP_DAMPING_FACTOR = 4;
 238 
 239     // Relating to the animation of items being dropped externally
 240     public static final int ANIMATE_INTO_POSITION_AND_DISAPPEAR = 0;
 241     public static final int ANIMATE_INTO_POSITION_AND_REMAIN = 1;
 242     public static final int ANIMATE_INTO_POSITION_AND_RESIZE = 2;
 243     public static final int COMPLETE_TWO_STAGE_WIDGET_DROP_ANIMATION = 3;
 244     public static final int CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION = 4;
 245 
 246     // Related to dragging, folder creation and reordering
 247     private static final int DRAG_MODE_NONE = 0;
 248     private static final int DRAG_MODE_CREATE_FOLDER = 1;
 249     private static final int DRAG_MODE_ADD_TO_FOLDER = 2;
 250     private static final int DRAG_MODE_REORDER = 3;
 251     private int mDragMode = DRAG_MODE_NONE;
 252     private int mLastReorderX = -1;
 253     private int mLastReorderY = -1;
 254 
 255     private SparseArray&lt;Parcelable&gt; mSavedStates;
 256     private final ArrayList&lt;Integer&gt; mRestoredPages = new ArrayList&lt;Integer&gt;();
 257 
 258     // These variables are used for storing the initial and final values during workspace animations
 259     private int mSavedScrollX;
 260     private float mSavedRotationY;
 261     private float mSavedTranslationX;
 262 
 263     private float mCurrentScale;
 264     private float mNewScale;
 265     private float[] mOldBackgroundAlphas;
 266     private float[] mOldAlphas;
 267     private float[] mNewBackgroundAlphas;
 268     private float[] mNewAlphas;
 269     private int mLastChildCount = -1;
 270     private float mTransitionProgress;
 271 
 272     private Runnable mDeferredAction;
 273     private boolean mDeferDropAfterUninstall;
 274     private boolean mUninstallSuccessful;
 275 
 276     private final Runnable mBindPages = new Runnable() {
 277         @Override
 278         public void run() {
 279             mLauncher.getModel().bindRemainingSynchronousPages();
 280         }
 281     };
 282 
 283     /**
 284      * Used to inflate the Workspace from XML.
 285      *
 286      * @param context The application&#x27;s context.
 287      * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 288      */
 289     public Workspace(Context context, AttributeSet attrs) {
 290         this(context, attrs, 0);
 291     }
 292 
 293     /**
 294      * Used to inflate the Workspace from XML.
 295      *
 296      * @param context The application&#x27;s context.
 297      * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 298      * @param defStyle Unused.
 299      */
 300     public Workspace(Context context, AttributeSet attrs, int defStyle) {
 301         super(context, attrs, defStyle);
 302         mContentIsRefreshable = false;
 303 
 304         mOutlineHelper = HolographicOutlineHelper.obtain(context);
 305 
 306         mDragEnforcer = new DropTarget.DragEnforcer(context);
 307         // With workspace, data is available straight from the get-go
 308         setDataIsReady();
 309 
 310         mLauncher = (Launcher) context;
 311         final Resources res = getResources();
 312         mWorkspaceFadeInAdjacentScreens = LauncherAppState.getInstance().getDynamicGrid().
 313                 getDeviceProfile().shouldFadeAdjacentWorkspaceScreens();
 314         mFadeInAdjacentScreens = false;
 315         mWallpaperManager = WallpaperManager.getInstance(context);
 316 
 317         LauncherAppState app = LauncherAppState.getInstance();
 318         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 319         TypedArray a = context.obtainStyledAttributes(attrs,
 320                 R.styleable.Workspace, defStyle, 0);
 321         mSpringLoadedShrinkFactor =
 322             res.getInteger(R.integer.config_workspaceSpringLoadShrinkPercentage) / 100.0f;
 323         mOverviewModeShrinkFactor = grid.getOverviewModeScale();
 324         mCameraDistance = res.getInteger(R.integer.config_cameraDistance);
 325         mOriginalDefaultPage = mDefaultPage = a.getInt(R.styleable.Workspace_defaultScreen, 1);
 326         a.recycle();
 327 
 328         setOnHierarchyChangeListener(this);
 329         setHapticFeedbackEnabled(false);
 330 
 331         initWorkspace();
 332 
 333         // Disable multitouch across the workspace/all apps/customize tray
 334         setMotionEventSplittingEnabled(true);
 335         setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
 336     }
 337 
 338     @Override
 339     public void setInsets(Rect insets) {
 340         mInsets.set(insets);
 341     }
 342 
 343     // estimate the size of a widget with spans hSpan, vSpan. return MAX_VALUE for each
 344     // dimension if unsuccessful
 345     public int[] estimateItemSize(int hSpan, int vSpan,
 346             ItemInfo itemInfo, boolean springLoaded) {
 347         int[] size = new int[2];
 348         if (getChildCount() &gt; 0) {
 349             // Use the first non-custom page to estimate the child position
 350             CellLayout cl = (CellLayout) getChildAt(numCustomPages());
 351             Rect r = estimateItemPosition(cl, itemInfo, 0, 0, hSpan, vSpan);
 352             size[0] = r.width();
 353             size[1] = r.height();
 354             if (springLoaded) {
 355                 size[0] *= mSpringLoadedShrinkFactor;
 356                 size[1] *= mSpringLoadedShrinkFactor;
 357             }
 358             return size;
 359         } else {
 360             size[0] = Integer.MAX_VALUE;
 361             size[1] = Integer.MAX_VALUE;
 362             return size;
 363         }
 364     }
 365 
 366     public Rect estimateItemPosition(CellLayout cl, ItemInfo pendingInfo,
 367             int hCell, int vCell, int hSpan, int vSpan) {
 368         Rect r = new Rect();
 369         cl.cellToRect(hCell, vCell, hSpan, vSpan, r);
 370         return r;
 371     }
 372 
 373     public void onDragStart(final DragSource source, Object info, int dragAction) {
 374         mIsDragOccuring = true;
 375         updateChildrenLayersEnabled(false);
 376         mLauncher.lockScreenOrientation();
 377         mLauncher.onInteractionBegin();
 378         setChildrenBackgroundAlphaMultipliers(1f);
 379         // Prevent any Un/InstallShortcutReceivers from updating the db while we are dragging
 380         InstallShortcutReceiver.enableInstallQueue();
 381         UninstallShortcutReceiver.enableUninstallQueue();
 382         post(new Runnable() {
 383             @Override
 384             public void run() {
 385                 if (mIsDragOccuring) {
 386                     addExtraEmptyScreenOnDrag();
 387                 }
 388             }
 389         });
 390     }
 391 
 392     public void onDragEnd() {
 393         mIsDragOccuring = false;
 394         updateChildrenLayersEnabled(false);
 395         mLauncher.unlockScreenOrientation(false);
 396 
 397         // Re-enable any Un/InstallShortcutReceiver and now process any queued items
 398         InstallShortcutReceiver.disableAndFlushInstallQueue(getContext());
 399         UninstallShortcutReceiver.disableAndFlushUninstallQueue(getContext());
 400 
 401         mDragSourceInternal = null;
 402         mLauncher.onInteractionEnd();
 403     }
 404 
 405     /**
 406      * Initializes various states for this workspace.
 407      */
 408     protected void initWorkspace() {
 409         Context context = getContext();
 410         mCurrentPage = mDefaultPage;
 411         Launcher.setScreen(mCurrentPage);
 412         LauncherAppState app = LauncherAppState.getInstance();
 413         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 414         mIconCache = app.getIconCache();
 415         setWillNotDraw(false);
 416         setClipChildren(false);
 417         setClipToPadding(false);
 418         setChildrenDrawnWithCacheEnabled(true);
 419         
 420         setMinScale(mOverviewModeShrinkFactor);
 421         setupLayoutTransition();
 422 
 423         final Resources res = getResources();
 424         try {
 425             mBackground = res.getDrawable(R.drawable.apps_customize_bg);
 426         } catch (Resources.NotFoundException e) {
 427             // In this case, we will skip drawing background protection
 428         }
 429 
 430         mWallpaperOffset = new WallpaperOffsetInterpolator();
 431         Display display = mLauncher.getWindowManager().getDefaultDisplay();
 432         display.getSize(mDisplaySize);
 433 
 434         mMaxDistanceForFolderCreation = (0.55f * grid.iconSizePx);
 435         mFlingThresholdVelocity = (int) (FLING_THRESHOLD_VELOCITY * mDensity);
 436     }
 437 
 438     private void setupLayoutTransition() {
 439         // We want to show layout transitions when pages are deleted, to close the gap.
 440         mLayoutTransition = new LayoutTransition();
 441         mLayoutTransition.enableTransitionType(LayoutTransition.DISAPPEARING);
 442         mLayoutTransition.enableTransitionType(LayoutTransition.CHANGE_DISAPPEARING);
 443         mLayoutTransition.disableTransitionType(LayoutTransition.APPEARING);
 444         mLayoutTransition.disableTransitionType(LayoutTransition.CHANGE_APPEARING);
 445         setLayoutTransition(mLayoutTransition);
 446     }
 447 
 448     void enableLayoutTransitions() {
 449         setLayoutTransition(mLayoutTransition);
 450     }
 451     void disableLayoutTransitions() {
 452         setLayoutTransition(null);
 453     }
 454 
 455     @Override
 456     protected int getScrollMode() {
 457         return SmoothPagedView.X_LARGE_MODE;
 458     }
 459 
 460     @Override
 461     public void onChildViewAdded(View parent, View child) {
 462         if (!(child instanceof CellLayout)) {
 463             throw new IllegalArgumentException(&quot;A Workspace can only have CellLayout children.&quot;);
 464         }
 465         CellLayout cl = ((CellLayout) child);
 466         cl.setOnInterceptTouchListener(this);
 467         cl.setClickable(true);
 468         cl.setImportantForAccessibility(ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_NO);
 469         super.onChildViewAdded(parent, child);
 470     }
 471 
 472     protected boolean shouldDrawChild(View child) {
 473         final CellLayout cl = (CellLayout) child;
 474         return super.shouldDrawChild(child) &amp;&amp;
 475             (mIsSwitchingState ||
 476              cl.getShortcutsAndWidgets().getAlpha() &gt; 0 ||
 477              cl.getBackgroundAlpha() &gt; 0);
 478     }
 479 
 480     /**
 481      * @return The open folder on the current screen, or null if there is none
 482      */
 483     Folder getOpenFolder() {
 484         DragLayer dragLayer = mLauncher.getDragLayer();
 485         int count = dragLayer.getChildCount();
 486         for (int i = 0; i &lt; count; i++) {
 487             View child = dragLayer.getChildAt(i);
 488             if (child instanceof Folder) {
 489                 Folder folder = (Folder) child;
 490                 if (folder.getInfo().opened)
 491                     return folder;
 492             }
 493         }
 494         return null;
 495     }
 496 
 497     boolean isTouchActive() {
 498         return mTouchState != TOUCH_STATE_REST;
 499     }
 500 
 501     public void removeAllWorkspaceScreens() {
 502         // Disable all layout transitions before removing all pages to ensure that we don&#x27;t get the
 503         // transition animations competing with us changing the scroll when we add pages or the
 504         // custom content screen
 505         disableLayoutTransitions();
 506 
 507         // Since we increment the current page when we call addCustomContentPage via bindScreens
 508         // (and other places), we need to adjust the current page back when we clear the pages
 509         if (hasCustomContent()) {
 510             removeCustomContentPage();
 511         }
 512 
 513         // Remove the pages and clear the screen models
 514         removeAllViews();
 515         mScreenOrder.clear();
 516         mWorkspaceScreens.clear();
 517 
 518         // Re-enable the layout transitions
 519         enableLayoutTransitions();
 520     }
 521 
 522     public long insertNewWorkspaceScreenBeforeEmptyScreen(long screenId) {
 523         // Find the index to insert this view into.  If the empty screen exists, then
 524         // insert it before that.
 525         int insertIndex = mScreenOrder.indexOf(EXTRA_EMPTY_SCREEN_ID);
 526         if (insertIndex &lt; 0) {
 527             insertIndex = mScreenOrder.size();
 528         }
 529         return insertNewWorkspaceScreen(screenId, insertIndex);
 530     }
 531 
 532     public long insertNewWorkspaceScreen(long screenId) {
 533         return insertNewWorkspaceScreen(screenId, getChildCount());
 534     }
 535 
 536     public long insertNewWorkspaceScreen(long screenId, int insertIndex) {
 537         if (mWorkspaceScreens.containsKey(screenId)) {
 538             throw new RuntimeException(&quot;Screen id &quot; + screenId + &quot; already exists!&quot;);
 539         }
 540 
 541         CellLayout newScreen = (CellLayout)
 542                 mLauncher.getLayoutInflater().inflate(R.layout.workspace_screen, null);
 543 
 544         newScreen.setOnLongClickListener(mLongClickListener);
 545         newScreen.setOnClickListener(mLauncher);
 546         newScreen.setSoundEffectsEnabled(false);
 547         mWorkspaceScreens.put(screenId, newScreen);
 548         mScreenOrder.add(insertIndex, screenId);
 549         addView(newScreen, insertIndex);
 550         return screenId;
 551     }
 552 
 553     public void createCustomContentPage() {
 554         CellLayout customScreen = (CellLayout)
 555                 mLauncher.getLayoutInflater().inflate(R.layout.workspace_screen, null);
 556 
 557         mWorkspaceScreens.put(CUSTOM_CONTENT_SCREEN_ID, customScreen);
 558         mScreenOrder.add(0, CUSTOM_CONTENT_SCREEN_ID);
 559 
 560         // We want no padding on the custom content
 561         customScreen.setPadding(0, 0, 0, 0);
 562 
 563         addFullScreenPage(customScreen);
 564 
 565         // Ensure that the current page and default page are maintained.
 566         mDefaultPage = mOriginalDefaultPage + 1;
 567 
 568         // Update the custom content hint
 569         mLauncher.updateCustomContentHintVisibility();
 570         if (mRestorePage != INVALID_RESTORE_PAGE) {
 571             mRestorePage = mRestorePage + 1;
 572         } else {
 573             setCurrentPage(getCurrentPage() + 1);
 574         }
 575     }
 576 
 577     public void removeCustomContentPage() {
 578         CellLayout customScreen = getScreenWithId(CUSTOM_CONTENT_SCREEN_ID);
 579         if (customScreen == null) {
 580             throw new RuntimeException(&quot;Expected custom content screen to exist&quot;);
 581         }
 582 
 583         mWorkspaceScreens.remove(CUSTOM_CONTENT_SCREEN_ID);
 584         mScreenOrder.remove(CUSTOM_CONTENT_SCREEN_ID);
 585         removeView(customScreen);
 586 
 587         if (mCustomContentCallbacks != null) {
 588             mCustomContentCallbacks.onScrollProgressChanged(0);
 589             mCustomContentCallbacks.onHide();
 590         }
 591 
 592         mCustomContentCallbacks = null;
 593 
 594         // Ensure that the current page and default page are maintained.
 595         mDefaultPage = mOriginalDefaultPage - 1;
 596 
 597         // Update the custom content hint
 598         mLauncher.updateCustomContentHintVisibility();
 599         if (mRestorePage != INVALID_RESTORE_PAGE) {
 600             mRestorePage = mRestorePage - 1;
 601         } else {
 602             setCurrentPage(getCurrentPage() - 1);
 603         }
 604     }
 605 
 606     public void addToCustomContentPage(View customContent, CustomContentCallbacks callbacks,
 607             String description) {
 608         if (getPageIndexForScreenId(CUSTOM_CONTENT_SCREEN_ID) &lt; 0) {
 609             throw new RuntimeException(&quot;Expected custom content screen to exist&quot;);
 610         }
 611 
 612         // Add the custom content to the full screen custom page
 613         CellLayout customScreen = getScreenWithId(CUSTOM_CONTENT_SCREEN_ID);
 614         int spanX = customScreen.getCountX();
 615         int spanY = customScreen.getCountY();
 616         CellLayout.LayoutParams lp = new CellLayout.LayoutParams(0, 0, spanX, spanY);
 617         lp.canReorder  = false;
 618         lp.isFullscreen = true;
 619         if (customContent instanceof Insettable) {
 620             ((Insettable)customContent).setInsets(mInsets);
 621         }
 622         customScreen.removeAllViews();
 623         customScreen.addViewToCellLayout(customContent, 0, 0, lp, true);
 624         mCustomContentDescription = description;
 625 
 626         mCustomContentCallbacks = callbacks;
 627     }
 628 
 629     public void addExtraEmptyScreenOnDrag() {
 630         boolean lastChildOnScreen = false;
 631         boolean childOnFinalScreen = false;
 632 
 633         // Cancel any pending removal of empty screen
 634         mRemoveEmptyScreenRunnable = null;
 635 
 636         if (mDragSourceInternal != null) {
 637             if (mDragSourceInternal.getChildCount() == 1) {
 638                 lastChildOnScreen = true;
 639             }
 640             CellLayout cl = (CellLayout) mDragSourceInternal.getParent();
 641             if (indexOfChild(cl) == getChildCount() - 1) {
 642                 childOnFinalScreen = true;
 643             }
 644         }
 645 
 646         // If this is the last item on the final screen
 647         if (lastChildOnScreen &amp;&amp; childOnFinalScreen) {
 648             return;
 649         }
 650         if (!mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID)) {
 651             insertNewWorkspaceScreen(EXTRA_EMPTY_SCREEN_ID);
 652         }
 653     }
 654 
 655     public boolean addExtraEmptyScreen() {
 656         if (!mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID)) {
 657             insertNewWorkspaceScreen(EXTRA_EMPTY_SCREEN_ID);
 658             return true;
 659         }
 660         return false;
 661     }
 662 
 663     private void convertFinalScreenToEmptyScreenIfNecessary() {
 664         if (hasExtraEmptyScreen() || mScreenOrder.size() == 0) return;
 665         long finalScreenId = mScreenOrder.get(mScreenOrder.size() - 1);
 666 
 667         if (finalScreenId == CUSTOM_CONTENT_SCREEN_ID) return;
 668         CellLayout finalScreen = mWorkspaceScreens.get(finalScreenId);
 669 
 670         // If the final screen is empty, convert it to the extra empty screen
 671         if (finalScreen.getShortcutsAndWidgets().getChildCount() == 0 &amp;&amp;
 672                 !finalScreen.isDropPending()) {
 673             mWorkspaceScreens.remove(finalScreenId);
 674             mScreenOrder.remove(finalScreenId);
 675 
 676             // if this is the last non-custom content screen, convert it to the empty screen
 677             mWorkspaceScreens.put(EXTRA_EMPTY_SCREEN_ID, finalScreen);
 678             mScreenOrder.add(EXTRA_EMPTY_SCREEN_ID);
 679         }
 680     }
 681 
 682     public void removeExtraEmptyScreen(final boolean animate, final Runnable onComplete) {
 683         removeExtraEmptyScreen(animate, onComplete, 0, false);
 684     }
 685 
 686     public void removeExtraEmptyScreen(final boolean animate, final Runnable onComplete,
 687             final int delay, final boolean stripEmptyScreens) {
 688         if (delay &gt; 0) {
 689             postDelayed(new Runnable() {
 690                 @Override
 691                 public void run() {
 692                     removeExtraEmptyScreen(animate, onComplete, 0, stripEmptyScreens);
 693                 }
 694 
 695             }, delay);
 696             return;
 697         }
 698 
 699         convertFinalScreenToEmptyScreenIfNecessary();
 700         if (hasExtraEmptyScreen()) {
 701             int emptyIndex = mScreenOrder.indexOf(EXTRA_EMPTY_SCREEN_ID);
 702             if (getNextPage() == emptyIndex) {
 703                 snapToPage(getNextPage() - 1, SNAP_OFF_EMPTY_SCREEN_DURATION);
 704                 fadeAndRemoveEmptyScreen(SNAP_OFF_EMPTY_SCREEN_DURATION, FADE_EMPTY_SCREEN_DURATION,
 705                         onComplete, stripEmptyScreens);
 706             } else {
 707                 fadeAndRemoveEmptyScreen(0, FADE_EMPTY_SCREEN_DURATION,
 708                         onComplete, stripEmptyScreens);
 709             }
 710             return;
 711         }
 712         if (onComplete != null) {
 713             onComplete.run();
 714         }
 715     }
 716 
 717     private void fadeAndRemoveEmptyScreen(int delay, int duration, final Runnable onComplete,
 718             final boolean stripEmptyScreens) {
 719         PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0f);
 720         PropertyValuesHolder bgAlpha = PropertyValuesHolder.ofFloat(&quot;backgroundAlpha&quot;, 0f);
 721 
 722         final CellLayout cl = mWorkspaceScreens.get(EXTRA_EMPTY_SCREEN_ID);
 723 
 724         mRemoveEmptyScreenRunnable = new Runnable() {
 725             @Override
 726             public void run() {
 727                 if (hasExtraEmptyScreen()) {
 728                     mWorkspaceScreens.remove(EXTRA_EMPTY_SCREEN_ID);
 729                     mScreenOrder.remove(EXTRA_EMPTY_SCREEN_ID);
 730                     removeView(cl);
 731                     if (stripEmptyScreens) {
 732                         stripEmptyScreens();
 733                     }
 734                 }
 735             }
 736         };
 737 
 738         ObjectAnimator oa = ObjectAnimator.ofPropertyValuesHolder(cl, alpha, bgAlpha);
 739         oa.setDuration(duration);
 740         oa.setStartDelay(delay);
 741         oa.addListener(new AnimatorListenerAdapter() {
 742             @Override
 743             public void onAnimationEnd(Animator animation) {
 744                 if (mRemoveEmptyScreenRunnable != null) {
 745                     mRemoveEmptyScreenRunnable.run();
 746                 }
 747                 if (onComplete != null) {
 748                     onComplete.run();
 749                 }
 750             }
 751         });
 752         oa.start();
 753     }
 754 
 755     public boolean hasExtraEmptyScreen() {
 756         int nScreens = getChildCount();
 757         nScreens = nScreens - numCustomPages();
 758         return mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID) &amp;&amp; nScreens &gt; 1;
 759     }
 760 
 761     public long commitExtraEmptyScreen() {
 762         int index = getPageIndexForScreenId(EXTRA_EMPTY_SCREEN_ID);
 763         CellLayout cl = mWorkspaceScreens.get(EXTRA_EMPTY_SCREEN_ID);
 764         mWorkspaceScreens.remove(EXTRA_EMPTY_SCREEN_ID);
 765         mScreenOrder.remove(EXTRA_EMPTY_SCREEN_ID);
 766 
 767         long newId = LauncherAppState.getLauncherProvider().generateNewScreenId();
 768         mWorkspaceScreens.put(newId, cl);
 769         mScreenOrder.add(newId);
 770 
 771         // Update the page indicator marker
 772         if (getPageIndicator() != null) {
 773             getPageIndicator().updateMarker(index, getPageIndicatorMarker(index));
 774         }
 775 
 776         // Update the model for the new screen
 777         mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
 778 
 779         return newId;
 780     }
 781 
 782     public CellLayout getScreenWithId(long screenId) {
 783         CellLayout layout = mWorkspaceScreens.get(screenId);
 784         return layout;
 785     }
 786 
 787     public long getIdForScreen(CellLayout layout) {
 788         Iterator&lt;Long&gt; iter = mWorkspaceScreens.keySet().iterator();
 789         while (iter.hasNext()) {
 790             long id = iter.next();
 791             if (mWorkspaceScreens.get(id) == layout) {
 792                 return id;
 793             }
 794         }
 795         return -1;
 796     }
 797 
 798     public int getPageIndexForScreenId(long screenId) {
 799         return indexOfChild(mWorkspaceScreens.get(screenId));
 800     }
 801 
 802     public long getScreenIdForPageIndex(int index) {
 803         if (0 &lt;= index &amp;&amp; index &lt; mScreenOrder.size()) {
 804             return mScreenOrder.get(index);
 805         }
 806         return -1;
 807     }
 808 
 809     ArrayList&lt;Long&gt; getScreenOrder() {
 810         return mScreenOrder;
 811     }
 812 
 813     public void stripEmptyScreens() {
 814         if (isPageMoving()) {
 815             mStripScreensOnPageStopMoving = true;
 816             return;
 817         }
 818 
 819         int currentPage = getNextPage();
 820         ArrayList&lt;Long&gt; removeScreens = new ArrayList&lt;Long&gt;();
 821         for (Long id: mWorkspaceScreens.keySet()) {
 822             CellLayout cl = mWorkspaceScreens.get(id);
 823             if (id &gt;= 0 &amp;&amp; cl.getShortcutsAndWidgets().getChildCount() == 0) {
 824                 removeScreens.add(id);
 825             }
 826         }
 827 
 828         // We enforce at least one page to add new items to. In the case that we remove the last
 829         // such screen, we convert the last screen to the empty screen
 830         int minScreens = 1 + numCustomPages();
 831 
 832         int pageShift = 0;
 833         for (Long id: removeScreens) {
 834             CellLayout cl = mWorkspaceScreens.get(id);
 835             mWorkspaceScreens.remove(id);
 836             mScreenOrder.remove(id);
 837 
 838             if (getChildCount() &gt; minScreens) {
 839                 if (indexOfChild(cl) &lt; currentPage) {
 840                     pageShift++;
 841                 }
 842                 removeView(cl);
 843             } else {
 844                 // if this is the last non-custom content screen, convert it to the empty screen
 845                 mRemoveEmptyScreenRunnable = null;
 846                 mWorkspaceScreens.put(EXTRA_EMPTY_SCREEN_ID, cl);
 847                 mScreenOrder.add(EXTRA_EMPTY_SCREEN_ID);
 848             }
 849         }
 850 
 851         if (!removeScreens.isEmpty()) {
 852             // Update the model if we have changed any screens
 853             mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
 854         }
 855 
 856         if (pageShift &gt;= 0) {
 857             setCurrentPage(currentPage - pageShift);
 858         }
 859     }
 860 
 861     // See implementation for parameter definition.
 862     void addInScreen(View child, long container, long screenId,
 863             int x, int y, int spanX, int spanY) {
 864         addInScreen(child, container, screenId, x, y, spanX, spanY, false, false);
 865     }
 866 
 867     // At bind time, we use the rank (screenId) to compute x and y for hotseat items.
 868     // See implementation for parameter definition.
 869     void addInScreenFromBind(View child, long container, long screenId, int x, int y,
 870             int spanX, int spanY) {
 871         addInScreen(child, container, screenId, x, y, spanX, spanY, false, true);
 872     }
 873 
 874     // See implementation for parameter definition.
 875     void addInScreen(View child, long container, long screenId, int x, int y, int spanX, int spanY,
 876             boolean insert) {
 877         addInScreen(child, container, screenId, x, y, spanX, spanY, insert, false);
 878     }
 879 
 880     /**
 881      * Adds the specified child in the specified screen. The position and dimension of
 882      * the child are defined by x, y, spanX and spanY.
 883      *
 884      * @param child The child to add in one of the workspace&#x27;s screens.
 885      * @param screenId The screen in which to add the child.
 886      * @param x The X position of the child in the screen&#x27;s grid.
 887      * @param y The Y position of the child in the screen&#x27;s grid.
 888      * @param spanX The number of cells spanned horizontally by the child.
 889      * @param spanY The number of cells spanned vertically by the child.
 890      * @param insert When true, the child is inserted at the beginning of the children list.
 891      * @param computeXYFromRank When true, we use the rank (stored in screenId) to compute
 892      *                          the x and y position in which to place hotseat items. Otherwise
 893      *                          we use the x and y position to compute the rank.
 894      */
 895     void addInScreen(View child, long container, long screenId, int x, int y, int spanX, int spanY,
 896             boolean insert, boolean computeXYFromRank) {
 897         if (container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 898             if (getScreenWithId(screenId) == null) {
 899                 Log.e(TAG, &quot;Skipping child, screenId &quot; + screenId + &quot; not found&quot;);
 900                 // DEBUGGING - Print out the stack trace to see where we are adding from
 901                 new Throwable().printStackTrace();
 902                 return;
 903             }
 904         }
 905         if (screenId == EXTRA_EMPTY_SCREEN_ID) {
 906             // This should never happen
 907             throw new RuntimeException(&quot;Screen id should not be EXTRA_EMPTY_SCREEN_ID&quot;);
 908         }
 909 
 910         final CellLayout layout;
 911         if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 912             layout = mLauncher.getHotseat().getLayout();
 913             child.setOnKeyListener(null);
 914 
 915             // Hide folder title in the hotseat
 916             if (child instanceof FolderIcon) {
 917                 ((FolderIcon) child).setTextVisible(false);
 918             }
 919 
 920             if (computeXYFromRank) {
 921                 x = mLauncher.getHotseat().getCellXFromOrder((int) screenId);
 922                 y = mLauncher.getHotseat().getCellYFromOrder((int) screenId);
 923             } else {
 924                 screenId = mLauncher.getHotseat().getOrderInHotseat(x, y);
 925             }
 926         } else {
 927             // Show folder title if not in the hotseat
 928             if (child instanceof FolderIcon) {
 929                 ((FolderIcon) child).setTextVisible(true);
 930             }
 931             layout = getScreenWithId(screenId);
 932             child.setOnKeyListener(new IconKeyEventListener());
 933         }
 934 
 935         ViewGroup.LayoutParams genericLp = child.getLayoutParams();
 936         CellLayout.LayoutParams lp;
 937         if (genericLp == null || !(genericLp instanceof CellLayout.LayoutParams)) {
 938             lp = new CellLayout.LayoutParams(x, y, spanX, spanY);
 939         } else {
 940             lp = (CellLayout.LayoutParams) genericLp;
 941             lp.cellX = x;
 942             lp.cellY = y;
 943             lp.cellHSpan = spanX;
 944             lp.cellVSpan = spanY;
 945         }
 946 
 947         if (spanX &lt; 0 &amp;&amp; spanY &lt; 0) {
 948             lp.isLockedToGrid = false;
 949         }
 950 
 951         // Get the canonical child id to uniquely represent this view in this screen
 952         ItemInfo info = (ItemInfo) child.getTag();
 953         int childId = mLauncher.getViewIdForItem(info);
 954 
 955         boolean markCellsAsOccupied = !(child instanceof Folder);
 956         if (!layout.addViewToCellLayout(child, insert ? 0 : -1, childId, lp, markCellsAsOccupied)) {
 957             // TODO: This branch occurs when the workspace is adding views
 958             // outside of the defined grid
 959             // maybe we should be deleting these items from the LauncherModel?
<abbr title=" 960             Launcher.addDumpLog(TAG, &quot;Failed to add to item at (&quot; + lp.cellX + &quot;,&quot; + lp.cellY + &quot;) to CellLayout&quot;, true);"> 960             Launcher.addDumpLog(TAG, &quot;Failed to add to item at (&quot; + lp.cellX + &quot;,&quot; + lp.cellY + &quot;) to Cel🔵</abbr>
 961         }
 962 
 963         if (!(child instanceof Folder)) {
 964             child.setHapticFeedbackEnabled(false);
 965             child.setOnLongClickListener(mLongClickListener);
 966         }
 967         if (child instanceof DropTarget) {
 968             mDragController.addDropTarget((DropTarget) child);
 969         }
 970     }
 971 
 972     /**
 973      * Called directly from a CellLayout (not by the framework), after we&#x27;ve been added as a
 974      * listener via setOnInterceptTouchEventListener(). This allows us to tell the CellLayout
 975      * that it should intercept touch events, which is not something that is normally supported.
 976      */
 977     @Override
 978     public boolean onTouch(View v, MotionEvent event) {
 979         return (isSmall() || !isFinishedSwitchingState())
 980                 || (!isSmall() &amp;&amp; indexOfChild(v) != mCurrentPage);
 981     }
 982 
 983     public boolean isSwitchingState() {
 984         return mIsSwitchingState;
 985     }
 986 
 987     /** This differs from isSwitchingState in that we take into account how far the transition
 988      *  has completed. */
 989     public boolean isFinishedSwitchingState() {
 990         return !mIsSwitchingState || (mTransitionProgress &gt; 0.5f);
 991     }
 992 
 993     protected void onWindowVisibilityChanged (int visibility) {
 994         mLauncher.onWindowVisibilityChanged(visibility);
 995     }
 996 
 997     @Override
 998     public boolean dispatchUnhandledMove(View focused, int direction) {
 999         if (isSmall() || !isFinishedSwitchingState()) {
1000             // when the home screens are shrunken, shouldn&#x27;t allow side-scrolling
1001             return false;
1002         }
1003         return super.dispatchUnhandledMove(focused, direction);
1004     }
1005 
1006     @Override
1007     public boolean onInterceptTouchEvent(MotionEvent ev) {
1008         switch (ev.getAction() &amp; MotionEvent.ACTION_MASK) {
1009         case MotionEvent.ACTION_DOWN:
1010             mXDown = ev.getX();
1011             mYDown = ev.getY();
1012             mTouchDownTime = System.currentTimeMillis();
1013             break;
1014         case MotionEvent.ACTION_POINTER_UP:
1015         case MotionEvent.ACTION_UP:
1016             if (mTouchState == TOUCH_STATE_REST) {
1017                 final CellLayout currentPage = (CellLayout) getChildAt(mCurrentPage);
1018                 if (!currentPage.lastDownOnOccupiedCell()) {
1019                     onWallpaperTap(ev);
1020                 }
1021             }
1022         }
1023         return super.onInterceptTouchEvent(ev);
1024     }
1025 
1026     protected void reinflateWidgetsIfNecessary() {
1027         final int clCount = getChildCount();
1028         for (int i = 0; i &lt; clCount; i++) {
1029             CellLayout cl = (CellLayout) getChildAt(i);
1030             ShortcutAndWidgetContainer swc = cl.getShortcutsAndWidgets();
1031             final int itemCount = swc.getChildCount();
1032             for (int j = 0; j &lt; itemCount; j++) {
1033                 View v = swc.getChildAt(j);
1034 
1035                 if (v.getTag() instanceof LauncherAppWidgetInfo) {
1036                     LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) v.getTag();
1037                     LauncherAppWidgetHostView lahv = (LauncherAppWidgetHostView) info.hostView;
1038                     if (lahv != null &amp;&amp; lahv.orientationChangedSincedInflation()) {
1039                         mLauncher.removeAppWidget(info);
1040                         // Remove the current widget which is inflated with the wrong orientation
1041                         cl.removeView(lahv);
1042                         mLauncher.bindAppWidget(info);
1043                     }
1044                 }
1045             }
1046         }
1047     }
1048 
1049     @Override
1050     protected void determineScrollingStart(MotionEvent ev) {
1051         if (!isFinishedSwitchingState()) return;
1052 
1053         float deltaX = ev.getX() - mXDown;
1054         float absDeltaX = Math.abs(deltaX);
1055         float absDeltaY = Math.abs(ev.getY() - mYDown);
1056 
1057         if (Float.compare(absDeltaX, 0f) == 0) return;
1058 
1059         float slope = absDeltaY / absDeltaX;
1060         float theta = (float) Math.atan(slope);
1061 
1062         if (absDeltaX &gt; mTouchSlop || absDeltaY &gt; mTouchSlop) {
1063             cancelCurrentPageLongPress();
1064         }
1065 
1066         boolean passRightSwipesToCustomContent =
1067                 (mTouchDownTime - mCustomContentShowTime) &gt; CUSTOM_CONTENT_GESTURE_DELAY;
1068 
1069         boolean swipeInIgnoreDirection = isLayoutRtl() ? deltaX &lt; 0 : deltaX &gt; 0;
1070         if (swipeInIgnoreDirection &amp;&amp; getScreenIdForPageIndex(getCurrentPage()) ==
1071                 CUSTOM_CONTENT_SCREEN_ID &amp;&amp; passRightSwipesToCustomContent) {
1072             // Pass swipes to the right to the custom content page.
1073             return;
1074         }
1075 
1076         if (theta &gt; MAX_SWIPE_ANGLE) {
1077             // Above MAX_SWIPE_ANGLE, we don&#x27;t want to ever start scrolling the workspace
1078             return;
1079         } else if (theta &gt; START_DAMPING_TOUCH_SLOP_ANGLE) {
1080             // Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to
1081             // increase the touch slop to make it harder to begin scrolling the workspace. This
1082             // results in vertically scrolling widgets to more easily. The higher the angle, the
1083             // more we increase touch slop.
1084             theta -= START_DAMPING_TOUCH_SLOP_ANGLE;
1085             float extraRatio = (float)
1086                     Math.sqrt((theta / (MAX_SWIPE_ANGLE - START_DAMPING_TOUCH_SLOP_ANGLE)));
1087             super.determineScrollingStart(ev, 1 + TOUCH_SLOP_DAMPING_FACTOR * extraRatio);
1088         } else {
1089             // Below START_DAMPING_TOUCH_SLOP_ANGLE, we don&#x27;t do anything special
1090             super.determineScrollingStart(ev);
1091         }
1092     }
1093 
1094     protected void onPageBeginMoving() {
1095         super.onPageBeginMoving();
1096 
1097         if (isHardwareAccelerated()) {
1098             updateChildrenLayersEnabled(false);
1099         } else {
1100             if (mNextPage != INVALID_PAGE) {
1101                 // we&#x27;re snapping to a particular screen
1102                 enableChildrenCache(mCurrentPage, mNextPage);
1103             } else {
1104                 // this is when user is actively dragging a particular screen, they might
1105                 // swipe it either left or right (but we won&#x27;t advance by more than one screen)
1106                 enableChildrenCache(mCurrentPage - 1, mCurrentPage + 1);
1107             }
1108         }
1109 
1110         // Only show page outlines as we pan if we are on large screen
1111         if (LauncherAppState.getInstance().isScreenLarge()) {
1112             showOutlines();
1113         }
1114 
1115         // If we are not fading in adjacent screens, we still need to restore the alpha in case the
1116         // user scrolls while we are transitioning (should not affect dispatchDraw optimizations)
1117         if (!mWorkspaceFadeInAdjacentScreens) {
1118             for (int i = 0; i &lt; getChildCount(); ++i) {
1119                 ((CellLayout) getPageAt(i)).setShortcutAndWidgetAlpha(1f);
1120             }
1121         }
1122     }
1123 
1124     protected void onPageEndMoving() {
1125         super.onPageEndMoving();
1126 
1127         if (isHardwareAccelerated()) {
1128             updateChildrenLayersEnabled(false);
1129         } else {
1130             clearChildrenCache();
1131         }
1132 
1133         if (mDragController.isDragging()) {
1134             if (isSmall()) {
1135                 // If we are in springloaded mode, then force an event to check if the current touch
1136                 // is under a new page (to scroll to)
1137                 mDragController.forceTouchMove();
1138             }
1139         } else {
1140             // If we are not mid-dragging, hide the page outlines if we are on a large screen
1141             if (LauncherAppState.getInstance().isScreenLarge()) {
1142                 hideOutlines();
1143             }
1144         }
1145 
1146         if (mDelayedResizeRunnable != null) {
1147             mDelayedResizeRunnable.run();
1148             mDelayedResizeRunnable = null;
1149         }
1150 
1151         if (mDelayedSnapToPageRunnable != null) {
1152             mDelayedSnapToPageRunnable.run();
1153             mDelayedSnapToPageRunnable = null;
1154         }
1155         if (mStripScreensOnPageStopMoving) {
1156             stripEmptyScreens();
1157             mStripScreensOnPageStopMoving = false;
1158         }
1159     }
1160 
1161     @Override
1162     protected void notifyPageSwitchListener() {
1163         super.notifyPageSwitchListener();
1164         Launcher.setScreen(mCurrentPage);
1165 
1166         if (hasCustomContent() &amp;&amp; getNextPage() == 0 &amp;&amp; !mCustomContentShowing) {
1167             mCustomContentShowing = true;
1168             if (mCustomContentCallbacks != null) {
1169                 mCustomContentCallbacks.onShow();
1170                 mCustomContentShowTime = System.currentTimeMillis();
1171                 mLauncher.updateVoiceButtonProxyVisible(false);
1172             }
1173         } else if (hasCustomContent() &amp;&amp; getNextPage() != 0 &amp;&amp; mCustomContentShowing) {
1174             mCustomContentShowing = false;
1175             if (mCustomContentCallbacks != null) {
1176                 mCustomContentCallbacks.onHide();
1177                 mLauncher.resetQSBScroll();
1178                 mLauncher.updateVoiceButtonProxyVisible(false);
1179             }
1180         }
1181         if (getPageIndicator() != null) {
1182             getPageIndicator().setContentDescription(getPageIndicatorDescription());
1183         }
1184     }
1185 
1186     protected CustomContentCallbacks getCustomContentCallbacks() {
1187         return mCustomContentCallbacks;
1188     }
1189 
1190     protected void setWallpaperDimension() {
1191         String spKey = WallpaperCropActivity.getSharedPreferencesKey();
1192         SharedPreferences sp = mLauncher.getSharedPreferences(spKey, Context.MODE_MULTI_PROCESS);
1193         WallpaperPickerActivity.suggestWallpaperDimension(mLauncher.getResources(),
1194                 sp, mLauncher.getWindowManager(), mWallpaperManager);
1195     }
1196 
1197     protected void snapToPage(int whichPage, Runnable r) {
1198         snapToPage(whichPage, SLOW_PAGE_SNAP_ANIMATION_DURATION, r);
1199     }
1200 
1201     protected void snapToPage(int whichPage, int duration, Runnable r) {
1202         if (mDelayedSnapToPageRunnable != null) {
1203             mDelayedSnapToPageRunnable.run();
1204         }
1205         mDelayedSnapToPageRunnable = r;
1206         snapToPage(whichPage, duration);
1207     }
1208 
1209     protected void snapToScreenId(long screenId, Runnable r) {
1210         snapToPage(getPageIndexForScreenId(screenId), r);
1211     }
1212 
1213     class WallpaperOffsetInterpolator implements Choreographer.FrameCallback {
1214         float mFinalOffset = 0.0f;
1215         float mCurrentOffset = 0.5f; // to force an initial update
1216         boolean mWaitingForUpdate;
1217         Choreographer mChoreographer;
1218         Interpolator mInterpolator;
1219         boolean mAnimating;
1220         long mAnimationStartTime;
1221         float mAnimationStartOffset;
1222         private final int ANIMATION_DURATION = 250;
1223         // Don&#x27;t use all the wallpaper for parallax until you have at least this many pages
1224         private final int MIN_PARALLAX_PAGE_SPAN = 3;
1225         int mNumScreens;
1226 
1227         public WallpaperOffsetInterpolator() {
1228             mChoreographer = Choreographer.getInstance();
1229             mInterpolator = new DecelerateInterpolator(1.5f);
1230         }
1231 
1232         @Override
1233         public void doFrame(long frameTimeNanos) {
1234             updateOffset(false);
1235         }
1236 
1237         private void updateOffset(boolean force) {
1238             if (mWaitingForUpdate || force) {
1239                 mWaitingForUpdate = false;
1240                 if (computeScrollOffset() &amp;&amp; mWindowToken != null) {
1241                     try {
1242                         mWallpaperManager.setWallpaperOffsets(mWindowToken,
1243                                 mWallpaperOffset.getCurrX(), 0.5f);
1244                         setWallpaperOffsetSteps();
1245                     } catch (IllegalArgumentException e) {
1246                         Log.e(TAG, &quot;Error updating wallpaper offset: &quot; + e);
1247                     }
1248                 }
1249             }
1250         }
1251 
1252         public boolean computeScrollOffset() {
1253             final float oldOffset = mCurrentOffset;
1254             if (mAnimating) {
1255                 long durationSinceAnimation = System.currentTimeMillis() - mAnimationStartTime;
1256                 float t0 = durationSinceAnimation / (float) ANIMATION_DURATION;
1257                 float t1 = mInterpolator.getInterpolation(t0);
1258                 mCurrentOffset = mAnimationStartOffset +
1259                         (mFinalOffset - mAnimationStartOffset) * t1;
1260                 mAnimating = durationSinceAnimation &lt; ANIMATION_DURATION;
1261             } else {
1262                 mCurrentOffset = mFinalOffset;
1263             }
1264 
1265             if (Math.abs(mCurrentOffset - mFinalOffset) &gt; 0.0000001f) {
1266                 scheduleUpdate();
1267             }
1268             if (Math.abs(oldOffset - mCurrentOffset) &gt; 0.0000001f) {
1269                 return true;
1270             }
1271             return false;
1272         }
1273 
1274         private float wallpaperOffsetForCurrentScroll() {
1275             if (getChildCount() &lt;= 1) {
1276                 return 0;
1277             }
1278 
1279             // Exclude the leftmost page
1280             int emptyExtraPages = numEmptyScreensToIgnore();
1281             int firstIndex = numCustomPages();
1282             // Exclude the last extra empty screen (if we have &gt; MIN_PARALLAX_PAGE_SPAN pages)
1283             int lastIndex = getChildCount() - 1 - emptyExtraPages;
1284             if (isLayoutRtl()) {
1285                 int temp = firstIndex;
1286                 firstIndex = lastIndex;
1287                 lastIndex = temp;
1288             }
1289 
1290             int firstPageScrollX = getScrollForPage(firstIndex);
1291             int scrollRange = getScrollForPage(lastIndex) - firstPageScrollX;
1292             if (scrollRange == 0) {
1293                 return 0;
1294             } else {
1295                 // TODO: do different behavior if it&#x27;s  a live wallpaper?
1296                 // Sometimes the left parameter of the pages is animated during a layout transition;
1297                 // this parameter offsets it to keep the wallpaper from animating as well
1298                 int adjustedScroll =
1299                         getScrollX() - firstPageScrollX - getLayoutTransitionOffsetForPage(0);
1300                 float offset = Math.min(1, adjustedScroll / (float) scrollRange);
1301                 offset = Math.max(0, offset);
1302                 // Don&#x27;t use up all the wallpaper parallax until you have at least
1303                 // MIN_PARALLAX_PAGE_SPAN pages
1304                 int numScrollingPages = getNumScreensExcludingEmptyAndCustom();
1305                 int parallaxPageSpan = Math.max(MIN_PARALLAX_PAGE_SPAN, numScrollingPages - 1);
1306                 // On RTL devices, push the wallpaper offset to the right if we don&#x27;t have enough
1307                 // pages (ie if numScrollingPages &lt; MIN_PARALLAX_PAGE_SPAN)
1308                 int padding = isLayoutRtl() ? parallaxPageSpan - numScrollingPages + 1 : 0;
1309                 return offset * (padding + numScrollingPages - 1) / parallaxPageSpan;
1310             }
1311         }
1312 
1313         private int numEmptyScreensToIgnore() {
1314             int numScrollingPages = getChildCount() - numCustomPages();
1315             if (numScrollingPages &gt;= MIN_PARALLAX_PAGE_SPAN &amp;&amp; hasExtraEmptyScreen()) {
1316                 return 1;
1317             } else {
1318                 return 0;
1319             }
1320         }
1321 
1322         private int getNumScreensExcludingEmptyAndCustom() {
1323             int numScrollingPages = getChildCount() - numEmptyScreensToIgnore() - numCustomPages();
1324             return numScrollingPages;
1325         }
1326 
1327         public void syncWithScroll() {
1328             float offset = wallpaperOffsetForCurrentScroll();
1329             mWallpaperOffset.setFinalX(offset);
1330             updateOffset(true);
1331         }
1332 
1333         public float getCurrX() {
1334             return mCurrentOffset;
1335         }
1336 
1337         public float getFinalX() {
1338             return mFinalOffset;
1339         }
1340 
1341         private void animateToFinal() {
1342             mAnimating = true;
1343             mAnimationStartOffset = mCurrentOffset;
1344             mAnimationStartTime = System.currentTimeMillis();
1345         }
1346 
1347         private void setWallpaperOffsetSteps() {
1348             // Set wallpaper offset steps (1 / (number of screens - 1))
1349             mWallpaperManager.setWallpaperOffsetSteps(1.0f / (getChildCount() - 1), 1.0f);
1350         }
1351 
1352         public void setFinalX(float x) {
1353             scheduleUpdate();
1354             mFinalOffset = Math.max(0f, Math.min(x, 1.0f));
1355             if (getNumScreensExcludingEmptyAndCustom() != mNumScreens) {
1356                 if (mNumScreens &gt; 0) {
1357                     // Don&#x27;t animate if we&#x27;re going from 0 screens
1358                     animateToFinal();
1359                 }
1360                 mNumScreens = getNumScreensExcludingEmptyAndCustom();
1361             }
1362         }
1363 
1364         private void scheduleUpdate() {
1365             if (!mWaitingForUpdate) {
1366                 mChoreographer.postFrameCallback(this);
1367                 mWaitingForUpdate = true;
1368             }
1369         }
1370 
1371         public void jumpToFinal() {
1372             mCurrentOffset = mFinalOffset;
1373         }
1374     }
1375 
1376     @Override
1377     public void computeScroll() {
1378         super.computeScroll();
1379         mWallpaperOffset.syncWithScroll();
1380     }
1381 
1382     void showOutlines() {
1383         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1384             if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
1385             if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
<abbr title="1386             mChildrenOutlineFadeInAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 1.0f);">1386             mChildrenOutlineFadeInAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 1.0🔵</abbr>
1387             mChildrenOutlineFadeInAnimation.setDuration(CHILDREN_OUTLINE_FADE_IN_DURATION);
1388             mChildrenOutlineFadeInAnimation.start();
1389         }
1390     }
1391 
1392     void hideOutlines() {
1393         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1394             if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1395             if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
<abbr title="1396             mChildrenOutlineFadeOutAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.0f);">1396             mChildrenOutlineFadeOutAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.🔵</abbr>
1397             mChildrenOutlineFadeOutAnimation.setDuration(CHILDREN_OUTLINE_FADE_OUT_DURATION);
1398             mChildrenOutlineFadeOutAnimation.setStartDelay(CHILDREN_OUTLINE_FADE_OUT_DELAY);
1399             mChildrenOutlineFadeOutAnimation.start();
1400         }
1401     }
1402 
1403     public void showOutlinesTemporarily() {
1404         if (!mIsPageMoving &amp;&amp; !isTouchActive()) {
1405             snapToPage(mCurrentPage);
1406         }
1407     }
1408 
1409     public void setChildrenOutlineAlpha(float alpha) {
1410         mChildrenOutlineAlpha = alpha;
1411         for (int i = 0; i &lt; getChildCount(); i++) {
1412             CellLayout cl = (CellLayout) getChildAt(i);
1413             cl.setBackgroundAlpha(alpha);
1414         }
1415     }
1416 
1417     public float getChildrenOutlineAlpha() {
1418         return mChildrenOutlineAlpha;
1419     }
1420 
1421     void disableBackground() {
1422         mDrawBackground = false;
1423     }
1424     void enableBackground() {
1425         mDrawBackground = true;
1426     }
1427 
1428     private void animateBackgroundGradient(float finalAlpha, boolean animated) {
1429         if (mBackground == null) return;
1430         if (mBackgroundFadeInAnimation != null) {
1431             mBackgroundFadeInAnimation.cancel();
1432             mBackgroundFadeInAnimation = null;
1433         }
1434         if (mBackgroundFadeOutAnimation != null) {
1435             mBackgroundFadeOutAnimation.cancel();
1436             mBackgroundFadeOutAnimation = null;
1437         }
1438         float startAlpha = getBackgroundAlpha();
1439         if (finalAlpha != startAlpha) {
1440             if (animated) {
1441                 mBackgroundFadeOutAnimation =
1442                         LauncherAnimUtils.ofFloat(this, startAlpha, finalAlpha);
1443                 mBackgroundFadeOutAnimation.addUpdateListener(new AnimatorUpdateListener() {
1444                     public void onAnimationUpdate(ValueAnimator animation) {
1445                         setBackgroundAlpha(((Float) animation.getAnimatedValue()).floatValue());
1446                     }
1447                 });
1448                 mBackgroundFadeOutAnimation.setInterpolator(new DecelerateInterpolator(1.5f));
1449                 mBackgroundFadeOutAnimation.setDuration(BACKGROUND_FADE_OUT_DURATION);
1450                 mBackgroundFadeOutAnimation.start();
1451             } else {
1452                 setBackgroundAlpha(finalAlpha);
1453             }
1454         }
1455     }
1456 
1457     public void setBackgroundAlpha(float alpha) {
1458         if (alpha != mBackgroundAlpha) {
1459             mBackgroundAlpha = alpha;
1460             invalidate();
1461         }
1462     }
1463 
1464     public float getBackgroundAlpha() {
1465         return mBackgroundAlpha;
1466     }
1467 
1468     float backgroundAlphaInterpolator(float r) {
1469         float pivotA = 0.1f;
1470         float pivotB = 0.4f;
1471         if (r &lt; pivotA) {
1472             return 0;
1473         } else if (r &gt; pivotB) {
1474             return 1.0f;
1475         } else {
1476             return (r - pivotA)/(pivotB - pivotA);
1477         }
1478     }
1479 
1480     private void updatePageAlphaValues(int screenCenter) {
1481         boolean isInOverscroll = mOverScrollX &lt; 0 || mOverScrollX &gt; mMaxScrollX;
1482         if (mWorkspaceFadeInAdjacentScreens &amp;&amp;
1483                 mState == State.NORMAL &amp;&amp;
1484                 !mIsSwitchingState &amp;&amp;
1485                 !isInOverscroll) {
1486             for (int i = numCustomPages(); i &lt; getChildCount(); i++) {
1487                 CellLayout child = (CellLayout) getChildAt(i);
1488                 if (child != null) {
1489                     float scrollProgress = getScrollProgress(screenCenter, child, i);
1490                     float alpha = 1 - Math.abs(scrollProgress);
1491                     child.getShortcutsAndWidgets().setAlpha(alpha);
1492                 }
1493             }
1494         }
1495     }
1496 
1497     private void setChildrenBackgroundAlphaMultipliers(float a) {
1498         for (int i = 0; i &lt; getChildCount(); i++) {
1499             CellLayout child = (CellLayout) getChildAt(i);
1500             child.setBackgroundAlphaMultiplier(a);
1501         }
1502     }
1503 
1504     public boolean hasCustomContent() {
1505         return (mScreenOrder.size() &gt; 0 &amp;&amp; mScreenOrder.get(0) == CUSTOM_CONTENT_SCREEN_ID);
1506     }
1507 
1508     public int numCustomPages() {
1509         return hasCustomContent() ? 1 : 0;
1510     }
1511 
1512     public boolean isOnOrMovingToCustomContent() {
1513         return hasCustomContent() &amp;&amp; getNextPage() == 0;
1514     }
1515 
1516     private void updateStateForCustomContent(int screenCenter) {
1517         float translationX = 0;
1518         float progress = 0;
1519         if (hasCustomContent()) {
1520             int index = mScreenOrder.indexOf(CUSTOM_CONTENT_SCREEN_ID);
1521 
1522             int scrollDelta = getScrollX() - getScrollForPage(index) -
1523                     getLayoutTransitionOffsetForPage(index);
1524             float scrollRange = getScrollForPage(index + 1) - getScrollForPage(index);
1525             translationX = scrollRange - scrollDelta;
1526             progress = (scrollRange - scrollDelta) / scrollRange;
1527 
1528             if (isLayoutRtl()) {
1529                 translationX = Math.min(0, translationX);
1530             } else {
1531                 translationX = Math.max(0, translationX);
1532             }
1533             progress = Math.max(0, progress);
1534         }
1535 
1536         if (Float.compare(progress, mLastCustomContentScrollProgress) == 0) return;
1537 
1538         CellLayout cc = mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID);
1539         if (progress &gt; 0 &amp;&amp; cc.getVisibility() != VISIBLE &amp;&amp; !isSmall()) {
1540             cc.setVisibility(VISIBLE);
1541         }
1542 
1543         mLastCustomContentScrollProgress = progress;
1544 
1545         setBackgroundAlpha(progress * 0.8f);
1546 
1547         if (mLauncher.getHotseat() != null) {
1548             mLauncher.getHotseat().setTranslationX(translationX);
1549         }
1550 
1551         if (getPageIndicator() != null) {
1552             getPageIndicator().setTranslationX(translationX);
1553         }
1554 
1555         if (mCustomContentCallbacks != null) {
1556             mCustomContentCallbacks.onScrollProgressChanged(progress);
1557         }
1558     }
1559 
1560     @Override
1561     protected OnClickListener getPageIndicatorClickListener() {
1562         AccessibilityManager am = (AccessibilityManager)
1563                 getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
1564         if (!am.isTouchExplorationEnabled()) {
1565             return null;
1566         }
1567         OnClickListener listener = new OnClickListener() {
1568             @Override
1569             public void onClick(View arg0) {
1570                 enterOverviewMode();
1571             }
1572         };
1573         return listener;
1574     }
1575 
1576     @Override
1577     protected void screenScrolled(int screenCenter) {
1578         final boolean isRtl = isLayoutRtl();
1579         super.screenScrolled(screenCenter);
1580 
1581         updatePageAlphaValues(screenCenter);
1582         updateStateForCustomContent(screenCenter);
1583         enableHwLayersOnVisiblePages();
1584 
1585         boolean shouldOverScroll = (mOverScrollX &lt; 0 &amp;&amp; (!hasCustomContent() || isLayoutRtl())) ||
1586                 (mOverScrollX &gt; mMaxScrollX &amp;&amp; (!hasCustomContent() || !isLayoutRtl()));
1587 
1588         if (shouldOverScroll) {
1589             int index = 0;
1590             float pivotX = 0f;
1591             final float leftBiasedPivot = 0.25f;
1592             final float rightBiasedPivot = 0.75f;
1593             final int lowerIndex = 0;
1594             final int upperIndex = getChildCount() - 1;
1595 
1596             final boolean isLeftPage = mOverScrollX &lt; 0;
1597             index = (!isRtl &amp;&amp; isLeftPage) || (isRtl &amp;&amp; !isLeftPage) ? lowerIndex : upperIndex;
1598             pivotX = isLeftPage ? rightBiasedPivot : leftBiasedPivot;
1599 
1600             CellLayout cl = (CellLayout) getChildAt(index);
1601             float scrollProgress = getScrollProgress(screenCenter, cl, index);
1602             cl.setOverScrollAmount(Math.abs(scrollProgress), isLeftPage);
1603             float rotation = -WORKSPACE_OVERSCROLL_ROTATION * scrollProgress;
1604             cl.setRotationY(rotation);
1605 
1606             if (!mOverscrollTransformsSet || Float.compare(mLastOverscrollPivotX, pivotX) != 0) {
1607                 mOverscrollTransformsSet = true;
1608                 mLastOverscrollPivotX = pivotX;
1609                 cl.setCameraDistance(mDensity * mCameraDistance);
1610                 cl.setPivotX(cl.getMeasuredWidth() * pivotX);
1611                 cl.setPivotY(cl.getMeasuredHeight() * 0.5f);
1612                 cl.setOverscrollTransformsDirty(true);
1613             }
1614         } else {
1615             if (mOverscrollTransformsSet) {
1616                 mOverscrollTransformsSet = false;
1617                 ((CellLayout) getChildAt(0)).resetOverscrollTransforms();
1618                 ((CellLayout) getChildAt(getChildCount() - 1)).resetOverscrollTransforms();
1619             }
1620         }
1621     }
1622 
1623     @Override
1624     protected void overScroll(float amount) {
1625         acceleratedOverScroll(amount);
1626     }
1627 
1628     protected void onAttachedToWindow() {
1629         super.onAttachedToWindow();
1630         mWindowToken = getWindowToken();
1631         computeScroll();
1632         mDragController.setWindowToken(mWindowToken);
1633     }
1634 
1635     protected void onDetachedFromWindow() {
1636         super.onDetachedFromWindow();
1637         mWindowToken = null;
1638     }
1639 
1640     protected void onResume() {
1641         if (getPageIndicator() != null) {
1642             // In case accessibility state has changed, we need to perform this on every
1643             // attach to window
1644             OnClickListener listener = getPageIndicatorClickListener();
1645             if (listener != null) {
1646                 getPageIndicator().setOnClickListener(listener);
1647             }
1648         }
1649         AccessibilityManager am = (AccessibilityManager)
1650                 getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
1651         sAccessibilityEnabled = am.isEnabled();
1652     }
1653 
1654     @Override
1655     protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
1656         if (mFirstLayout &amp;&amp; mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getChildCount()) {
1657             mWallpaperOffset.syncWithScroll();
1658             mWallpaperOffset.jumpToFinal();
1659         }
1660         super.onLayout(changed, left, top, right, bottom);
1661     }
1662 
1663     @Override
1664     protected void onDraw(Canvas canvas) {
1665         // Draw the background gradient if necessary
1666         if (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground) {
1667             int alpha = (int) (mBackgroundAlpha * 255);
1668             mBackground.setAlpha(alpha);
1669             mBackground.setBounds(getScrollX(), 0, getScrollX() + getMeasuredWidth(),
1670                     getMeasuredHeight());
1671             mBackground.draw(canvas);
1672         }
1673 
1674         super.onDraw(canvas);
1675 
1676         // Call back to LauncherModel to finish binding after the first draw
1677         post(mBindPages);
1678     }
1679 
1680     boolean isDrawingBackgroundGradient() {
1681         return (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground);
1682     }
1683 
1684     @Override
1685     protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1686         if (!mLauncher.isAllAppsVisible()) {
1687             final Folder openFolder = getOpenFolder();
1688             if (openFolder != null) {
1689                 return openFolder.requestFocus(direction, previouslyFocusedRect);
1690             } else {
1691                 return super.onRequestFocusInDescendants(direction, previouslyFocusedRect);
1692             }
1693         }
1694         return false;
1695     }
1696 
1697     @Override
1698     public int getDescendantFocusability() {
1699         if (isSmall()) {
1700             return ViewGroup.FOCUS_BLOCK_DESCENDANTS;
1701         }
1702         return super.getDescendantFocusability();
1703     }
1704 
1705     @Override
1706     public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1707         if (!mLauncher.isAllAppsVisible()) {
1708             final Folder openFolder = getOpenFolder();
1709             if (openFolder != null) {
1710                 openFolder.addFocusables(views, direction);
1711             } else {
1712                 super.addFocusables(views, direction, focusableMode);
1713             }
1714         }
1715     }
1716 
1717     public boolean isSmall() {
1718         return mState == State.SMALL || mState == State.SPRING_LOADED || mState == State.OVERVIEW;
1719     }
1720 
1721     void enableChildrenCache(int fromPage, int toPage) {
1722         if (fromPage &gt; toPage) {
1723             final int temp = fromPage;
1724             fromPage = toPage;
1725             toPage = temp;
1726         }
1727 
1728         final int screenCount = getChildCount();
1729 
1730         fromPage = Math.max(fromPage, 0);
1731         toPage = Math.min(toPage, screenCount - 1);
1732 
1733         for (int i = fromPage; i &lt;= toPage; i++) {
1734             final CellLayout layout = (CellLayout) getChildAt(i);
1735             layout.setChildrenDrawnWithCacheEnabled(true);
1736             layout.setChildrenDrawingCacheEnabled(true);
1737         }
1738     }
1739 
1740     void clearChildrenCache() {
1741         final int screenCount = getChildCount();
1742         for (int i = 0; i &lt; screenCount; i++) {
1743             final CellLayout layout = (CellLayout) getChildAt(i);
1744             layout.setChildrenDrawnWithCacheEnabled(false);
1745             // In software mode, we don&#x27;t want the items to continue to be drawn into bitmaps
1746             if (!isHardwareAccelerated()) {
1747                 layout.setChildrenDrawingCacheEnabled(false);
1748             }
1749         }
1750     }
1751 
1752     private void updateChildrenLayersEnabled(boolean force) {
1753         boolean small = mState == State.SMALL || mState == State.OVERVIEW || mIsSwitchingState;
1754         boolean enableChildrenLayers = force || small || mAnimatingViewIntoPlace || isPageMoving();
1755 
1756         if (enableChildrenLayers != mChildrenLayersEnabled) {
1757             mChildrenLayersEnabled = enableChildrenLayers;
1758             if (mChildrenLayersEnabled) {
1759                 enableHwLayersOnVisiblePages();
1760             } else {
1761                 for (int i = 0; i &lt; getPageCount(); i++) {
1762                     final CellLayout cl = (CellLayout) getChildAt(i);
1763                     cl.enableHardwareLayer(false);
1764                 }
1765             }
1766         }
1767     }
1768 
1769     private void enableHwLayersOnVisiblePages() {
1770         if (mChildrenLayersEnabled) {
1771             final int screenCount = getChildCount();
1772             getVisiblePages(mTempVisiblePagesRange);
1773             int leftScreen = mTempVisiblePagesRange[0];
1774             int rightScreen = mTempVisiblePagesRange[1];
1775             if (leftScreen == rightScreen) {
1776                 // make sure we&#x27;re caching at least two pages always
1777                 if (rightScreen &lt; screenCount - 1) {
1778                     rightScreen++;
1779                 } else if (leftScreen &gt; 0) {
1780                     leftScreen--;
1781                 }
1782             }
1783 
1784             final CellLayout customScreen = mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID);
1785             for (int i = 0; i &lt; screenCount; i++) {
1786                 final CellLayout layout = (CellLayout) getPageAt(i);
1787 
1788                 // enable layers between left and right screen inclusive, except for the
1789                 // customScreen, which may animate its content during transitions.
1790                 boolean enableLayer = layout != customScreen &amp;&amp;
1791                         leftScreen &lt;= i &amp;&amp; i &lt;= rightScreen &amp;&amp; shouldDrawChild(layout);
1792                 layout.enableHardwareLayer(enableLayer);
1793             }
1794         }
1795     }
1796 
1797     public void buildPageHardwareLayers() {
1798         // force layers to be enabled just for the call to buildLayer
1799         updateChildrenLayersEnabled(true);
1800         if (getWindowToken() != null) {
1801             final int childCount = getChildCount();
1802             for (int i = 0; i &lt; childCount; i++) {
1803                 CellLayout cl = (CellLayout) getChildAt(i);
1804                 cl.buildHardwareLayer();
1805             }
1806         }
1807         updateChildrenLayersEnabled(false);
1808     }
1809 
1810     protected void onWallpaperTap(MotionEvent ev) {
1811         final int[] position = mTempCell;
1812         getLocationOnScreen(position);
1813 
1814         int pointerIndex = ev.getActionIndex();
1815         position[0] += (int) ev.getX(pointerIndex);
1816         position[1] += (int) ev.getY(pointerIndex);
1817 
1818         mWallpaperManager.sendWallpaperCommand(getWindowToken(),
1819                 ev.getAction() == MotionEvent.ACTION_UP
1820                         ? WallpaperManager.COMMAND_TAP : WallpaperManager.COMMAND_SECONDARY_TAP,
1821                 position[0], position[1], 0, null);
1822     }
1823 
1824     /*
1825      * This interpolator emulates the rate at which the perceived scale of an object changes
1826      * as its distance from a camera increases. When this interpolator is applied to a scale
1827      * animation on a view, it evokes the sense that the object is shrinking due to moving away
1828      * from the camera.
1829      */
1830     static class ZInterpolator implements TimeInterpolator {
1831         private float focalLength;
1832 
1833         public ZInterpolator(float foc) {
1834             focalLength = foc;
1835         }
1836 
1837         public float getInterpolation(float input) {
1838             return (1.0f - focalLength / (focalLength + input)) /
1839                 (1.0f - focalLength / (focalLength + 1.0f));
1840         }
1841     }
1842 
1843     /*
1844      * The exact reverse of ZInterpolator.
1845      */
1846     static class InverseZInterpolator implements TimeInterpolator {
1847         private ZInterpolator zInterpolator;
1848         public InverseZInterpolator(float foc) {
1849             zInterpolator = new ZInterpolator(foc);
1850         }
1851         public float getInterpolation(float input) {
1852             return 1 - zInterpolator.getInterpolation(1 - input);
1853         }
1854     }
1855 
1856     /*
1857      * ZInterpolator compounded with an ease-out.
1858      */
1859     static class ZoomOutInterpolator implements TimeInterpolator {
1860         private final DecelerateInterpolator decelerate = new DecelerateInterpolator(0.75f);
1861         private final ZInterpolator zInterpolator = new ZInterpolator(0.13f);
1862 
1863         public float getInterpolation(float input) {
1864             return decelerate.getInterpolation(zInterpolator.getInterpolation(input));
1865         }
1866     }
1867 
1868     /*
1869      * InvereZInterpolator compounded with an ease-out.
1870      */
1871     static class ZoomInInterpolator implements TimeInterpolator {
1872         private final InverseZInterpolator inverseZInterpolator = new InverseZInterpolator(0.35f);
1873         private final DecelerateInterpolator decelerate = new DecelerateInterpolator(3.0f);
1874 
1875         public float getInterpolation(float input) {
1876             return decelerate.getInterpolation(inverseZInterpolator.getInterpolation(input));
1877         }
1878     }
1879 
1880     private final ZoomInInterpolator mZoomInInterpolator = new ZoomInInterpolator();
1881 
1882     /*
1883     *
1884     * We call these methods (onDragStartedWithItemSpans/onDragStartedWithSize) whenever we
1885     * start a drag in Launcher, regardless of whether the drag has ever entered the Workspace
1886     *
1887     * These methods mark the appropriate pages as accepting drops (which alters their visual
1888     * appearance).
1889     *
1890     */
1891     public void onDragStartedWithItem(View v) {
1892         final Canvas canvas = new Canvas();
1893 
1894         // The outline is used to visualize where the item will land if dropped
1895         mDragOutline = createDragOutline(v, canvas, DRAG_BITMAP_PADDING);
1896     }
1897 
1898     public void onDragStartedWithItem(PendingAddItemInfo info, Bitmap b, boolean clipAlpha) {
1899         final Canvas canvas = new Canvas();
1900 
1901         int[] size = estimateItemSize(info.spanX, info.spanY, info, false);
1902 
1903         // The outline is used to visualize where the item will land if dropped
1904         mDragOutline = createDragOutline(b, canvas, DRAG_BITMAP_PADDING, size[0],
1905                 size[1], clipAlpha);
1906     }
1907 
1908     public void exitWidgetResizeMode() {
1909         DragLayer dragLayer = mLauncher.getDragLayer();
1910         dragLayer.clearAllResizeFrames();
1911     }
1912 
1913     private void initAnimationArrays() {
1914         final int childCount = getChildCount();
1915         if (mLastChildCount == childCount) return;
1916 
1917         mOldBackgroundAlphas = new float[childCount];
1918         mOldAlphas = new float[childCount];
1919         mNewBackgroundAlphas = new float[childCount];
1920         mNewAlphas = new float[childCount];
1921     }
1922 
1923     Animator getChangeStateAnimation(final State state, boolean animated) {
1924         return getChangeStateAnimation(state, animated, 0, -1);
1925     }
1926 
1927     @Override
1928     protected void getOverviewModePages(int[] range) {
1929         int start = numCustomPages();
1930         int end = getChildCount() - 1;
1931 
1932         range[0] = Math.max(0, Math.min(start, getChildCount() - 1));
1933         range[1] = Math.max(0,  end);
1934      }
1935 
1936     protected void onStartReordering() {
1937         super.onStartReordering();
1938         showOutlines();
1939         // Reordering handles its own animations, disable the automatic ones.
1940         disableLayoutTransitions();
1941     }
1942 
1943     protected void onEndReordering() {
1944         super.onEndReordering();
1945 
1946         hideOutlines();
1947         mScreenOrder.clear();
1948         int count = getChildCount();
1949         for (int i = 0; i &lt; count; i++) {
1950             CellLayout cl = ((CellLayout) getChildAt(i));
1951             mScreenOrder.add(getIdForScreen(cl));
1952         }
1953 
1954         mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
1955 
1956         // Re-enable auto layout transitions for page deletion.
1957         enableLayoutTransitions();
1958     }
1959 
1960     public boolean isInOverviewMode() {
1961         return mState == State.OVERVIEW;
1962     }
1963 
1964     public boolean enterOverviewMode() {
1965         if (mTouchState != TOUCH_STATE_REST) {
1966             return false;
1967         }
1968         enableOverviewMode(true, -1, true);
1969         return true;
1970     }
1971 
1972     public void exitOverviewMode(boolean animated) {
1973         exitOverviewMode(-1, animated);
1974     }
1975 
1976     public void exitOverviewMode(int snapPage, boolean animated) {
1977         enableOverviewMode(false, snapPage, animated);
1978     }
1979 
1980     private void enableOverviewMode(boolean enable, int snapPage, boolean animated) {
1981         State finalState = Workspace.State.OVERVIEW;
1982         if (!enable) {
1983             finalState = Workspace.State.NORMAL;
1984         }
1985 
1986         Animator workspaceAnim = getChangeStateAnimation(finalState, animated, 0, snapPage);
1987         if (workspaceAnim != null) {
1988             onTransitionPrepare();
1989             workspaceAnim.addListener(new AnimatorListenerAdapter() {
1990                 @Override
1991                 public void onAnimationEnd(Animator arg0) {
1992                     onTransitionEnd();
1993                 }
1994             });
1995             workspaceAnim.start();
1996         }
1997     }
1998 
1999     int getOverviewModeTranslationY() {
2000         LauncherAppState app = LauncherAppState.getInstance();
2001         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2002         Rect overviewBar = grid.getOverviewModeButtonBarRect();
2003 
2004         int availableHeight = getViewportHeight();
2005         int scaledHeight = (int) (mOverviewModeShrinkFactor * getNormalChildHeight());
2006         int offsetFromTopEdge = (availableHeight - scaledHeight) / 2;
2007         int offsetToCenterInOverview = (availableHeight - mInsets.top - overviewBar.height()
2008                 - scaledHeight) / 2;
2009 
2010         return -offsetFromTopEdge + mInsets.top + offsetToCenterInOverview;
2011     }
2012 
2013     boolean shouldVoiceButtonProxyBeVisible() {
2014         if (isOnOrMovingToCustomContent()) {
2015             return false;
2016         }
2017         if (mState != State.NORMAL) {
2018             return false;
2019         }
2020         return true;
2021     }
2022 
2023     public void updateInteractionForState() {
2024         if (mState != State.NORMAL) {
2025             mLauncher.onInteractionBegin();
2026         } else {
2027             mLauncher.onInteractionEnd();
2028         }
2029     }
2030 
2031     private void setState(State state) {
2032         mState = state;
2033         updateInteractionForState();
2034         updateAccessibilityFlags();
2035     }
2036 
2037     private void updateAccessibilityFlags() {
2038         int accessible = mState == State.NORMAL ?
2039                 ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES :
2040                 ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS;
2041         setImportantForAccessibility(accessible);
2042     }
2043 
2044     Animator getChangeStateAnimation(final State state, boolean animated, int delay, int snapPage) {
2045         if (mState == state) {
2046             return null;
2047         }
2048 
2049         // Initialize animation arrays for the first time if necessary
2050         initAnimationArrays();
2051 
2052         AnimatorSet anim = animated ? LauncherAnimUtils.createAnimatorSet() : null;
2053 
2054         final State oldState = mState;
2055         final boolean oldStateIsNormal = (oldState == State.NORMAL);
2056         final boolean oldStateIsSpringLoaded = (oldState == State.SPRING_LOADED);
2057         final boolean oldStateIsSmall = (oldState == State.SMALL);
2058         final boolean oldStateIsOverview = (oldState == State.OVERVIEW);
2059         setState(state);
2060         final boolean stateIsNormal = (state == State.NORMAL);
2061         final boolean stateIsSpringLoaded = (state == State.SPRING_LOADED);
2062         final boolean stateIsSmall = (state == State.SMALL);
2063         final boolean stateIsOverview = (state == State.OVERVIEW);
2064         float finalBackgroundAlpha = (stateIsSpringLoaded || stateIsOverview) ? 1.0f : 0f;
2065         float finalHotseatAndPageIndicatorAlpha = (stateIsOverview || stateIsSmall) ? 0f : 1f;
2066         float finalOverviewPanelAlpha = stateIsOverview ? 1f : 0f;
2067         float finalSearchBarAlpha = !stateIsNormal ? 0f : 1f;
2068         float finalWorkspaceTranslationY = stateIsOverview ? getOverviewModeTranslationY() : 0;
2069 
2070         boolean workspaceToAllApps = (oldStateIsNormal &amp;&amp; stateIsSmall);
2071         boolean allAppsToWorkspace = (oldStateIsSmall &amp;&amp; stateIsNormal);
2072         boolean workspaceToOverview = (oldStateIsNormal &amp;&amp; stateIsOverview);
2073         boolean overviewToWorkspace = (oldStateIsOverview &amp;&amp; stateIsNormal);
2074 
2075         mNewScale = 1.0f;
2076 
2077         if (oldStateIsOverview) {
2078             disableFreeScroll(snapPage);
2079         } else if (stateIsOverview) {
2080             enableFreeScroll();
2081         }
2082 
2083         if (state != State.NORMAL) {
2084             if (stateIsSpringLoaded) {
2085                 mNewScale = mSpringLoadedShrinkFactor;
2086             } else if (stateIsOverview) {
2087                 mNewScale = mOverviewModeShrinkFactor;
2088             } else if (stateIsSmall){
2089                 mNewScale = mOverviewModeShrinkFactor - 0.3f;
2090             }
2091             if (workspaceToAllApps) {
2092                 updateChildrenLayersEnabled(false);
2093             }
2094         }
2095 
2096         final int duration;
2097         if (workspaceToAllApps) {
2098             duration = getResources().getInteger(R.integer.config_workspaceUnshrinkTime);
2099         } else if (workspaceToOverview || overviewToWorkspace) {
2100             duration = getResources().getInteger(R.integer.config_overviewTransitionTime);
2101         } else {
2102             duration = getResources().getInteger(R.integer.config_appsCustomizeWorkspaceShrinkTime);
2103         }
2104 
2105         for (int i = 0; i &lt; getChildCount(); i++) {
2106             final CellLayout cl = (CellLayout) getChildAt(i);
2107             boolean isCurrentPage = (i == getNextPage());
2108             float initialAlpha = cl.getShortcutsAndWidgets().getAlpha();
2109             float finalAlpha;
2110             if (stateIsSmall) {
2111                 finalAlpha = 0f;
2112             } else if (stateIsNormal &amp;&amp; mWorkspaceFadeInAdjacentScreens) {
2113 
2114                 finalAlpha = (i == getNextPage() || i &lt; numCustomPages()) ? 1f : 0f;
2115             } else {
2116                 finalAlpha = 1f;
2117             }
2118 
2119             // If we are animating to/from the small state, then hide the side pages and fade the
2120             // current page in
2121             if (!mIsSwitchingState) {
2122                 if (workspaceToAllApps || allAppsToWorkspace) {
2123                     if (allAppsToWorkspace &amp;&amp; isCurrentPage) {
2124                         initialAlpha = 0f;
2125                     } else if (!isCurrentPage) {
2126                         initialAlpha = finalAlpha = 0f;
2127                     }
2128                     cl.setShortcutAndWidgetAlpha(initialAlpha);
2129                 }
2130             }
2131 
2132             mOldAlphas[i] = initialAlpha;
2133             mNewAlphas[i] = finalAlpha;
2134             if (animated) {
2135                 mOldBackgroundAlphas[i] = cl.getBackgroundAlpha();
2136                 mNewBackgroundAlphas[i] = finalBackgroundAlpha;
2137             } else {
2138                 cl.setBackgroundAlpha(finalBackgroundAlpha);
2139                 cl.setShortcutAndWidgetAlpha(finalAlpha);
2140             }
2141         }
2142 
2143         final View searchBar = mLauncher.getQsbBar();
2144         final View overviewPanel = mLauncher.getOverviewPanel();
2145         final View hotseat = mLauncher.getHotseat();
2146         if (animated) {
2147             anim.setDuration(duration);
2148             LauncherViewPropertyAnimator scale = new LauncherViewPropertyAnimator(this);
2149             scale.scaleX(mNewScale)
2150                 .scaleY(mNewScale)
2151                 .translationY(finalWorkspaceTranslationY)
2152                 .setInterpolator(mZoomInInterpolator);
2153             anim.play(scale);
2154             for (int index = 0; index &lt; getChildCount(); index++) {
2155                 final int i = index;
2156                 final CellLayout cl = (CellLayout) getChildAt(i);
2157                 float currentAlpha = cl.getShortcutsAndWidgets().getAlpha();
2158                 if (mOldAlphas[i] == 0 &amp;&amp; mNewAlphas[i] == 0) {
2159                     cl.setBackgroundAlpha(mNewBackgroundAlphas[i]);
2160                     cl.setShortcutAndWidgetAlpha(mNewAlphas[i]);
2161                 } else {
2162                     if (mOldAlphas[i] != mNewAlphas[i] || currentAlpha != mNewAlphas[i]) {
2163                         LauncherViewPropertyAnimator alphaAnim =
2164                             new LauncherViewPropertyAnimator(cl.getShortcutsAndWidgets());
2165                         alphaAnim.alpha(mNewAlphas[i])
2166                             .setInterpolator(mZoomInInterpolator);
2167                         anim.play(alphaAnim);
2168                     }
2169                     if (mOldBackgroundAlphas[i] != 0 ||
2170                         mNewBackgroundAlphas[i] != 0) {
2171                         ValueAnimator bgAnim =
2172                                 LauncherAnimUtils.ofFloat(cl, 0f, 1f);
2173                         bgAnim.setInterpolator(mZoomInInterpolator);
2174                         bgAnim.addUpdateListener(new LauncherAnimatorUpdateListener() {
2175                                 public void onAnimationUpdate(float a, float b) {
2176                                     cl.setBackgroundAlpha(
2177                                             a * mOldBackgroundAlphas[i] +
2178                                             b * mNewBackgroundAlphas[i]);
2179                                 }
2180                             });
2181                         anim.play(bgAnim);
2182                     }
2183                 }
2184             }
2185             ObjectAnimator pageIndicatorAlpha = null;
2186             if (getPageIndicator() != null) {
2187                 pageIndicatorAlpha = ObjectAnimator.ofFloat(getPageIndicator(), &quot;alpha&quot;,
2188                         finalHotseatAndPageIndicatorAlpha);
2189             }
2190             ObjectAnimator hotseatAlpha = ObjectAnimator.ofFloat(hotseat, &quot;alpha&quot;,
2191                     finalHotseatAndPageIndicatorAlpha);
2192             ObjectAnimator searchBarAlpha = ObjectAnimator.ofFloat(searchBar,
2193                     &quot;alpha&quot;, finalSearchBarAlpha);
2194             ObjectAnimator overviewPanelAlpha = ObjectAnimator.ofFloat(overviewPanel,
2195                     &quot;alpha&quot;, finalOverviewPanelAlpha);
2196 
2197             overviewPanelAlpha.addListener(new AlphaUpdateListener(overviewPanel));
2198             hotseatAlpha.addListener(new AlphaUpdateListener(hotseat));
2199             searchBarAlpha.addListener(new AlphaUpdateListener(searchBar));
2200 
2201             if (workspaceToOverview) {
2202                 hotseatAlpha.setInterpolator(new DecelerateInterpolator(2));
2203             } else if (overviewToWorkspace) {
2204                 overviewPanelAlpha.setInterpolator(new DecelerateInterpolator(2));
2205             }
2206 
2207             if (getPageIndicator() != null) {
2208                 pageIndicatorAlpha.addListener(new AlphaUpdateListener(getPageIndicator()));
2209             }
2210 
2211             anim.play(overviewPanelAlpha);
2212             anim.play(hotseatAlpha);
2213             anim.play(searchBarAlpha);
2214             anim.play(pageIndicatorAlpha);
2215             anim.setStartDelay(delay);
2216         } else {
2217             overviewPanel.setAlpha(finalOverviewPanelAlpha);
2218             AlphaUpdateListener.updateVisibility(overviewPanel);
2219             hotseat.setAlpha(finalHotseatAndPageIndicatorAlpha);
2220             AlphaUpdateListener.updateVisibility(hotseat);
2221             if (getPageIndicator() != null) {
2222                 getPageIndicator().setAlpha(finalHotseatAndPageIndicatorAlpha);
2223                 AlphaUpdateListener.updateVisibility(getPageIndicator());
2224             }
2225             searchBar.setAlpha(finalSearchBarAlpha);
2226             AlphaUpdateListener.updateVisibility(searchBar);
2227             updateCustomContentVisibility();
2228             setScaleX(mNewScale);
2229             setScaleY(mNewScale);
2230             setTranslationY(finalWorkspaceTranslationY);
2231         }
2232         mLauncher.updateVoiceButtonProxyVisible(false);
2233 
2234         if (stateIsSpringLoaded) {
2235             // Right now we&#x27;re covered by Apps Customize
2236             // Show the background gradient immediately, so the gradient will
2237             // be showing once AppsCustomize disappears
2238             animateBackgroundGradient(getResources().getInteger(
2239                     R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100f, false);
2240         } else if (stateIsOverview) {
2241             animateBackgroundGradient(getResources().getInteger(
2242                     R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100f, true);
2243         } else {
2244             // Fade the background gradient away
2245             animateBackgroundGradient(0f, animated);
2246         }
2247         return anim;
2248     }
2249 
2250     static class AlphaUpdateListener implements AnimatorUpdateListener, AnimatorListener {
2251         View view;
2252         public AlphaUpdateListener(View v) {
2253             view = v;
2254         }
2255 
2256         @Override
2257         public void onAnimationUpdate(ValueAnimator arg0) {
2258             updateVisibility(view);
2259         }
2260 
2261         public static void updateVisibility(View view) {
2262             // We want to avoid the extra layout pass by setting the views to GONE unless
2263             // accessibility is on, in which case not setting them to GONE causes a glitch.
2264             int invisibleState = sAccessibilityEnabled ? GONE : INVISIBLE;
2265             if (view.getAlpha() &lt; ALPHA_CUTOFF_THRESHOLD &amp;&amp; view.getVisibility() != invisibleState) {
2266                 view.setVisibility(invisibleState);
2267             } else if (view.getAlpha() &gt; ALPHA_CUTOFF_THRESHOLD
2268                     &amp;&amp; view.getVisibility() != VISIBLE) {
2269                 view.setVisibility(VISIBLE);
2270             }
2271         }
2272 
2273         @Override
2274         public void onAnimationCancel(Animator arg0) {
2275         }
2276 
2277         @Override
2278         public void onAnimationEnd(Animator arg0) {
2279             updateVisibility(view);
2280         }
2281 
2282         @Override
2283         public void onAnimationRepeat(Animator arg0) {
2284         }
2285 
2286         @Override
2287         public void onAnimationStart(Animator arg0) {
2288             // We want the views to be visible for animation, so fade-in/out is visible
2289             view.setVisibility(VISIBLE);
2290         }
2291     }
2292 
2293     @Override
2294     public void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace) {
2295         onTransitionPrepare();
2296     }
2297 
2298     @Override
2299     public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
2300     }
2301 
2302     @Override
2303     public void onLauncherTransitionStep(Launcher l, float t) {
2304         mTransitionProgress = t;
2305     }
2306 
2307     @Override
2308     public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
2309         onTransitionEnd();
2310     }
2311 
2312     private void onTransitionPrepare() {
2313         mIsSwitchingState = true;
2314 
2315         // Invalidate here to ensure that the pages are rendered during the state change transition.
2316         invalidate();
2317 
2318         updateChildrenLayersEnabled(false);
2319         hideCustomContentIfNecessary();
2320     }
2321 
2322     void updateCustomContentVisibility() {
2323         int visibility = mState == Workspace.State.NORMAL ? VISIBLE : INVISIBLE;
2324         if (hasCustomContent()) {
2325             mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(visibility);
2326         }
2327     }
2328 
2329     void showCustomContentIfNecessary() {
2330         boolean show  = mState == Workspace.State.NORMAL;
2331         if (show &amp;&amp; hasCustomContent()) {
2332             mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(VISIBLE);
2333         }
2334     }
2335 
2336     void hideCustomContentIfNecessary() {
2337         boolean hide  = mState != Workspace.State.NORMAL;
2338         if (hide &amp;&amp; hasCustomContent()) {
2339             mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(INVISIBLE);
2340         }
2341     }
2342 
2343     private void onTransitionEnd() {
2344         mIsSwitchingState = false;
2345         updateChildrenLayersEnabled(false);
2346         // The code in getChangeStateAnimation to determine initialAlpha and finalAlpha will ensure
2347         // ensure that only the current page is visible during (and subsequently, after) the
2348         // transition animation.  If fade adjacent pages is disabled, then re-enable the page
2349         // visibility after the transition animation.
2350         if (!mWorkspaceFadeInAdjacentScreens) {
2351             for (int i = 0; i &lt; getChildCount(); i++) {
2352                 final CellLayout cl = (CellLayout) getChildAt(i);
2353                 cl.setShortcutAndWidgetAlpha(1f);
2354             }
2355         } else {
2356             for (int i = 0; i &lt; numCustomPages(); i++) {
2357                 final CellLayout cl = (CellLayout) getChildAt(i);
2358                 cl.setShortcutAndWidgetAlpha(1f);
2359             }
2360         }
2361         showCustomContentIfNecessary();
2362     }
2363 
2364     @Override
2365     public View getContent() {
2366         return this;
2367     }
2368 
2369     /**
2370      * Draw the View v into the given Canvas.
2371      *
2372      * @param v the view to draw
2373      * @param destCanvas the canvas to draw on
2374      * @param padding the horizontal and vertical padding to use when drawing
2375      */
2376     private void drawDragView(View v, Canvas destCanvas, int padding, boolean pruneToDrawable) {
2377         final Rect clipRect = mTempRect;
2378         v.getDrawingRect(clipRect);
2379 
2380         boolean textVisible = false;
2381 
2382         destCanvas.save();
2383         if (v instanceof TextView &amp;&amp; pruneToDrawable) {
2384             Drawable d = ((TextView) v).getCompoundDrawables()[1];
2385             clipRect.set(0, 0, d.getIntrinsicWidth() + padding, d.getIntrinsicHeight() + padding);
2386             destCanvas.translate(padding / 2, padding / 2);
2387             d.draw(destCanvas);
2388         } else {
2389             if (v instanceof FolderIcon) {
2390                 // For FolderIcons the text can bleed into the icon area, and so we need to
2391                 // hide the text completely (which can&#x27;t be achieved by clipping).
2392                 if (((FolderIcon) v).getTextVisible()) {
2393                     ((FolderIcon) v).setTextVisible(false);
2394                     textVisible = true;
2395                 }
2396             } else if (v instanceof BubbleTextView) {
2397                 final BubbleTextView tv = (BubbleTextView) v;
2398                 clipRect.bottom = tv.getExtendedPaddingTop() - (int) BubbleTextView.PADDING_V +
2399                         tv.getLayout().getLineTop(0);
2400             } else if (v instanceof TextView) {
2401                 final TextView tv = (TextView) v;
2402                 clipRect.bottom = tv.getExtendedPaddingTop() - tv.getCompoundDrawablePadding() +
2403                         tv.getLayout().getLineTop(0);
2404             }
2405             destCanvas.translate(-v.getScrollX() + padding / 2, -v.getScrollY() + padding / 2);
2406             destCanvas.clipRect(clipRect, Op.REPLACE);
2407             v.draw(destCanvas);
2408 
2409             // Restore text visibility of FolderIcon if necessary
2410             if (textVisible) {
2411                 ((FolderIcon) v).setTextVisible(true);
2412             }
2413         }
2414         destCanvas.restore();
2415     }
2416 
2417     /**
2418      * Returns a new bitmap to show when the given View is being dragged around.
2419      * Responsibility for the bitmap is transferred to the caller.
2420      */
2421     public Bitmap createDragBitmap(View v, Canvas canvas, int padding) {
2422         Bitmap b;
2423 
2424         if (v instanceof TextView) {
2425             Drawable d = ((TextView) v).getCompoundDrawables()[1];
2426             b = Bitmap.createBitmap(d.getIntrinsicWidth() + padding,
2427                     d.getIntrinsicHeight() + padding, Bitmap.Config.ARGB_8888);
2428         } else {
2429             b = Bitmap.createBitmap(
2430                     v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
2431         }
2432 
2433         canvas.setBitmap(b);
2434         drawDragView(v, canvas, padding, true);
2435         canvas.setBitmap(null);
2436 
2437         return b;
2438     }
2439 
2440     /**
2441      * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
2442      * Responsibility for the bitmap is transferred to the caller.
2443      */
2444     private Bitmap createDragOutline(View v, Canvas canvas, int padding) {
2445         final int outlineColor = getResources().getColor(R.color.outline_color);
2446         final Bitmap b = Bitmap.createBitmap(
2447                 v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
2448 
2449         canvas.setBitmap(b);
2450         drawDragView(v, canvas, padding, true);
2451         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
2452         canvas.setBitmap(null);
2453         return b;
2454     }
2455 
2456     /**
2457      * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
2458      * Responsibility for the bitmap is transferred to the caller.
2459      */
2460     private Bitmap createDragOutline(Bitmap orig, Canvas canvas, int padding, int w, int h,
2461             boolean clipAlpha) {
2462         final int outlineColor = getResources().getColor(R.color.outline_color);
2463         final Bitmap b = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
2464         canvas.setBitmap(b);
2465 
2466         Rect src = new Rect(0, 0, orig.getWidth(), orig.getHeight());
2467         float scaleFactor = Math.min((w - padding) / (float) orig.getWidth(),
2468                 (h - padding) / (float) orig.getHeight());
2469         int scaledWidth = (int) (scaleFactor * orig.getWidth());
2470         int scaledHeight = (int) (scaleFactor * orig.getHeight());
2471         Rect dst = new Rect(0, 0, scaledWidth, scaledHeight);
2472 
2473         // center the image
2474         dst.offset((w - scaledWidth) / 2, (h - scaledHeight) / 2);
2475 
2476         canvas.drawBitmap(orig, src, dst, null);
2477         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor,
2478                 clipAlpha);
2479         canvas.setBitmap(null);
2480 
2481         return b;
2482     }
2483 
2484     void startDrag(CellLayout.CellInfo cellInfo) {
2485         View child = cellInfo.cell;
2486 
2487         // Make sure the drag was started by a long press as opposed to a long click.
2488         if (!child.isInTouchMode()) {
2489             return;
2490         }
2491 
2492         mDragInfo = cellInfo;
2493         child.setVisibility(INVISIBLE);
2494         CellLayout layout = (CellLayout) child.getParent().getParent();
2495         layout.prepareChildForDrag(child);
2496 
2497         child.clearFocus();
2498         child.setPressed(false);
2499 
2500         final Canvas canvas = new Canvas();
2501 
2502         // The outline is used to visualize where the item will land if dropped
2503         mDragOutline = createDragOutline(child, canvas, DRAG_BITMAP_PADDING);
2504         beginDragShared(child, this);
2505     }
2506 
2507     public void beginDragShared(View child, DragSource source) {
2508         // The drag bitmap follows the touch point around on the screen
2509         final Bitmap b = createDragBitmap(child, new Canvas(), DRAG_BITMAP_PADDING);
2510 
2511         final int bmpWidth = b.getWidth();
2512         final int bmpHeight = b.getHeight();
2513 
2514         float scale = mLauncher.getDragLayer().getLocationInDragLayer(child, mTempXY);
2515         int dragLayerX =
2516                 Math.round(mTempXY[0] - (bmpWidth - scale * child.getWidth()) / 2);
2517         int dragLayerY =
2518                 Math.round(mTempXY[1] - (bmpHeight - scale * bmpHeight) / 2
2519                         - DRAG_BITMAP_PADDING / 2);
2520 
2521         LauncherAppState app = LauncherAppState.getInstance();
2522         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2523         Point dragVisualizeOffset = null;
2524         Rect dragRect = null;
2525         if (child instanceof BubbleTextView || child instanceof PagedViewIcon) {
2526             int iconSize = grid.iconSizePx;
2527             int top = child.getPaddingTop();
2528             int left = (bmpWidth - iconSize) / 2;
2529             int right = left + iconSize;
2530             int bottom = top + iconSize;
2531             dragLayerY += top;
2532             // Note: The drag region is used to calculate drag layer offsets, but the
2533             // dragVisualizeOffset in addition to the dragRect (the size) to position the outline.
2534             dragVisualizeOffset = new Point(-DRAG_BITMAP_PADDING / 2, DRAG_BITMAP_PADDING / 2);
2535             dragRect = new Rect(left, top, right, bottom);
2536         } else if (child instanceof FolderIcon) {
2537             int previewSize = grid.folderIconSizePx;
2538             dragRect = new Rect(0, child.getPaddingTop(), child.getWidth(), previewSize);
2539         }
2540 
2541         // Clear the pressed state if necessary
2542         if (child instanceof BubbleTextView) {
2543             BubbleTextView icon = (BubbleTextView) child;
2544             icon.clearPressedOrFocusedBackground();
2545         }
2546 
2547 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2548         if (child.getTag() == null || !(child.getTag() instanceof ItemInfo)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2549             String msg = &quot;Drag started with a view that has no tag set. This &quot;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2550                     + &quot;will cause a crash (issue 11627249) down the line. &quot;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2551                     + &quot;View: &quot; + child + &quot;  tag: &quot; + child.getTag();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2552             throw new IllegalStateException(msg);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2553         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2554 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2555         mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),</span>
2556 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2557         mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2558                 DragController.DRAG_ACTION_MOVE, dragVisualizeOffset, dragRect, scale);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2559 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2560         if (child.getParent() instanceof ShortcutAndWidgetContainer) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2561             mDragSourceInternal = (ShortcutAndWidgetContainer) child.getParent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2562         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2563 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2564         b.recycle();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2565     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2566 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2567     void addApplicationShortcut(ShortcutInfo info, CellLayout target, long container, long screenId,</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2568             int cellX, int cellY, boolean insertAtFirst, int intersectX, int intersectY) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2569         View view = mLauncher.createShortcut(R.layout.application, target, (ShortcutInfo) info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2570 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2571         final int[] cellXY = new int[2];</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2572         target.findCellForSpanThatIntersects(cellXY, 1, 1, intersectX, intersectY);</span>
2573 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2574         DragView dv = mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),</span>
2575 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
2576                 DragController.DRAG_ACTION_MOVE, dragVisualizeOffset, dragRect, scale);
2577         dv.setIntrinsicIconScaleFactor(source.getIntrinsicIconScaleFactor());
2578 
2579         if (child.getParent() instanceof ShortcutAndWidgetContainer) {
2580             mDragSourceInternal = (ShortcutAndWidgetContainer) child.getParent();
2581         }
2582 
2583         b.recycle();
2584     }
2585 
2586     void addApplicationShortcut(ShortcutInfo info, CellLayout target, long container, long screenId,
2587             int cellX, int cellY, boolean insertAtFirst, int intersectX, int intersectY) {
2588         View view = mLauncher.createShortcut(R.layout.application, target, (ShortcutInfo) info);
2589 
2590         final int[] cellXY = new int[2];
2591         target.findCellForSpanThatIntersects(cellXY, 1, 1, intersectX, intersectY);
2592         addInScreen(view, container, screenId, cellXY[0], cellXY[1], 1, 1, insertAtFirst);
2593 
2594         LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screenId, cellXY[0],
2595                 cellXY[1]);
2596     }
2597 
2598     public boolean transitionStateShouldAllowDrop() {
2599         return ((!isSwitchingState() || mTransitionProgress &gt; 0.5f) &amp;&amp; mState != State.SMALL);
2600     }
2601 
2602     /**
2603      * {@inheritDoc}
2604      */
2605     public boolean acceptDrop(DragObject d) {
2606         // If it&#x27;s an external drop (e.g. from All Apps), check if it should be accepted
2607         CellLayout dropTargetLayout = mDropToLayout;
2608         if (d.dragSource != this) {
2609             // Don&#x27;t accept the drop if we&#x27;re not over a screen at time of drop
2610             if (dropTargetLayout == null) {
2611                 return false;
2612             }
2613             if (!transitionStateShouldAllowDrop()) return false;
2614 
2615             mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
2616                     d.dragView, mDragViewVisualCenter);
2617 
2618             // We want the point to be mapped to the dragTarget.
2619             if (mLauncher.isHotseatLayout(dropTargetLayout)) {
2620                 mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
2621             } else {
2622                 mapPointFromSelfToChild(dropTargetLayout, mDragViewVisualCenter, null);
2623             }
2624 
2625             int spanX = 1;
2626             int spanY = 1;
2627             if (mDragInfo != null) {
2628                 final CellLayout.CellInfo dragCellInfo = mDragInfo;
2629                 spanX = dragCellInfo.spanX;
2630                 spanY = dragCellInfo.spanY;
2631             } else {
2632                 final ItemInfo dragInfo = (ItemInfo) d.dragInfo;
2633                 spanX = dragInfo.spanX;
2634                 spanY = dragInfo.spanY;
2635             }
2636 
2637             int minSpanX = spanX;
2638             int minSpanY = spanY;
2639             if (d.dragInfo instanceof PendingAddWidgetInfo) {
2640                 minSpanX = ((PendingAddWidgetInfo) d.dragInfo).minSpanX;
2641                 minSpanY = ((PendingAddWidgetInfo) d.dragInfo).minSpanY;
2642             }
2643 
2644             mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
2645                     (int) mDragViewVisualCenter[1], minSpanX, minSpanY, dropTargetLayout,
2646                     mTargetCell);
2647             float distance = dropTargetLayout.getDistanceFromCell(mDragViewVisualCenter[0],
2648                     mDragViewVisualCenter[1], mTargetCell);
2649             if (willCreateUserFolder((ItemInfo) d.dragInfo, dropTargetLayout,
2650                     mTargetCell, distance, true)) {
2651                 return true;
2652             }
2653             if (willAddToExistingUserFolder((ItemInfo) d.dragInfo, dropTargetLayout,
2654                     mTargetCell, distance)) {
2655                 return true;
2656             }
2657 
2658             int[] resultSpan = new int[2];
2659             mTargetCell = dropTargetLayout.createArea((int) mDragViewVisualCenter[0],
2660                     (int) mDragViewVisualCenter[1], minSpanX, minSpanY, spanX, spanY,
2661                     null, mTargetCell, resultSpan, CellLayout.MODE_ACCEPT_DROP);
2662             boolean foundCell = mTargetCell[0] &gt;= 0 &amp;&amp; mTargetCell[1] &gt;= 0;
2663 
2664             // Don&#x27;t accept the drop if there&#x27;s no room for the item
2665             if (!foundCell) {
2666                 // Don&#x27;t show the message if we are dropping on the AllApps button and the hotseat
2667                 // is full
2668                 boolean isHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
2669                 if (mTargetCell != null &amp;&amp; isHotseat) {
2670                     Hotseat hotseat = mLauncher.getHotseat();
2671                     if (hotseat.isAllAppsButtonRank(
2672                             hotseat.getOrderInHotseat(mTargetCell[0], mTargetCell[1]))) {
2673                         return false;
2674                     }
2675                 }
2676 
2677                 mLauncher.showOutOfSpaceMessage(isHotseat);
2678                 return false;
2679             }
2680         }
2681 
2682         long screenId = getIdForScreen(dropTargetLayout);
2683         if (screenId == EXTRA_EMPTY_SCREEN_ID) {
2684             commitExtraEmptyScreen();
2685         }
2686 
2687         return true;
2688     }
2689 
2690     boolean willCreateUserFolder(ItemInfo info, CellLayout target, int[] targetCell, float
2691             distance, boolean considerTimeout) {
2692         if (distance &gt; mMaxDistanceForFolderCreation) return false;
2693         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2694 
2695         if (dropOverView != null) {
2696             CellLayout.LayoutParams lp = (CellLayout.LayoutParams) dropOverView.getLayoutParams();
2697             if (lp.useTmpCoords &amp;&amp; (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.tmpCellY)) {
2698                 return false;
2699             }
2700         }
2701 
2702         boolean hasntMoved = false;
2703         if (mDragInfo != null) {
2704             hasntMoved = dropOverView == mDragInfo.cell;
2705         }
2706 
2707         if (dropOverView == null || hasntMoved || (considerTimeout &amp;&amp; !mCreateUserFolderOnDrop)) {
2708             return false;
2709         }
2710 
2711         boolean aboveShortcut = (dropOverView.getTag() instanceof ShortcutInfo);
2712         boolean willBecomeShortcut =
2713                 (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
2714                 info.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT);
2715 
2716         return (aboveShortcut &amp;&amp; willBecomeShortcut);
2717     }
2718 
2719     boolean willAddToExistingUserFolder(Object dragInfo, CellLayout target, int[] targetCell,
2720             float distance) {
2721         if (distance &gt; mMaxDistanceForFolderCreation) return false;
2722         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2723 
2724         if (dropOverView != null) {
2725             CellLayout.LayoutParams lp = (CellLayout.LayoutParams) dropOverView.getLayoutParams();
2726             if (lp.useTmpCoords &amp;&amp; (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.tmpCellY)) {
2727                 return false;
2728             }
2729         }
2730 
2731         if (dropOverView instanceof FolderIcon) {
2732             FolderIcon fi = (FolderIcon) dropOverView;
2733             if (fi.acceptDrop(dragInfo)) {
2734                 return true;
2735             }
2736         }
2737         return false;
2738     }
2739 
2740     boolean createUserFolderIfNecessary(View newView, long container, CellLayout target,
2741             int[] targetCell, float distance, boolean external, DragView dragView,
2742             Runnable postAnimationRunnable) {
2743         if (distance &gt; mMaxDistanceForFolderCreation) return false;
2744         View v = target.getChildAt(targetCell[0], targetCell[1]);
2745 
2746         boolean hasntMoved = false;
2747         if (mDragInfo != null) {
2748             CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2749             hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2750                     mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2751         }
2752 
2753         if (v == null || hasntMoved || !mCreateUserFolderOnDrop) return false;
2754         mCreateUserFolderOnDrop = false;
2755         final long screenId = (targetCell == null) ? mDragInfo.screenId : getIdForScreen(target);
2756 
2757         boolean aboveShortcut = (v.getTag() instanceof ShortcutInfo);
2758         boolean willBecomeShortcut = (newView.getTag() instanceof ShortcutInfo);
2759 
2760         if (aboveShortcut &amp;&amp; willBecomeShortcut) {
2761             ShortcutInfo sourceInfo = (ShortcutInfo) newView.getTag();
2762             ShortcutInfo destInfo = (ShortcutInfo) v.getTag();
2763             // if the drag started here, we need to remove it from the workspace
2764             if (!external) {
2765                 getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2766             }
2767 
2768             Rect folderLocation = new Rect();
2769             float scale = mLauncher.getDragLayer().getDescendantRectRelativeToSelf(v, folderLocation);
2770             target.removeView(v);
2771 
2772             FolderIcon fi =
2773                 mLauncher.addFolder(target, container, screenId, targetCell[0], targetCell[1]);
2774             destInfo.cellX = -1;
2775             destInfo.cellY = -1;
2776             sourceInfo.cellX = -1;
2777             sourceInfo.cellY = -1;
2778 
2779             // If the dragView is null, we can&#x27;t animate
2780             boolean animate = dragView != null;
2781             if (animate) {
2782                 fi.performCreateAnimation(destInfo, v, sourceInfo, dragView, folderLocation, scale,
2783                         postAnimationRunnable);
2784             } else {
2785                 fi.addItem(destInfo);
2786                 fi.addItem(sourceInfo);
2787             }
2788             return true;
2789         }
2790         return false;
2791     }
2792 
2793     boolean addToExistingFolderIfNecessary(View newView, CellLayout target, int[] targetCell,
2794             float distance, DragObject d, boolean external) {
2795         if (distance &gt; mMaxDistanceForFolderCreation) return false;
2796 
2797         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2798         if (!mAddToExistingFolderOnDrop) return false;
2799         mAddToExistingFolderOnDrop = false;
2800 
2801         if (dropOverView instanceof FolderIcon) {
2802             FolderIcon fi = (FolderIcon) dropOverView;
2803             if (fi.acceptDrop(d.dragInfo)) {
2804                 fi.onDrop(d);
2805 
2806                 // if the drag started here, we need to remove it from the workspace
2807                 if (!external) {
2808                     getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2809                 }
2810                 return true;
2811             }
2812         }
2813         return false;
2814     }
2815 
2816     public void onDrop(final DragObject d) {
2817         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView,
2818                 mDragViewVisualCenter);
2819 
2820         CellLayout dropTargetLayout = mDropToLayout;
2821 
2822         // We want the point to be mapped to the dragTarget.
2823         if (dropTargetLayout != null) {
2824             if (mLauncher.isHotseatLayout(dropTargetLayout)) {
2825                 mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
2826             } else {
2827                 mapPointFromSelfToChild(dropTargetLayout, mDragViewVisualCenter, null);
2828             }
2829         }
2830 
2831         int snapScreen = -1;
2832         boolean resizeOnDrop = false;
2833         if (d.dragSource != this) {
2834             final int[] touchXY = new int[] { (int) mDragViewVisualCenter[0],
2835                     (int) mDragViewVisualCenter[1] };
2836             onDropExternal(touchXY, d.dragInfo, dropTargetLayout, false, d);
2837         } else if (mDragInfo != null) {
2838             final View cell = mDragInfo.cell;
2839 
2840             Runnable resizeRunnable = null;
2841             if (dropTargetLayout != null &amp;&amp; !d.cancelled) {
2842                 // Move internally
2843                 boolean hasMovedLayouts = (getParentCellLayoutForView(cell) != dropTargetLayout);
2844                 boolean hasMovedIntoHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
2845                 long container = hasMovedIntoHotseat ?
2846                         LauncherSettings.Favorites.CONTAINER_HOTSEAT :
2847                         LauncherSettings.Favorites.CONTAINER_DESKTOP;
2848                 long screenId = (mTargetCell[0] &lt; 0) ?
2849                         mDragInfo.screenId : getIdForScreen(dropTargetLayout);
2850                 int spanX = mDragInfo != null ? mDragInfo.spanX : 1;
2851                 int spanY = mDragInfo != null ? mDragInfo.spanY : 1;
2852                 // First we find the cell nearest to point at which the item is
2853                 // dropped, without any consideration to whether there is an item there.
2854 
2855                 mTargetCell = findNearestArea((int) mDragViewVisualCenter[0], (int)
2856                         mDragViewVisualCenter[1], spanX, spanY, dropTargetLayout, mTargetCell);
2857                 float distance = dropTargetLayout.getDistanceFromCell(mDragViewVisualCenter[0],
2858                         mDragViewVisualCenter[1], mTargetCell);
2859 
2860                 // If the item being dropped is a shortcut and the nearest drop
2861                 // cell also contains a shortcut, then create a folder with the two shortcuts.
2862                 if (!mInScrollArea &amp;&amp; createUserFolderIfNecessary(cell, container,
2863                         dropTargetLayout, mTargetCell, distance, false, d.dragView, null)) {
2864                     removeExtraEmptyScreen(true, null, 0, true);
2865                     return;
2866                 }
2867 
2868                 if (addToExistingFolderIfNecessary(cell, dropTargetLayout, mTargetCell,
2869                         distance, d, false)) {
2870                     removeExtraEmptyScreen(true, null, 0, true);
2871                     return;
2872                 }
2873 
2874                 // Aside from the special case where we&#x27;re dropping a shortcut onto a shortcut,
2875                 // we need to find the nearest cell location that is vacant
2876                 ItemInfo item = (ItemInfo) d.dragInfo;
2877                 int minSpanX = item.spanX;
2878                 int minSpanY = item.spanY;
2879                 if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
2880                     minSpanX = item.minSpanX;
2881                     minSpanY = item.minSpanY;
2882                 }
2883 
2884                 int[] resultSpan = new int[2];
2885                 mTargetCell = dropTargetLayout.createArea((int) mDragViewVisualCenter[0],
2886                         (int) mDragViewVisualCenter[1], minSpanX, minSpanY, spanX, spanY, cell,
2887                         mTargetCell, resultSpan, CellLayout.MODE_ON_DROP);
2888 
2889                 boolean foundCell = mTargetCell[0] &gt;= 0 &amp;&amp; mTargetCell[1] &gt;= 0;
2890 
2891                 // if the widget resizes on drop
2892                 if (foundCell &amp;&amp; (cell instanceof AppWidgetHostView) &amp;&amp;
2893                         (resultSpan[0] != item.spanX || resultSpan[1] != item.spanY)) {
2894                     resizeOnDrop = true;
2895                     item.spanX = resultSpan[0];
2896                     item.spanY = resultSpan[1];
2897                     AppWidgetHostView awhv = (AppWidgetHostView) cell;
2898                     AppWidgetResizeFrame.updateWidgetSizeRanges(awhv, mLauncher, resultSpan[0],
2899                             resultSpan[1]);
2900                 }
2901 
2902                 if (getScreenIdForPageIndex(mCurrentPage) != screenId &amp;&amp; !hasMovedIntoHotseat) {
2903                     snapScreen = getPageIndexForScreenId(screenId);
2904                     snapToPage(snapScreen);
2905                 }
2906 
2907                 if (foundCell) {
2908                     final ItemInfo info = (ItemInfo) cell.getTag();
2909                     if (hasMovedLayouts) {
2910                         // Reparent the view
2911                         getParentCellLayoutForView(cell).removeView(cell);
2912                         addInScreen(cell, container, screenId, mTargetCell[0], mTargetCell[1],
2913                                 info.spanX, info.spanY);
2914                     }
2915 
2916                     // update the item&#x27;s position after drop
2917                     CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();
2918                     lp.cellX = lp.tmpCellX = mTargetCell[0];
2919                     lp.cellY = lp.tmpCellY = mTargetCell[1];
2920                     lp.cellHSpan = item.spanX;
2921                     lp.cellVSpan = item.spanY;
2922                     lp.isLockedToGrid = true;
2923 
2924                     if (container != LauncherSettings.Favorites.CONTAINER_HOTSEAT &amp;&amp;
2925                             cell instanceof LauncherAppWidgetHostView) {
2926                         final CellLayout cellLayout = dropTargetLayout;
2927                         // We post this call so that the widget has a chance to be placed
2928                         // in its final location
2929 
2930                         final LauncherAppWidgetHostView hostView = (LauncherAppWidgetHostView) cell;
2931                         AppWidgetProviderInfo pinfo = hostView.getAppWidgetInfo();
2932                         if (pinfo != null &amp;&amp;
2933                                 pinfo.resizeMode != AppWidgetProviderInfo.RESIZE_NONE) {
2934                             final Runnable addResizeFrame = new Runnable() {
2935                                 public void run() {
2936                                     DragLayer dragLayer = mLauncher.getDragLayer();
2937                                     dragLayer.addResizeFrame(info, hostView, cellLayout);
2938                                 }
2939                             };
2940                             resizeRunnable = (new Runnable() {
2941                                 public void run() {
2942                                     if (!isPageMoving()) {
2943                                         addResizeFrame.run();
2944                                     } else {
2945                                         mDelayedResizeRunnable = addResizeFrame;
2946                                     }
2947                                 }
2948                             });
2949                         }
2950                     }
2951 
2952                     LauncherModel.modifyItemInDatabase(mLauncher, info, container, screenId, lp.cellX,
2953                             lp.cellY, item.spanX, item.spanY);
2954                 } else {
2955                     // If we can&#x27;t find a drop location, we return the item to its original position
2956                     CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();
2957                     mTargetCell[0] = lp.cellX;
2958                     mTargetCell[1] = lp.cellY;
2959                     CellLayout layout = (CellLayout) cell.getParent().getParent();
2960                     layout.markCellsAsOccupiedForView(cell);
2961                 }
2962             }
2963 
2964             final CellLayout parent = (CellLayout) cell.getParent().getParent();
2965             final Runnable finalResizeRunnable = resizeRunnable;
2966             // Prepare it to be animated into its new position
2967             // This must be called after the view has been re-parented
2968             final Runnable onCompleteRunnable = new Runnable() {
2969                 @Override
2970                 public void run() {
2971                     mAnimatingViewIntoPlace = false;
2972                     updateChildrenLayersEnabled(false);
2973                     if (finalResizeRunnable != null) {
2974                         finalResizeRunnable.run();
2975                     }
2976                     removeExtraEmptyScreen(true, null, 0, true);
2977                 }
2978             };
2979             mAnimatingViewIntoPlace = true;
2980             if (d.dragView.hasDrawn()) {
2981                 final ItemInfo info = (ItemInfo) cell.getTag();
2982                 if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET) {
2983                     int animationType = resizeOnDrop ? ANIMATE_INTO_POSITION_AND_RESIZE :
2984                             ANIMATE_INTO_POSITION_AND_DISAPPEAR;
2985                     animateWidgetDrop(info, parent, d.dragView,
2986                             onCompleteRunnable, animationType, cell, false);
2987                 } else {
2988                     int duration = snapScreen &lt; 0 ? -1 : ADJACENT_SCREEN_DROP_DURATION;
2989                     mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, cell, duration,
2990                             onCompleteRunnable, this);
2991                 }
2992             } else {
2993                 d.deferDragViewCleanupPostAnimation = false;
2994                 cell.setVisibility(VISIBLE);
2995             }
2996             parent.onDropChild(cell);
2997         }
2998     }
2999 
3000     public void setFinalScrollForPageChange(int pageIndex) {
3001         CellLayout cl = (CellLayout) getChildAt(pageIndex);
3002         if (cl != null) {
3003             mSavedScrollX = getScrollX();
3004             mSavedTranslationX = cl.getTranslationX();
3005             mSavedRotationY = cl.getRotationY();
3006             final int newX = getScrollForPage(pageIndex);
3007             setScrollX(newX);
3008             cl.setTranslationX(0f);
3009             cl.setRotationY(0f);
3010         }
3011     }
3012 
3013     public void resetFinalScrollForPageChange(int pageIndex) {
3014         if (pageIndex &gt;= 0) {
3015             CellLayout cl = (CellLayout) getChildAt(pageIndex);
3016             setScrollX(mSavedScrollX);
3017             cl.setTranslationX(mSavedTranslationX);
3018             cl.setRotationY(mSavedRotationY);
3019         }
3020     }
3021 
3022     public void getViewLocationRelativeToSelf(View v, int[] location) {
3023         getLocationInWindow(location);
3024         int x = location[0];
3025         int y = location[1];
3026 
3027         v.getLocationInWindow(location);
3028         int vX = location[0];
3029         int vY = location[1];
3030 
3031         location[0] = vX - x;
3032         location[1] = vY - y;
3033     }
3034 
3035     public void onDragEnter(DragObject d) {
3036         mDragEnforcer.onDragEnter();
3037         mCreateUserFolderOnDrop = false;
3038         mAddToExistingFolderOnDrop = false;
3039 
3040         mDropToLayout = null;
3041         CellLayout layout = getCurrentDropLayout();
3042         setCurrentDropLayout(layout);
3043         setCurrentDragOverlappingLayout(layout);
3044 
3045         // Because we don&#x27;t have space in the Phone UI (the CellLayouts run to the edge) we
3046         // don&#x27;t need to show the outlines
3047         if (LauncherAppState.getInstance().isScreenLarge()) {
3048             showOutlines();
3049         }
3050     }
3051 
3052     /** Return a rect that has the cellWidth/cellHeight (left, top), and
3053      * widthGap/heightGap (right, bottom) */
3054     static Rect getCellLayoutMetrics(Launcher launcher, int orientation) {
3055         LauncherAppState app = LauncherAppState.getInstance();
3056         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
3057 
3058         Resources res = launcher.getResources();
3059         Display display = launcher.getWindowManager().getDefaultDisplay();
3060         Point smallestSize = new Point();
3061         Point largestSize = new Point();
3062         display.getCurrentSizeRange(smallestSize, largestSize);
3063         int countX = (int) grid.numColumns;
3064         int countY = (int) grid.numRows;
3065         int constrainedLongEdge = largestSize.y;
3066         int constrainedShortEdge = smallestSize.y;
3067         if (orientation == CellLayout.LANDSCAPE) {
3068             if (mLandscapeCellLayoutMetrics == null) {
3069                 Rect padding = grid.getWorkspacePadding(CellLayout.LANDSCAPE);
3070                 int width = constrainedLongEdge - padding.left - padding.right;
3071                 int height = constrainedShortEdge - padding.top - padding.bottom;
3072                 mLandscapeCellLayoutMetrics = new Rect();
3073                 mLandscapeCellLayoutMetrics.set(
3074                         grid.calculateCellWidth(width, countX),
3075                         grid.calculateCellHeight(height, countY), 0, 0);
3076             }
3077             return mLandscapeCellLayoutMetrics;
3078         } else if (orientation == CellLayout.PORTRAIT) {
3079             if (mPortraitCellLayoutMetrics == null) {
3080                 Rect padding = grid.getWorkspacePadding(CellLayout.PORTRAIT);
3081                 int width = constrainedShortEdge - padding.left - padding.right;
3082                 int height = constrainedLongEdge - padding.top - padding.bottom;
3083                 mPortraitCellLayoutMetrics = new Rect();
3084                 mPortraitCellLayoutMetrics.set(
3085                         grid.calculateCellWidth(width, countX),
3086                         grid.calculateCellHeight(height, countY), 0, 0);
3087             }
3088             return mPortraitCellLayoutMetrics;
3089         }
3090         return null;
3091     }
3092 
3093     public void onDragExit(DragObject d) {
3094         mDragEnforcer.onDragExit();
3095 
3096         // Here we store the final page that will be dropped to, if the workspace in fact
3097         // receives the drop
3098         if (mInScrollArea) {
3099             if (isPageMoving()) {
3100                 // If the user drops while the page is scrolling, we should use that page as the
3101                 // destination instead of the page that is being hovered over.
3102                 mDropToLayout = (CellLayout) getPageAt(getNextPage());
3103             } else {
3104                 mDropToLayout = mDragOverlappingLayout;
3105             }
3106         } else {
3107             mDropToLayout = mDragTargetLayout;
3108         }
3109 
3110         if (mDragMode == DRAG_MODE_CREATE_FOLDER) {
3111             mCreateUserFolderOnDrop = true;
3112         } else if (mDragMode == DRAG_MODE_ADD_TO_FOLDER) {
3113             mAddToExistingFolderOnDrop = true;
3114         }
3115 
3116         // Reset the scroll area and previous drag target
3117         onResetScrollArea();
3118         setCurrentDropLayout(null);
3119         setCurrentDragOverlappingLayout(null);
3120 
3121         mSpringLoadedDragController.cancel();
3122 
3123         if (!mIsPageMoving) {
3124             hideOutlines();
3125         }
3126     }
3127 
3128     void setCurrentDropLayout(CellLayout layout) {
3129         if (mDragTargetLayout != null) {
3130             mDragTargetLayout.revertTempState();
3131             mDragTargetLayout.onDragExit();
3132         }
3133         mDragTargetLayout = layout;
3134         if (mDragTargetLayout != null) {
3135             mDragTargetLayout.onDragEnter();
3136         }
3137         cleanupReorder(true);
3138         cleanupFolderCreation();
3139         setCurrentDropOverCell(-1, -1);
3140     }
3141 
3142     void setCurrentDragOverlappingLayout(CellLayout layout) {
3143         if (mDragOverlappingLayout != null) {
3144             mDragOverlappingLayout.setIsDragOverlapping(false);
3145         }
3146         mDragOverlappingLayout = layout;
3147         if (mDragOverlappingLayout != null) {
3148             mDragOverlappingLayout.setIsDragOverlapping(true);
3149         }
3150         invalidate();
3151     }
3152 
3153     void setCurrentDropOverCell(int x, int y) {
3154         if (x != mDragOverX || y != mDragOverY) {
3155             mDragOverX = x;
3156             mDragOverY = y;
3157             setDragMode(DRAG_MODE_NONE);
3158         }
3159     }
3160 
3161     void setDragMode(int dragMode) {
3162         if (dragMode != mDragMode) {
3163             if (dragMode == DRAG_MODE_NONE) {
3164                 cleanupAddToFolder();
3165                 // We don&#x27;t want to cancel the re-order alarm every time the target cell changes
3166                 // as this feels to slow / unresponsive.
3167                 cleanupReorder(false);
3168                 cleanupFolderCreation();
3169             } else if (dragMode == DRAG_MODE_ADD_TO_FOLDER) {
3170                 cleanupReorder(true);
3171                 cleanupFolderCreation();
3172             } else if (dragMode == DRAG_MODE_CREATE_FOLDER) {
3173                 cleanupAddToFolder();
3174                 cleanupReorder(true);
3175             } else if (dragMode == DRAG_MODE_REORDER) {
3176                 cleanupAddToFolder();
3177                 cleanupFolderCreation();
3178             }
3179             mDragMode = dragMode;
3180         }
3181     }
3182 
3183     private void cleanupFolderCreation() {
3184         if (mDragFolderRingAnimator != null) {
3185             mDragFolderRingAnimator.animateToNaturalState();
3186             mDragFolderRingAnimator = null;
3187         }
3188         mFolderCreationAlarm.setOnAlarmListener(null);
3189         mFolderCreationAlarm.cancelAlarm();
3190     }
3191 
3192     private void cleanupAddToFolder() {
3193         if (mDragOverFolderIcon != null) {
3194             mDragOverFolderIcon.onDragExit(null);
3195             mDragOverFolderIcon = null;
3196         }
3197     }
3198 
3199     private void cleanupReorder(boolean cancelAlarm) {
3200         // Any pending reorders are canceled
3201         if (cancelAlarm) {
3202             mReorderAlarm.cancelAlarm();
3203         }
3204         mLastReorderX = -1;
3205         mLastReorderY = -1;
3206     }
3207 
3208    /*
3209     *
3210     * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
3211     * coordinate space. The argument xy is modified with the return result.
3212     *
3213     * if cachedInverseMatrix is not null, this method will just use that matrix instead of
3214     * computing it itself; we use this to avoid redundant matrix inversions in
3215     * findMatchingPageForDragOver
3216     *
3217     */
3218    void mapPointFromSelfToChild(View v, float[] xy, Matrix cachedInverseMatrix) {
3219        xy[0] = xy[0] - v.getLeft();
3220        xy[1] = xy[1] - v.getTop();
3221    }
3222 
3223    boolean isPointInSelfOverHotseat(int x, int y, Rect r) {
3224        if (r == null) {
3225            r = new Rect();
3226        }
3227        mTempPt[0] = x;
3228        mTempPt[1] = y;
3229        mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(this, mTempPt, true);
3230 
3231        LauncherAppState app = LauncherAppState.getInstance();
3232        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
3233        r = grid.getHotseatRect();
3234        if (r.contains(mTempPt[0], mTempPt[1])) {
3235            return true;
3236        }
3237        return false;
3238    }
3239 
3240    void mapPointFromSelfToHotseatLayout(Hotseat hotseat, float[] xy) {
3241        mTempPt[0] = (int) xy[0];
3242        mTempPt[1] = (int) xy[1];
3243        mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(this, mTempPt, true);
3244        mLauncher.getDragLayer().mapCoordInSelfToDescendent(hotseat.getLayout(), mTempPt);
3245 
3246        xy[0] = mTempPt[0];
3247        xy[1] = mTempPt[1];
3248    }
3249 
3250    /*
3251     *
3252     * Convert the 2D coordinate xy from this CellLayout&#x27;s coordinate space to
3253     * the parent View&#x27;s coordinate space. The argument xy is modified with the return result.
3254     *
3255     */
3256    void mapPointFromChildToSelf(View v, float[] xy) {
3257        xy[0] += v.getLeft();
3258        xy[1] += v.getTop();
3259    }
3260 
3261    static private float squaredDistance(float[] point1, float[] point2) {
3262         float distanceX = point1[0] - point2[0];
3263         float distanceY = point2[1] - point2[1];
3264         return distanceX * distanceX + distanceY * distanceY;
3265    }
3266 
3267     /*
3268      *
3269      * This method returns the CellLayout that is currently being dragged to. In order to drag
3270      * to a CellLayout, either the touch point must be directly over the CellLayout, or as a second
3271      * strategy, we see if the dragView is overlapping any CellLayout and choose the closest one
3272      *
3273      * Return null if no CellLayout is currently being dragged over
3274      *
3275      */
3276     private CellLayout findMatchingPageForDragOver(
3277             DragView dragView, float originX, float originY, boolean exact) {
3278         // We loop through all the screens (ie CellLayouts) and see which ones overlap
3279         // with the item being dragged and then choose the one that&#x27;s closest to the touch point
3280         final int screenCount = getChildCount();
3281         CellLayout bestMatchingScreen = null;
3282         float smallestDistSoFar = Float.MAX_VALUE;
3283 
3284         for (int i = 0; i &lt; screenCount; i++) {
3285             // The custom content screen is not a valid drag over option
3286             if (mScreenOrder.get(i) == CUSTOM_CONTENT_SCREEN_ID) {
3287                 continue;
3288             }
3289 
3290             CellLayout cl = (CellLayout) getChildAt(i);
3291 
3292             final float[] touchXy = {originX, originY};
3293             // Transform the touch coordinates to the CellLayout&#x27;s local coordinates
3294             // If the touch point is within the bounds of the cell layout, we can return immediately
3295             cl.getMatrix().invert(mTempInverseMatrix);
3296             mapPointFromSelfToChild(cl, touchXy, mTempInverseMatrix);
3297 
3298             if (touchXy[0] &gt;= 0 &amp;&amp; touchXy[0] &lt;= cl.getWidth() &amp;&amp;
3299                     touchXy[1] &gt;= 0 &amp;&amp; touchXy[1] &lt;= cl.getHeight()) {
3300                 return cl;
3301             }
3302 
3303             if (!exact) {
3304                 // Get the center of the cell layout in screen coordinates
3305                 final float[] cellLayoutCenter = mTempCellLayoutCenterCoordinates;
3306                 cellLayoutCenter[0] = cl.getWidth()/2;
3307                 cellLayoutCenter[1] = cl.getHeight()/2;
3308                 mapPointFromChildToSelf(cl, cellLayoutCenter);
3309 
3310                 touchXy[0] = originX;
3311                 touchXy[1] = originY;
3312 
3313                 // Calculate the distance between the center of the CellLayout
3314                 // and the touch point
3315                 float dist = squaredDistance(touchXy, cellLayoutCenter);
3316 
3317                 if (dist &lt; smallestDistSoFar) {
3318                     smallestDistSoFar = dist;
3319                     bestMatchingScreen = cl;
3320                 }
3321             }
3322         }
3323         return bestMatchingScreen;
3324     }
3325 
3326     // This is used to compute the visual center of the dragView. This point is then
3327     // used to visualize drop locations and determine where to drop an item. The idea is that
3328     // the visual center represents the user&#x27;s interpretation of where the item is, and hence
3329     // is the appropriate point to use when determining drop location.
3330     private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
3331             DragView dragView, float[] recycle) {
3332         float res[];
3333         if (recycle == null) {
3334             res = new float[2];
3335         } else {
3336             res = recycle;
3337         }
3338 
3339         // First off, the drag view has been shifted in a way that is not represented in the
3340         // x and y values or the x/yOffsets. Here we account for that shift.
3341         x += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetX);
3342         y += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
3343 
3344         // These represent the visual top and left of drag view if a dragRect was provided.
3345         // If a dragRect was not provided, then they correspond to the actual view left and
3346         // top, as the dragRect is in that case taken to be the entire dragView.
3347         // R.dimen.dragViewOffsetY.
3348         int left = x - xOffset;
3349         int top = y - yOffset;
3350 
3351         // In order to find the visual center, we shift by half the dragRect
3352         res[0] = left + dragView.getDragRegion().width() / 2;
3353         res[1] = top + dragView.getDragRegion().height() / 2;
3354 
3355         return res;
3356     }
3357 
3358     private boolean isDragWidget(DragObject d) {
3359         return (d.dragInfo instanceof LauncherAppWidgetInfo ||
3360                 d.dragInfo instanceof PendingAddWidgetInfo);
3361     }
3362     private boolean isExternalDragWidget(DragObject d) {
3363         return d.dragSource != this &amp;&amp; isDragWidget(d);
3364     }
3365 
3366     public void onDragOver(DragObject d) {
3367         // Skip drag over events while we are dragging over side pages
3368         if (mInScrollArea || mIsSwitchingState || mState == State.SMALL) return;
3369 
3370         Rect r = new Rect();
3371         CellLayout layout = null;
3372         ItemInfo item = (ItemInfo) d.dragInfo;
3373 
3374         // Ensure that we have proper spans for the item that we are dropping
3375         if (item.spanX &lt; 0 || item.spanY &lt; 0) throw new RuntimeException(&quot;Improper spans found&quot;);
3376         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
3377             d.dragView, mDragViewVisualCenter);
3378 
3379         final View child = (mDragInfo == null) ? null : mDragInfo.cell;
3380         // Identify whether we have dragged over a side page
3381         if (isSmall()) {
3382             if (mLauncher.getHotseat() != null &amp;&amp; !isExternalDragWidget(d)) {
3383                 if (isPointInSelfOverHotseat(d.x, d.y, r)) {
3384                     layout = mLauncher.getHotseat().getLayout();
3385                 }
3386             }
3387             if (layout == null) {
3388                 layout = findMatchingPageForDragOver(d.dragView, d.x, d.y, false);
3389             }
3390             if (layout != mDragTargetLayout) {
3391                 setCurrentDropLayout(layout);
3392                 setCurrentDragOverlappingLayout(layout);
3393 
3394                 boolean isInSpringLoadedMode = (mState == State.SPRING_LOADED);
3395                 if (isInSpringLoadedMode) {
3396                     if (mLauncher.isHotseatLayout(layout)) {
3397                         mSpringLoadedDragController.cancel();
3398                     } else {
3399                         mSpringLoadedDragController.setAlarm(mDragTargetLayout);
3400                     }
3401                 }
3402             }
3403         } else {
3404             // Test to see if we are over the hotseat otherwise just use the current page
3405             if (mLauncher.getHotseat() != null &amp;&amp; !isDragWidget(d)) {
3406                 if (isPointInSelfOverHotseat(d.x, d.y, r)) {
3407                     layout = mLauncher.getHotseat().getLayout();
3408                 }
3409             }
3410             if (layout == null) {
3411                 layout = getCurrentDropLayout();
3412             }
3413             if (layout != mDragTargetLayout) {
3414                 setCurrentDropLayout(layout);
3415                 setCurrentDragOverlappingLayout(layout);
3416             }
3417         }
3418 
3419         // Handle the drag over
3420         if (mDragTargetLayout != null) {
3421             // We want the point to be mapped to the dragTarget.
3422             if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
3423                 mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
3424             } else {
3425                 mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
3426             }
3427 
3428             ItemInfo info = (ItemInfo) d.dragInfo;
3429 
3430             int minSpanX = item.spanX;
3431             int minSpanY = item.spanY;
3432             if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
3433                 minSpanX = item.minSpanX;
3434                 minSpanY = item.minSpanY;
3435             }
3436 
3437             mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
3438                     (int) mDragViewVisualCenter[1], minSpanX, minSpanY,
3439                     mDragTargetLayout, mTargetCell);
3440             int reorderX = mTargetCell[0];
3441             int reorderY = mTargetCell[1];
3442 
3443             setCurrentDropOverCell(mTargetCell[0], mTargetCell[1]);
3444 
3445             float targetCellDistance = mDragTargetLayout.getDistanceFromCell(
3446                     mDragViewVisualCenter[0], mDragViewVisualCenter[1], mTargetCell);
3447 
3448             final View dragOverView = mDragTargetLayout.getChildAt(mTargetCell[0],
3449                     mTargetCell[1]);
3450 
3451             manageFolderFeedback(info, mDragTargetLayout, mTargetCell,
3452                     targetCellDistance, dragOverView);
3453 
3454             boolean nearestDropOccupied = mDragTargetLayout.isNearestDropLocationOccupied((int)
3455                     mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1], item.spanX,
3456                     item.spanY, child, mTargetCell);
3457 
3458             if (!nearestDropOccupied) {
3459                 mDragTargetLayout.visualizeDropLocation(child, mDragOutline,
3460                         (int) mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1],
3461                         mTargetCell[0], mTargetCell[1], item.spanX, item.spanY, false,
3462                         d.dragView.getDragVisualizeOffset(), d.dragView.getDragRegion());
3463             } else if ((mDragMode == DRAG_MODE_NONE || mDragMode == DRAG_MODE_REORDER)
3464                     &amp;&amp; !mReorderAlarm.alarmPending() &amp;&amp; (mLastReorderX != reorderX ||
3465                     mLastReorderY != reorderY)) {
3466 
3467                 // Otherwise, if we aren&#x27;t adding to or creating a folder and there&#x27;s no pending
3468                 // reorder, then we schedule a reorder
3469                 ReorderAlarmListener listener = new ReorderAlarmListener(mDragViewVisualCenter,
3470                         minSpanX, minSpanY, item.spanX, item.spanY, d.dragView, child);
3471                 mReorderAlarm.setOnAlarmListener(listener);
3472                 mReorderAlarm.setAlarm(REORDER_TIMEOUT);
3473             }
3474 
3475             if (mDragMode == DRAG_MODE_CREATE_FOLDER || mDragMode == DRAG_MODE_ADD_TO_FOLDER ||
3476                     !nearestDropOccupied) {
3477                 if (mDragTargetLayout != null) {
3478                     mDragTargetLayout.revertTempState();
3479                 }
3480             }
3481         }
3482     }
3483 
3484     private void manageFolderFeedback(ItemInfo info, CellLayout targetLayout,
3485             int[] targetCell, float distance, View dragOverView) {
3486         boolean userFolderPending = willCreateUserFolder(info, targetLayout, targetCell, distance,
3487                 false);
3488 
3489         if (mDragMode == DRAG_MODE_NONE &amp;&amp; userFolderPending &amp;&amp;
3490                 !mFolderCreationAlarm.alarmPending()) {
3491             mFolderCreationAlarm.setOnAlarmListener(new
3492                     FolderCreationAlarmListener(targetLayout, targetCell[0], targetCell[1]));
3493             mFolderCreationAlarm.setAlarm(FOLDER_CREATION_TIMEOUT);
3494             return;
3495         }
3496 
3497         boolean willAddToFolder =
3498                 willAddToExistingUserFolder(info, targetLayout, targetCell, distance);
3499 
3500         if (willAddToFolder &amp;&amp; mDragMode == DRAG_MODE_NONE) {
3501             mDragOverFolderIcon = ((FolderIcon) dragOverView);
3502             mDragOverFolderIcon.onDragEnter(info);
3503             if (targetLayout != null) {
3504                 targetLayout.clearDragOutlines();
3505             }
3506             setDragMode(DRAG_MODE_ADD_TO_FOLDER);
3507             return;
3508         }
3509 
3510         if (mDragMode == DRAG_MODE_ADD_TO_FOLDER &amp;&amp; !willAddToFolder) {
3511             setDragMode(DRAG_MODE_NONE);
3512         }
3513         if (mDragMode == DRAG_MODE_CREATE_FOLDER &amp;&amp; !userFolderPending) {
3514             setDragMode(DRAG_MODE_NONE);
3515         }
3516 
3517         return;
3518     }
3519 
3520     class FolderCreationAlarmListener implements OnAlarmListener {
3521         CellLayout layout;
3522         int cellX;
3523         int cellY;
3524 
3525         public FolderCreationAlarmListener(CellLayout layout, int cellX, int cellY) {
3526             this.layout = layout;
3527             this.cellX = cellX;
3528             this.cellY = cellY;
3529         }
3530 
3531         public void onAlarm(Alarm alarm) {
3532             if (mDragFolderRingAnimator != null) {
3533                 // This shouldn&#x27;t happen ever, but just in case, make sure we clean up the mess.
3534                 mDragFolderRingAnimator.animateToNaturalState();
3535             }
3536             mDragFolderRingAnimator = new FolderRingAnimator(mLauncher, null);
3537             mDragFolderRingAnimator.setCell(cellX, cellY);
3538             mDragFolderRingAnimator.setCellLayout(layout);
3539             mDragFolderRingAnimator.animateToAcceptState();
3540             layout.showFolderAccept(mDragFolderRingAnimator);
3541             layout.clearDragOutlines();
3542             setDragMode(DRAG_MODE_CREATE_FOLDER);
3543         }
3544     }
3545 
3546     class ReorderAlarmListener implements OnAlarmListener {
3547         float[] dragViewCenter;
3548         int minSpanX, minSpanY, spanX, spanY;
3549         DragView dragView;
3550         View child;
3551 
3552         public ReorderAlarmListener(float[] dragViewCenter, int minSpanX, int minSpanY, int spanX,
3553                 int spanY, DragView dragView, View child) {
3554             this.dragViewCenter = dragViewCenter;
3555             this.minSpanX = minSpanX;
3556             this.minSpanY = minSpanY;
3557             this.spanX = spanX;
3558             this.spanY = spanY;
3559             this.child = child;
3560             this.dragView = dragView;
3561         }
3562 
3563         public void onAlarm(Alarm alarm) {
3564             int[] resultSpan = new int[2];
3565             mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
3566                     (int) mDragViewVisualCenter[1], minSpanX, minSpanY, mDragTargetLayout,
3567                     mTargetCell);
3568             mLastReorderX = mTargetCell[0];
3569             mLastReorderY = mTargetCell[1];
3570 
3571             mTargetCell = mDragTargetLayout.createArea((int) mDragViewVisualCenter[0],
3572                 (int) mDragViewVisualCenter[1], minSpanX, minSpanY, spanX, spanY,
3573                 child, mTargetCell, resultSpan, CellLayout.MODE_DRAG_OVER);
3574 
3575             if (mTargetCell[0] &lt; 0 || mTargetCell[1] &lt; 0) {
3576                 mDragTargetLayout.revertTempState();
3577             } else {
3578                 setDragMode(DRAG_MODE_REORDER);
3579             }
3580 
3581             boolean resize = resultSpan[0] != spanX || resultSpan[1] != spanY;
3582             mDragTargetLayout.visualizeDropLocation(child, mDragOutline,
3583                 (int) mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1],
3584                 mTargetCell[0], mTargetCell[1], resultSpan[0], resultSpan[1], resize,
3585                 dragView.getDragVisualizeOffset(), dragView.getDragRegion());
3586         }
3587     }
3588 
3589     @Override
3590     public void getHitRectRelativeToDragLayer(Rect outRect) {
3591         // We want the workspace to have the whole area of the display (it will find the correct
3592         // cell layout to drop to in the existing drag/drop logic.
3593         mLauncher.getDragLayer().getDescendantRectRelativeToSelf(this, outRect);
3594     }
3595 
3596     /**
3597      * Add the item specified by dragInfo to the given layout.
3598      * @return true if successful
3599      */
3600     public boolean addExternalItemToScreen(ItemInfo dragInfo, CellLayout layout) {
3601         if (layout.findCellForSpan(mTempEstimate, dragInfo.spanX, dragInfo.spanY)) {
3602             onDropExternal(dragInfo.dropPos, (ItemInfo) dragInfo, (CellLayout) layout, false);
3603             return true;
3604         }
3605         mLauncher.showOutOfSpaceMessage(mLauncher.isHotseatLayout(layout));
3606         return false;
3607     }
3608 
3609     private void onDropExternal(int[] touchXY, Object dragInfo,
3610             CellLayout cellLayout, boolean insertAtFirst) {
3611         onDropExternal(touchXY, dragInfo, cellLayout, insertAtFirst, null);
3612     }
3613 
3614     /**
3615      * Drop an item that didn&#x27;t originate on one of the workspace screens.
3616      * It may have come from Launcher (e.g. from all apps or customize), or it may have
3617      * come from another app altogether.
3618      *
3619      * NOTE: This can also be called when we are outside of a drag event, when we want
3620      * to add an item to one of the workspace screens.
3621      */
3622     private void onDropExternal(final int[] touchXY, final Object dragInfo,
3623             final CellLayout cellLayout, boolean insertAtFirst, DragObject d) {
3624         final Runnable exitSpringLoadedRunnable = new Runnable() {
3625             @Override
3626             public void run() {
3627                 removeExtraEmptyScreen(false, new Runnable() {
3628                     @Override
3629                     public void run() {
3630                         mLauncher.exitSpringLoadedDragModeDelayed(true,
3631                                 Launcher.EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
3632                     }
3633                 });
3634             }
3635         };
3636 
3637         ItemInfo info = (ItemInfo) dragInfo;
3638         int spanX = info.spanX;
3639         int spanY = info.spanY;
3640         if (mDragInfo != null) {
3641             spanX = mDragInfo.spanX;
3642             spanY = mDragInfo.spanY;
3643         }
3644 
3645         final long container = mLauncher.isHotseatLayout(cellLayout) ?
3646                 LauncherSettings.Favorites.CONTAINER_HOTSEAT :
3647                     LauncherSettings.Favorites.CONTAINER_DESKTOP;
3648         final long screenId = getIdForScreen(cellLayout);
3649         if (!mLauncher.isHotseatLayout(cellLayout)
3650                 &amp;&amp; screenId != getScreenIdForPageIndex(mCurrentPage)
3651                 &amp;&amp; mState != State.SPRING_LOADED) {
3652             snapToScreenId(screenId, null);
3653         }
3654 
3655         if (info instanceof PendingAddItemInfo) {
3656             final PendingAddItemInfo pendingInfo = (PendingAddItemInfo) dragInfo;
3657 
3658             boolean findNearestVacantCell = true;
3659             if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) {
3660                 mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3661                         cellLayout, mTargetCell);
3662                 float distance = cellLayout.getDistanceFromCell(mDragViewVisualCenter[0],
3663                         mDragViewVisualCenter[1], mTargetCell);
3664                 if (willCreateUserFolder((ItemInfo) d.dragInfo, cellLayout, mTargetCell,
3665                         distance, true) || willAddToExistingUserFolder((ItemInfo) d.dragInfo,
3666                                 cellLayout, mTargetCell, distance)) {
3667                     findNearestVacantCell = false;
3668                 }
3669             }
3670 
3671             final ItemInfo item = (ItemInfo) d.dragInfo;
3672             boolean updateWidgetSize = false;
3673             if (findNearestVacantCell) {
3674                 int minSpanX = item.spanX;
3675                 int minSpanY = item.spanY;
3676                 if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
3677                     minSpanX = item.minSpanX;
3678                     minSpanY = item.minSpanY;
3679                 }
3680                 int[] resultSpan = new int[2];
3681                 mTargetCell = cellLayout.createArea((int) mDragViewVisualCenter[0],
3682                         (int) mDragViewVisualCenter[1], minSpanX, minSpanY, info.spanX, info.spanY,
3683                         null, mTargetCell, resultSpan, CellLayout.MODE_ON_DROP_EXTERNAL);
3684 
3685                 if (resultSpan[0] != item.spanX || resultSpan[1] != item.spanY) {
3686                     updateWidgetSize = true;
3687                 }
3688                 item.spanX = resultSpan[0];
3689                 item.spanY = resultSpan[1];
3690             }
3691 
3692             Runnable onAnimationCompleteRunnable = new Runnable() {
3693                 @Override
3694                 public void run() {
3695                     // When dragging and dropping from customization tray, we deal with creating
3696                     // widgets/shortcuts/folders in a slightly different way
3697                     switch (pendingInfo.itemType) {
3698                     case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
3699                         int span[] = new int[2];
3700                         span[0] = item.spanX;
3701                         span[1] = item.spanY;
3702                         mLauncher.addAppWidgetFromDrop((PendingAddWidgetInfo) pendingInfo,
3703                                 container, screenId, mTargetCell, span, null);
3704                         break;
3705                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3706                         mLauncher.processShortcutFromDrop(pendingInfo.componentName,
3707                                 container, screenId, mTargetCell, null);
3708                         break;
3709                     default:
3710                         throw new IllegalStateException(&quot;Unknown item type: &quot; +
3711                                 pendingInfo.itemType);
3712                     }
3713                 }
3714             };
3715             View finalView = pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET
3716                     ? ((PendingAddWidgetInfo) pendingInfo).boundWidget : null;
3717 
3718             if (finalView instanceof AppWidgetHostView &amp;&amp; updateWidgetSize) {
3719                 AppWidgetHostView awhv = (AppWidgetHostView) finalView;
3720                 AppWidgetResizeFrame.updateWidgetSizeRanges(awhv, mLauncher, item.spanX,
3721                         item.spanY);
3722             }
3723 
3724             int animationStyle = ANIMATE_INTO_POSITION_AND_DISAPPEAR;
3725             if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;
3726                     ((PendingAddWidgetInfo) pendingInfo).info.configure != null) {
3727                 animationStyle = ANIMATE_INTO_POSITION_AND_REMAIN;
3728             }
3729             animateWidgetDrop(info, cellLayout, d.dragView, onAnimationCompleteRunnable,
3730                     animationStyle, finalView, true);
3731         } else {
3732             // This is for other drag/drop cases, like dragging from All Apps
3733             View view = null;
3734 
3735             switch (info.itemType) {
3736             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
3737             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3738                 if (info.container == NO_ID &amp;&amp; info instanceof AppInfo) {
3739                     // Came from all apps -- make a copy
3740                     info = new ShortcutInfo((AppInfo) info);
3741                 }
3742                 view = mLauncher.createShortcut(R.layout.application, cellLayout,
3743                         (ShortcutInfo) info);
3744                 break;
3745             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
3746                 view = FolderIcon.fromXml(R.layout.folder_icon, mLauncher, cellLayout,
3747                         (FolderInfo) info, mIconCache);
3748                 break;
3749             default:
3750                 throw new IllegalStateException(&quot;Unknown item type: &quot; + info.itemType);
3751             }
3752 
3753             // First we find the cell nearest to point at which the item is
3754             // dropped, without any consideration to whether there is an item there.
3755             if (touchXY != null) {
3756                 mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3757                         cellLayout, mTargetCell);
3758                 float distance = cellLayout.getDistanceFromCell(mDragViewVisualCenter[0],
3759                         mDragViewVisualCenter[1], mTargetCell);
3760                 d.postAnimationRunnable = exitSpringLoadedRunnable;
3761                 if (createUserFolderIfNecessary(view, container, cellLayout, mTargetCell, distance,
3762                         true, d.dragView, d.postAnimationRunnable)) {
3763                     return;
3764                 }
3765                 if (addToExistingFolderIfNecessary(view, cellLayout, mTargetCell, distance, d,
3766                         true)) {
3767                     return;
3768                 }
3769             }
3770 
3771             if (touchXY != null) {
3772                 // when dragging and dropping, just find the closest free spot
3773                 mTargetCell = cellLayout.createArea((int) mDragViewVisualCenter[0],
3774                         (int) mDragViewVisualCenter[1], 1, 1, 1, 1,
3775                         null, mTargetCell, null, CellLayout.MODE_ON_DROP_EXTERNAL);
3776             } else {
3777                 cellLayout.findCellForSpan(mTargetCell, 1, 1);
3778             }
3779             addInScreen(view, container, screenId, mTargetCell[0], mTargetCell[1], info.spanX,
3780                     info.spanY, insertAtFirst);
3781             cellLayout.onDropChild(view);
3782             CellLayout.LayoutParams lp = (CellLayout.LayoutParams) view.getLayoutParams();
3783             cellLayout.getShortcutsAndWidgets().measureChild(view);
3784 
3785             LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screenId,
3786                     lp.cellX, lp.cellY);
3787 
3788             if (d.dragView != null) {
3789                 // We wrap the animation call in the temporary set and reset of the current
3790                 // cellLayout to its final transform -- this means we animate the drag view to
3791                 // the correct final location.
3792                 setFinalTransitionTransform(cellLayout);
3793                 mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, view,
3794                         exitSpringLoadedRunnable, this);
3795                 resetTransitionTransform(cellLayout);
3796             }
3797         }
3798     }
3799 
3800     public Bitmap createWidgetBitmap(ItemInfo widgetInfo, View layout) {
3801         int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(widgetInfo.spanX,
3802                 widgetInfo.spanY, widgetInfo, false);
3803         int visibility = layout.getVisibility();
3804         layout.setVisibility(VISIBLE);
3805 
3806         int width = MeasureSpec.makeMeasureSpec(unScaledSize[0], MeasureSpec.EXACTLY);
3807         int height = MeasureSpec.makeMeasureSpec(unScaledSize[1], MeasureSpec.EXACTLY);
3808         Bitmap b = Bitmap.createBitmap(unScaledSize[0], unScaledSize[1],
3809                 Bitmap.Config.ARGB_8888);
3810         Canvas c = new Canvas(b);
3811 
3812         layout.measure(width, height);
3813         layout.layout(0, 0, unScaledSize[0], unScaledSize[1]);
3814         layout.draw(c);
3815         c.setBitmap(null);
3816         layout.setVisibility(visibility);
3817         return b;
3818     }
3819 
3820     private void getFinalPositionForDropAnimation(int[] loc, float[] scaleXY,
3821             DragView dragView, CellLayout layout, ItemInfo info, int[] targetCell,
3822             boolean external, boolean scale) {
3823         // Now we animate the dragView, (ie. the widget or shortcut preview) into its final
3824         // location and size on the home screen.
3825         int spanX = info.spanX;
3826         int spanY = info.spanY;
3827 
3828         Rect r = estimateItemPosition(layout, info, targetCell[0], targetCell[1], spanX, spanY);
3829         loc[0] = r.left;
3830         loc[1] = r.top;
3831 
3832         setFinalTransitionTransform(layout);
3833         float cellLayoutScale =
3834                 mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(layout, loc, true);
3835         resetTransitionTransform(layout);
3836 
3837         float dragViewScaleX;
3838         float dragViewScaleY;
3839         if (scale) {
3840             dragViewScaleX = (1.0f * r.width()) / dragView.getMeasuredWidth();
3841             dragViewScaleY = (1.0f * r.height()) / dragView.getMeasuredHeight();
3842         } else {
3843             dragViewScaleX = 1f;
3844             dragViewScaleY = 1f;
3845         }
3846 
3847         // The animation will scale the dragView about its center, so we need to center about
3848         // the final location.
3849         loc[0] -= (dragView.getMeasuredWidth() - cellLayoutScale * r.width()) / 2;
3850         loc[1] -= (dragView.getMeasuredHeight() - cellLayoutScale * r.height()) / 2;
3851 
3852         scaleXY[0] = dragViewScaleX * cellLayoutScale;
3853         scaleXY[1] = dragViewScaleY * cellLayoutScale;
3854     }
3855 
3856     public void animateWidgetDrop(ItemInfo info, CellLayout cellLayout, DragView dragView,
3857             final Runnable onCompleteRunnable, int animationType, final View finalView,
3858             boolean external) {
3859         Rect from = new Rect();
3860         mLauncher.getDragLayer().getViewRectRelativeToSelf(dragView, from);
3861 
3862         int[] finalPos = new int[2];
3863         float scaleXY[] = new float[2];
3864         boolean scalePreview = !(info instanceof PendingAddShortcutInfo);
3865         getFinalPositionForDropAnimation(finalPos, scaleXY, dragView, cellLayout, info, mTargetCell,
3866                 external, scalePreview);
3867 
3868         Resources res = mLauncher.getResources();
3869         final int duration = res.getInteger(R.integer.config_dropAnimMaxDuration) - 200;
3870 
3871         // In the case where we&#x27;ve prebound the widget, we remove it from the DragLayer
3872         if (finalView instanceof AppWidgetHostView &amp;&amp; external) {
3873             Log.d(TAG, &quot;6557954 Animate widget drop, final view is appWidgetHostView&quot;);
3874             mLauncher.getDragLayer().removeView(finalView);
3875         }
3876         if ((animationType == ANIMATE_INTO_POSITION_AND_RESIZE || external) &amp;&amp; finalView != null) {
3877             Bitmap crossFadeBitmap = createWidgetBitmap(info, finalView);
3878             dragView.setCrossFadeBitmap(crossFadeBitmap);
3879             dragView.crossFade((int) (duration * 0.8f));
3880         } else if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp; external) {
3881             scaleXY[0] = scaleXY[1] = Math.min(scaleXY[0],  scaleXY[1]);
3882         }
3883 
3884         DragLayer dragLayer = mLauncher.getDragLayer();
3885         if (animationType == CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION) {
3886             mLauncher.getDragLayer().animateViewIntoPosition(dragView, finalPos, 0f, 0.1f, 0.1f,
3887                     DragLayer.ANIMATION_END_DISAPPEAR, onCompleteRunnable, duration);
3888         } else {
3889             int endStyle;
3890             if (animationType == ANIMATE_INTO_POSITION_AND_REMAIN) {
3891                 endStyle = DragLayer.ANIMATION_END_REMAIN_VISIBLE;
3892             } else {
3893                 endStyle = DragLayer.ANIMATION_END_DISAPPEAR;;
3894             }
3895 
3896             Runnable onComplete = new Runnable() {
3897                 @Override
3898                 public void run() {
3899                     if (finalView != null) {
3900                         finalView.setVisibility(VISIBLE);
3901                     }
3902                     if (onCompleteRunnable != null) {
3903                         onCompleteRunnable.run();
3904                     }
3905                 }
3906             };
3907             dragLayer.animateViewIntoPosition(dragView, from.left, from.top, finalPos[0],
3908                     finalPos[1], 1, 1, 1, scaleXY[0], scaleXY[1], onComplete, endStyle,
3909                     duration, this);
3910         }
3911     }
3912 
3913     public void setFinalTransitionTransform(CellLayout layout) {
3914         if (isSwitchingState()) {
3915             mCurrentScale = getScaleX();
3916             setScaleX(mNewScale);
3917             setScaleY(mNewScale);
3918         }
3919     }
3920     public void resetTransitionTransform(CellLayout layout) {
3921         if (isSwitchingState()) {
3922             setScaleX(mCurrentScale);
3923             setScaleY(mCurrentScale);
3924         }
3925     }
3926 
3927     /**
3928      * Return the current {@link CellLayout}, correctly picking the destination
3929      * screen while a scroll is in progress.
3930      */
3931     public CellLayout getCurrentDropLayout() {
3932         return (CellLayout) getChildAt(getNextPage());
3933     }
3934 
3935     /**
3936      * Return the current CellInfo describing our current drag; this method exists
3937      * so that Launcher can sync this object with the correct info when the activity is created/
3938      * destroyed
3939      *
3940      */
3941     public CellLayout.CellInfo getDragInfo() {
3942         return mDragInfo;
3943     }
3944 
3945     public int getRestorePage() {
3946         return getNextPage() - numCustomPages();
3947     }
3948 
3949     /**
3950      * Calculate the nearest cell where the given object would be dropped.
3951      *
3952      * pixelX and pixelY should be in the coordinate system of layout
3953      */
3954     private int[] findNearestArea(int pixelX, int pixelY,
3955             int spanX, int spanY, CellLayout layout, int[] recycle) {
3956         return layout.findNearestArea(
3957                 pixelX, pixelY, spanX, spanY, recycle);
3958     }
3959 
3960     void setup(DragController dragController) {
3961         mSpringLoadedDragController = new SpringLoadedDragController(mLauncher);
3962         mDragController = dragController;
3963 
3964         // hardware layers on children are enabled on startup, but should be disabled until
3965         // needed
3966         updateChildrenLayersEnabled(false);
3967         setWallpaperDimension();
3968     }
3969 
3970     /**
3971      * Called at the end of a drag which originated on the workspace.
3972      */
3973     public void onDropCompleted(final View target, final DragObject d,
3974             final boolean isFlingToDelete, final boolean success) {
3975         if (mDeferDropAfterUninstall) {
3976             mDeferredAction = new Runnable() {
3977                 public void run() {
3978                     onDropCompleted(target, d, isFlingToDelete, success);
3979                     mDeferredAction = null;
3980                 }
3981             };
3982             return;
3983         }
3984 
3985         boolean beingCalledAfterUninstall = mDeferredAction != null;
3986 
3987         if (success &amp;&amp; !(beingCalledAfterUninstall &amp;&amp; !mUninstallSuccessful)) {
3988             if (target != this &amp;&amp; mDragInfo != null) {
3989                 CellLayout parentCell = getParentCellLayoutForView(mDragInfo.cell);
3990                 if (parentCell != null) {
3991                     parentCell.removeView(mDragInfo.cell);
3992                 }
3993                 if (mDragInfo.cell instanceof DropTarget) {
3994                     mDragController.removeDropTarget((DropTarget) mDragInfo.cell);
3995                 }
3996                 // If we move the item to anything not on the Workspace, check if any empty
3997                 // screens need to be removed. If we dropped back on the workspace, this will
3998                 // be done post drop animation.
3999                 removeExtraEmptyScreen(true, null, 0, true);
4000             }
4001         } else if (mDragInfo != null) {
4002             CellLayout cellLayout;
4003             if (mLauncher.isHotseatLayout(target)) {
4004                 cellLayout = mLauncher.getHotseat().getLayout();
4005             } else {
4006                 cellLayout = getScreenWithId(mDragInfo.screenId);
4007             }
4008             cellLayout.onDropChild(mDragInfo.cell);
4009         }
4010         if ((d.cancelled || (beingCalledAfterUninstall &amp;&amp; !mUninstallSuccessful))
4011                 &amp;&amp; mDragInfo.cell != null) {
4012             mDragInfo.cell.setVisibility(VISIBLE);
4013         }
4014         mDragOutline = null;
4015         mDragInfo = null;
4016     }
4017 
4018     public void deferCompleteDropAfterUninstallActivity() {
4019         mDeferDropAfterUninstall = true;
4020     }
4021 
4022     /// maybe move this into a smaller part
4023     public void onUninstallActivityReturned(boolean success) {
4024         mDeferDropAfterUninstall = false;
4025         mUninstallSuccessful = success;
4026         if (mDeferredAction != null) {
4027             mDeferredAction.run();
4028         }
4029     }
4030 
4031     void updateItemLocationsInDatabase(CellLayout cl) {
4032         int count = cl.getShortcutsAndWidgets().getChildCount();
4033 
4034         long screenId = getIdForScreen(cl);
4035         int container = Favorites.CONTAINER_DESKTOP;
4036 
4037         if (mLauncher.isHotseatLayout(cl)) {
4038             screenId = -1;
4039             container = Favorites.CONTAINER_HOTSEAT;
4040         }
4041 
4042         for (int i = 0; i &lt; count; i++) {
4043             View v = cl.getShortcutsAndWidgets().getChildAt(i);
4044             ItemInfo info = (ItemInfo) v.getTag();
4045             // Null check required as the AllApps button doesn&#x27;t have an item info
4046             if (info != null &amp;&amp; info.requiresDbUpdate) {
4047                 info.requiresDbUpdate = false;
4048                 LauncherModel.modifyItemInDatabase(mLauncher, info, container, screenId, info.cellX,
4049                         info.cellY, info.spanX, info.spanY);
4050             }
4051         }
4052     }
4053 
<abbr title="4054     ArrayList&lt;ComponentName&gt; getUniqueComponents(boolean stripDuplicates, ArrayList&lt;ComponentName&gt; duplicates) {">4054     ArrayList&lt;ComponentName&gt; getUniqueComponents(boolean stripDuplicates, ArrayList&lt;ComponentName&gt; duplic🔵</abbr>
4055         ArrayList&lt;ComponentName&gt; uniqueIntents = new ArrayList&lt;ComponentName&gt;();
<abbr title="4056         getUniqueIntents((CellLayout) mLauncher.getHotseat().getLayout(), uniqueIntents, duplicates, false);">4056         getUniqueIntents((CellLayout) mLauncher.getHotseat().getLayout(), uniqueIntents, duplicates, fals🔵</abbr>
4057         int count = getChildCount();
4058         for (int i = 0; i &lt; count; i++) {
4059             CellLayout cl = (CellLayout) getChildAt(i);
4060             getUniqueIntents(cl, uniqueIntents, duplicates, false);
4061         }
4062         return uniqueIntents;
4063     }
4064 
4065     void getUniqueIntents(CellLayout cl, ArrayList&lt;ComponentName&gt; uniqueIntents,
4066             ArrayList&lt;ComponentName&gt; duplicates, boolean stripDuplicates) {
4067         int count = cl.getShortcutsAndWidgets().getChildCount();
4068 
4069         ArrayList&lt;View&gt; children = new ArrayList&lt;View&gt;();
4070         for (int i = 0; i &lt; count; i++) {
4071             View v = cl.getShortcutsAndWidgets().getChildAt(i);
4072             children.add(v);
4073         }
4074 
4075         for (int i = 0; i &lt; count; i++) {
4076             View v = children.get(i);
4077             ItemInfo info = (ItemInfo) v.getTag();
4078             // Null check required as the AllApps button doesn&#x27;t have an item info
4079             if (info instanceof ShortcutInfo) {
4080                 ShortcutInfo si = (ShortcutInfo) info;
4081                 ComponentName cn = si.intent.getComponent();
4082 
4083                 Uri dataUri = si.intent.getData();
4084                 // If dataUri is not null / empty or if this component isn&#x27;t one that would
4085                 // have previously showed up in the AllApps list, then this is a widget-type
4086                 // shortcut, so ignore it.
4087                 if (dataUri != null &amp;&amp; !dataUri.equals(Uri.EMPTY)) {
4088                     continue;
4089                 }
4090 
4091                 if (!uniqueIntents.contains(cn)) {
4092                     uniqueIntents.add(cn);
4093                 } else {
4094                     if (stripDuplicates) {
4095                         cl.removeViewInLayout(v);
4096                         LauncherModel.deleteItemFromDatabase(mLauncher, si);
4097                     }
4098                     if (duplicates != null) {
4099                         duplicates.add(cn);
4100                     }
4101                 }
4102             }
4103             if (v instanceof FolderIcon) {
4104                 FolderIcon fi = (FolderIcon) v;
4105                 ArrayList&lt;View&gt; items = fi.getFolder().getItemsInReadingOrder();
4106                 for (int j = 0; j &lt; items.size(); j++) {
4107                     if (items.get(j).getTag() instanceof ShortcutInfo) {
4108                         ShortcutInfo si = (ShortcutInfo) items.get(j).getTag();
4109                         ComponentName cn = si.intent.getComponent();
4110 
4111                         Uri dataUri = si.intent.getData();
4112                         // If dataUri is not null / empty or if this component isn&#x27;t one that would
4113                         // have previously showed up in the AllApps list, then this is a widget-type
4114                         // shortcut, so ignore it.
4115                         if (dataUri != null &amp;&amp; !dataUri.equals(Uri.EMPTY)) {
4116                             continue;
4117                         }
4118 
4119                         if (!uniqueIntents.contains(cn)) {
4120                             uniqueIntents.add(cn);
4121                         }  else {
4122                             if (stripDuplicates) {
4123                                 fi.getFolderInfo().remove(si);
4124                                 LauncherModel.deleteItemFromDatabase(mLauncher, si);
4125                             }
4126                             if (duplicates != null) {
4127                                 duplicates.add(cn);
4128                             }
4129                         }
4130                     }
4131                 }
4132             }
4133         }
4134     }
4135 
4136     void saveWorkspaceToDb() {
4137         saveWorkspaceScreenToDb((CellLayout) mLauncher.getHotseat().getLayout());
4138         int count = getChildCount();
4139         for (int i = 0; i &lt; count; i++) {
4140             CellLayout cl = (CellLayout) getChildAt(i);
4141             saveWorkspaceScreenToDb(cl);
4142         }
4143     }
4144 
4145     void saveWorkspaceScreenToDb(CellLayout cl) {
4146         int count = cl.getShortcutsAndWidgets().getChildCount();
4147 
4148         long screenId = getIdForScreen(cl);
4149         int container = Favorites.CONTAINER_DESKTOP;
4150 
4151         Hotseat hotseat = mLauncher.getHotseat();
4152         if (mLauncher.isHotseatLayout(cl)) {
4153             screenId = -1;
4154             container = Favorites.CONTAINER_HOTSEAT;
4155         }
4156 
4157         for (int i = 0; i &lt; count; i++) {
4158             View v = cl.getShortcutsAndWidgets().getChildAt(i);
4159             ItemInfo info = (ItemInfo) v.getTag();
4160             // Null check required as the AllApps button doesn&#x27;t have an item info
4161             if (info != null) {
4162                 int cellX = info.cellX;
4163                 int cellY = info.cellY;
4164                 if (container == Favorites.CONTAINER_HOTSEAT) {
4165                     cellX = hotseat.getCellXFromOrder((int) info.screenId);
4166                     cellY = hotseat.getCellYFromOrder((int) info.screenId);
4167                 }
4168                 LauncherModel.addItemToDatabase(mLauncher, info, container, screenId, cellX,
4169                         cellY, false);
4170             }
4171             if (v instanceof FolderIcon) {
4172                 FolderIcon fi = (FolderIcon) v;
4173                 fi.getFolder().addItemLocationsInDatabase();
4174             }
4175         }
4176     }
4177 
4178     @Override
4179     public float getIntrinsicIconScaleFactor() {
4180         return 1f;
4181     }
4182 
4183     @Override
4184     public boolean supportsFlingToDelete() {
4185         return true;
4186     }
4187 
4188     @Override
4189     public void onFlingToDelete(DragObject d, int x, int y, PointF vec) {
4190         // Do nothing
4191     }
4192 
4193     @Override
4194     public void onFlingToDeleteCompleted() {
4195         // Do nothing
4196     }
4197 
4198     public boolean isDropEnabled() {
4199         return true;
4200     }
4201 
4202     @Override
4203     protected void onRestoreInstanceState(Parcelable state) {
4204         super.onRestoreInstanceState(state);
4205         Launcher.setScreen(mCurrentPage);
4206     }
4207 
4208     @Override
4209     protected void dispatchRestoreInstanceState(SparseArray&lt;Parcelable&gt; container) {
4210         // We don&#x27;t dispatch restoreInstanceState to our children using this code path.
4211         // Some pages will be restored immediately as their items are bound immediately, and
4212         // others we will need to wait until after their items are bound.
4213         mSavedStates = container;
4214     }
4215 
4216     public void restoreInstanceStateForChild(int child) {
4217         if (mSavedStates != null) {
4218             mRestoredPages.add(child);
4219             CellLayout cl = (CellLayout) getChildAt(child);
4220             cl.restoreInstanceState(mSavedStates);
4221         }
4222     }
4223 
4224     public void restoreInstanceStateForRemainingPages() {
4225         int count = getChildCount();
4226         for (int i = 0; i &lt; count; i++) {
4227             if (!mRestoredPages.contains(i)) {
4228                 restoreInstanceStateForChild(i);
4229             }
4230         }
4231         mRestoredPages.clear();
4232         mSavedStates = null;
4233     }
4234 
4235     @Override
4236     public void scrollLeft() {
4237         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
4238             super.scrollLeft();
4239         }
4240         Folder openFolder = getOpenFolder();
4241         if (openFolder != null) {
4242             openFolder.completeDragExit();
4243         }
4244     }
4245 
4246     @Override
4247     public void scrollRight() {
4248         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
4249             super.scrollRight();
4250         }
4251         Folder openFolder = getOpenFolder();
4252         if (openFolder != null) {
4253             openFolder.completeDragExit();
4254         }
4255     }
4256 
4257     @Override
4258     public boolean onEnterScrollArea(int x, int y, int direction) {
4259         // Ignore the scroll area if we are dragging over the hot seat
4260         boolean isPortrait = !LauncherAppState.isScreenLandscape(getContext());
4261         if (mLauncher.getHotseat() != null &amp;&amp; isPortrait) {
4262             Rect r = new Rect();
4263             mLauncher.getHotseat().getHitRect(r);
4264             if (r.contains(x, y)) {
4265                 return false;
4266             }
4267         }
4268 
4269         boolean result = false;
4270         if (!isSmall() &amp;&amp; !mIsSwitchingState &amp;&amp; getOpenFolder() == null) {
4271             mInScrollArea = true;
4272 
4273             final int page = getNextPage() +
4274                        (direction == DragController.SCROLL_LEFT ? -1 : 1);
4275             // We always want to exit the current layout to ensure parity of enter / exit
4276             setCurrentDropLayout(null);
4277 
4278             if (0 &lt;= page &amp;&amp; page &lt; getChildCount()) {
4279                 // Ensure that we are not dragging over to the custom content screen
4280                 if (getScreenIdForPageIndex(page) == CUSTOM_CONTENT_SCREEN_ID) {
4281                     return false;
4282                 }
4283 
4284                 CellLayout layout = (CellLayout) getChildAt(page);
4285                 setCurrentDragOverlappingLayout(layout);
4286 
4287                 // Workspace is responsible for drawing the edge glow on adjacent pages,
4288                 // so we need to redraw the workspace when this may have changed.
4289                 invalidate();
4290                 result = true;
4291             }
4292         }
4293         return result;
4294     }
4295 
4296     @Override
4297     public boolean onExitScrollArea() {
4298         boolean result = false;
4299         if (mInScrollArea) {
4300             invalidate();
4301             CellLayout layout = getCurrentDropLayout();
4302             setCurrentDropLayout(layout);
4303             setCurrentDragOverlappingLayout(layout);
4304 
4305             result = true;
4306             mInScrollArea = false;
4307         }
4308         return result;
4309     }
4310 
4311     private void onResetScrollArea() {
4312         setCurrentDragOverlappingLayout(null);
4313         mInScrollArea = false;
4314     }
4315 
4316     /**
4317      * Returns a specific CellLayout
4318      */
4319     CellLayout getParentCellLayoutForView(View v) {
4320         ArrayList&lt;CellLayout&gt; layouts = getWorkspaceAndHotseatCellLayouts();
4321         for (CellLayout layout : layouts) {
4322             if (layout.getShortcutsAndWidgets().indexOfChild(v) &gt; -1) {
4323                 return layout;
4324             }
4325         }
4326         return null;
4327     }
4328 
4329     /**
4330      * Returns a list of all the CellLayouts in the workspace.
4331      */
4332     ArrayList&lt;CellLayout&gt; getWorkspaceAndHotseatCellLayouts() {
4333         ArrayList&lt;CellLayout&gt; layouts = new ArrayList&lt;CellLayout&gt;();
4334         int screenCount = getChildCount();
4335         for (int screen = 0; screen &lt; screenCount; screen++) {
4336             layouts.add(((CellLayout) getChildAt(screen)));
4337         }
4338         if (mLauncher.getHotseat() != null) {
4339             layouts.add(mLauncher.getHotseat().getLayout());
4340         }
4341         return layouts;
4342     }
4343 
4344     /**
4345      * We should only use this to search for specific children.  Do not use this method to modify
4346      * ShortcutsAndWidgetsContainer directly. Includes ShortcutAndWidgetContainers from
4347      * the hotseat and workspace pages
4348      */
4349     ArrayList&lt;ShortcutAndWidgetContainer&gt; getAllShortcutAndWidgetContainers() {
4350         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4351                 new ArrayList&lt;ShortcutAndWidgetContainer&gt;();
4352         int screenCount = getChildCount();
4353         for (int screen = 0; screen &lt; screenCount; screen++) {
4354             childrenLayouts.add(((CellLayout) getChildAt(screen)).getShortcutsAndWidgets());
4355         }
4356         if (mLauncher.getHotseat() != null) {
4357             childrenLayouts.add(mLauncher.getHotseat().getLayout().getShortcutsAndWidgets());
4358         }
4359         return childrenLayouts;
4360     }
4361 
4362     public Folder getFolderForTag(Object tag) {
4363         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4364                 getAllShortcutAndWidgetContainers();
4365         for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4366             int count = layout.getChildCount();
4367             for (int i = 0; i &lt; count; i++) {
4368                 View child = layout.getChildAt(i);
4369                 if (child instanceof Folder) {
4370                     Folder f = (Folder) child;
4371                     if (f.getInfo() == tag &amp;&amp; f.getInfo().opened) {
4372                         return f;
4373                     }
4374                 }
4375             }
4376         }
4377         return null;
4378     }
4379 
4380     public View getViewForTag(Object tag) {
4381         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4382                 getAllShortcutAndWidgetContainers();
4383         for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4384             int count = layout.getChildCount();
4385             for (int i = 0; i &lt; count; i++) {
4386                 View child = layout.getChildAt(i);
4387                 if (child.getTag() == tag) {
4388                     return child;
4389                 }
4390             }
4391         }
4392         return null;
4393     }
4394 
4395     void clearDropTargets() {
4396         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4397                 getAllShortcutAndWidgetContainers();
4398         for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4399             int childCount = layout.getChildCount();
4400             for (int j = 0; j &lt; childCount; j++) {
4401                 View v = layout.getChildAt(j);
4402                 if (v instanceof DropTarget) {
4403                     mDragController.removeDropTarget((DropTarget) v);
4404                 }
4405             }
4406         }
4407     }
4408 
4409     // Removes ALL items that match a given package name, this is usually called when a package
4410     // has been removed and we want to remove all components (widgets, shortcuts, apps) that
4411     // belong to that package.
4412     void removeItemsByPackageName(final ArrayList&lt;String&gt; packages) {
4413         final HashSet&lt;String&gt; packageNames = new HashSet&lt;String&gt;();
4414         packageNames.addAll(packages);
4415 
4416         // Filter out all the ItemInfos that this is going to affect
4417         final HashSet&lt;ItemInfo&gt; infos = new HashSet&lt;ItemInfo&gt;();
4418         final HashSet&lt;ComponentName&gt; cns = new HashSet&lt;ComponentName&gt;();
4419         ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
4420         for (CellLayout layoutParent : cellLayouts) {
4421             ViewGroup layout = layoutParent.getShortcutsAndWidgets();
4422             int childCount = layout.getChildCount();
4423             for (int i = 0; i &lt; childCount; ++i) {
4424                 View view = layout.getChildAt(i);
4425                 infos.add((ItemInfo) view.getTag());
4426             }
4427         }
4428         LauncherModel.ItemInfoFilter filter = new LauncherModel.ItemInfoFilter() {
4429             @Override
4430             public boolean filterItem(ItemInfo parent, ItemInfo info,
4431                                       ComponentName cn) {
4432                 if (packageNames.contains(cn.getPackageName())) {
4433                     cns.add(cn);
4434                     return true;
4435                 }
4436                 return false;
4437             }
4438         };
4439         LauncherModel.filterItemInfos(infos, filter);
4440 
4441         // Remove the affected components
4442         removeItemsByComponentName(cns);
4443     }
4444 
4445     // Removes items that match the application info specified, when applications are removed
4446     // as a part of an update, this is called to ensure that other widgets and application
4447     // shortcuts are not removed.
4448     void removeItemsByApplicationInfo(final ArrayList&lt;AppInfo&gt; appInfos) {
4449         // Just create a hash table of all the specific components that this will affect
4450         HashSet&lt;ComponentName&gt; cns = new HashSet&lt;ComponentName&gt;();
4451         for (AppInfo info : appInfos) {
4452             cns.add(info.componentName);
4453         }
4454 
4455         // Remove all the things
4456         removeItemsByComponentName(cns);
4457     }
4458 
4459     void removeItemsByComponentName(final HashSet&lt;ComponentName&gt; componentNames) {
4460         ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
4461         for (final CellLayout layoutParent: cellLayouts) {
4462             final ViewGroup layout = layoutParent.getShortcutsAndWidgets();
4463 
4464             final HashMap&lt;ItemInfo, View&gt; children = new HashMap&lt;ItemInfo, View&gt;();
4465             for (int j = 0; j &lt; layout.getChildCount(); j++) {
4466                 final View view = layout.getChildAt(j);
4467                 children.put((ItemInfo) view.getTag(), view);
4468             }
4469 
4470             final ArrayList&lt;View&gt; childrenToRemove = new ArrayList&lt;View&gt;();
4471             final HashMap&lt;FolderInfo, ArrayList&lt;ShortcutInfo&gt;&gt; folderAppsToRemove =
4472                     new HashMap&lt;FolderInfo, ArrayList&lt;ShortcutInfo&gt;&gt;();
4473             LauncherModel.ItemInfoFilter filter = new LauncherModel.ItemInfoFilter() {
4474                 @Override
4475                 public boolean filterItem(ItemInfo parent, ItemInfo info,
4476                                           ComponentName cn) {
4477                     if (parent instanceof FolderInfo) {
4478                         if (componentNames.contains(cn)) {
4479                             FolderInfo folder = (FolderInfo) parent;
4480                             ArrayList&lt;ShortcutInfo&gt; appsToRemove;
4481                             if (folderAppsToRemove.containsKey(folder)) {
4482                                 appsToRemove = folderAppsToRemove.get(folder);
4483                             } else {
4484                                 appsToRemove = new ArrayList&lt;ShortcutInfo&gt;();
4485                                 folderAppsToRemove.put(folder, appsToRemove);
4486                             }
4487                             appsToRemove.add((ShortcutInfo) info);
4488                             return true;
4489                         }
4490                     } else {
4491                         if (componentNames.contains(cn)) {
4492                             childrenToRemove.add(children.get(info));
4493                             return true;
4494                         }
4495                     }
4496                     return false;
4497                 }
4498             };
4499             LauncherModel.filterItemInfos(children.keySet(), filter);
4500 
4501             // Remove all the apps from their folders
4502             for (FolderInfo folder : folderAppsToRemove.keySet()) {
4503                 ArrayList&lt;ShortcutInfo&gt; appsToRemove = folderAppsToRemove.get(folder);
4504                 for (ShortcutInfo info : appsToRemove) {
4505                     folder.remove(info);
4506                 }
4507             }
4508 
4509             // Remove all the other children
4510             for (View child : childrenToRemove) {
4511                 // Note: We can not remove the view directly from CellLayoutChildren as this
4512                 // does not re-mark the spaces as unoccupied.
4513                 layoutParent.removeViewInLayout(child);
4514                 if (child instanceof DropTarget) {
4515                     mDragController.removeDropTarget((DropTarget) child);
4516                 }
4517             }
4518 
4519             if (childrenToRemove.size() &gt; 0) {
4520                 layout.requestLayout();
4521                 layout.invalidate();
4522             }
4523         }
4524 
4525         // Strip all the empty screens
4526         stripEmptyScreens();
4527     }
4528 
4529     private void updateShortcut(HashMap&lt;ComponentName, AppInfo&gt; appsMap, ItemInfo info,
4530                                 View child) {
4531         ComponentName cn = info.getIntent().getComponent();
4532         if (cn != null) {
4533             AppInfo appInfo = appsMap.get(info.getIntent().getComponent());
4534             if ((appInfo != null) &amp;&amp; LauncherModel.isShortcutInfoUpdateable(info)) {
4535                 ShortcutInfo shortcutInfo = (ShortcutInfo) info;
4536                 BubbleTextView shortcut = (BubbleTextView) child;
4537                 shortcutInfo.updateIcon(mIconCache);
4538                 shortcutInfo.title = appInfo.title.toString();
4539                 shortcut.applyFromShortcutInfo(shortcutInfo, mIconCache);
4540             }
4541         }
4542     }
4543 
4544     void updateShortcuts(ArrayList&lt;AppInfo&gt; apps) {
4545         // Create a map of the apps to test against
4546         final HashMap&lt;ComponentName, AppInfo&gt; appsMap = new HashMap&lt;ComponentName, AppInfo&gt;();
4547         for (AppInfo ai : apps) {
4548             appsMap.put(ai.componentName, ai);
4549         }
4550 
4551         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts = getAllShortcutAndWidgetContainers();
4552         for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4553             // Update all the children shortcuts
4554             final HashMap&lt;ItemInfo, View&gt; children = new HashMap&lt;ItemInfo, View&gt;();
4555             for (int j = 0; j &lt; layout.getChildCount(); j++) {
4556                 View v = layout.getChildAt(j);
4557                 ItemInfo info = (ItemInfo) v.getTag();
4558                 if (info instanceof FolderInfo &amp;&amp; v instanceof FolderIcon) {
4559                     FolderIcon folder = (FolderIcon) v;
4560                     ArrayList&lt;View&gt; folderChildren = folder.getFolder().getItemsInReadingOrder();
4561                     for (View fv : folderChildren) {
4562                         info = (ItemInfo) fv.getTag();
4563                         updateShortcut(appsMap, info, fv);
4564                     }
4565                     folder.invalidate();
4566                 } else if (info instanceof ShortcutInfo) {
4567                     updateShortcut(appsMap, info, v);
4568                 }
4569             }
4570         }
4571     }
4572 
4573     private void moveToScreen(int page, boolean animate) {
4574         if (!isSmall()) {
4575             if (animate) {
4576                 snapToPage(page);
4577             } else {
4578                 setCurrentPage(page);
4579             }
4580         }
4581         View child = getChildAt(page);
4582         if (child != null) {
4583             child.requestFocus();
4584         }
4585     }
4586 
4587     void moveToDefaultScreen(boolean animate) {
4588         moveToScreen(mDefaultPage, animate);
4589     }
4590 
4591     void moveToCustomContentScreen(boolean animate) {
4592         if (hasCustomContent()) {
4593             int ccIndex = getPageIndexForScreenId(CUSTOM_CONTENT_SCREEN_ID);
4594             if (animate) {
4595                 snapToPage(ccIndex);
4596             } else {
4597                 setCurrentPage(ccIndex);
4598             }
4599             View child = getChildAt(ccIndex);
4600             if (child != null) {
4601                 child.requestFocus();
4602             }
4603          }
4604         exitWidgetResizeMode();
4605     }
4606 
4607     @Override
4608     protected PageIndicator.PageMarkerResources getPageIndicatorMarker(int pageIndex) {
4609         long screenId = getScreenIdForPageIndex(pageIndex);
4610         if (screenId == EXTRA_EMPTY_SCREEN_ID) {
4611             int count = mScreenOrder.size() - numCustomPages();
4612             if (count &gt; 1) {
4613                 return new PageIndicator.PageMarkerResources(R.drawable.ic_pageindicator_current,
4614                         R.drawable.ic_pageindicator_add);
4615             }
4616         }
4617 
4618         return super.getPageIndicatorMarker(pageIndex);
4619     }
4620 
4621     @Override
4622     public void syncPages() {
4623     }
4624 
4625     @Override
4626     public void syncPageItems(int page, boolean immediate) {
4627     }
4628 
4629     protected String getPageIndicatorDescription() {
4630         String settings = getResources().getString(R.string.settings_button_text);
4631         return getCurrentPageDescription() + &quot;, &quot; + settings;
4632     }
4633 
4634     protected String getCurrentPageDescription() {
4635         int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
4636         int delta = numCustomPages();
4637         if (hasCustomContent() &amp;&amp; getNextPage() == 0) {
4638             return mCustomContentDescription;
4639         }
4640         return String.format(getContext().getString(R.string.workspace_scroll_format),
4641                 page + 1 - delta, getChildCount() - delta);
4642     }
4643 
4644     public void getLocationInDragLayer(int[] loc) {
4645         mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
4646     }
4647 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 
  17 package com.android.launcher3;
  18 
  19 import android.animation.Animator;
  20 import android.animation.Animator.AnimatorListener;
  21 import android.animation.AnimatorListenerAdapter;
  22 import android.animation.AnimatorSet;
  23 import android.animation.LayoutTransition;
  24 import android.animation.ObjectAnimator;
  25 import android.animation.PropertyValuesHolder;
  26 import android.animation.TimeInterpolator;
  27 import android.animation.ValueAnimator;
  28 import android.animation.ValueAnimator.AnimatorUpdateListener;
  29 import android.app.WallpaperManager;
  30 import android.appwidget.AppWidgetHostView;
  31 import android.appwidget.AppWidgetProviderInfo;
  32 import android.content.ComponentName;
  33 import android.content.Context;
  34 import android.content.Intent;
  35 import android.content.SharedPreferences;
  36 import android.content.res.Resources;
  37 import android.content.res.TypedArray;
  38 import android.graphics.Bitmap;
  39 import android.graphics.Canvas;
  40 import android.graphics.Matrix;
  41 import android.graphics.Point;
  42 import android.graphics.PointF;
  43 import android.graphics.Rect;
  44 import android.graphics.Region.Op;
  45 import android.graphics.drawable.Drawable;
  46 import android.net.Uri;
  47 import android.os.IBinder;
  48 import android.os.Parcelable;
  49 import android.support.v4.view.ViewCompat;
  50 import android.util.AttributeSet;
  51 import android.util.Log;
  52 import android.util.SparseArray;
  53 import android.view.Choreographer;
  54 import android.view.Display;
  55 import android.view.MotionEvent;
  56 import android.view.View;
  57 import android.view.ViewGroup;
  58 import android.view.View.OnClickListener;
  59 import android.view.accessibility.AccessibilityEvent;
  60 import android.view.accessibility.AccessibilityManager;
  61 import android.view.accessibility.AccessibilityNodeInfo;
  62 import android.view.animation.DecelerateInterpolator;
  63 import android.view.animation.Interpolator;
  64 import android.widget.TextView;
  65 
  66 import com.android.launcher3.FolderIcon.FolderRingAnimator;
  67 import com.android.launcher3.Launcher.CustomContentCallbacks;
  68 import com.android.launcher3.LauncherSettings.Favorites;
  69 
  70 import java.util.ArrayList;
  71 import java.util.HashMap;
  72 import java.util.HashSet;
  73 import java.util.Iterator;
  74 
  75 /**
  76  * The workspace is a wide area with a wallpaper and a finite number of pages.
  77  * Each page contains a number of icons, folders or widgets the user can
  78  * interact with. A workspace is meant to be used with a fixed width only.
  79  */
  80 public class Workspace extends SmoothPagedView
  81         implements DropTarget, DragSource, DragScroller, View.OnTouchListener,
  82         DragController.DragListener, LauncherTransitionable, ViewGroup.OnHierarchyChangeListener,
  83         Insettable {
  84     private static final String TAG = &quot;Launcher.Workspace&quot;;
  85 
  86     // Y rotation to apply to the workspace screens
  87     private static final float WORKSPACE_OVERSCROLL_ROTATION = 24f;
  88 
  89     private static final int CHILDREN_OUTLINE_FADE_OUT_DELAY = 0;
  90     private static final int CHILDREN_OUTLINE_FADE_OUT_DURATION = 375;
  91     private static final int CHILDREN_OUTLINE_FADE_IN_DURATION = 100;
  92 
  93     protected static final int SNAP_OFF_EMPTY_SCREEN_DURATION = 400;
  94     protected static final int FADE_EMPTY_SCREEN_DURATION = 150;
  95 
  96     private static final int BACKGROUND_FADE_OUT_DURATION = 350;
  97     private static final int ADJACENT_SCREEN_DROP_DURATION = 300;
  98     private static final int FLING_THRESHOLD_VELOCITY = 500;
  99 
 100     private static final float ALPHA_CUTOFF_THRESHOLD = 0.01f;
 101 
 102     // These animators are used to fade the children&#x27;s outlines
 103     private ObjectAnimator mChildrenOutlineFadeInAnimation;
 104     private ObjectAnimator mChildrenOutlineFadeOutAnimation;
 105     private float mChildrenOutlineAlpha = 0;
 106 
 107     // These properties refer to the background protection gradient used for AllApps and Customize
 108     private ValueAnimator mBackgroundFadeInAnimation;
 109     private ValueAnimator mBackgroundFadeOutAnimation;
 110     private Drawable mBackground;
 111     boolean mDrawBackground = true;
 112     private float mBackgroundAlpha = 0;
 113 
 114     private static final long CUSTOM_CONTENT_GESTURE_DELAY = 200;
 115     private long mTouchDownTime = -1;
 116     private long mCustomContentShowTime = -1;
 117 
 118     private LayoutTransition mLayoutTransition;
 119     private final WallpaperManager mWallpaperManager;
 120     private IBinder mWindowToken;
 121 
 122     private int mOriginalDefaultPage;
 123     private int mDefaultPage;
 124 
 125     private ShortcutAndWidgetContainer mDragSourceInternal;
 126     private static boolean sAccessibilityEnabled;
 127 
 128     // The screen id used for the empty screen always present to the right.
 129     private final static long EXTRA_EMPTY_SCREEN_ID = -201;
 130     private final static long CUSTOM_CONTENT_SCREEN_ID = -301;
 131 
 132     private HashMap&lt;Long, CellLayout&gt; mWorkspaceScreens = new HashMap&lt;Long, CellLayout&gt;();
 133     private ArrayList&lt;Long&gt; mScreenOrder = new ArrayList&lt;Long&gt;();
 134 
 135     private Runnable mRemoveEmptyScreenRunnable;
 136 
 137     /**
 138      * CellInfo for the cell that is currently being dragged
 139      */
 140     private CellLayout.CellInfo mDragInfo;
 141 
 142     /**
 143      * Target drop area calculated during last acceptDrop call.
 144      */
 145     private int[] mTargetCell = new int[2];
 146     private int mDragOverX = -1;
 147     private int mDragOverY = -1;
 148 
 149     static Rect mLandscapeCellLayoutMetrics = null;
 150     static Rect mPortraitCellLayoutMetrics = null;
 151 
 152     CustomContentCallbacks mCustomContentCallbacks;
 153     boolean mCustomContentShowing;
 154     private float mLastCustomContentScrollProgress = -1f;
 155     private String mCustomContentDescription = &quot;&quot;;
 156 
 157     /**
 158      * The CellLayout that is currently being dragged over
 159      */
 160     private CellLayout mDragTargetLayout = null;
 161     /**
 162      * The CellLayout that we will show as glowing
 163      */
 164     private CellLayout mDragOverlappingLayout = null;
 165 
 166     /**
 167      * The CellLayout which will be dropped to
 168      */
 169     private CellLayout mDropToLayout = null;
 170 
 171     private Launcher mLauncher;
 172     private IconCache mIconCache;
 173     private DragController mDragController;
 174 
 175     // These are temporary variables to prevent having to allocate a new object just to
 176     // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
 177     private int[] mTempCell = new int[2];
 178     private int[] mTempPt = new int[2];
 179     private int[] mTempEstimate = new int[2];
 180     private float[] mDragViewVisualCenter = new float[2];
 181     private float[] mTempCellLayoutCenterCoordinates = new float[2];
 182     private Matrix mTempInverseMatrix = new Matrix();
 183 
 184     private SpringLoadedDragController mSpringLoadedDragController;
 185     private float mSpringLoadedShrinkFactor;
 186     private float mOverviewModeShrinkFactor;
 187 
 188     // State variable that indicates whether the pages are small (ie when you&#x27;re
 189     // in all apps or customize mode)
 190 
 191 
 192 
 193     // State variable that indicates whether the pages are small (ie when you&#x27;re
 194     // in all apps or customize mode)
 195 
 196     enum State { NORMAL, SPRING_LOADED, SMALL, OVERVIEW};;
 197     private State mState = State.NORMAL;
 198     private boolean mIsSwitchingState = false;
 199 
 200     boolean mAnimatingViewIntoPlace = false;
 201     boolean mIsDragOccuring = false;
 202     boolean mChildrenLayersEnabled = true;
 203 
 204     private boolean mStripScreensOnPageStopMoving = false;
 205 
 206     /** Is the user is dragging an item near the edge of a page? */
 207     private boolean mInScrollArea = false;
 208 
 209     private HolographicOutlineHelper mOutlineHelper;
 210     private Bitmap mDragOutline = null;
 211     private final Rect mTempRect = new Rect();
 212     private final int[] mTempXY = new int[2];
 213     private int[] mTempVisiblePagesRange = new int[2];
 214     private boolean mOverscrollTransformsSet;
 215     private float mLastOverscrollPivotX;
 216     public static final int DRAG_BITMAP_PADDING = 2;
 217     private boolean mWorkspaceFadeInAdjacentScreens;
 218 
 219     WallpaperOffsetInterpolator mWallpaperOffset;
 220     private Runnable mDelayedResizeRunnable;
 221     private Runnable mDelayedSnapToPageRunnable;
 222     private Point mDisplaySize = new Point();
 223     private int mCameraDistance;
 224 
 225     // Variables relating to the creation of user folders by hovering shortcuts over shortcuts
 226     private static final int FOLDER_CREATION_TIMEOUT = 0;
 227     private static final int REORDER_TIMEOUT = 250;
 228     private final Alarm mFolderCreationAlarm = new Alarm();
 229     private final Alarm mReorderAlarm = new Alarm();
 230     private FolderRingAnimator mDragFolderRingAnimator = null;
 231     private FolderIcon mDragOverFolderIcon = null;
 232     private boolean mCreateUserFolderOnDrop = false;
 233     private boolean mAddToExistingFolderOnDrop = false;
 234     private DropTarget.DragEnforcer mDragEnforcer;
 235     private float mMaxDistanceForFolderCreation;
 236 
 237     // Variables relating to touch disambiguation (scrolling workspace vs. scrolling a widget)
 238     private float mXDown;
 239     private float mYDown;
 240     final static float START_DAMPING_TOUCH_SLOP_ANGLE = (float) Math.PI / 6;
 241     final static float MAX_SWIPE_ANGLE = (float) Math.PI / 3;
 242     final static float TOUCH_SLOP_DAMPING_FACTOR = 4;
 243 
 244     // Relating to the animation of items being dropped externally
 245     public static final int ANIMATE_INTO_POSITION_AND_DISAPPEAR = 0;
 246     public static final int ANIMATE_INTO_POSITION_AND_REMAIN = 1;
 247     public static final int ANIMATE_INTO_POSITION_AND_RESIZE = 2;
 248     public static final int COMPLETE_TWO_STAGE_WIDGET_DROP_ANIMATION = 3;
 249     public static final int CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION = 4;
 250 
 251     // Related to dragging, folder creation and reordering
 252     private static final int DRAG_MODE_NONE = 0;
 253     private static final int DRAG_MODE_CREATE_FOLDER = 1;
 254     private static final int DRAG_MODE_ADD_TO_FOLDER = 2;
 255     private static final int DRAG_MODE_REORDER = 3;
 256     private int mDragMode = DRAG_MODE_NONE;
 257     private int mLastReorderX = -1;
 258     private int mLastReorderY = -1;
 259 
 260     private SparseArray&lt;Parcelable&gt; mSavedStates;
 261     private final ArrayList&lt;Integer&gt; mRestoredPages = new ArrayList&lt;Integer&gt;();
 262 
 263     // These variables are used for storing the initial and final values during workspace animations
 264     private int mSavedScrollX;
 265     private float mSavedRotationY;
 266     private float mSavedTranslationX;
 267 
 268     private float mCurrentScale;
 269     private float mNewScale;
 270     private float[] mOldBackgroundAlphas;
 271     private float[] mOldAlphas;
 272     private float[] mNewBackgroundAlphas;
 273     private float[] mNewAlphas;
 274     private int mLastChildCount = -1;
 275     private float mTransitionProgress;
 276 
 277     private Runnable mDeferredAction;
 278     private boolean mDeferDropAfterUninstall;
 279     private boolean mUninstallSuccessful;
 280 
 281     private final Runnable mBindPages = new Runnable() {
 282         @Override
 283         public void run() {
 284             mLauncher.getModel().bindRemainingSynchronousPages();
 285         }
 286     };
 287 
 288     /**
 289      * Used to inflate the Workspace from XML.
 290      *
 291      * @param context The application&#x27;s context.
 292      * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 293      */
 294     public Workspace(Context context, AttributeSet attrs) {
 295         this(context, attrs, 0);
 296     }
 297 
 298     /**
 299      * Used to inflate the Workspace from XML.
 300      *
 301      * @param context The application&#x27;s context.
 302      * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 303      * @param defStyle Unused.
 304      */
 305     public Workspace(Context context, AttributeSet attrs, int defStyle) {
 306         super(context, attrs, defStyle);
 307         mContentIsRefreshable = false;
 308 
 309         mOutlineHelper = HolographicOutlineHelper.obtain(context);
 310 
 311         mDragEnforcer = new DropTarget.DragEnforcer(context);
 312         // With workspace, data is available straight from the get-go
 313         setDataIsReady();
 314 
 315         mLauncher = (Launcher) context;
 316         final Resources res = getResources();
 317         mWorkspaceFadeInAdjacentScreens = LauncherAppState.getInstance().getDynamicGrid().
 318                 getDeviceProfile().shouldFadeAdjacentWorkspaceScreens();
 319         mFadeInAdjacentScreens = false;
 320         mWallpaperManager = WallpaperManager.getInstance(context);
 321 
 322         LauncherAppState app = LauncherAppState.getInstance();
 323         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 324         TypedArray a = context.obtainStyledAttributes(attrs,
 325                 R.styleable.Workspace, defStyle, 0);
 326         mSpringLoadedShrinkFactor =
 327             res.getInteger(R.integer.config_workspaceSpringLoadShrinkPercentage) / 100.0f;
 328         mOverviewModeShrinkFactor = grid.getOverviewModeScale();
 329         mCameraDistance = res.getInteger(R.integer.config_cameraDistance);
 330         mOriginalDefaultPage = mDefaultPage = a.getInt(R.styleable.Workspace_defaultScreen, 1);
 331         a.recycle();
 332 
 333         setOnHierarchyChangeListener(this);
 334         setHapticFeedbackEnabled(false);
 335 
 336         initWorkspace();
 337 
 338         // Disable multitouch across the workspace/all apps/customize tray
 339         setMotionEventSplittingEnabled(true);
 340         setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
 341     }
 342 
 343     @Override
 344     public void setInsets(Rect insets) {
 345         mInsets.set(insets);
 346     }
 347 
 348     // estimate the size of a widget with spans hSpan, vSpan. return MAX_VALUE for each
 349     // dimension if unsuccessful
 350     public int[] estimateItemSize(int hSpan, int vSpan,
 351             ItemInfo itemInfo, boolean springLoaded) {
 352         int[] size = new int[2];
 353         if (getChildCount() &gt; 0) {
 354             // Use the first non-custom page to estimate the child position
 355             CellLayout cl = (CellLayout) getChildAt(numCustomPages());
 356             Rect r = estimateItemPosition(cl, itemInfo, 0, 0, hSpan, vSpan);
 357             size[0] = r.width();
 358             size[1] = r.height();
 359             if (springLoaded) {
 360                 size[0] *= mSpringLoadedShrinkFactor;
 361                 size[1] *= mSpringLoadedShrinkFactor;
 362             }
 363             return size;
 364         } else {
 365             size[0] = Integer.MAX_VALUE;
 366             size[1] = Integer.MAX_VALUE;
 367             return size;
 368         }
 369     }
 370 
 371     public Rect estimateItemPosition(CellLayout cl, ItemInfo pendingInfo,
 372             int hCell, int vCell, int hSpan, int vSpan) {
 373         Rect r = new Rect();
 374         cl.cellToRect(hCell, vCell, hSpan, vSpan, r);
 375         return r;
 376     }
 377 
 378     public void onDragStart(final DragSource source, Object info, int dragAction) {
 379         mIsDragOccuring = true;
 380         updateChildrenLayersEnabled(false);
 381         mLauncher.lockScreenOrientation();
 382         mLauncher.onInteractionBegin();
 383         setChildrenBackgroundAlphaMultipliers(1f);
 384         // Prevent any Un/InstallShortcutReceivers from updating the db while we are dragging
 385         InstallShortcutReceiver.enableInstallQueue();
 386         UninstallShortcutReceiver.enableUninstallQueue();
 387         post(new Runnable() {
 388             @Override
 389             public void run() {
 390                 if (mIsDragOccuring) {
 391                     addExtraEmptyScreenOnDrag();
 392                 }
 393             }
 394         });
 395     }
 396 
 397     public void onDragEnd() {
 398         mIsDragOccuring = false;
 399         updateChildrenLayersEnabled(false);
 400         mLauncher.unlockScreenOrientation(false);
 401 
 402         // Re-enable any Un/InstallShortcutReceiver and now process any queued items
 403         InstallShortcutReceiver.disableAndFlushInstallQueue(getContext());
 404         UninstallShortcutReceiver.disableAndFlushUninstallQueue(getContext());
 405 
 406         mDragSourceInternal = null;
 407         mLauncher.onInteractionEnd();
 408     }
 409 
 410     /**
 411      * Initializes various states for this workspace.
 412      */
 413     protected void initWorkspace() {
 414         Context context = getContext();
 415         mCurrentPage = mDefaultPage;
 416         Launcher.setScreen(mCurrentPage);
 417         LauncherAppState app = LauncherAppState.getInstance();
 418         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 419         mIconCache = app.getIconCache();
 420         setWillNotDraw(false);
 421         setClipChildren(false);
 422         setClipToPadding(false);
 423         setChildrenDrawnWithCacheEnabled(true);
 424 
 425         setMinScale(mOverviewModeShrinkFactor);
 426         setupLayoutTransition();
 427 
 428         final Resources res = getResources();
 429         try {
 430             mBackground = res.getDrawable(R.drawable.apps_customize_bg);
 431         } catch (Resources.NotFoundException e) {
 432             // In this case, we will skip drawing background protection
 433         }
 434 
 435         mWallpaperOffset = new WallpaperOffsetInterpolator();
 436         Display display = mLauncher.getWindowManager().getDefaultDisplay();
 437         display.getSize(mDisplaySize);
 438 
 439         mMaxDistanceForFolderCreation = (0.55f * grid.iconSizePx);
 440         mFlingThresholdVelocity = (int) (FLING_THRESHOLD_VELOCITY * mDensity);
 441     }
 442 
 443     private void setupLayoutTransition() {
 444         // We want to show layout transitions when pages are deleted, to close the gap.
 445         mLayoutTransition = new LayoutTransition();
 446         mLayoutTransition.enableTransitionType(LayoutTransition.DISAPPEARING);
 447         mLayoutTransition.enableTransitionType(LayoutTransition.CHANGE_DISAPPEARING);
 448         mLayoutTransition.disableTransitionType(LayoutTransition.APPEARING);
 449         mLayoutTransition.disableTransitionType(LayoutTransition.CHANGE_APPEARING);
 450         setLayoutTransition(mLayoutTransition);
 451     }
 452 
 453     void enableLayoutTransitions() {
 454         setLayoutTransition(mLayoutTransition);
 455     }
 456     void disableLayoutTransitions() {
 457         setLayoutTransition(null);
 458     }
 459 
 460     @Override
 461     protected int getScrollMode() {
 462         return SmoothPagedView.X_LARGE_MODE;
 463     }
 464 
 465     @Override
 466     public void onChildViewAdded(View parent, View child) {
 467         if (!(child instanceof CellLayout)) {
 468             throw new IllegalArgumentException(&quot;A Workspace can only have CellLayout children.&quot;);
 469         }
 470         CellLayout cl = ((CellLayout) child);
 471         cl.setOnInterceptTouchListener(this);
 472         cl.setClickable(true);
 473         cl.setImportantForAccessibility(ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_NO);
 474         super.onChildViewAdded(parent, child);
 475     }
 476 
 477     protected boolean shouldDrawChild(View child) {
 478         final CellLayout cl = (CellLayout) child;
 479         return super.shouldDrawChild(child) &amp;&amp;
 480             (mIsSwitchingState ||
 481              cl.getShortcutsAndWidgets().getAlpha() &gt; 0 ||
 482              cl.getBackgroundAlpha() &gt; 0);
 483     }
 484 
 485     /**
 486      * @return The open folder on the current screen, or null if there is none
 487      */
 488     Folder getOpenFolder() {
 489         DragLayer dragLayer = mLauncher.getDragLayer();
 490         int count = dragLayer.getChildCount();
 491         for (int i = 0; i &lt; count; i++) {
 492             View child = dragLayer.getChildAt(i);
 493             if (child instanceof Folder) {
 494                 Folder folder = (Folder) child;
 495                 if (folder.getInfo().opened)
 496                     return folder;
 497             }
 498         }
 499         return null;
 500     }
 501 
 502     boolean isTouchActive() {
 503         return mTouchState != TOUCH_STATE_REST;
 504     }
 505 
 506     public void removeAllWorkspaceScreens() {
 507         // Disable all layout transitions before removing all pages to ensure that we don&#x27;t get the
 508         // transition animations competing with us changing the scroll when we add pages or the
 509         // custom content screen
 510         disableLayoutTransitions();
 511 
 512         // Since we increment the current page when we call addCustomContentPage via bindScreens
 513         // (and other places), we need to adjust the current page back when we clear the pages
 514         if (hasCustomContent()) {
 515             removeCustomContentPage();
 516         }
 517 
 518         // Remove the pages and clear the screen models
 519         removeAllViews();
 520         mScreenOrder.clear();
 521         mWorkspaceScreens.clear();
 522 
 523         // Re-enable the layout transitions
 524         enableLayoutTransitions();
 525     }
 526 
 527     public long insertNewWorkspaceScreenBeforeEmptyScreen(long screenId) {
 528         // Find the index to insert this view into.  If the empty screen exists, then
 529         // insert it before that.
 530         int insertIndex = mScreenOrder.indexOf(EXTRA_EMPTY_SCREEN_ID);
 531         if (insertIndex &lt; 0) {
 532             insertIndex = mScreenOrder.size();
 533         }
 534         return insertNewWorkspaceScreen(screenId, insertIndex);
 535     }
 536 
 537     public long insertNewWorkspaceScreen(long screenId) {
 538         return insertNewWorkspaceScreen(screenId, getChildCount());
 539     }
 540 
 541     public long insertNewWorkspaceScreen(long screenId, int insertIndex) {
 542         if (mWorkspaceScreens.containsKey(screenId)) {
 543             throw new RuntimeException(&quot;Screen id &quot; + screenId + &quot; already exists!&quot;);
 544         }
 545 
 546         CellLayout newScreen = (CellLayout)
 547                 mLauncher.getLayoutInflater().inflate(R.layout.workspace_screen, null);
 548 
 549         newScreen.setOnLongClickListener(mLongClickListener);
 550         newScreen.setOnClickListener(mLauncher);
 551         newScreen.setSoundEffectsEnabled(false);
 552         mWorkspaceScreens.put(screenId, newScreen);
 553         mScreenOrder.add(insertIndex, screenId);
 554         addView(newScreen, insertIndex);
 555         return screenId;
 556     }
 557 
 558     public void createCustomContentPage() {
 559         CellLayout customScreen = (CellLayout)
 560                 mLauncher.getLayoutInflater().inflate(R.layout.workspace_screen, null);
 561 
 562         mWorkspaceScreens.put(CUSTOM_CONTENT_SCREEN_ID, customScreen);
 563         mScreenOrder.add(0, CUSTOM_CONTENT_SCREEN_ID);
 564 
 565         // We want no padding on the custom content
 566         customScreen.setPadding(0, 0, 0, 0);
 567 
 568         addFullScreenPage(customScreen);
 569 
 570         // Ensure that the current page and default page are maintained.
 571         mDefaultPage = mOriginalDefaultPage + 1;
 572 
 573         // Update the custom content hint
 574         mLauncher.updateCustomContentHintVisibility();
 575         if (mRestorePage != INVALID_RESTORE_PAGE) {
 576             mRestorePage = mRestorePage + 1;
 577         } else {
 578             setCurrentPage(getCurrentPage() + 1);
 579         }
 580     }
 581 
 582     public void removeCustomContentPage() {
 583         CellLayout customScreen = getScreenWithId(CUSTOM_CONTENT_SCREEN_ID);
 584         if (customScreen == null) {
 585             throw new RuntimeException(&quot;Expected custom content screen to exist&quot;);
 586         }
 587 
 588         mWorkspaceScreens.remove(CUSTOM_CONTENT_SCREEN_ID);
 589         mScreenOrder.remove(CUSTOM_CONTENT_SCREEN_ID);
 590         removeView(customScreen);
 591 
 592         if (mCustomContentCallbacks != null) {
 593             mCustomContentCallbacks.onScrollProgressChanged(0);
 594             mCustomContentCallbacks.onHide();
 595         }
 596 
 597         mCustomContentCallbacks = null;
 598 
 599         // Ensure that the current page and default page are maintained.
 600         mDefaultPage = mOriginalDefaultPage - 1;
 601 
 602         // Update the custom content hint
 603         mLauncher.updateCustomContentHintVisibility();
 604         if (mRestorePage != INVALID_RESTORE_PAGE) {
 605             mRestorePage = mRestorePage - 1;
 606         } else {
 607             setCurrentPage(getCurrentPage() - 1);
 608         }
 609     }
 610 
 611     public void addToCustomContentPage(View customContent, CustomContentCallbacks callbacks,
 612             String description) {
 613         if (getPageIndexForScreenId(CUSTOM_CONTENT_SCREEN_ID) &lt; 0) {
 614             throw new RuntimeException(&quot;Expected custom content screen to exist&quot;);
 615         }
 616 
 617         // Add the custom content to the full screen custom page
 618         CellLayout customScreen = getScreenWithId(CUSTOM_CONTENT_SCREEN_ID);
 619         int spanX = customScreen.getCountX();
 620         int spanY = customScreen.getCountY();
 621         CellLayout.LayoutParams lp = new CellLayout.LayoutParams(0, 0, spanX, spanY);
 622         lp.canReorder  = false;
 623         lp.isFullscreen = true;
 624         if (customContent instanceof Insettable) {
 625             ((Insettable)customContent).setInsets(mInsets);
 626         }
 627         customScreen.removeAllViews();
 628         customScreen.addViewToCellLayout(customContent, 0, 0, lp, true);
 629         mCustomContentDescription = description;
 630 
 631         mCustomContentCallbacks = callbacks;
 632     }
 633 
 634     public void addExtraEmptyScreenOnDrag() {
 635         boolean lastChildOnScreen = false;
 636         boolean childOnFinalScreen = false;
 637 
 638         // Cancel any pending removal of empty screen
 639         mRemoveEmptyScreenRunnable = null;
 640 
 641         if (mDragSourceInternal != null) {
 642             if (mDragSourceInternal.getChildCount() == 1) {
 643                 lastChildOnScreen = true;
 644             }
 645             CellLayout cl = (CellLayout) mDragSourceInternal.getParent();
 646             if (indexOfChild(cl) == getChildCount() - 1) {
 647                 childOnFinalScreen = true;
 648             }
 649         }
 650 
 651         // If this is the last item on the final screen
 652         if (lastChildOnScreen &amp;&amp; childOnFinalScreen) {
 653             return;
 654         }
 655         if (!mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID)) {
 656             insertNewWorkspaceScreen(EXTRA_EMPTY_SCREEN_ID);
 657         }
 658     }
 659 
 660     public boolean addExtraEmptyScreen() {
 661         if (!mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID)) {
 662             insertNewWorkspaceScreen(EXTRA_EMPTY_SCREEN_ID);
 663             return true;
 664         }
 665         return false;
 666     }
 667 
 668     private void convertFinalScreenToEmptyScreenIfNecessary() {
 669         if (hasExtraEmptyScreen() || mScreenOrder.size() == 0) return;
 670         long finalScreenId = mScreenOrder.get(mScreenOrder.size() - 1);
 671 
 672         if (finalScreenId == CUSTOM_CONTENT_SCREEN_ID) return;
 673         CellLayout finalScreen = mWorkspaceScreens.get(finalScreenId);
 674 
 675         // If the final screen is empty, convert it to the extra empty screen
 676         if (finalScreen.getShortcutsAndWidgets().getChildCount() == 0 &amp;&amp;
 677                 !finalScreen.isDropPending()) {
 678             mWorkspaceScreens.remove(finalScreenId);
 679             mScreenOrder.remove(finalScreenId);
 680 
 681             // if this is the last non-custom content screen, convert it to the empty screen
 682             mWorkspaceScreens.put(EXTRA_EMPTY_SCREEN_ID, finalScreen);
 683             mScreenOrder.add(EXTRA_EMPTY_SCREEN_ID);
 684         }
 685     }
 686 
 687     public void removeExtraEmptyScreen(final boolean animate, final Runnable onComplete) {
 688         removeExtraEmptyScreen(animate, onComplete, 0, false);
 689     }
 690 
 691     public void removeExtraEmptyScreen(final boolean animate, final Runnable onComplete,
 692             final int delay, final boolean stripEmptyScreens) {
 693         if (delay &gt; 0) {
 694             postDelayed(new Runnable() {
 695                 @Override
 696                 public void run() {
 697                     removeExtraEmptyScreen(animate, onComplete, 0, stripEmptyScreens);
 698                 }
 699 
 700             }, delay);
 701             return;
 702         }
 703 
 704         convertFinalScreenToEmptyScreenIfNecessary();
 705         if (hasExtraEmptyScreen()) {
 706             int emptyIndex = mScreenOrder.indexOf(EXTRA_EMPTY_SCREEN_ID);
 707             if (getNextPage() == emptyIndex) {
 708                 snapToPage(getNextPage() - 1, SNAP_OFF_EMPTY_SCREEN_DURATION);
 709                 fadeAndRemoveEmptyScreen(SNAP_OFF_EMPTY_SCREEN_DURATION, FADE_EMPTY_SCREEN_DURATION,
 710                         onComplete, stripEmptyScreens);
 711             } else {
 712                 fadeAndRemoveEmptyScreen(0, FADE_EMPTY_SCREEN_DURATION,
 713                         onComplete, stripEmptyScreens);
 714             }
 715             return;
 716         }
 717         if (onComplete != null) {
 718             onComplete.run();
 719         }
 720     }
 721 
 722     private void fadeAndRemoveEmptyScreen(int delay, int duration, final Runnable onComplete,
 723             final boolean stripEmptyScreens) {
 724         PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0f);
 725         PropertyValuesHolder bgAlpha = PropertyValuesHolder.ofFloat(&quot;backgroundAlpha&quot;, 0f);
 726 
 727         final CellLayout cl = mWorkspaceScreens.get(EXTRA_EMPTY_SCREEN_ID);
 728 
 729         mRemoveEmptyScreenRunnable = new Runnable() {
 730             @Override
 731             public void run() {
 732                 if (hasExtraEmptyScreen()) {
 733                     mWorkspaceScreens.remove(EXTRA_EMPTY_SCREEN_ID);
 734                     mScreenOrder.remove(EXTRA_EMPTY_SCREEN_ID);
 735                     removeView(cl);
 736                     if (stripEmptyScreens) {
 737                         stripEmptyScreens();
 738                     }
 739                 }
 740             }
 741         };
 742 
 743         ObjectAnimator oa = ObjectAnimator.ofPropertyValuesHolder(cl, alpha, bgAlpha);
 744         oa.setDuration(duration);
 745         oa.setStartDelay(delay);
 746         oa.addListener(new AnimatorListenerAdapter() {
 747             @Override
 748             public void onAnimationEnd(Animator animation) {
 749                 if (mRemoveEmptyScreenRunnable != null) {
 750                     mRemoveEmptyScreenRunnable.run();
 751                 }
 752                 if (onComplete != null) {
 753                     onComplete.run();
 754                 }
 755             }
 756         });
 757         oa.start();
 758     }
 759 
 760     public boolean hasExtraEmptyScreen() {
 761         int nScreens = getChildCount();
 762         nScreens = nScreens - numCustomPages();
 763         return mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID) &amp;&amp; nScreens &gt; 1;
 764     }
 765 
 766     public long commitExtraEmptyScreen() {
 767         int index = getPageIndexForScreenId(EXTRA_EMPTY_SCREEN_ID);
 768         CellLayout cl = mWorkspaceScreens.get(EXTRA_EMPTY_SCREEN_ID);
 769         mWorkspaceScreens.remove(EXTRA_EMPTY_SCREEN_ID);
 770         mScreenOrder.remove(EXTRA_EMPTY_SCREEN_ID);
 771 
 772         long newId = LauncherAppState.getLauncherProvider().generateNewScreenId();
 773         mWorkspaceScreens.put(newId, cl);
 774         mScreenOrder.add(newId);
 775 
 776         // Update the page indicator marker
 777         if (getPageIndicator() != null) {
 778             getPageIndicator().updateMarker(index, getPageIndicatorMarker(index));
 779         }
 780 
 781         // Update the model for the new screen
 782         mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
 783 
 784         return newId;
 785     }
 786 
 787     public CellLayout getScreenWithId(long screenId) {
 788         CellLayout layout = mWorkspaceScreens.get(screenId);
 789         return layout;
 790     }
 791 
 792     public long getIdForScreen(CellLayout layout) {
 793         Iterator&lt;Long&gt; iter = mWorkspaceScreens.keySet().iterator();
 794         while (iter.hasNext()) {
 795             long id = iter.next();
 796             if (mWorkspaceScreens.get(id) == layout) {
 797                 return id;
 798             }
 799         }
 800         return -1;
 801     }
 802 
 803     public int getPageIndexForScreenId(long screenId) {
 804         return indexOfChild(mWorkspaceScreens.get(screenId));
 805     }
 806 
 807     public long getScreenIdForPageIndex(int index) {
 808         if (0 &lt;= index &amp;&amp; index &lt; mScreenOrder.size()) {
 809             return mScreenOrder.get(index);
 810         }
 811         return -1;
 812     }
 813 
 814     ArrayList&lt;Long&gt; getScreenOrder() {
 815         return mScreenOrder;
 816     }
 817 
 818     public void stripEmptyScreens() {
 819         if (isPageMoving()) {
 820             mStripScreensOnPageStopMoving = true;
 821             return;
 822         }
 823 
 824         int currentPage = getNextPage();
 825         ArrayList&lt;Long&gt; removeScreens = new ArrayList&lt;Long&gt;();
 826         for (Long id: mWorkspaceScreens.keySet()) {
 827             CellLayout cl = mWorkspaceScreens.get(id);
 828             if (id &gt;= 0 &amp;&amp; cl.getShortcutsAndWidgets().getChildCount() == 0) {
 829                 removeScreens.add(id);
 830             }
 831         }
 832 
 833         // We enforce at least one page to add new items to. In the case that we remove the last
 834         // such screen, we convert the last screen to the empty screen
 835         int minScreens = 1 + numCustomPages();
 836 
 837         int pageShift = 0;
 838         for (Long id: removeScreens) {
 839             CellLayout cl = mWorkspaceScreens.get(id);
 840             mWorkspaceScreens.remove(id);
 841             mScreenOrder.remove(id);
 842 
 843             if (getChildCount() &gt; minScreens) {
 844                 if (indexOfChild(cl) &lt; currentPage) {
 845                     pageShift++;
 846                 }
 847                 removeView(cl);
 848             } else {
 849                 // if this is the last non-custom content screen, convert it to the empty screen
 850                 mRemoveEmptyScreenRunnable = null;
 851                 mWorkspaceScreens.put(EXTRA_EMPTY_SCREEN_ID, cl);
 852                 mScreenOrder.add(EXTRA_EMPTY_SCREEN_ID);
 853             }
 854         }
 855 
 856         if (!removeScreens.isEmpty()) {
 857             // Update the model if we have changed any screens
 858             mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
 859         }
 860 
 861         if (pageShift &gt;= 0) {
 862             setCurrentPage(currentPage - pageShift);
 863         }
 864     }
 865 
 866     // See implementation for parameter definition.
 867     void addInScreen(View child, long container, long screenId,
 868             int x, int y, int spanX, int spanY) {
 869         addInScreen(child, container, screenId, x, y, spanX, spanY, false, false);
 870     }
 871 
 872     // At bind time, we use the rank (screenId) to compute x and y for hotseat items.
 873     // See implementation for parameter definition.
 874     void addInScreenFromBind(View child, long container, long screenId, int x, int y,
 875             int spanX, int spanY) {
 876         addInScreen(child, container, screenId, x, y, spanX, spanY, false, true);
 877     }
 878 
 879     // See implementation for parameter definition.
 880     void addInScreen(View child, long container, long screenId, int x, int y, int spanX, int spanY,
 881             boolean insert) {
 882         addInScreen(child, container, screenId, x, y, spanX, spanY, insert, false);
 883     }
 884 
 885     /**
 886      * Adds the specified child in the specified screen. The position and dimension of
 887      * the child are defined by x, y, spanX and spanY.
 888      *
 889      * @param child The child to add in one of the workspace&#x27;s screens.
 890      * @param screenId The screen in which to add the child.
 891      * @param x The X position of the child in the screen&#x27;s grid.
 892      * @param y The Y position of the child in the screen&#x27;s grid.
 893      * @param spanX The number of cells spanned horizontally by the child.
 894      * @param spanY The number of cells spanned vertically by the child.
 895      * @param insert When true, the child is inserted at the beginning of the children list.
 896      * @param computeXYFromRank When true, we use the rank (stored in screenId) to compute
 897      *                          the x and y position in which to place hotseat items. Otherwise
 898      *                          we use the x and y position to compute the rank.
 899      */
 900     void addInScreen(View child, long container, long screenId, int x, int y, int spanX, int spanY,
 901             boolean insert, boolean computeXYFromRank) {
 902         if (container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 903             if (getScreenWithId(screenId) == null) {
 904                 Log.e(TAG, &quot;Skipping child, screenId &quot; + screenId + &quot; not found&quot;);
 905                 // DEBUGGING - Print out the stack trace to see where we are adding from
 906                 new Throwable().printStackTrace();
 907                 return;
 908             }
 909         }
 910         if (screenId == EXTRA_EMPTY_SCREEN_ID) {
 911             // This should never happen
 912             throw new RuntimeException(&quot;Screen id should not be EXTRA_EMPTY_SCREEN_ID&quot;);
 913         }
 914 
 915         final CellLayout layout;
 916         if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 917             layout = mLauncher.getHotseat().getLayout();
 918             child.setOnKeyListener(null);
 919 
 920             // Hide folder title in the hotseat
 921             if (child instanceof FolderIcon) {
 922                 ((FolderIcon) child).setTextVisible(false);
 923             }
 924 
 925             if (computeXYFromRank) {
 926                 x = mLauncher.getHotseat().getCellXFromOrder((int) screenId);
 927                 y = mLauncher.getHotseat().getCellYFromOrder((int) screenId);
 928             } else {
 929                 screenId = mLauncher.getHotseat().getOrderInHotseat(x, y);
 930             }
 931         } else {
 932             // Show folder title if not in the hotseat
 933             if (child instanceof FolderIcon) {
 934                 ((FolderIcon) child).setTextVisible(true);
 935             }
 936             layout = getScreenWithId(screenId);
 937             child.setOnKeyListener(new IconKeyEventListener());
 938         }
 939 
 940         ViewGroup.LayoutParams genericLp = child.getLayoutParams();
 941         CellLayout.LayoutParams lp;
 942         if (genericLp == null || !(genericLp instanceof CellLayout.LayoutParams)) {
 943             lp = new CellLayout.LayoutParams(x, y, spanX, spanY);
 944         } else {
 945             lp = (CellLayout.LayoutParams) genericLp;
 946             lp.cellX = x;
 947             lp.cellY = y;
 948             lp.cellHSpan = spanX;
 949             lp.cellVSpan = spanY;
 950         }
 951 
 952         if (spanX &lt; 0 &amp;&amp; spanY &lt; 0) {
 953             lp.isLockedToGrid = false;
 954         }
 955 
 956         // Get the canonical child id to uniquely represent this view in this screen
 957         ItemInfo info = (ItemInfo) child.getTag();
 958         int childId = mLauncher.getViewIdForItem(info);
 959 
 960         boolean markCellsAsOccupied = !(child instanceof Folder);
 961         if (!layout.addViewToCellLayout(child, insert ? 0 : -1, childId, lp, markCellsAsOccupied)) {
 962             // TODO: This branch occurs when the workspace is adding views
 963             // outside of the defined grid
 964             // maybe we should be deleting these items from the LauncherModel?
<abbr title=" 965             Launcher.addDumpLog(TAG, &quot;Failed to add to item at (&quot; + lp.cellX + &quot;,&quot; + lp.cellY + &quot;) to CellLayout&quot;, true);"> 965             Launcher.addDumpLog(TAG, &quot;Failed to add to item at (&quot; + lp.cellX + &quot;,&quot; + lp.cellY + &quot;) to Cel🔵</abbr>
 966         }
 967 
 968         if (!(child instanceof Folder)) {
 969             child.setHapticFeedbackEnabled(false);
 970             child.setOnLongClickListener(mLongClickListener);
 971         }
 972         if (child instanceof DropTarget) {
 973             mDragController.addDropTarget((DropTarget) child);
 974         }
 975     }
 976 
 977     /**
 978      * Called directly from a CellLayout (not by the framework), after we&#x27;ve been added as a
 979      * listener via setOnInterceptTouchEventListener(). This allows us to tell the CellLayout
 980      * that it should intercept touch events, which is not something that is normally supported.
 981      */
 982     @Override
 983     public boolean onTouch(View v, MotionEvent event) {
 984         return (isSmall() || !isFinishedSwitchingState())
 985                 || (!isSmall() &amp;&amp; indexOfChild(v) != mCurrentPage);
 986     }
 987 
 988     public boolean isSwitchingState() {
 989         return mIsSwitchingState;
 990     }
 991 
 992     /** This differs from isSwitchingState in that we take into account how far the transition
 993      *  has completed. */
 994     public boolean isFinishedSwitchingState() {
 995         return !mIsSwitchingState || (mTransitionProgress &gt; 0.5f);
 996     }
 997 
 998     protected void onWindowVisibilityChanged (int visibility) {
 999         mLauncher.onWindowVisibilityChanged(visibility);
1000     }
1001 
1002     @Override
1003     public boolean dispatchUnhandledMove(View focused, int direction) {
1004         if (isSmall() || !isFinishedSwitchingState()) {
1005             // when the home screens are shrunken, shouldn&#x27;t allow side-scrolling
1006             return false;
1007         }
1008         return super.dispatchUnhandledMove(focused, direction);
1009     }
1010 
1011     @Override
1012     public boolean onInterceptTouchEvent(MotionEvent ev) {
1013         switch (ev.getAction() &amp; MotionEvent.ACTION_MASK) {
1014         case MotionEvent.ACTION_DOWN:
1015             mXDown = ev.getX();
1016             mYDown = ev.getY();
1017             mTouchDownTime = System.currentTimeMillis();
1018             break;
1019         case MotionEvent.ACTION_POINTER_UP:
1020         case MotionEvent.ACTION_UP:
1021             if (mTouchState == TOUCH_STATE_REST) {
1022                 final CellLayout currentPage = (CellLayout) getChildAt(mCurrentPage);
1023                 if (!currentPage.lastDownOnOccupiedCell()) {
1024                     onWallpaperTap(ev);
1025                 }
1026             }
1027         }
1028         return super.onInterceptTouchEvent(ev);
1029     }
1030 
1031     protected void reinflateWidgetsIfNecessary() {
1032         final int clCount = getChildCount();
1033         for (int i = 0; i &lt; clCount; i++) {
1034             CellLayout cl = (CellLayout) getChildAt(i);
1035             ShortcutAndWidgetContainer swc = cl.getShortcutsAndWidgets();
1036             final int itemCount = swc.getChildCount();
1037             for (int j = 0; j &lt; itemCount; j++) {
1038                 View v = swc.getChildAt(j);
1039 
1040                 if (v.getTag() instanceof LauncherAppWidgetInfo) {
1041                     LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) v.getTag();
1042                     LauncherAppWidgetHostView lahv = (LauncherAppWidgetHostView) info.hostView;
1043                     if (lahv != null &amp;&amp; lahv.orientationChangedSincedInflation()) {
1044                         mLauncher.removeAppWidget(info);
1045                         // Remove the current widget which is inflated with the wrong orientation
1046                         cl.removeView(lahv);
1047                         mLauncher.bindAppWidget(info);
1048                     }
1049                 }
1050             }
1051         }
1052     }
1053 
1054     @Override
1055     protected void determineScrollingStart(MotionEvent ev) {
1056         if (!isFinishedSwitchingState()) return;
1057 
1058         float deltaX = ev.getX() - mXDown;
1059         float absDeltaX = Math.abs(deltaX);
1060         float absDeltaY = Math.abs(ev.getY() - mYDown);
1061 
1062         if (Float.compare(absDeltaX, 0f) == 0) return;
1063 
1064         float slope = absDeltaY / absDeltaX;
1065         float theta = (float) Math.atan(slope);
1066 
1067         if (absDeltaX &gt; mTouchSlop || absDeltaY &gt; mTouchSlop) {
1068             cancelCurrentPageLongPress();
1069         }
1070 
1071         boolean passRightSwipesToCustomContent =
1072                 (mTouchDownTime - mCustomContentShowTime) &gt; CUSTOM_CONTENT_GESTURE_DELAY;
1073 
1074         boolean swipeInIgnoreDirection = isLayoutRtl() ? deltaX &lt; 0 : deltaX &gt; 0;
1075         if (swipeInIgnoreDirection &amp;&amp; getScreenIdForPageIndex(getCurrentPage()) ==
1076                 CUSTOM_CONTENT_SCREEN_ID &amp;&amp; passRightSwipesToCustomContent) {
1077             // Pass swipes to the right to the custom content page.
1078             return;
1079         }
1080 
1081         if (theta &gt; MAX_SWIPE_ANGLE) {
1082             // Above MAX_SWIPE_ANGLE, we don&#x27;t want to ever start scrolling the workspace
1083             return;
1084         } else if (theta &gt; START_DAMPING_TOUCH_SLOP_ANGLE) {
1085             // Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to
1086             // increase the touch slop to make it harder to begin scrolling the workspace. This
1087             // results in vertically scrolling widgets to more easily. The higher the angle, the
1088             // more we increase touch slop.
1089             theta -= START_DAMPING_TOUCH_SLOP_ANGLE;
1090             float extraRatio = (float)
1091                     Math.sqrt((theta / (MAX_SWIPE_ANGLE - START_DAMPING_TOUCH_SLOP_ANGLE)));
1092             super.determineScrollingStart(ev, 1 + TOUCH_SLOP_DAMPING_FACTOR * extraRatio);
1093         } else {
1094             // Below START_DAMPING_TOUCH_SLOP_ANGLE, we don&#x27;t do anything special
1095             super.determineScrollingStart(ev);
1096         }
1097     }
1098 
1099     protected void onPageBeginMoving() {
1100         super.onPageBeginMoving();
1101 
1102         if (isHardwareAccelerated()) {
1103             updateChildrenLayersEnabled(false);
1104         } else {
1105             if (mNextPage != INVALID_PAGE) {
1106                 // we&#x27;re snapping to a particular screen
1107                 enableChildrenCache(mCurrentPage, mNextPage);
1108             } else {
1109                 // this is when user is actively dragging a particular screen, they might
1110                 // swipe it either left or right (but we won&#x27;t advance by more than one screen)
1111                 enableChildrenCache(mCurrentPage - 1, mCurrentPage + 1);
1112             }
1113         }
1114 
1115         // Only show page outlines as we pan if we are on large screen
1116         if (LauncherAppState.getInstance().isScreenLarge()) {
1117             showOutlines();
1118         }
1119 
1120         // If we are not fading in adjacent screens, we still need to restore the alpha in case the
1121         // user scrolls while we are transitioning (should not affect dispatchDraw optimizations)
1122         if (!mWorkspaceFadeInAdjacentScreens) {
1123             for (int i = 0; i &lt; getChildCount(); ++i) {
1124                 ((CellLayout) getPageAt(i)).setShortcutAndWidgetAlpha(1f);
1125             }
1126         }
1127     }
1128 
1129     protected void onPageEndMoving() {
1130         super.onPageEndMoving();
1131 
1132         if (isHardwareAccelerated()) {
1133             updateChildrenLayersEnabled(false);
1134         } else {
1135             clearChildrenCache();
1136         }
1137 
1138         if (mDragController.isDragging()) {
1139             if (isSmall()) {
1140                 // If we are in springloaded mode, then force an event to check if the current touch
1141                 // is under a new page (to scroll to)
1142                 mDragController.forceTouchMove();
1143             }
1144         } else {
1145             // If we are not mid-dragging, hide the page outlines if we are on a large screen
1146             if (LauncherAppState.getInstance().isScreenLarge()) {
1147                 hideOutlines();
1148             }
1149         }
1150 
1151         if (mDelayedResizeRunnable != null) {
1152             mDelayedResizeRunnable.run();
1153             mDelayedResizeRunnable = null;
1154         }
1155 
1156         if (mDelayedSnapToPageRunnable != null) {
1157             mDelayedSnapToPageRunnable.run();
1158             mDelayedSnapToPageRunnable = null;
1159         }
1160         if (mStripScreensOnPageStopMoving) {
1161             stripEmptyScreens();
1162             mStripScreensOnPageStopMoving = false;
1163         }
1164     }
1165 
1166     @Override
1167     protected void notifyPageSwitchListener() {
1168         super.notifyPageSwitchListener();
1169         Launcher.setScreen(mCurrentPage);
1170 
1171         if (hasCustomContent() &amp;&amp; getNextPage() == 0 &amp;&amp; !mCustomContentShowing) {
1172             mCustomContentShowing = true;
1173             if (mCustomContentCallbacks != null) {
1174                 mCustomContentCallbacks.onShow();
1175                 mCustomContentShowTime = System.currentTimeMillis();
1176                 mLauncher.updateVoiceButtonProxyVisible(false);
1177             }
1178         } else if (hasCustomContent() &amp;&amp; getNextPage() != 0 &amp;&amp; mCustomContentShowing) {
1179             mCustomContentShowing = false;
1180             if (mCustomContentCallbacks != null) {
1181                 mCustomContentCallbacks.onHide();
1182                 mLauncher.resetQSBScroll();
1183                 mLauncher.updateVoiceButtonProxyVisible(false);
1184             }
1185         }
1186         if (getPageIndicator() != null) {
1187             getPageIndicator().setContentDescription(getPageIndicatorDescription());
1188         }
1189     }
1190 
1191     protected CustomContentCallbacks getCustomContentCallbacks() {
1192         return mCustomContentCallbacks;
1193     }
1194 
1195     protected void setWallpaperDimension() {
1196         String spKey = WallpaperCropActivity.getSharedPreferencesKey();
1197         SharedPreferences sp = mLauncher.getSharedPreferences(spKey, Context.MODE_MULTI_PROCESS);
1198         WallpaperPickerActivity.suggestWallpaperDimension(mLauncher.getResources(),
1199                 sp, mLauncher.getWindowManager(), mWallpaperManager);
1200     }
1201 
1202     protected void snapToPage(int whichPage, Runnable r) {
1203         snapToPage(whichPage, SLOW_PAGE_SNAP_ANIMATION_DURATION, r);
1204     }
1205 
1206     protected void snapToPage(int whichPage, int duration, Runnable r) {
1207         if (mDelayedSnapToPageRunnable != null) {
1208             mDelayedSnapToPageRunnable.run();
1209         }
1210         mDelayedSnapToPageRunnable = r;
1211         snapToPage(whichPage, duration);
1212     }
1213 
1214     protected void snapToScreenId(long screenId, Runnable r) {
1215         snapToPage(getPageIndexForScreenId(screenId), r);
1216     }
1217 
1218     class WallpaperOffsetInterpolator implements Choreographer.FrameCallback {
1219         float mFinalOffset = 0.0f;
1220         float mCurrentOffset = 0.5f; // to force an initial update
1221         boolean mWaitingForUpdate;
1222         Choreographer mChoreographer;
1223         Interpolator mInterpolator;
1224         boolean mAnimating;
1225         long mAnimationStartTime;
1226         float mAnimationStartOffset;
1227         private final int ANIMATION_DURATION = 250;
1228         // Don&#x27;t use all the wallpaper for parallax until you have at least this many pages
1229         private final int MIN_PARALLAX_PAGE_SPAN = 3;
1230         int mNumScreens;
1231 
1232         public WallpaperOffsetInterpolator() {
1233             mChoreographer = Choreographer.getInstance();
1234             mInterpolator = new DecelerateInterpolator(1.5f);
1235         }
1236 
1237         @Override
1238         public void doFrame(long frameTimeNanos) {
1239             updateOffset(false);
1240         }
1241 
1242         private void updateOffset(boolean force) {
1243             if (mWaitingForUpdate || force) {
1244                 mWaitingForUpdate = false;
1245                 if (computeScrollOffset() &amp;&amp; mWindowToken != null) {
1246                     try {
1247                         mWallpaperManager.setWallpaperOffsets(mWindowToken,
1248                                 mWallpaperOffset.getCurrX(), 0.5f);
1249                         setWallpaperOffsetSteps();
1250                     } catch (IllegalArgumentException e) {
1251                         Log.e(TAG, &quot;Error updating wallpaper offset: &quot; + e);
1252                     }
1253                 }
1254             }
1255         }
1256 
1257         public boolean computeScrollOffset() {
1258             final float oldOffset = mCurrentOffset;
1259             if (mAnimating) {
1260                 long durationSinceAnimation = System.currentTimeMillis() - mAnimationStartTime;
1261                 float t0 = durationSinceAnimation / (float) ANIMATION_DURATION;
1262                 float t1 = mInterpolator.getInterpolation(t0);
1263                 mCurrentOffset = mAnimationStartOffset +
1264                         (mFinalOffset - mAnimationStartOffset) * t1;
1265                 mAnimating = durationSinceAnimation &lt; ANIMATION_DURATION;
1266             } else {
1267                 mCurrentOffset = mFinalOffset;
1268             }
1269 
1270             if (Math.abs(mCurrentOffset - mFinalOffset) &gt; 0.0000001f) {
1271                 scheduleUpdate();
1272             }
1273             if (Math.abs(oldOffset - mCurrentOffset) &gt; 0.0000001f) {
1274                 return true;
1275             }
1276             return false;
1277         }
1278 
1279         private float wallpaperOffsetForCurrentScroll() {
1280             if (getChildCount() &lt;= 1) {
1281                 return 0;
1282             }
1283 
1284             // Exclude the leftmost page
1285             int emptyExtraPages = numEmptyScreensToIgnore();
1286             int firstIndex = numCustomPages();
1287             // Exclude the last extra empty screen (if we have &gt; MIN_PARALLAX_PAGE_SPAN pages)
1288             int lastIndex = getChildCount() - 1 - emptyExtraPages;
1289             if (isLayoutRtl()) {
1290                 int temp = firstIndex;
1291                 firstIndex = lastIndex;
1292                 lastIndex = temp;
1293             }
1294 
1295             int firstPageScrollX = getScrollForPage(firstIndex);
1296             int scrollRange = getScrollForPage(lastIndex) - firstPageScrollX;
1297             if (scrollRange == 0) {
1298                 return 0;
1299             } else {
1300                 // TODO: do different behavior if it&#x27;s  a live wallpaper?
1301                 // Sometimes the left parameter of the pages is animated during a layout transition;
1302                 // this parameter offsets it to keep the wallpaper from animating as well
1303                 int adjustedScroll =
1304                         getScrollX() - firstPageScrollX - getLayoutTransitionOffsetForPage(0);
1305                 float offset = Math.min(1, adjustedScroll / (float) scrollRange);
1306                 offset = Math.max(0, offset);
1307                 // Don&#x27;t use up all the wallpaper parallax until you have at least
1308                 // MIN_PARALLAX_PAGE_SPAN pages
1309                 int numScrollingPages = getNumScreensExcludingEmptyAndCustom();
1310                 int parallaxPageSpan = Math.max(MIN_PARALLAX_PAGE_SPAN, numScrollingPages - 1);
1311                 // On RTL devices, push the wallpaper offset to the right if we don&#x27;t have enough
1312                 // pages (ie if numScrollingPages &lt; MIN_PARALLAX_PAGE_SPAN)
1313                 int padding = isLayoutRtl() ? parallaxPageSpan - numScrollingPages + 1 : 0;
1314                 return offset * (padding + numScrollingPages - 1) / parallaxPageSpan;
1315             }
1316         }
1317 
1318         private int numEmptyScreensToIgnore() {
1319             int numScrollingPages = getChildCount() - numCustomPages();
1320             if (numScrollingPages &gt;= MIN_PARALLAX_PAGE_SPAN &amp;&amp; hasExtraEmptyScreen()) {
1321                 return 1;
1322             } else {
1323                 return 0;
1324             }
1325         }
1326 
1327         private int getNumScreensExcludingEmptyAndCustom() {
1328             int numScrollingPages = getChildCount() - numEmptyScreensToIgnore() - numCustomPages();
1329             return numScrollingPages;
1330         }
1331 
1332         public void syncWithScroll() {
1333             float offset = wallpaperOffsetForCurrentScroll();
1334             mWallpaperOffset.setFinalX(offset);
1335             updateOffset(true);
1336         }
1337 
1338         public float getCurrX() {
1339             return mCurrentOffset;
1340         }
1341 
1342         public float getFinalX() {
1343             return mFinalOffset;
1344         }
1345 
1346         private void animateToFinal() {
1347             mAnimating = true;
1348             mAnimationStartOffset = mCurrentOffset;
1349             mAnimationStartTime = System.currentTimeMillis();
1350         }
1351 
1352         private void setWallpaperOffsetSteps() {
1353             // Set wallpaper offset steps (1 / (number of screens - 1))
1354             mWallpaperManager.setWallpaperOffsetSteps(1.0f / (getChildCount() - 1), 1.0f);
1355         }
1356 
1357         public void setFinalX(float x) {
1358             scheduleUpdate();
1359             mFinalOffset = Math.max(0f, Math.min(x, 1.0f));
1360             if (getNumScreensExcludingEmptyAndCustom() != mNumScreens) {
1361                 if (mNumScreens &gt; 0) {
1362                     // Don&#x27;t animate if we&#x27;re going from 0 screens
1363                     animateToFinal();
1364                 }
1365                 mNumScreens = getNumScreensExcludingEmptyAndCustom();
1366             }
1367         }
1368 
1369         private void scheduleUpdate() {
1370             if (!mWaitingForUpdate) {
1371                 mChoreographer.postFrameCallback(this);
1372                 mWaitingForUpdate = true;
1373             }
1374         }
1375 
1376         public void jumpToFinal() {
1377             mCurrentOffset = mFinalOffset;
1378         }
1379     }
1380 
1381     @Override
1382     public void computeScroll() {
1383         super.computeScroll();
1384         mWallpaperOffset.syncWithScroll();
1385     }
1386 
1387     void showOutlines() {
1388         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1389             if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
1390             if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
<abbr title="1391             mChildrenOutlineFadeInAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 1.0f);">1391             mChildrenOutlineFadeInAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 1.0🔵</abbr>
1392             mChildrenOutlineFadeInAnimation.setDuration(CHILDREN_OUTLINE_FADE_IN_DURATION);
1393             mChildrenOutlineFadeInAnimation.start();
1394         }
1395     }
1396 
1397     void hideOutlines() {
1398         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1399             if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1400             if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
<abbr title="1401             mChildrenOutlineFadeOutAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.0f);">1401             mChildrenOutlineFadeOutAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.🔵</abbr>
1402             mChildrenOutlineFadeOutAnimation.setDuration(CHILDREN_OUTLINE_FADE_OUT_DURATION);
1403             mChildrenOutlineFadeOutAnimation.setStartDelay(CHILDREN_OUTLINE_FADE_OUT_DELAY);
1404             mChildrenOutlineFadeOutAnimation.start();
1405         }
1406     }
1407 
1408     public void showOutlinesTemporarily() {
1409         if (!mIsPageMoving &amp;&amp; !isTouchActive()) {
1410             snapToPage(mCurrentPage);
1411         }
1412     }
1413 
1414     public void setChildrenOutlineAlpha(float alpha) {
1415         mChildrenOutlineAlpha = alpha;
1416         for (int i = 0; i &lt; getChildCount(); i++) {
1417             CellLayout cl = (CellLayout) getChildAt(i);
1418             cl.setBackgroundAlpha(alpha);
1419         }
1420     }
1421 
1422     public float getChildrenOutlineAlpha() {
1423         return mChildrenOutlineAlpha;
1424     }
1425 
1426     void disableBackground() {
1427         mDrawBackground = false;
1428     }
1429     void enableBackground() {
1430         mDrawBackground = true;
1431     }
1432 
1433     private void animateBackgroundGradient(float finalAlpha, boolean animated) {
1434         if (mBackground == null) return;
1435         if (mBackgroundFadeInAnimation != null) {
1436             mBackgroundFadeInAnimation.cancel();
1437             mBackgroundFadeInAnimation = null;
1438         }
1439         if (mBackgroundFadeOutAnimation != null) {
1440             mBackgroundFadeOutAnimation.cancel();
1441             mBackgroundFadeOutAnimation = null;
1442         }
1443         float startAlpha = getBackgroundAlpha();
1444         if (finalAlpha != startAlpha) {
1445             if (animated) {
1446                 mBackgroundFadeOutAnimation =
1447                         LauncherAnimUtils.ofFloat(this, startAlpha, finalAlpha);
1448                 mBackgroundFadeOutAnimation.addUpdateListener(new AnimatorUpdateListener() {
1449                     public void onAnimationUpdate(ValueAnimator animation) {
1450                         setBackgroundAlpha(((Float) animation.getAnimatedValue()).floatValue());
1451                     }
1452                 });
1453                 mBackgroundFadeOutAnimation.setInterpolator(new DecelerateInterpolator(1.5f));
1454                 mBackgroundFadeOutAnimation.setDuration(BACKGROUND_FADE_OUT_DURATION);
1455                 mBackgroundFadeOutAnimation.start();
1456             } else {
1457                 setBackgroundAlpha(finalAlpha);
1458             }
1459         }
1460     }
1461 
1462     public void setBackgroundAlpha(float alpha) {
1463         if (alpha != mBackgroundAlpha) {
1464             mBackgroundAlpha = alpha;
1465             invalidate();
1466         }
1467     }
1468 
1469     public float getBackgroundAlpha() {
1470         return mBackgroundAlpha;
1471     }
1472 
1473     float backgroundAlphaInterpolator(float r) {
1474         float pivotA = 0.1f;
1475         float pivotB = 0.4f;
1476         if (r &lt; pivotA) {
1477             return 0;
1478         } else if (r &gt; pivotB) {
1479             return 1.0f;
1480         } else {
1481             return (r - pivotA)/(pivotB - pivotA);
1482         }
1483     }
1484 
1485     private void updatePageAlphaValues(int screenCenter) {
1486         boolean isInOverscroll = mOverScrollX &lt; 0 || mOverScrollX &gt; mMaxScrollX;
1487         if (mWorkspaceFadeInAdjacentScreens &amp;&amp;
1488                 mState == State.NORMAL &amp;&amp;
1489                 !mIsSwitchingState &amp;&amp;
1490                 !isInOverscroll) {
1491             for (int i = numCustomPages(); i &lt; getChildCount(); i++) {
1492                 CellLayout child = (CellLayout) getChildAt(i);
1493                 if (child != null) {
1494                     float scrollProgress = getScrollProgress(screenCenter, child, i);
1495                     float alpha = 1 - Math.abs(scrollProgress);
1496                     child.getShortcutsAndWidgets().setAlpha(alpha);
1497                 }
1498             }
1499         }
1500     }
1501 
1502     private void setChildrenBackgroundAlphaMultipliers(float a) {
1503         for (int i = 0; i &lt; getChildCount(); i++) {
1504             CellLayout child = (CellLayout) getChildAt(i);
1505             child.setBackgroundAlphaMultiplier(a);
1506         }
1507     }
1508 
1509     public boolean hasCustomContent() {
1510         return (mScreenOrder.size() &gt; 0 &amp;&amp; mScreenOrder.get(0) == CUSTOM_CONTENT_SCREEN_ID);
1511     }
1512 
1513     public int numCustomPages() {
1514         return hasCustomContent() ? 1 : 0;
1515     }
1516 
1517     public boolean isOnOrMovingToCustomContent() {
1518         return hasCustomContent() &amp;&amp; getNextPage() == 0;
1519     }
1520 
1521     private void updateStateForCustomContent(int screenCenter) {
1522         float translationX = 0;
1523         float progress = 0;
1524         if (hasCustomContent()) {
1525             int index = mScreenOrder.indexOf(CUSTOM_CONTENT_SCREEN_ID);
1526 
1527             int scrollDelta = getScrollX() - getScrollForPage(index) -
1528                     getLayoutTransitionOffsetForPage(index);
1529             float scrollRange = getScrollForPage(index + 1) - getScrollForPage(index);
1530             translationX = scrollRange - scrollDelta;
1531             progress = (scrollRange - scrollDelta) / scrollRange;
1532 
1533             if (isLayoutRtl()) {
1534                 translationX = Math.min(0, translationX);
1535             } else {
1536                 translationX = Math.max(0, translationX);
1537             }
1538             progress = Math.max(0, progress);
1539         }
1540 
1541         if (Float.compare(progress, mLastCustomContentScrollProgress) == 0) return;
1542 
1543         CellLayout cc = mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID);
1544         if (progress &gt; 0 &amp;&amp; cc.getVisibility() != VISIBLE &amp;&amp; !isSmall()) {
1545             cc.setVisibility(VISIBLE);
1546         }
1547 
1548         mLastCustomContentScrollProgress = progress;
1549 
1550         setBackgroundAlpha(progress * 0.8f);
1551 
1552         if (mLauncher.getHotseat() != null) {
1553             mLauncher.getHotseat().setTranslationX(translationX);
1554         }
1555 
1556         if (getPageIndicator() != null) {
1557             getPageIndicator().setTranslationX(translationX);
1558         }
1559 
1560         if (mCustomContentCallbacks != null) {
1561             mCustomContentCallbacks.onScrollProgressChanged(progress);
1562         }
1563     }
1564 
1565     @Override
1566     protected OnClickListener getPageIndicatorClickListener() {
1567         AccessibilityManager am = (AccessibilityManager)
1568                 getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
1569         if (!am.isTouchExplorationEnabled()) {
1570             return null;
1571         }
1572         OnClickListener listener = new OnClickListener() {
1573             @Override
1574             public void onClick(View arg0) {
1575                 enterOverviewMode();
1576             }
1577         };
1578         return listener;
1579     }
1580 
1581     @Override
1582     protected void screenScrolled(int screenCenter) {
1583         final boolean isRtl = isLayoutRtl();
1584         super.screenScrolled(screenCenter);
1585 
1586         updatePageAlphaValues(screenCenter);
1587         updateStateForCustomContent(screenCenter);
1588         enableHwLayersOnVisiblePages();
1589 
1590         boolean shouldOverScroll = (mOverScrollX &lt; 0 &amp;&amp; (!hasCustomContent() || isLayoutRtl())) ||
1591                 (mOverScrollX &gt; mMaxScrollX &amp;&amp; (!hasCustomContent() || !isLayoutRtl()));
1592 
1593         if (shouldOverScroll) {
1594             int index = 0;
1595             float pivotX = 0f;
1596             final float leftBiasedPivot = 0.25f;
1597             final float rightBiasedPivot = 0.75f;
1598             final int lowerIndex = 0;
1599             final int upperIndex = getChildCount() - 1;
1600 
1601             final boolean isLeftPage = mOverScrollX &lt; 0;
1602             index = (!isRtl &amp;&amp; isLeftPage) || (isRtl &amp;&amp; !isLeftPage) ? lowerIndex : upperIndex;
1603             pivotX = isLeftPage ? rightBiasedPivot : leftBiasedPivot;
1604 
1605             CellLayout cl = (CellLayout) getChildAt(index);
1606             float scrollProgress = getScrollProgress(screenCenter, cl, index);
1607             cl.setOverScrollAmount(Math.abs(scrollProgress), isLeftPage);
1608             float rotation = -WORKSPACE_OVERSCROLL_ROTATION * scrollProgress;
1609             cl.setRotationY(rotation);
1610 
1611             if (!mOverscrollTransformsSet || Float.compare(mLastOverscrollPivotX, pivotX) != 0) {
1612                 mOverscrollTransformsSet = true;
1613                 mLastOverscrollPivotX = pivotX;
1614                 cl.setCameraDistance(mDensity * mCameraDistance);
1615                 cl.setPivotX(cl.getMeasuredWidth() * pivotX);
1616                 cl.setPivotY(cl.getMeasuredHeight() * 0.5f);
1617                 cl.setOverscrollTransformsDirty(true);
1618             }
1619         } else {
1620             if (mOverscrollTransformsSet) {
1621                 mOverscrollTransformsSet = false;
1622                 ((CellLayout) getChildAt(0)).resetOverscrollTransforms();
1623                 ((CellLayout) getChildAt(getChildCount() - 1)).resetOverscrollTransforms();
1624             }
1625         }
1626     }
1627 
1628     @Override
1629     protected void overScroll(float amount) {
1630         acceleratedOverScroll(amount);
1631     }
1632 
1633     protected void onAttachedToWindow() {
1634         super.onAttachedToWindow();
1635         mWindowToken = getWindowToken();
1636         computeScroll();
1637         mDragController.setWindowToken(mWindowToken);
1638     }
1639 
1640     protected void onDetachedFromWindow() {
1641         super.onDetachedFromWindow();
1642         mWindowToken = null;
1643     }
1644 
1645     protected void onResume() {
1646         if (getPageIndicator() != null) {
1647             // In case accessibility state has changed, we need to perform this on every
1648             // attach to window
1649             OnClickListener listener = getPageIndicatorClickListener();
1650             if (listener != null) {
1651                 getPageIndicator().setOnClickListener(listener);
1652             }
1653         }
1654         AccessibilityManager am = (AccessibilityManager)
1655                 getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
1656         sAccessibilityEnabled = am.isEnabled();
1657     }
1658 
1659     @Override
1660     protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
1661         if (mFirstLayout &amp;&amp; mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getChildCount()) {
1662             mWallpaperOffset.syncWithScroll();
1663             mWallpaperOffset.jumpToFinal();
1664         }
1665         super.onLayout(changed, left, top, right, bottom);
1666     }
1667 
1668     @Override
1669     protected void onDraw(Canvas canvas) {
1670         // Draw the background gradient if necessary
1671         if (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground) {
1672             int alpha = (int) (mBackgroundAlpha * 255);
1673             mBackground.setAlpha(alpha);
1674             mBackground.setBounds(getScrollX(), 0, getScrollX() + getMeasuredWidth(),
1675                     getMeasuredHeight());
1676             mBackground.draw(canvas);
1677         }
1678 
1679         super.onDraw(canvas);
1680 
1681         // Call back to LauncherModel to finish binding after the first draw
1682         post(mBindPages);
1683     }
1684 
1685     boolean isDrawingBackgroundGradient() {
1686         return (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground);
1687     }
1688 
1689     @Override
1690     protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1691         if (!mLauncher.isAllAppsVisible()) {
1692             final Folder openFolder = getOpenFolder();
1693             if (openFolder != null) {
1694                 return openFolder.requestFocus(direction, previouslyFocusedRect);
1695             } else {
1696                 return super.onRequestFocusInDescendants(direction, previouslyFocusedRect);
1697             }
1698         }
1699         return false;
1700     }
1701 
1702     @Override
1703     public int getDescendantFocusability() {
1704         if (isSmall()) {
1705             return ViewGroup.FOCUS_BLOCK_DESCENDANTS;
1706         }
1707         return super.getDescendantFocusability();
1708     }
1709 
1710     @Override
1711     public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1712         if (!mLauncher.isAllAppsVisible()) {
1713             final Folder openFolder = getOpenFolder();
1714             if (openFolder != null) {
1715                 openFolder.addFocusables(views, direction);
1716             } else {
1717                 super.addFocusables(views, direction, focusableMode);
1718             }
1719         }
1720     }
1721 
1722     public boolean isSmall() {
1723         return mState == State.SMALL || mState == State.SPRING_LOADED || mState == State.OVERVIEW;
1724     }
1725 
1726     void enableChildrenCache(int fromPage, int toPage) {
1727         if (fromPage &gt; toPage) {
1728             final int temp = fromPage;
1729             fromPage = toPage;
1730             toPage = temp;
1731         }
1732 
1733         final int screenCount = getChildCount();
1734 
1735         fromPage = Math.max(fromPage, 0);
1736         toPage = Math.min(toPage, screenCount - 1);
1737 
1738         for (int i = fromPage; i &lt;= toPage; i++) {
1739             final CellLayout layout = (CellLayout) getChildAt(i);
1740             layout.setChildrenDrawnWithCacheEnabled(true);
1741             layout.setChildrenDrawingCacheEnabled(true);
1742         }
1743     }
1744 
1745     void clearChildrenCache() {
1746         final int screenCount = getChildCount();
1747         for (int i = 0; i &lt; screenCount; i++) {
1748             final CellLayout layout = (CellLayout) getChildAt(i);
1749             layout.setChildrenDrawnWithCacheEnabled(false);
1750             // In software mode, we don&#x27;t want the items to continue to be drawn into bitmaps
1751             if (!isHardwareAccelerated()) {
1752                 layout.setChildrenDrawingCacheEnabled(false);
1753             }
1754         }
1755     }
1756 
1757     private void updateChildrenLayersEnabled(boolean force) {
1758         boolean small = mState == State.SMALL || mState == State.OVERVIEW || mIsSwitchingState;
1759         boolean enableChildrenLayers = force || small || mAnimatingViewIntoPlace || isPageMoving();
1760 
1761         if (enableChildrenLayers != mChildrenLayersEnabled) {
1762             mChildrenLayersEnabled = enableChildrenLayers;
1763             if (mChildrenLayersEnabled) {
1764                 enableHwLayersOnVisiblePages();
1765             } else {
1766                 for (int i = 0; i &lt; getPageCount(); i++) {
1767                     final CellLayout cl = (CellLayout) getChildAt(i);
1768                     cl.enableHardwareLayer(false);
1769                 }
1770             }
1771         }
1772     }
1773 
1774     private void enableHwLayersOnVisiblePages() {
1775         if (mChildrenLayersEnabled) {
1776             final int screenCount = getChildCount();
1777             getVisiblePages(mTempVisiblePagesRange);
1778             int leftScreen = mTempVisiblePagesRange[0];
1779             int rightScreen = mTempVisiblePagesRange[1];
1780             if (leftScreen == rightScreen) {
1781                 // make sure we&#x27;re caching at least two pages always
1782                 if (rightScreen &lt; screenCount - 1) {
1783                     rightScreen++;
1784                 } else if (leftScreen &gt; 0) {
1785                     leftScreen--;
1786                 }
1787             }
1788 
1789             final CellLayout customScreen = mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID);
1790             for (int i = 0; i &lt; screenCount; i++) {
1791                 final CellLayout layout = (CellLayout) getPageAt(i);
1792 
1793                 // enable layers between left and right screen inclusive, except for the
1794                 // customScreen, which may animate its content during transitions.
1795                 boolean enableLayer = layout != customScreen &amp;&amp;
1796                         leftScreen &lt;= i &amp;&amp; i &lt;= rightScreen &amp;&amp; shouldDrawChild(layout);
1797                 layout.enableHardwareLayer(enableLayer);
1798             }
1799         }
1800     }
1801 
1802     public void buildPageHardwareLayers() {
1803         // force layers to be enabled just for the call to buildLayer
1804         updateChildrenLayersEnabled(true);
1805         if (getWindowToken() != null) {
1806             final int childCount = getChildCount();
1807             for (int i = 0; i &lt; childCount; i++) {
1808                 CellLayout cl = (CellLayout) getChildAt(i);
1809                 cl.buildHardwareLayer();
1810             }
1811         }
1812         updateChildrenLayersEnabled(false);
1813     }
1814 
1815     protected void onWallpaperTap(MotionEvent ev) {
1816         final int[] position = mTempCell;
1817         getLocationOnScreen(position);
1818 
1819         int pointerIndex = ev.getActionIndex();
1820         position[0] += (int) ev.getX(pointerIndex);
1821         position[1] += (int) ev.getY(pointerIndex);
1822 
1823         mWallpaperManager.sendWallpaperCommand(getWindowToken(),
1824                 ev.getAction() == MotionEvent.ACTION_UP
1825                         ? WallpaperManager.COMMAND_TAP : WallpaperManager.COMMAND_SECONDARY_TAP,
1826                 position[0], position[1], 0, null);
1827     }
1828 
1829     /*
1830      * This interpolator emulates the rate at which the perceived scale of an object changes
1831      * as its distance from a camera increases. When this interpolator is applied to a scale
1832      * animation on a view, it evokes the sense that the object is shrinking due to moving away
1833      * from the camera.
1834      */
1835     static class ZInterpolator implements TimeInterpolator {
1836         private float focalLength;
1837 
1838         public ZInterpolator(float foc) {
1839             focalLength = foc;
1840         }
1841 
1842         public float getInterpolation(float input) {
1843             return (1.0f - focalLength / (focalLength + input)) /
1844                 (1.0f - focalLength / (focalLength + 1.0f));
1845         }
1846     }
1847 
1848     /*
1849      * The exact reverse of ZInterpolator.
1850      */
1851     static class InverseZInterpolator implements TimeInterpolator {
1852         private ZInterpolator zInterpolator;
1853         public InverseZInterpolator(float foc) {
1854             zInterpolator = new ZInterpolator(foc);
1855         }
1856         public float getInterpolation(float input) {
1857             return 1 - zInterpolator.getInterpolation(1 - input);
1858         }
1859     }
1860 
1861     /*
1862      * ZInterpolator compounded with an ease-out.
1863      */
1864     static class ZoomOutInterpolator implements TimeInterpolator {
1865         private final DecelerateInterpolator decelerate = new DecelerateInterpolator(0.75f);
1866         private final ZInterpolator zInterpolator = new ZInterpolator(0.13f);
1867 
1868         public float getInterpolation(float input) {
1869             return decelerate.getInterpolation(zInterpolator.getInterpolation(input));
1870         }
1871     }
1872 
1873     /*
1874      * InvereZInterpolator compounded with an ease-out.
1875      */
1876     static class ZoomInInterpolator implements TimeInterpolator {
1877         private final InverseZInterpolator inverseZInterpolator = new InverseZInterpolator(0.35f);
1878         private final DecelerateInterpolator decelerate = new DecelerateInterpolator(3.0f);
1879 
1880         public float getInterpolation(float input) {
1881             return decelerate.getInterpolation(inverseZInterpolator.getInterpolation(input));
1882         }
1883     }
1884 
1885     private final ZoomInInterpolator mZoomInInterpolator = new ZoomInInterpolator();
1886 
1887     /*
1888     *
1889     * We call these methods (onDragStartedWithItemSpans/onDragStartedWithSize) whenever we
1890     * start a drag in Launcher, regardless of whether the drag has ever entered the Workspace
1891     *
1892     * These methods mark the appropriate pages as accepting drops (which alters their visual
1893     * appearance).
1894     *
1895     */
1896     public void onDragStartedWithItem(View v) {
1897         final Canvas canvas = new Canvas();
1898 
1899         // The outline is used to visualize where the item will land if dropped
1900         mDragOutline = createDragOutline(v, canvas, DRAG_BITMAP_PADDING);
1901     }
1902 
1903     public void onDragStartedWithItem(PendingAddItemInfo info, Bitmap b, boolean clipAlpha) {
1904         final Canvas canvas = new Canvas();
1905 
1906         int[] size = estimateItemSize(info.spanX, info.spanY, info, false);
1907 
1908         // The outline is used to visualize where the item will land if dropped
1909         mDragOutline = createDragOutline(b, canvas, DRAG_BITMAP_PADDING, size[0],
1910                 size[1], clipAlpha);
1911     }
1912 
1913     public void exitWidgetResizeMode() {
1914         DragLayer dragLayer = mLauncher.getDragLayer();
1915         dragLayer.clearAllResizeFrames();
1916     }
1917 
1918     private void initAnimationArrays() {
1919         final int childCount = getChildCount();
1920         if (mLastChildCount == childCount) return;
1921 
1922         mOldBackgroundAlphas = new float[childCount];
1923         mOldAlphas = new float[childCount];
1924         mNewBackgroundAlphas = new float[childCount];
1925         mNewAlphas = new float[childCount];
1926     }
1927 
1928     Animator getChangeStateAnimation(final State state, boolean animated) {
1929         return getChangeStateAnimation(state, animated, 0, -1);
1930     }
1931 
1932     @Override
1933     protected void getOverviewModePages(int[] range) {
1934         int start = numCustomPages();
1935         int end = getChildCount() - 1;
1936 
1937         range[0] = Math.max(0, Math.min(start, getChildCount() - 1));
1938         range[1] = Math.max(0,  end);
1939      }
1940 
1941     protected void onStartReordering() {
1942         super.onStartReordering();
1943         showOutlines();
1944         // Reordering handles its own animations, disable the automatic ones.
1945         disableLayoutTransitions();
1946     }
1947 
1948     protected void onEndReordering() {
1949         super.onEndReordering();
1950 
1951         hideOutlines();
1952         mScreenOrder.clear();
1953         int count = getChildCount();
1954         for (int i = 0; i &lt; count; i++) {
1955             CellLayout cl = ((CellLayout) getChildAt(i));
1956             mScreenOrder.add(getIdForScreen(cl));
1957         }
1958 
1959         mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
1960 
1961         // Re-enable auto layout transitions for page deletion.
1962         enableLayoutTransitions();
1963     }
1964 
1965     public boolean isInOverviewMode() {
1966         return mState == State.OVERVIEW;
1967     }
1968 
1969     public boolean enterOverviewMode() {
1970         if (mTouchState != TOUCH_STATE_REST) {
1971             return false;
1972         }
1973         enableOverviewMode(true, -1, true);
1974         return true;
1975     }
1976 
1977     public void exitOverviewMode(boolean animated) {
1978         exitOverviewMode(-1, animated);
1979     }
1980 
1981     public void exitOverviewMode(int snapPage, boolean animated) {
1982         enableOverviewMode(false, snapPage, animated);
1983     }
1984 
1985     private void enableOverviewMode(boolean enable, int snapPage, boolean animated) {
1986         State finalState = Workspace.State.OVERVIEW;
1987         if (!enable) {
1988             finalState = Workspace.State.NORMAL;
1989         }
1990 
1991         Animator workspaceAnim = getChangeStateAnimation(finalState, animated, 0, snapPage);
1992         if (workspaceAnim != null) {
1993             onTransitionPrepare();
1994             workspaceAnim.addListener(new AnimatorListenerAdapter() {
1995                 @Override
1996                 public void onAnimationEnd(Animator arg0) {
1997                     onTransitionEnd();
1998                 }
1999             });
2000             workspaceAnim.start();
2001         }
2002     }
2003 
2004     int getOverviewModeTranslationY() {
2005         LauncherAppState app = LauncherAppState.getInstance();
2006         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2007         Rect overviewBar = grid.getOverviewModeButtonBarRect();
2008 
2009         int availableHeight = getViewportHeight();
2010         int scaledHeight = (int) (mOverviewModeShrinkFactor * getNormalChildHeight());
2011         int offsetFromTopEdge = (availableHeight - scaledHeight) / 2;
2012         int offsetToCenterInOverview = (availableHeight - mInsets.top - overviewBar.height()
2013                 - scaledHeight) / 2;
2014 
2015         return -offsetFromTopEdge + mInsets.top + offsetToCenterInOverview;
2016     }
2017 
2018     boolean shouldVoiceButtonProxyBeVisible() {
2019         if (isOnOrMovingToCustomContent()) {
2020             return false;
2021         }
2022         if (mState != State.NORMAL) {
2023             return false;
2024         }
2025         return true;
2026     }
2027 
2028     public void updateInteractionForState() {
2029         if (mState != State.NORMAL) {
2030             mLauncher.onInteractionBegin();
2031         } else {
2032             mLauncher.onInteractionEnd();
2033         }
2034     }
2035 
2036     private void setState(State state) {
2037         mState = state;
2038         updateInteractionForState();
2039         updateAccessibilityFlags();
2040     }
2041 
2042     private void updateAccessibilityFlags() {
2043         int accessible = mState == State.NORMAL ?
2044                 ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES :
2045                 ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS;
2046         setImportantForAccessibility(accessible);
2047     }
2048 
2049     Animator getChangeStateAnimation(final State state, boolean animated, int delay, int snapPage) {
2050         if (mState == state) {
2051             return null;
2052         }
2053 
2054         // Initialize animation arrays for the first time if necessary
2055         initAnimationArrays();
2056 
2057         AnimatorSet anim = animated ? LauncherAnimUtils.createAnimatorSet() : null;
2058 
2059         final State oldState = mState;
2060         final boolean oldStateIsNormal = (oldState == State.NORMAL);
2061         final boolean oldStateIsSpringLoaded = (oldState == State.SPRING_LOADED);
2062         final boolean oldStateIsSmall = (oldState == State.SMALL);
2063         final boolean oldStateIsOverview = (oldState == State.OVERVIEW);
2064         setState(state);
2065         final boolean stateIsNormal = (state == State.NORMAL);
2066         final boolean stateIsSpringLoaded = (state == State.SPRING_LOADED);
2067         final boolean stateIsSmall = (state == State.SMALL);
2068         final boolean stateIsOverview = (state == State.OVERVIEW);
2069         float finalBackgroundAlpha = (stateIsSpringLoaded || stateIsOverview) ? 1.0f : 0f;
2070         float finalHotseatAndPageIndicatorAlpha = (stateIsOverview || stateIsSmall) ? 0f : 1f;
2071         float finalOverviewPanelAlpha = stateIsOverview ? 1f : 0f;
2072         float finalSearchBarAlpha = !stateIsNormal ? 0f : 1f;
2073         float finalWorkspaceTranslationY = stateIsOverview ? getOverviewModeTranslationY() : 0;
2074 
2075         boolean workspaceToAllApps = (oldStateIsNormal &amp;&amp; stateIsSmall);
2076         boolean allAppsToWorkspace = (oldStateIsSmall &amp;&amp; stateIsNormal);
2077         boolean workspaceToOverview = (oldStateIsNormal &amp;&amp; stateIsOverview);
2078         boolean overviewToWorkspace = (oldStateIsOverview &amp;&amp; stateIsNormal);
2079 
2080         mNewScale = 1.0f;
2081 
2082         if (oldStateIsOverview) {
2083             disableFreeScroll(snapPage);
2084         } else if (stateIsOverview) {
2085             enableFreeScroll();
2086         }
2087 
2088         if (state != State.NORMAL) {
2089             if (stateIsSpringLoaded) {
2090                 mNewScale = mSpringLoadedShrinkFactor;
2091             } else if (stateIsOverview) {
2092                 mNewScale = mOverviewModeShrinkFactor;
2093             } else if (stateIsSmall){
2094                 mNewScale = mOverviewModeShrinkFactor - 0.3f;
2095             }
2096             if (workspaceToAllApps) {
2097                 updateChildrenLayersEnabled(false);
2098             }
2099         }
2100 
2101         final int duration;
2102         if (workspaceToAllApps) {
2103             duration = getResources().getInteger(R.integer.config_workspaceUnshrinkTime);
2104         } else if (workspaceToOverview || overviewToWorkspace) {
2105             duration = getResources().getInteger(R.integer.config_overviewTransitionTime);
2106         } else {
2107             duration = getResources().getInteger(R.integer.config_appsCustomizeWorkspaceShrinkTime);
2108         }
2109 
2110         for (int i = 0; i &lt; getChildCount(); i++) {
2111             final CellLayout cl = (CellLayout) getChildAt(i);
2112             boolean isCurrentPage = (i == getNextPage());
2113             float initialAlpha = cl.getShortcutsAndWidgets().getAlpha();
2114             float finalAlpha;
2115             if (stateIsSmall) {
2116                 finalAlpha = 0f;
2117             } else if (stateIsNormal &amp;&amp; mWorkspaceFadeInAdjacentScreens) {
2118 
2119                 finalAlpha = (i == getNextPage() || i &lt; numCustomPages()) ? 1f : 0f;
2120             } else {
2121                 finalAlpha = 1f;
2122             }
2123 
2124             // If we are animating to/from the small state, then hide the side pages and fade the
2125             // current page in
2126             if (!mIsSwitchingState) {
2127                 if (workspaceToAllApps || allAppsToWorkspace) {
2128                     if (allAppsToWorkspace &amp;&amp; isCurrentPage) {
2129                         initialAlpha = 0f;
2130                     } else if (!isCurrentPage) {
2131                         initialAlpha = finalAlpha = 0f;
2132                     }
2133                     cl.setShortcutAndWidgetAlpha(initialAlpha);
2134                 }
2135             }
2136 
2137             mOldAlphas[i] = initialAlpha;
2138             mNewAlphas[i] = finalAlpha;
2139             if (animated) {
2140                 mOldBackgroundAlphas[i] = cl.getBackgroundAlpha();
2141                 mNewBackgroundAlphas[i] = finalBackgroundAlpha;
2142             } else {
2143                 cl.setBackgroundAlpha(finalBackgroundAlpha);
2144                 cl.setShortcutAndWidgetAlpha(finalAlpha);
2145             }
2146         }
2147 
2148         final View searchBar = mLauncher.getQsbBar();
2149         final View overviewPanel = mLauncher.getOverviewPanel();
2150         final View hotseat = mLauncher.getHotseat();
2151         if (animated) {
2152             anim.setDuration(duration);
2153             LauncherViewPropertyAnimator scale = new LauncherViewPropertyAnimator(this);
2154             scale.scaleX(mNewScale)
2155                 .scaleY(mNewScale)
2156                 .translationY(finalWorkspaceTranslationY)
2157                 .setInterpolator(mZoomInInterpolator);
2158             anim.play(scale);
2159             for (int index = 0; index &lt; getChildCount(); index++) {
2160                 final int i = index;
2161                 final CellLayout cl = (CellLayout) getChildAt(i);
2162                 float currentAlpha = cl.getShortcutsAndWidgets().getAlpha();
2163                 if (mOldAlphas[i] == 0 &amp;&amp; mNewAlphas[i] == 0) {
2164                     cl.setBackgroundAlpha(mNewBackgroundAlphas[i]);
2165                     cl.setShortcutAndWidgetAlpha(mNewAlphas[i]);
2166                 } else {
2167                     if (mOldAlphas[i] != mNewAlphas[i] || currentAlpha != mNewAlphas[i]) {
2168                         LauncherViewPropertyAnimator alphaAnim =
2169                             new LauncherViewPropertyAnimator(cl.getShortcutsAndWidgets());
2170                         alphaAnim.alpha(mNewAlphas[i])
2171                             .setInterpolator(mZoomInInterpolator);
2172                         anim.play(alphaAnim);
2173                     }
2174                     if (mOldBackgroundAlphas[i] != 0 ||
2175                         mNewBackgroundAlphas[i] != 0) {
2176                         ValueAnimator bgAnim =
2177                                 LauncherAnimUtils.ofFloat(cl, 0f, 1f);
2178                         bgAnim.setInterpolator(mZoomInInterpolator);
2179                         bgAnim.addUpdateListener(new LauncherAnimatorUpdateListener() {
2180                                 public void onAnimationUpdate(float a, float b) {
2181                                     cl.setBackgroundAlpha(
2182                                             a * mOldBackgroundAlphas[i] +
2183                                             b * mNewBackgroundAlphas[i]);
2184                                 }
2185                             });
2186                         anim.play(bgAnim);
2187                     }
2188                 }
2189             }
2190             ObjectAnimator pageIndicatorAlpha = null;
2191             if (getPageIndicator() != null) {
2192                 pageIndicatorAlpha = ObjectAnimator.ofFloat(getPageIndicator(), &quot;alpha&quot;,
2193                         finalHotseatAndPageIndicatorAlpha);
2194             }
2195             ObjectAnimator hotseatAlpha = ObjectAnimator.ofFloat(hotseat, &quot;alpha&quot;,
2196                     finalHotseatAndPageIndicatorAlpha);
2197             ObjectAnimator searchBarAlpha = ObjectAnimator.ofFloat(searchBar,
2198                     &quot;alpha&quot;, finalSearchBarAlpha);
2199             ObjectAnimator overviewPanelAlpha = ObjectAnimator.ofFloat(overviewPanel,
2200                     &quot;alpha&quot;, finalOverviewPanelAlpha);
2201 
2202             overviewPanelAlpha.addListener(new AlphaUpdateListener(overviewPanel));
2203             hotseatAlpha.addListener(new AlphaUpdateListener(hotseat));
2204             searchBarAlpha.addListener(new AlphaUpdateListener(searchBar));
2205 
2206             if (workspaceToOverview) {
2207                 hotseatAlpha.setInterpolator(new DecelerateInterpolator(2));
2208             } else if (overviewToWorkspace) {
2209                 overviewPanelAlpha.setInterpolator(new DecelerateInterpolator(2));
2210             }
2211 
2212             if (getPageIndicator() != null) {
2213                 pageIndicatorAlpha.addListener(new AlphaUpdateListener(getPageIndicator()));
2214             }
2215 
2216             anim.play(overviewPanelAlpha);
2217             anim.play(hotseatAlpha);
2218             anim.play(searchBarAlpha);
2219             anim.play(pageIndicatorAlpha);
2220             anim.setStartDelay(delay);
2221         } else {
2222             overviewPanel.setAlpha(finalOverviewPanelAlpha);
2223             AlphaUpdateListener.updateVisibility(overviewPanel);
2224             hotseat.setAlpha(finalHotseatAndPageIndicatorAlpha);
2225             AlphaUpdateListener.updateVisibility(hotseat);
2226             if (getPageIndicator() != null) {
2227                 getPageIndicator().setAlpha(finalHotseatAndPageIndicatorAlpha);
2228                 AlphaUpdateListener.updateVisibility(getPageIndicator());
2229             }
2230             searchBar.setAlpha(finalSearchBarAlpha);
2231             AlphaUpdateListener.updateVisibility(searchBar);
2232             updateCustomContentVisibility();
2233             setScaleX(mNewScale);
2234             setScaleY(mNewScale);
2235             setTranslationY(finalWorkspaceTranslationY);
2236         }
2237         mLauncher.updateVoiceButtonProxyVisible(false);
2238 
2239         if (stateIsSpringLoaded) {
2240             // Right now we&#x27;re covered by Apps Customize
2241             // Show the background gradient immediately, so the gradient will
2242             // be showing once AppsCustomize disappears
2243             animateBackgroundGradient(getResources().getInteger(
2244                     R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100f, false);
2245         } else if (stateIsOverview) {
2246             animateBackgroundGradient(getResources().getInteger(
2247                     R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100f, true);
2248         } else {
2249             // Fade the background gradient away
2250             animateBackgroundGradient(0f, animated);
2251         }
2252         return anim;
2253     }
2254 
2255     static class AlphaUpdateListener implements AnimatorUpdateListener, AnimatorListener {
2256         View view;
2257         public AlphaUpdateListener(View v) {
2258             view = v;
2259         }
2260 
2261         @Override
2262         public void onAnimationUpdate(ValueAnimator arg0) {
2263             updateVisibility(view);
2264         }
2265 
2266         public static void updateVisibility(View view) {
2267             // We want to avoid the extra layout pass by setting the views to GONE unless
2268             // accessibility is on, in which case not setting them to GONE causes a glitch.
2269             int invisibleState = sAccessibilityEnabled ? GONE : INVISIBLE;
2270             if (view.getAlpha() &lt; ALPHA_CUTOFF_THRESHOLD &amp;&amp; view.getVisibility() != invisibleState) {
2271                 view.setVisibility(invisibleState);
2272             } else if (view.getAlpha() &gt; ALPHA_CUTOFF_THRESHOLD
2273                     &amp;&amp; view.getVisibility() != VISIBLE) {
2274                 view.setVisibility(VISIBLE);
2275             }
2276         }
2277 
2278         @Override
2279         public void onAnimationCancel(Animator arg0) {
2280         }
2281 
2282         @Override
2283         public void onAnimationEnd(Animator arg0) {
2284             updateVisibility(view);
2285         }
2286 
2287         @Override
2288         public void onAnimationRepeat(Animator arg0) {
2289         }
2290 
2291         @Override
2292         public void onAnimationStart(Animator arg0) {
2293             // We want the views to be visible for animation, so fade-in/out is visible
2294             view.setVisibility(VISIBLE);
2295         }
2296     }
2297 
2298     @Override
2299     public void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace) {
2300         onTransitionPrepare();
2301     }
2302 
2303     @Override
2304     public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
2305     }
2306 
2307     @Override
2308     public void onLauncherTransitionStep(Launcher l, float t) {
2309         mTransitionProgress = t;
2310     }
2311 
2312     @Override
2313     public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
2314         onTransitionEnd();
2315     }
2316 
2317     private void onTransitionPrepare() {
2318         mIsSwitchingState = true;
2319 
2320         // Invalidate here to ensure that the pages are rendered during the state change transition.
2321         invalidate();
2322 
2323         updateChildrenLayersEnabled(false);
2324         hideCustomContentIfNecessary();
2325     }
2326 
2327     void updateCustomContentVisibility() {
2328         int visibility = mState == Workspace.State.NORMAL ? VISIBLE : INVISIBLE;
2329         if (hasCustomContent()) {
2330             mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(visibility);
2331         }
2332     }
2333 
2334     void showCustomContentIfNecessary() {
2335         boolean show  = mState == Workspace.State.NORMAL;
2336         if (show &amp;&amp; hasCustomContent()) {
2337             mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(VISIBLE);
2338         }
2339     }
2340 
2341     void hideCustomContentIfNecessary() {
2342         boolean hide  = mState != Workspace.State.NORMAL;
2343         if (hide &amp;&amp; hasCustomContent()) {
2344             mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(INVISIBLE);
2345         }
2346     }
2347 
2348     private void onTransitionEnd() {
2349         mIsSwitchingState = false;
2350         updateChildrenLayersEnabled(false);
2351         // The code in getChangeStateAnimation to determine initialAlpha and finalAlpha will ensure
2352         // ensure that only the current page is visible during (and subsequently, after) the
2353         // transition animation.  If fade adjacent pages is disabled, then re-enable the page
2354         // visibility after the transition animation.
2355         if (!mWorkspaceFadeInAdjacentScreens) {
2356             for (int i = 0; i &lt; getChildCount(); i++) {
2357                 final CellLayout cl = (CellLayout) getChildAt(i);
2358                 cl.setShortcutAndWidgetAlpha(1f);
2359             }
2360         } else {
2361             for (int i = 0; i &lt; numCustomPages(); i++) {
2362                 final CellLayout cl = (CellLayout) getChildAt(i);
2363                 cl.setShortcutAndWidgetAlpha(1f);
2364             }
2365         }
2366         showCustomContentIfNecessary();
2367     }
2368 
2369     @Override
2370     public View getContent() {
2371         return this;
2372     }
2373 
2374     /**
2375      * Draw the View v into the given Canvas.
2376      *
2377      * @param v the view to draw
2378      * @param destCanvas the canvas to draw on
2379      * @param padding the horizontal and vertical padding to use when drawing
2380      */
2381     private void drawDragView(View v, Canvas destCanvas, int padding, boolean pruneToDrawable) {
2382         final Rect clipRect = mTempRect;
2383         v.getDrawingRect(clipRect);
2384 
2385         boolean textVisible = false;
2386 
2387         destCanvas.save();
2388         if (v instanceof TextView &amp;&amp; pruneToDrawable) {
2389             Drawable d = ((TextView) v).getCompoundDrawables()[1];
2390             clipRect.set(0, 0, d.getIntrinsicWidth() + padding, d.getIntrinsicHeight() + padding);
2391             destCanvas.translate(padding / 2, padding / 2);
2392             d.draw(destCanvas);
2393         } else {
2394             if (v instanceof FolderIcon) {
2395                 // For FolderIcons the text can bleed into the icon area, and so we need to
2396                 // hide the text completely (which can&#x27;t be achieved by clipping).
2397                 if (((FolderIcon) v).getTextVisible()) {
2398                     ((FolderIcon) v).setTextVisible(false);
2399                     textVisible = true;
2400                 }
2401             } else if (v instanceof BubbleTextView) {
2402                 final BubbleTextView tv = (BubbleTextView) v;
2403                 clipRect.bottom = tv.getExtendedPaddingTop() - (int) BubbleTextView.PADDING_V +
2404                         tv.getLayout().getLineTop(0);
2405             } else if (v instanceof TextView) {
2406                 final TextView tv = (TextView) v;
2407                 clipRect.bottom = tv.getExtendedPaddingTop() - tv.getCompoundDrawablePadding() +
2408                         tv.getLayout().getLineTop(0);
2409             }
2410             destCanvas.translate(-v.getScrollX() + padding / 2, -v.getScrollY() + padding / 2);
2411             destCanvas.clipRect(clipRect, Op.REPLACE);
2412             v.draw(destCanvas);
2413 
2414             // Restore text visibility of FolderIcon if necessary
2415             if (textVisible) {
2416                 ((FolderIcon) v).setTextVisible(true);
2417             }
2418         }
2419         destCanvas.restore();
2420     }
2421 
2422     /**
2423      * Returns a new bitmap to show when the given View is being dragged around.
2424      * Responsibility for the bitmap is transferred to the caller.
2425      */
2426     public Bitmap createDragBitmap(View v, Canvas canvas, int padding) {
2427         Bitmap b;
2428 
2429         if (v instanceof TextView) {
2430             Drawable d = ((TextView) v).getCompoundDrawables()[1];
2431             b = Bitmap.createBitmap(d.getIntrinsicWidth() + padding,
2432                     d.getIntrinsicHeight() + padding, Bitmap.Config.ARGB_8888);
2433         } else {
2434             b = Bitmap.createBitmap(
2435                     v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
2436         }
2437 
2438         canvas.setBitmap(b);
2439         drawDragView(v, canvas, padding, true);
2440         canvas.setBitmap(null);
2441 
2442         return b;
2443     }
2444 
2445     /**
2446      * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
2447      * Responsibility for the bitmap is transferred to the caller.
2448      */
2449     private Bitmap createDragOutline(View v, Canvas canvas, int padding) {
2450         final int outlineColor = getResources().getColor(R.color.outline_color);
2451         final Bitmap b = Bitmap.createBitmap(
2452                 v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
2453 
2454         canvas.setBitmap(b);
2455         drawDragView(v, canvas, padding, true);
2456         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
2457         canvas.setBitmap(null);
2458         return b;
2459     }
2460 
2461     /**
2462      * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
2463      * Responsibility for the bitmap is transferred to the caller.
2464      */
2465     private Bitmap createDragOutline(Bitmap orig, Canvas canvas, int padding, int w, int h,
2466             boolean clipAlpha) {
2467         final int outlineColor = getResources().getColor(R.color.outline_color);
2468         final Bitmap b = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
2469         canvas.setBitmap(b);
2470 
2471         Rect src = new Rect(0, 0, orig.getWidth(), orig.getHeight());
2472         float scaleFactor = Math.min((w - padding) / (float) orig.getWidth(),
2473                 (h - padding) / (float) orig.getHeight());
2474         int scaledWidth = (int) (scaleFactor * orig.getWidth());
2475         int scaledHeight = (int) (scaleFactor * orig.getHeight());
2476         Rect dst = new Rect(0, 0, scaledWidth, scaledHeight);
2477 
2478         // center the image
2479         dst.offset((w - scaledWidth) / 2, (h - scaledHeight) / 2);
2480 
2481         canvas.drawBitmap(orig, src, dst, null);
2482         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor,
2483                 clipAlpha);
2484         canvas.setBitmap(null);
2485 
2486         return b;
2487     }
2488 
2489     void startDrag(CellLayout.CellInfo cellInfo) {
2490         View child = cellInfo.cell;
2491 
2492         // Make sure the drag was started by a long press as opposed to a long click.
2493         if (!child.isInTouchMode()) {
2494             return;
2495         }
2496 
2497         mDragInfo = cellInfo;
2498         child.setVisibility(INVISIBLE);
2499         CellLayout layout = (CellLayout) child.getParent().getParent();
2500         layout.prepareChildForDrag(child);
2501 
2502         child.clearFocus();
2503         child.setPressed(false);
2504 
2505         final Canvas canvas = new Canvas();
2506 
2507         // The outline is used to visualize where the item will land if dropped
2508         mDragOutline = createDragOutline(child, canvas, DRAG_BITMAP_PADDING);
2509         beginDragShared(child, this);
2510     }
2511 
2512     public void beginDragShared(View child, DragSource source) {
2513         // The drag bitmap follows the touch point around on the screen
2514         final Bitmap b = createDragBitmap(child, new Canvas(), DRAG_BITMAP_PADDING);
2515 
2516         final int bmpWidth = b.getWidth();
2517         final int bmpHeight = b.getHeight();
2518 
2519         float scale = mLauncher.getDragLayer().getLocationInDragLayer(child, mTempXY);
2520         int dragLayerX =
2521                 Math.round(mTempXY[0] - (bmpWidth - scale * child.getWidth()) / 2);
2522         int dragLayerY =
2523                 Math.round(mTempXY[1] - (bmpHeight - scale * bmpHeight) / 2
2524                         - DRAG_BITMAP_PADDING / 2);
2525 
2526         LauncherAppState app = LauncherAppState.getInstance();
2527         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2528         Point dragVisualizeOffset = null;
2529         Rect dragRect = null;
2530         if (child instanceof BubbleTextView || child instanceof PagedViewIcon) {
2531             int iconSize = grid.iconSizePx;
2532             int top = child.getPaddingTop();
2533             int left = (bmpWidth - iconSize) / 2;
2534             int right = left + iconSize;
2535             int bottom = top + iconSize;
2536             dragLayerY += top;
2537             // Note: The drag region is used to calculate drag layer offsets, but the
2538             // dragVisualizeOffset in addition to the dragRect (the size) to position the outline.
2539             dragVisualizeOffset = new Point(-DRAG_BITMAP_PADDING / 2, DRAG_BITMAP_PADDING / 2);
2540             dragRect = new Rect(left, top, right, bottom);
2541         } else if (child instanceof FolderIcon) {
2542             int previewSize = grid.folderIconSizePx;
2543             dragRect = new Rect(0, child.getPaddingTop(), child.getWidth(), previewSize);
2544         }
2545 
2546         // Clear the pressed state if necessary
2547         if (child instanceof BubbleTextView) {
2548             BubbleTextView icon = (BubbleTextView) child;
2549             icon.clearPressedOrFocusedBackground();
2550         }
2551 
2552 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2553         if (child.getTag() == null || !(child.getTag() instanceof ItemInfo)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2554             String msg = &quot;Drag started with a view that has no tag set. This &quot;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2555                     + &quot;will cause a crash (issue 11627249) down the line. &quot;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2556                     + &quot;View: &quot; + child + &quot;  tag: &quot; + child.getTag();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2557             throw new IllegalStateException(msg);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2558         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2559 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2560         mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),</span>
2561 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2562         mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2563                 DragController.DRAG_ACTION_MOVE, dragVisualizeOffset, dragRect, scale);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2564 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2565         if (child.getParent() instanceof ShortcutAndWidgetContainer) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2566             mDragSourceInternal = (ShortcutAndWidgetContainer) child.getParent();</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2567         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2568 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">2569         b.recycle();</span>
2570 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2571         DragView dv = mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),</span>
2572 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
2573                 DragController.DRAG_ACTION_MOVE, dragVisualizeOffset, dragRect, scale);
2574         dv.setIntrinsicIconScaleFactor(source.getIntrinsicIconScaleFactor());
2575 
2576         if (child.getParent() instanceof ShortcutAndWidgetContainer) {
2577             mDragSourceInternal = (ShortcutAndWidgetContainer) child.getParent();
2578         }
2579 
2580         b.recycle();
2581     }
2582 
2583     void addApplicationShortcut(ShortcutInfo info, CellLayout target, long container, long screenId,
2584             int cellX, int cellY, boolean insertAtFirst, int intersectX, int intersectY) {
2585         View view = mLauncher.createShortcut(R.layout.application, target, (ShortcutInfo) info);
2586 
2587         final int[] cellXY = new int[2];
2588         target.findCellForSpanThatIntersects(cellXY, 1, 1, intersectX, intersectY);
2589         addInScreen(view, container, screenId, cellXY[0], cellXY[1], 1, 1, insertAtFirst);
2590 
2591         LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screenId, cellXY[0],
2592                 cellXY[1]);
2593     }
2594 
2595     public boolean transitionStateShouldAllowDrop() {
2596         return ((!isSwitchingState() || mTransitionProgress &gt; 0.5f) &amp;&amp; mState != State.SMALL);
2597     }
2598 
2599     /**
2600      * {@inheritDoc}
2601      */
2602     public boolean acceptDrop(DragObject d) {
2603         // If it&#x27;s an external drop (e.g. from All Apps), check if it should be accepted
2604         CellLayout dropTargetLayout = mDropToLayout;
2605         if (d.dragSource != this) {
2606             // Don&#x27;t accept the drop if we&#x27;re not over a screen at time of drop
2607             if (dropTargetLayout == null) {
2608                 return false;
2609             }
2610             if (!transitionStateShouldAllowDrop()) return false;
2611 
2612             mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
2613                     d.dragView, mDragViewVisualCenter);
2614 
2615             // We want the point to be mapped to the dragTarget.
2616             if (mLauncher.isHotseatLayout(dropTargetLayout)) {
2617                 mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
2618             } else {
2619                 mapPointFromSelfToChild(dropTargetLayout, mDragViewVisualCenter, null);
2620             }
2621 
2622             int spanX = 1;
2623             int spanY = 1;
2624             if (mDragInfo != null) {
2625                 final CellLayout.CellInfo dragCellInfo = mDragInfo;
2626                 spanX = dragCellInfo.spanX;
2627                 spanY = dragCellInfo.spanY;
2628             } else {
2629                 final ItemInfo dragInfo = (ItemInfo) d.dragInfo;
2630                 spanX = dragInfo.spanX;
2631                 spanY = dragInfo.spanY;
2632             }
2633 
2634             int minSpanX = spanX;
2635             int minSpanY = spanY;
2636             if (d.dragInfo instanceof PendingAddWidgetInfo) {
2637                 minSpanX = ((PendingAddWidgetInfo) d.dragInfo).minSpanX;
2638                 minSpanY = ((PendingAddWidgetInfo) d.dragInfo).minSpanY;
2639             }
2640 
2641             mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
2642                     (int) mDragViewVisualCenter[1], minSpanX, minSpanY, dropTargetLayout,
2643                     mTargetCell);
2644             float distance = dropTargetLayout.getDistanceFromCell(mDragViewVisualCenter[0],
2645                     mDragViewVisualCenter[1], mTargetCell);
2646             if (willCreateUserFolder((ItemInfo) d.dragInfo, dropTargetLayout,
2647                     mTargetCell, distance, true)) {
2648                 return true;
2649             }
2650             if (willAddToExistingUserFolder((ItemInfo) d.dragInfo, dropTargetLayout,
2651                     mTargetCell, distance)) {
2652                 return true;
2653             }
2654 
2655             int[] resultSpan = new int[2];
2656             mTargetCell = dropTargetLayout.createArea((int) mDragViewVisualCenter[0],
2657                     (int) mDragViewVisualCenter[1], minSpanX, minSpanY, spanX, spanY,
2658                     null, mTargetCell, resultSpan, CellLayout.MODE_ACCEPT_DROP);
2659             boolean foundCell = mTargetCell[0] &gt;= 0 &amp;&amp; mTargetCell[1] &gt;= 0;
2660 
2661             // Don&#x27;t accept the drop if there&#x27;s no room for the item
2662             if (!foundCell) {
2663                 // Don&#x27;t show the message if we are dropping on the AllApps button and the hotseat
2664                 // is full
2665                 boolean isHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
2666                 if (mTargetCell != null &amp;&amp; isHotseat) {
2667                     Hotseat hotseat = mLauncher.getHotseat();
2668                     if (hotseat.isAllAppsButtonRank(
2669                             hotseat.getOrderInHotseat(mTargetCell[0], mTargetCell[1]))) {
2670                         return false;
2671                     }
2672                 }
2673 
2674                 mLauncher.showOutOfSpaceMessage(isHotseat);
2675                 return false;
2676             }
2677         }
2678 
2679         long screenId = getIdForScreen(dropTargetLayout);
2680         if (screenId == EXTRA_EMPTY_SCREEN_ID) {
2681             commitExtraEmptyScreen();
2682         }
2683 
2684         return true;
2685     }
2686 
2687     boolean willCreateUserFolder(ItemInfo info, CellLayout target, int[] targetCell, float
2688             distance, boolean considerTimeout) {
2689         if (distance &gt; mMaxDistanceForFolderCreation) return false;
2690         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2691 
2692         if (dropOverView != null) {
2693             CellLayout.LayoutParams lp = (CellLayout.LayoutParams) dropOverView.getLayoutParams();
2694             if (lp.useTmpCoords &amp;&amp; (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.tmpCellY)) {
2695                 return false;
2696             }
2697         }
2698 
2699         boolean hasntMoved = false;
2700         if (mDragInfo != null) {
2701             hasntMoved = dropOverView == mDragInfo.cell;
2702         }
2703 
2704         if (dropOverView == null || hasntMoved || (considerTimeout &amp;&amp; !mCreateUserFolderOnDrop)) {
2705             return false;
2706         }
2707 
2708         boolean aboveShortcut = (dropOverView.getTag() instanceof ShortcutInfo);
2709         boolean willBecomeShortcut =
2710                 (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
2711                 info.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT);
2712 
2713         return (aboveShortcut &amp;&amp; willBecomeShortcut);
2714     }
2715 
2716     boolean willAddToExistingUserFolder(Object dragInfo, CellLayout target, int[] targetCell,
2717             float distance) {
2718         if (distance &gt; mMaxDistanceForFolderCreation) return false;
2719         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2720 
2721         if (dropOverView != null) {
2722             CellLayout.LayoutParams lp = (CellLayout.LayoutParams) dropOverView.getLayoutParams();
2723             if (lp.useTmpCoords &amp;&amp; (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.tmpCellY)) {
2724                 return false;
2725             }
2726         }
2727 
2728         if (dropOverView instanceof FolderIcon) {
2729             FolderIcon fi = (FolderIcon) dropOverView;
2730             if (fi.acceptDrop(dragInfo)) {
2731                 return true;
2732             }
2733         }
2734         return false;
2735     }
2736 
2737     boolean createUserFolderIfNecessary(View newView, long container, CellLayout target,
2738             int[] targetCell, float distance, boolean external, DragView dragView,
2739             Runnable postAnimationRunnable) {
2740         if (distance &gt; mMaxDistanceForFolderCreation) return false;
2741         View v = target.getChildAt(targetCell[0], targetCell[1]);
2742 
2743         boolean hasntMoved = false;
2744         if (mDragInfo != null) {
2745             CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2746             hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2747                     mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2748         }
2749 
2750         if (v == null || hasntMoved || !mCreateUserFolderOnDrop) return false;
2751         mCreateUserFolderOnDrop = false;
2752         final long screenId = (targetCell == null) ? mDragInfo.screenId : getIdForScreen(target);
2753 
2754         boolean aboveShortcut = (v.getTag() instanceof ShortcutInfo);
2755         boolean willBecomeShortcut = (newView.getTag() instanceof ShortcutInfo);
2756 
2757         if (aboveShortcut &amp;&amp; willBecomeShortcut) {
2758             ShortcutInfo sourceInfo = (ShortcutInfo) newView.getTag();
2759             ShortcutInfo destInfo = (ShortcutInfo) v.getTag();
2760             // if the drag started here, we need to remove it from the workspace
2761             if (!external) {
2762                 getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2763             }
2764 
2765             Rect folderLocation = new Rect();
2766             float scale = mLauncher.getDragLayer().getDescendantRectRelativeToSelf(v, folderLocation);
2767             target.removeView(v);
2768 
2769             FolderIcon fi =
2770                 mLauncher.addFolder(target, container, screenId, targetCell[0], targetCell[1]);
2771             destInfo.cellX = -1;
2772             destInfo.cellY = -1;
2773             sourceInfo.cellX = -1;
2774             sourceInfo.cellY = -1;
2775 
2776             // If the dragView is null, we can&#x27;t animate
2777             boolean animate = dragView != null;
2778             if (animate) {
2779                 fi.performCreateAnimation(destInfo, v, sourceInfo, dragView, folderLocation, scale,
2780                         postAnimationRunnable);
2781             } else {
2782                 fi.addItem(destInfo);
2783                 fi.addItem(sourceInfo);
2784             }
2785             return true;
2786         }
2787         return false;
2788     }
2789 
2790     boolean addToExistingFolderIfNecessary(View newView, CellLayout target, int[] targetCell,
2791             float distance, DragObject d, boolean external) {
2792         if (distance &gt; mMaxDistanceForFolderCreation) return false;
2793 
2794         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2795         if (!mAddToExistingFolderOnDrop) return false;
2796         mAddToExistingFolderOnDrop = false;
2797 
2798         if (dropOverView instanceof FolderIcon) {
2799             FolderIcon fi = (FolderIcon) dropOverView;
2800             if (fi.acceptDrop(d.dragInfo)) {
2801                 fi.onDrop(d);
2802 
2803                 // if the drag started here, we need to remove it from the workspace
2804                 if (!external) {
2805                     getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2806                 }
2807                 return true;
2808             }
2809         }
2810         return false;
2811     }
2812 
2813     public void onDrop(final DragObject d) {
2814         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView,
2815                 mDragViewVisualCenter);
2816 
2817         CellLayout dropTargetLayout = mDropToLayout;
2818 
2819         // We want the point to be mapped to the dragTarget.
2820         if (dropTargetLayout != null) {
2821             if (mLauncher.isHotseatLayout(dropTargetLayout)) {
2822                 mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
2823             } else {
2824                 mapPointFromSelfToChild(dropTargetLayout, mDragViewVisualCenter, null);
2825             }
2826         }
2827 
2828         int snapScreen = -1;
2829         boolean resizeOnDrop = false;
2830         if (d.dragSource != this) {
2831             final int[] touchXY = new int[] { (int) mDragViewVisualCenter[0],
2832                     (int) mDragViewVisualCenter[1] };
2833             onDropExternal(touchXY, d.dragInfo, dropTargetLayout, false, d);
2834         } else if (mDragInfo != null) {
2835             final View cell = mDragInfo.cell;
2836 
2837             Runnable resizeRunnable = null;
2838             if (dropTargetLayout != null &amp;&amp; !d.cancelled) {
2839                 // Move internally
2840                 boolean hasMovedLayouts = (getParentCellLayoutForView(cell) != dropTargetLayout);
2841                 boolean hasMovedIntoHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
2842                 long container = hasMovedIntoHotseat ?
2843                         LauncherSettings.Favorites.CONTAINER_HOTSEAT :
2844                         LauncherSettings.Favorites.CONTAINER_DESKTOP;
2845                 long screenId = (mTargetCell[0] &lt; 0) ?
2846                         mDragInfo.screenId : getIdForScreen(dropTargetLayout);
2847                 int spanX = mDragInfo != null ? mDragInfo.spanX : 1;
2848                 int spanY = mDragInfo != null ? mDragInfo.spanY : 1;
2849                 // First we find the cell nearest to point at which the item is
2850                 // dropped, without any consideration to whether there is an item there.
2851 
2852                 mTargetCell = findNearestArea((int) mDragViewVisualCenter[0], (int)
2853                         mDragViewVisualCenter[1], spanX, spanY, dropTargetLayout, mTargetCell);
2854                 float distance = dropTargetLayout.getDistanceFromCell(mDragViewVisualCenter[0],
2855                         mDragViewVisualCenter[1], mTargetCell);
2856 
2857                 // If the item being dropped is a shortcut and the nearest drop
2858                 // cell also contains a shortcut, then create a folder with the two shortcuts.
2859                 if (!mInScrollArea &amp;&amp; createUserFolderIfNecessary(cell, container,
2860                         dropTargetLayout, mTargetCell, distance, false, d.dragView, null)) {
2861                     removeExtraEmptyScreen(true, null, 0, true);
2862                     return;
2863                 }
2864 
2865                 if (addToExistingFolderIfNecessary(cell, dropTargetLayout, mTargetCell,
2866                         distance, d, false)) {
2867                     removeExtraEmptyScreen(true, null, 0, true);
2868                     return;
2869                 }
2870 
2871                 // Aside from the special case where we&#x27;re dropping a shortcut onto a shortcut,
2872                 // we need to find the nearest cell location that is vacant
2873                 ItemInfo item = (ItemInfo) d.dragInfo;
2874                 int minSpanX = item.spanX;
2875                 int minSpanY = item.spanY;
2876                 if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
2877                     minSpanX = item.minSpanX;
2878                     minSpanY = item.minSpanY;
2879                 }
2880 
2881                 int[] resultSpan = new int[2];
2882                 mTargetCell = dropTargetLayout.createArea((int) mDragViewVisualCenter[0],
2883                         (int) mDragViewVisualCenter[1], minSpanX, minSpanY, spanX, spanY, cell,
2884                         mTargetCell, resultSpan, CellLayout.MODE_ON_DROP);
2885 
2886                 boolean foundCell = mTargetCell[0] &gt;= 0 &amp;&amp; mTargetCell[1] &gt;= 0;
2887 
2888                 // if the widget resizes on drop
2889                 if (foundCell &amp;&amp; (cell instanceof AppWidgetHostView) &amp;&amp;
2890                         (resultSpan[0] != item.spanX || resultSpan[1] != item.spanY)) {
2891                     resizeOnDrop = true;
2892                     item.spanX = resultSpan[0];
2893                     item.spanY = resultSpan[1];
2894                     AppWidgetHostView awhv = (AppWidgetHostView) cell;
2895                     AppWidgetResizeFrame.updateWidgetSizeRanges(awhv, mLauncher, resultSpan[0],
2896                             resultSpan[1]);
2897                 }
2898 
2899                 if (getScreenIdForPageIndex(mCurrentPage) != screenId &amp;&amp; !hasMovedIntoHotseat) {
2900                     snapScreen = getPageIndexForScreenId(screenId);
2901                     snapToPage(snapScreen);
2902                 }
2903 
2904                 if (foundCell) {
2905                     final ItemInfo info = (ItemInfo) cell.getTag();
2906                     if (hasMovedLayouts) {
2907                         // Reparent the view
2908                         getParentCellLayoutForView(cell).removeView(cell);
2909                         addInScreen(cell, container, screenId, mTargetCell[0], mTargetCell[1],
2910                                 info.spanX, info.spanY);
2911                     }
2912 
2913                     // update the item&#x27;s position after drop
2914                     CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();
2915                     lp.cellX = lp.tmpCellX = mTargetCell[0];
2916                     lp.cellY = lp.tmpCellY = mTargetCell[1];
2917                     lp.cellHSpan = item.spanX;
2918                     lp.cellVSpan = item.spanY;
2919                     lp.isLockedToGrid = true;
2920 
2921                     if (container != LauncherSettings.Favorites.CONTAINER_HOTSEAT &amp;&amp;
2922                             cell instanceof LauncherAppWidgetHostView) {
2923                         final CellLayout cellLayout = dropTargetLayout;
2924                         // We post this call so that the widget has a chance to be placed
2925                         // in its final location
2926 
2927                         final LauncherAppWidgetHostView hostView = (LauncherAppWidgetHostView) cell;
2928                         AppWidgetProviderInfo pinfo = hostView.getAppWidgetInfo();
2929                         if (pinfo != null &amp;&amp;
2930                                 pinfo.resizeMode != AppWidgetProviderInfo.RESIZE_NONE) {
2931                             final Runnable addResizeFrame = new Runnable() {
2932                                 public void run() {
2933                                     DragLayer dragLayer = mLauncher.getDragLayer();
2934                                     dragLayer.addResizeFrame(info, hostView, cellLayout);
2935                                 }
2936                             };
2937                             resizeRunnable = (new Runnable() {
2938                                 public void run() {
2939                                     if (!isPageMoving()) {
2940                                         addResizeFrame.run();
2941                                     } else {
2942                                         mDelayedResizeRunnable = addResizeFrame;
2943                                     }
2944                                 }
2945                             });
2946                         }
2947                     }
2948 
2949                     LauncherModel.modifyItemInDatabase(mLauncher, info, container, screenId, lp.cellX,
2950                             lp.cellY, item.spanX, item.spanY);
2951                 } else {
2952                     // If we can&#x27;t find a drop location, we return the item to its original position
2953                     CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();
2954                     mTargetCell[0] = lp.cellX;
2955                     mTargetCell[1] = lp.cellY;
2956                     CellLayout layout = (CellLayout) cell.getParent().getParent();
2957                     layout.markCellsAsOccupiedForView(cell);
2958                 }
2959             }
2960 
2961             final CellLayout parent = (CellLayout) cell.getParent().getParent();
2962             final Runnable finalResizeRunnable = resizeRunnable;
2963             // Prepare it to be animated into its new position
2964             // This must be called after the view has been re-parented
2965             final Runnable onCompleteRunnable = new Runnable() {
2966                 @Override
2967                 public void run() {
2968                     mAnimatingViewIntoPlace = false;
2969                     updateChildrenLayersEnabled(false);
2970                     if (finalResizeRunnable != null) {
2971                         finalResizeRunnable.run();
2972                     }
2973                     removeExtraEmptyScreen(true, null, 0, true);
2974                 }
2975             };
2976             mAnimatingViewIntoPlace = true;
2977             if (d.dragView.hasDrawn()) {
2978                 final ItemInfo info = (ItemInfo) cell.getTag();
2979                 if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET) {
2980                     int animationType = resizeOnDrop ? ANIMATE_INTO_POSITION_AND_RESIZE :
2981                             ANIMATE_INTO_POSITION_AND_DISAPPEAR;
2982                     animateWidgetDrop(info, parent, d.dragView,
2983                             onCompleteRunnable, animationType, cell, false);
2984                 } else {
2985                     int duration = snapScreen &lt; 0 ? -1 : ADJACENT_SCREEN_DROP_DURATION;
2986                     mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, cell, duration,
2987                             onCompleteRunnable, this);
2988                 }
2989             } else {
2990                 d.deferDragViewCleanupPostAnimation = false;
2991                 cell.setVisibility(VISIBLE);
2992             }
2993             parent.onDropChild(cell);
2994         }
2995     }
2996 
2997     public void setFinalScrollForPageChange(int pageIndex) {
2998         CellLayout cl = (CellLayout) getChildAt(pageIndex);
2999         if (cl != null) {
3000             mSavedScrollX = getScrollX();
3001             mSavedTranslationX = cl.getTranslationX();
3002             mSavedRotationY = cl.getRotationY();
3003             final int newX = getScrollForPage(pageIndex);
3004             setScrollX(newX);
3005             cl.setTranslationX(0f);
3006             cl.setRotationY(0f);
3007         }
3008     }
3009 
3010     public void resetFinalScrollForPageChange(int pageIndex) {
3011         if (pageIndex &gt;= 0) {
3012             CellLayout cl = (CellLayout) getChildAt(pageIndex);
3013             setScrollX(mSavedScrollX);
3014             cl.setTranslationX(mSavedTranslationX);
3015             cl.setRotationY(mSavedRotationY);
3016         }
3017     }
3018 
3019     public void getViewLocationRelativeToSelf(View v, int[] location) {
3020         getLocationInWindow(location);
3021         int x = location[0];
3022         int y = location[1];
3023 
3024         v.getLocationInWindow(location);
3025         int vX = location[0];
3026         int vY = location[1];
3027 
3028         location[0] = vX - x;
3029         location[1] = vY - y;
3030     }
3031 
3032     public void onDragEnter(DragObject d) {
3033         mDragEnforcer.onDragEnter();
3034         mCreateUserFolderOnDrop = false;
3035         mAddToExistingFolderOnDrop = false;
3036 
3037         mDropToLayout = null;
3038         CellLayout layout = getCurrentDropLayout();
3039         setCurrentDropLayout(layout);
3040         setCurrentDragOverlappingLayout(layout);
3041 
3042         // Because we don&#x27;t have space in the Phone UI (the CellLayouts run to the edge) we
3043         // don&#x27;t need to show the outlines
3044         if (LauncherAppState.getInstance().isScreenLarge()) {
3045             showOutlines();
3046         }
3047     }
3048 
3049     /** Return a rect that has the cellWidth/cellHeight (left, top), and
3050      * widthGap/heightGap (right, bottom) */
3051     static Rect getCellLayoutMetrics(Launcher launcher, int orientation) {
3052         LauncherAppState app = LauncherAppState.getInstance();
3053         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
3054 
3055         Resources res = launcher.getResources();
3056         Display display = launcher.getWindowManager().getDefaultDisplay();
3057         Point smallestSize = new Point();
3058         Point largestSize = new Point();
3059         display.getCurrentSizeRange(smallestSize, largestSize);
3060         int countX = (int) grid.numColumns;
3061         int countY = (int) grid.numRows;
3062         int constrainedLongEdge = largestSize.y;
3063         int constrainedShortEdge = smallestSize.y;
3064         if (orientation == CellLayout.LANDSCAPE) {
3065             if (mLandscapeCellLayoutMetrics == null) {
3066                 Rect padding = grid.getWorkspacePadding(CellLayout.LANDSCAPE);
3067                 int width = constrainedLongEdge - padding.left - padding.right;
3068                 int height = constrainedShortEdge - padding.top - padding.bottom;
3069                 mLandscapeCellLayoutMetrics = new Rect();
3070                 mLandscapeCellLayoutMetrics.set(
3071                         grid.calculateCellWidth(width, countX),
3072                         grid.calculateCellHeight(height, countY), 0, 0);
3073             }
3074             return mLandscapeCellLayoutMetrics;
3075         } else if (orientation == CellLayout.PORTRAIT) {
3076             if (mPortraitCellLayoutMetrics == null) {
3077                 Rect padding = grid.getWorkspacePadding(CellLayout.PORTRAIT);
3078                 int width = constrainedShortEdge - padding.left - padding.right;
3079                 int height = constrainedLongEdge - padding.top - padding.bottom;
3080                 mPortraitCellLayoutMetrics = new Rect();
3081                 mPortraitCellLayoutMetrics.set(
3082                         grid.calculateCellWidth(width, countX),
3083                         grid.calculateCellHeight(height, countY), 0, 0);
3084             }
3085             return mPortraitCellLayoutMetrics;
3086         }
3087         return null;
3088     }
3089 
3090     public void onDragExit(DragObject d) {
3091         mDragEnforcer.onDragExit();
3092 
3093         // Here we store the final page that will be dropped to, if the workspace in fact
3094         // receives the drop
3095         if (mInScrollArea) {
3096             if (isPageMoving()) {
3097                 // If the user drops while the page is scrolling, we should use that page as the
3098                 // destination instead of the page that is being hovered over.
3099                 mDropToLayout = (CellLayout) getPageAt(getNextPage());
3100             } else {
3101                 mDropToLayout = mDragOverlappingLayout;
3102             }
3103         } else {
3104             mDropToLayout = mDragTargetLayout;
3105         }
3106 
3107         if (mDragMode == DRAG_MODE_CREATE_FOLDER) {
3108             mCreateUserFolderOnDrop = true;
3109         } else if (mDragMode == DRAG_MODE_ADD_TO_FOLDER) {
3110             mAddToExistingFolderOnDrop = true;
3111         }
3112 
3113         // Reset the scroll area and previous drag target
3114         onResetScrollArea();
3115         setCurrentDropLayout(null);
3116         setCurrentDragOverlappingLayout(null);
3117 
3118         mSpringLoadedDragController.cancel();
3119 
3120         if (!mIsPageMoving) {
3121             hideOutlines();
3122         }
3123     }
3124 
3125     void setCurrentDropLayout(CellLayout layout) {
3126         if (mDragTargetLayout != null) {
3127             mDragTargetLayout.revertTempState();
3128             mDragTargetLayout.onDragExit();
3129         }
3130         mDragTargetLayout = layout;
3131         if (mDragTargetLayout != null) {
3132             mDragTargetLayout.onDragEnter();
3133         }
3134         cleanupReorder(true);
3135         cleanupFolderCreation();
3136         setCurrentDropOverCell(-1, -1);
3137     }
3138 
3139     void setCurrentDragOverlappingLayout(CellLayout layout) {
3140         if (mDragOverlappingLayout != null) {
3141             mDragOverlappingLayout.setIsDragOverlapping(false);
3142         }
3143         mDragOverlappingLayout = layout;
3144         if (mDragOverlappingLayout != null) {
3145             mDragOverlappingLayout.setIsDragOverlapping(true);
3146         }
3147         invalidate();
3148     }
3149 
3150     void setCurrentDropOverCell(int x, int y) {
3151         if (x != mDragOverX || y != mDragOverY) {
3152             mDragOverX = x;
3153             mDragOverY = y;
3154             setDragMode(DRAG_MODE_NONE);
3155         }
3156     }
3157 
3158     void setDragMode(int dragMode) {
3159         if (dragMode != mDragMode) {
3160             if (dragMode == DRAG_MODE_NONE) {
3161                 cleanupAddToFolder();
3162                 // We don&#x27;t want to cancel the re-order alarm every time the target cell changes
3163                 // as this feels to slow / unresponsive.
3164                 cleanupReorder(false);
3165                 cleanupFolderCreation();
3166             } else if (dragMode == DRAG_MODE_ADD_TO_FOLDER) {
3167                 cleanupReorder(true);
3168                 cleanupFolderCreation();
3169             } else if (dragMode == DRAG_MODE_CREATE_FOLDER) {
3170                 cleanupAddToFolder();
3171                 cleanupReorder(true);
3172             } else if (dragMode == DRAG_MODE_REORDER) {
3173                 cleanupAddToFolder();
3174                 cleanupFolderCreation();
3175             }
3176             mDragMode = dragMode;
3177         }
3178     }
3179 
3180     private void cleanupFolderCreation() {
3181         if (mDragFolderRingAnimator != null) {
3182             mDragFolderRingAnimator.animateToNaturalState();
3183             mDragFolderRingAnimator = null;
3184         }
3185         mFolderCreationAlarm.setOnAlarmListener(null);
3186         mFolderCreationAlarm.cancelAlarm();
3187     }
3188 
3189     private void cleanupAddToFolder() {
3190         if (mDragOverFolderIcon != null) {
3191             mDragOverFolderIcon.onDragExit(null);
3192             mDragOverFolderIcon = null;
3193         }
3194     }
3195 
3196     private void cleanupReorder(boolean cancelAlarm) {
3197         // Any pending reorders are canceled
3198         if (cancelAlarm) {
3199             mReorderAlarm.cancelAlarm();
3200         }
3201         mLastReorderX = -1;
3202         mLastReorderY = -1;
3203     }
3204 
3205    /*
3206     *
3207     * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
3208     * coordinate space. The argument xy is modified with the return result.
3209     *
3210     * if cachedInverseMatrix is not null, this method will just use that matrix instead of
3211     * computing it itself; we use this to avoid redundant matrix inversions in
3212     * findMatchingPageForDragOver
3213     *
3214     */
3215    void mapPointFromSelfToChild(View v, float[] xy, Matrix cachedInverseMatrix) {
3216        xy[0] = xy[0] - v.getLeft();
3217        xy[1] = xy[1] - v.getTop();
3218    }
3219 
3220    boolean isPointInSelfOverHotseat(int x, int y, Rect r) {
3221        if (r == null) {
3222            r = new Rect();
3223        }
3224        mTempPt[0] = x;
3225        mTempPt[1] = y;
3226        mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(this, mTempPt, true);
3227 
3228        LauncherAppState app = LauncherAppState.getInstance();
3229        DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
3230        r = grid.getHotseatRect();
3231        if (r.contains(mTempPt[0], mTempPt[1])) {
3232            return true;
3233        }
3234        return false;
3235    }
3236 
3237    void mapPointFromSelfToHotseatLayout(Hotseat hotseat, float[] xy) {
3238        mTempPt[0] = (int) xy[0];
3239        mTempPt[1] = (int) xy[1];
3240        mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(this, mTempPt, true);
3241        mLauncher.getDragLayer().mapCoordInSelfToDescendent(hotseat.getLayout(), mTempPt);
3242 
3243        xy[0] = mTempPt[0];
3244        xy[1] = mTempPt[1];
3245    }
3246 
3247    /*
3248     *
3249     * Convert the 2D coordinate xy from this CellLayout&#x27;s coordinate space to
3250     * the parent View&#x27;s coordinate space. The argument xy is modified with the return result.
3251     *
3252     */
3253    void mapPointFromChildToSelf(View v, float[] xy) {
3254        xy[0] += v.getLeft();
3255        xy[1] += v.getTop();
3256    }
3257 
3258    static private float squaredDistance(float[] point1, float[] point2) {
3259         float distanceX = point1[0] - point2[0];
3260         float distanceY = point2[1] - point2[1];
3261         return distanceX * distanceX + distanceY * distanceY;
3262    }
3263 
3264     /*
3265      *
3266      * This method returns the CellLayout that is currently being dragged to. In order to drag
3267      * to a CellLayout, either the touch point must be directly over the CellLayout, or as a second
3268      * strategy, we see if the dragView is overlapping any CellLayout and choose the closest one
3269      *
3270      * Return null if no CellLayout is currently being dragged over
3271      *
3272      */
3273     private CellLayout findMatchingPageForDragOver(
3274             DragView dragView, float originX, float originY, boolean exact) {
3275         // We loop through all the screens (ie CellLayouts) and see which ones overlap
3276         // with the item being dragged and then choose the one that&#x27;s closest to the touch point
3277         final int screenCount = getChildCount();
3278         CellLayout bestMatchingScreen = null;
3279         float smallestDistSoFar = Float.MAX_VALUE;
3280 
3281         for (int i = 0; i &lt; screenCount; i++) {
3282             // The custom content screen is not a valid drag over option
3283             if (mScreenOrder.get(i) == CUSTOM_CONTENT_SCREEN_ID) {
3284                 continue;
3285             }
3286 
3287             CellLayout cl = (CellLayout) getChildAt(i);
3288 
3289             final float[] touchXy = {originX, originY};
3290             // Transform the touch coordinates to the CellLayout&#x27;s local coordinates
3291             // If the touch point is within the bounds of the cell layout, we can return immediately
3292             cl.getMatrix().invert(mTempInverseMatrix);
3293             mapPointFromSelfToChild(cl, touchXy, mTempInverseMatrix);
3294 
3295             if (touchXy[0] &gt;= 0 &amp;&amp; touchXy[0] &lt;= cl.getWidth() &amp;&amp;
3296                     touchXy[1] &gt;= 0 &amp;&amp; touchXy[1] &lt;= cl.getHeight()) {
3297                 return cl;
3298             }
3299 
3300             if (!exact) {
3301                 // Get the center of the cell layout in screen coordinates
3302                 final float[] cellLayoutCenter = mTempCellLayoutCenterCoordinates;
3303                 cellLayoutCenter[0] = cl.getWidth()/2;
3304                 cellLayoutCenter[1] = cl.getHeight()/2;
3305                 mapPointFromChildToSelf(cl, cellLayoutCenter);
3306 
3307                 touchXy[0] = originX;
3308                 touchXy[1] = originY;
3309 
3310                 // Calculate the distance between the center of the CellLayout
3311                 // and the touch point
3312                 float dist = squaredDistance(touchXy, cellLayoutCenter);
3313 
3314                 if (dist &lt; smallestDistSoFar) {
3315                     smallestDistSoFar = dist;
3316                     bestMatchingScreen = cl;
3317                 }
3318             }
3319         }
3320         return bestMatchingScreen;
3321     }
3322 
3323     // This is used to compute the visual center of the dragView. This point is then
3324     // used to visualize drop locations and determine where to drop an item. The idea is that
3325     // the visual center represents the user&#x27;s interpretation of where the item is, and hence
3326     // is the appropriate point to use when determining drop location.
3327     private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
3328             DragView dragView, float[] recycle) {
3329         float res[];
3330         if (recycle == null) {
3331             res = new float[2];
3332         } else {
3333             res = recycle;
3334         }
3335 
3336         // First off, the drag view has been shifted in a way that is not represented in the
3337         // x and y values or the x/yOffsets. Here we account for that shift.
3338         x += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetX);
3339         y += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
3340 
3341         // These represent the visual top and left of drag view if a dragRect was provided.
3342         // If a dragRect was not provided, then they correspond to the actual view left and
3343         // top, as the dragRect is in that case taken to be the entire dragView.
3344         // R.dimen.dragViewOffsetY.
3345         int left = x - xOffset;
3346         int top = y - yOffset;
3347 
3348         // In order to find the visual center, we shift by half the dragRect
3349         res[0] = left + dragView.getDragRegion().width() / 2;
3350         res[1] = top + dragView.getDragRegion().height() / 2;
3351 
3352         return res;
3353     }
3354 
3355     private boolean isDragWidget(DragObject d) {
3356         return (d.dragInfo instanceof LauncherAppWidgetInfo ||
3357                 d.dragInfo instanceof PendingAddWidgetInfo);
3358     }
3359     private boolean isExternalDragWidget(DragObject d) {
3360         return d.dragSource != this &amp;&amp; isDragWidget(d);
3361     }
3362 
3363     public void onDragOver(DragObject d) {
3364         // Skip drag over events while we are dragging over side pages
3365         if (mInScrollArea || mIsSwitchingState || mState == State.SMALL) return;
3366 
3367         Rect r = new Rect();
3368         CellLayout layout = null;
3369         ItemInfo item = (ItemInfo) d.dragInfo;
3370 
3371         // Ensure that we have proper spans for the item that we are dropping
3372         if (item.spanX &lt; 0 || item.spanY &lt; 0) throw new RuntimeException(&quot;Improper spans found&quot;);
3373         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
3374             d.dragView, mDragViewVisualCenter);
3375 
3376         final View child = (mDragInfo == null) ? null : mDragInfo.cell;
3377         // Identify whether we have dragged over a side page
3378         if (isSmall()) {
3379             if (mLauncher.getHotseat() != null &amp;&amp; !isExternalDragWidget(d)) {
3380                 if (isPointInSelfOverHotseat(d.x, d.y, r)) {
3381                     layout = mLauncher.getHotseat().getLayout();
3382                 }
3383             }
3384             if (layout == null) {
3385                 layout = findMatchingPageForDragOver(d.dragView, d.x, d.y, false);
3386             }
3387             if (layout != mDragTargetLayout) {
3388                 setCurrentDropLayout(layout);
3389                 setCurrentDragOverlappingLayout(layout);
3390 
3391                 boolean isInSpringLoadedMode = (mState == State.SPRING_LOADED);
3392                 if (isInSpringLoadedMode) {
3393                     if (mLauncher.isHotseatLayout(layout)) {
3394                         mSpringLoadedDragController.cancel();
3395                     } else {
3396                         mSpringLoadedDragController.setAlarm(mDragTargetLayout);
3397                     }
3398                 }
3399             }
3400         } else {
3401             // Test to see if we are over the hotseat otherwise just use the current page
3402             if (mLauncher.getHotseat() != null &amp;&amp; !isDragWidget(d)) {
3403                 if (isPointInSelfOverHotseat(d.x, d.y, r)) {
3404                     layout = mLauncher.getHotseat().getLayout();
3405                 }
3406             }
3407             if (layout == null) {
3408                 layout = getCurrentDropLayout();
3409             }
3410             if (layout != mDragTargetLayout) {
3411                 setCurrentDropLayout(layout);
3412                 setCurrentDragOverlappingLayout(layout);
3413             }
3414         }
3415 
3416         // Handle the drag over
3417         if (mDragTargetLayout != null) {
3418             // We want the point to be mapped to the dragTarget.
3419             if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
3420                 mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
3421             } else {
3422                 mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
3423             }
3424 
3425             ItemInfo info = (ItemInfo) d.dragInfo;
3426 
3427             int minSpanX = item.spanX;
3428             int minSpanY = item.spanY;
3429             if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
3430                 minSpanX = item.minSpanX;
3431                 minSpanY = item.minSpanY;
3432             }
3433 
3434             mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
3435                     (int) mDragViewVisualCenter[1], minSpanX, minSpanY,
3436                     mDragTargetLayout, mTargetCell);
3437             int reorderX = mTargetCell[0];
3438             int reorderY = mTargetCell[1];
3439 
3440             setCurrentDropOverCell(mTargetCell[0], mTargetCell[1]);
3441 
3442             float targetCellDistance = mDragTargetLayout.getDistanceFromCell(
3443                     mDragViewVisualCenter[0], mDragViewVisualCenter[1], mTargetCell);
3444 
3445             final View dragOverView = mDragTargetLayout.getChildAt(mTargetCell[0],
3446                     mTargetCell[1]);
3447 
3448             manageFolderFeedback(info, mDragTargetLayout, mTargetCell,
3449                     targetCellDistance, dragOverView);
3450 
3451             boolean nearestDropOccupied = mDragTargetLayout.isNearestDropLocationOccupied((int)
3452                     mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1], item.spanX,
3453                     item.spanY, child, mTargetCell);
3454 
3455             if (!nearestDropOccupied) {
3456                 mDragTargetLayout.visualizeDropLocation(child, mDragOutline,
3457                         (int) mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1],
3458                         mTargetCell[0], mTargetCell[1], item.spanX, item.spanY, false,
3459                         d.dragView.getDragVisualizeOffset(), d.dragView.getDragRegion());
3460             } else if ((mDragMode == DRAG_MODE_NONE || mDragMode == DRAG_MODE_REORDER)
3461                     &amp;&amp; !mReorderAlarm.alarmPending() &amp;&amp; (mLastReorderX != reorderX ||
3462                     mLastReorderY != reorderY)) {
3463 
3464                 // Otherwise, if we aren&#x27;t adding to or creating a folder and there&#x27;s no pending
3465                 // reorder, then we schedule a reorder
3466                 ReorderAlarmListener listener = new ReorderAlarmListener(mDragViewVisualCenter,
3467                         minSpanX, minSpanY, item.spanX, item.spanY, d.dragView, child);
3468                 mReorderAlarm.setOnAlarmListener(listener);
3469                 mReorderAlarm.setAlarm(REORDER_TIMEOUT);
3470             }
3471 
3472             if (mDragMode == DRAG_MODE_CREATE_FOLDER || mDragMode == DRAG_MODE_ADD_TO_FOLDER ||
3473                     !nearestDropOccupied) {
3474                 if (mDragTargetLayout != null) {
3475                     mDragTargetLayout.revertTempState();
3476                 }
3477             }
3478         }
3479     }
3480 
3481     private void manageFolderFeedback(ItemInfo info, CellLayout targetLayout,
3482             int[] targetCell, float distance, View dragOverView) {
3483         boolean userFolderPending = willCreateUserFolder(info, targetLayout, targetCell, distance,
3484                 false);
3485 
3486         if (mDragMode == DRAG_MODE_NONE &amp;&amp; userFolderPending &amp;&amp;
3487                 !mFolderCreationAlarm.alarmPending()) {
3488             mFolderCreationAlarm.setOnAlarmListener(new
3489                     FolderCreationAlarmListener(targetLayout, targetCell[0], targetCell[1]));
3490             mFolderCreationAlarm.setAlarm(FOLDER_CREATION_TIMEOUT);
3491             return;
3492         }
3493 
3494         boolean willAddToFolder =
3495                 willAddToExistingUserFolder(info, targetLayout, targetCell, distance);
3496 
3497         if (willAddToFolder &amp;&amp; mDragMode == DRAG_MODE_NONE) {
3498             mDragOverFolderIcon = ((FolderIcon) dragOverView);
3499             mDragOverFolderIcon.onDragEnter(info);
3500             if (targetLayout != null) {
3501                 targetLayout.clearDragOutlines();
3502             }
3503             setDragMode(DRAG_MODE_ADD_TO_FOLDER);
3504             return;
3505         }
3506 
3507         if (mDragMode == DRAG_MODE_ADD_TO_FOLDER &amp;&amp; !willAddToFolder) {
3508             setDragMode(DRAG_MODE_NONE);
3509         }
3510         if (mDragMode == DRAG_MODE_CREATE_FOLDER &amp;&amp; !userFolderPending) {
3511             setDragMode(DRAG_MODE_NONE);
3512         }
3513 
3514         return;
3515     }
3516 
3517     class FolderCreationAlarmListener implements OnAlarmListener {
3518         CellLayout layout;
3519         int cellX;
3520         int cellY;
3521 
3522         public FolderCreationAlarmListener(CellLayout layout, int cellX, int cellY) {
3523             this.layout = layout;
3524             this.cellX = cellX;
3525             this.cellY = cellY;
3526         }
3527 
3528         public void onAlarm(Alarm alarm) {
3529             if (mDragFolderRingAnimator != null) {
3530                 // This shouldn&#x27;t happen ever, but just in case, make sure we clean up the mess.
3531                 mDragFolderRingAnimator.animateToNaturalState();
3532             }
3533             mDragFolderRingAnimator = new FolderRingAnimator(mLauncher, null);
3534             mDragFolderRingAnimator.setCell(cellX, cellY);
3535             mDragFolderRingAnimator.setCellLayout(layout);
3536             mDragFolderRingAnimator.animateToAcceptState();
3537             layout.showFolderAccept(mDragFolderRingAnimator);
3538             layout.clearDragOutlines();
3539             setDragMode(DRAG_MODE_CREATE_FOLDER);
3540         }
3541     }
3542 
3543     class ReorderAlarmListener implements OnAlarmListener {
3544         float[] dragViewCenter;
3545         int minSpanX, minSpanY, spanX, spanY;
3546         DragView dragView;
3547         View child;
3548 
3549         public ReorderAlarmListener(float[] dragViewCenter, int minSpanX, int minSpanY, int spanX,
3550                 int spanY, DragView dragView, View child) {
3551             this.dragViewCenter = dragViewCenter;
3552             this.minSpanX = minSpanX;
3553             this.minSpanY = minSpanY;
3554             this.spanX = spanX;
3555             this.spanY = spanY;
3556             this.child = child;
3557             this.dragView = dragView;
3558         }
3559 
3560         public void onAlarm(Alarm alarm) {
3561             int[] resultSpan = new int[2];
3562             mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
3563                     (int) mDragViewVisualCenter[1], minSpanX, minSpanY, mDragTargetLayout,
3564                     mTargetCell);
3565             mLastReorderX = mTargetCell[0];
3566             mLastReorderY = mTargetCell[1];
3567 
3568             mTargetCell = mDragTargetLayout.createArea((int) mDragViewVisualCenter[0],
3569                 (int) mDragViewVisualCenter[1], minSpanX, minSpanY, spanX, spanY,
3570                 child, mTargetCell, resultSpan, CellLayout.MODE_DRAG_OVER);
3571 
3572             if (mTargetCell[0] &lt; 0 || mTargetCell[1] &lt; 0) {
3573                 mDragTargetLayout.revertTempState();
3574             } else {
3575                 setDragMode(DRAG_MODE_REORDER);
3576             }
3577 
3578             boolean resize = resultSpan[0] != spanX || resultSpan[1] != spanY;
3579             mDragTargetLayout.visualizeDropLocation(child, mDragOutline,
3580                 (int) mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1],
3581                 mTargetCell[0], mTargetCell[1], resultSpan[0], resultSpan[1], resize,
3582                 dragView.getDragVisualizeOffset(), dragView.getDragRegion());
3583         }
3584     }
3585 
3586     @Override
3587     public void getHitRectRelativeToDragLayer(Rect outRect) {
3588         // We want the workspace to have the whole area of the display (it will find the correct
3589         // cell layout to drop to in the existing drag/drop logic.
3590         mLauncher.getDragLayer().getDescendantRectRelativeToSelf(this, outRect);
3591     }
3592 
3593     /**
3594      * Add the item specified by dragInfo to the given layout.
3595      * @return true if successful
3596      */
3597     public boolean addExternalItemToScreen(ItemInfo dragInfo, CellLayout layout) {
3598         if (layout.findCellForSpan(mTempEstimate, dragInfo.spanX, dragInfo.spanY)) {
3599             onDropExternal(dragInfo.dropPos, (ItemInfo) dragInfo, (CellLayout) layout, false);
3600             return true;
3601         }
3602         mLauncher.showOutOfSpaceMessage(mLauncher.isHotseatLayout(layout));
3603         return false;
3604     }
3605 
3606     private void onDropExternal(int[] touchXY, Object dragInfo,
3607             CellLayout cellLayout, boolean insertAtFirst) {
3608         onDropExternal(touchXY, dragInfo, cellLayout, insertAtFirst, null);
3609     }
3610 
3611     /**
3612      * Drop an item that didn&#x27;t originate on one of the workspace screens.
3613      * It may have come from Launcher (e.g. from all apps or customize), or it may have
3614      * come from another app altogether.
3615      *
3616      * NOTE: This can also be called when we are outside of a drag event, when we want
3617      * to add an item to one of the workspace screens.
3618      */
3619     private void onDropExternal(final int[] touchXY, final Object dragInfo,
3620             final CellLayout cellLayout, boolean insertAtFirst, DragObject d) {
3621         final Runnable exitSpringLoadedRunnable = new Runnable() {
3622             @Override
3623             public void run() {
3624                 removeExtraEmptyScreen(false, new Runnable() {
3625                     @Override
3626                     public void run() {
3627                         mLauncher.exitSpringLoadedDragModeDelayed(true,
3628                                 Launcher.EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
3629                     }
3630                 });
3631             }
3632         };
3633 
3634         ItemInfo info = (ItemInfo) dragInfo;
3635         int spanX = info.spanX;
3636         int spanY = info.spanY;
3637         if (mDragInfo != null) {
3638             spanX = mDragInfo.spanX;
3639             spanY = mDragInfo.spanY;
3640         }
3641 
3642         final long container = mLauncher.isHotseatLayout(cellLayout) ?
3643                 LauncherSettings.Favorites.CONTAINER_HOTSEAT :
3644                     LauncherSettings.Favorites.CONTAINER_DESKTOP;
3645         final long screenId = getIdForScreen(cellLayout);
3646         if (!mLauncher.isHotseatLayout(cellLayout)
3647                 &amp;&amp; screenId != getScreenIdForPageIndex(mCurrentPage)
3648                 &amp;&amp; mState != State.SPRING_LOADED) {
3649             snapToScreenId(screenId, null);
3650         }
3651 
3652         if (info instanceof PendingAddItemInfo) {
3653             final PendingAddItemInfo pendingInfo = (PendingAddItemInfo) dragInfo;
3654 
3655             boolean findNearestVacantCell = true;
3656             if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) {
3657                 mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3658                         cellLayout, mTargetCell);
3659                 float distance = cellLayout.getDistanceFromCell(mDragViewVisualCenter[0],
3660                         mDragViewVisualCenter[1], mTargetCell);
3661                 if (willCreateUserFolder((ItemInfo) d.dragInfo, cellLayout, mTargetCell,
3662                         distance, true) || willAddToExistingUserFolder((ItemInfo) d.dragInfo,
3663                                 cellLayout, mTargetCell, distance)) {
3664                     findNearestVacantCell = false;
3665                 }
3666             }
3667 
3668             final ItemInfo item = (ItemInfo) d.dragInfo;
3669             boolean updateWidgetSize = false;
3670             if (findNearestVacantCell) {
3671                 int minSpanX = item.spanX;
3672                 int minSpanY = item.spanY;
3673                 if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
3674                     minSpanX = item.minSpanX;
3675                     minSpanY = item.minSpanY;
3676                 }
3677                 int[] resultSpan = new int[2];
3678                 mTargetCell = cellLayout.createArea((int) mDragViewVisualCenter[0],
3679                         (int) mDragViewVisualCenter[1], minSpanX, minSpanY, info.spanX, info.spanY,
3680                         null, mTargetCell, resultSpan, CellLayout.MODE_ON_DROP_EXTERNAL);
3681 
3682                 if (resultSpan[0] != item.spanX || resultSpan[1] != item.spanY) {
3683                     updateWidgetSize = true;
3684                 }
3685                 item.spanX = resultSpan[0];
3686                 item.spanY = resultSpan[1];
3687             }
3688 
3689             Runnable onAnimationCompleteRunnable = new Runnable() {
3690                 @Override
3691                 public void run() {
3692                     // When dragging and dropping from customization tray, we deal with creating
3693                     // widgets/shortcuts/folders in a slightly different way
3694                     switch (pendingInfo.itemType) {
3695                     case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
3696                         int span[] = new int[2];
3697                         span[0] = item.spanX;
3698                         span[1] = item.spanY;
3699                         mLauncher.addAppWidgetFromDrop((PendingAddWidgetInfo) pendingInfo,
3700                                 container, screenId, mTargetCell, span, null);
3701                         break;
3702                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3703                         mLauncher.processShortcutFromDrop(pendingInfo.componentName,
3704                                 container, screenId, mTargetCell, null);
3705                         break;
3706                     default:
3707                         throw new IllegalStateException(&quot;Unknown item type: &quot; +
3708                                 pendingInfo.itemType);
3709                     }
3710                 }
3711             };
3712             View finalView = pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET
3713                     ? ((PendingAddWidgetInfo) pendingInfo).boundWidget : null;
3714 
3715             if (finalView instanceof AppWidgetHostView &amp;&amp; updateWidgetSize) {
3716                 AppWidgetHostView awhv = (AppWidgetHostView) finalView;
3717                 AppWidgetResizeFrame.updateWidgetSizeRanges(awhv, mLauncher, item.spanX,
3718                         item.spanY);
3719             }
3720 
3721             int animationStyle = ANIMATE_INTO_POSITION_AND_DISAPPEAR;
3722             if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;
3723                     ((PendingAddWidgetInfo) pendingInfo).info.configure != null) {
3724                 animationStyle = ANIMATE_INTO_POSITION_AND_REMAIN;
3725             }
3726             animateWidgetDrop(info, cellLayout, d.dragView, onAnimationCompleteRunnable,
3727                     animationStyle, finalView, true);
3728         } else {
3729             // This is for other drag/drop cases, like dragging from All Apps
3730             View view = null;
3731 
3732             switch (info.itemType) {
3733             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
3734             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3735                 if (info.container == NO_ID &amp;&amp; info instanceof AppInfo) {
3736                     // Came from all apps -- make a copy
3737                     info = new ShortcutInfo((AppInfo) info);
3738                 }
3739                 view = mLauncher.createShortcut(R.layout.application, cellLayout,
3740                         (ShortcutInfo) info);
3741                 break;
3742             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
3743                 view = FolderIcon.fromXml(R.layout.folder_icon, mLauncher, cellLayout,
3744                         (FolderInfo) info, mIconCache);
3745                 break;
3746             default:
3747                 throw new IllegalStateException(&quot;Unknown item type: &quot; + info.itemType);
3748             }
3749 
3750             // First we find the cell nearest to point at which the item is
3751             // dropped, without any consideration to whether there is an item there.
3752             if (touchXY != null) {
3753                 mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3754                         cellLayout, mTargetCell);
3755                 float distance = cellLayout.getDistanceFromCell(mDragViewVisualCenter[0],
3756                         mDragViewVisualCenter[1], mTargetCell);
3757                 d.postAnimationRunnable = exitSpringLoadedRunnable;
3758                 if (createUserFolderIfNecessary(view, container, cellLayout, mTargetCell, distance,
3759                         true, d.dragView, d.postAnimationRunnable)) {
3760                     return;
3761                 }
3762                 if (addToExistingFolderIfNecessary(view, cellLayout, mTargetCell, distance, d,
3763                         true)) {
3764                     return;
3765                 }
3766             }
3767 
3768             if (touchXY != null) {
3769                 // when dragging and dropping, just find the closest free spot
3770                 mTargetCell = cellLayout.createArea((int) mDragViewVisualCenter[0],
3771                         (int) mDragViewVisualCenter[1], 1, 1, 1, 1,
3772                         null, mTargetCell, null, CellLayout.MODE_ON_DROP_EXTERNAL);
3773             } else {
3774                 cellLayout.findCellForSpan(mTargetCell, 1, 1);
3775             }
3776             addInScreen(view, container, screenId, mTargetCell[0], mTargetCell[1], info.spanX,
3777                     info.spanY, insertAtFirst);
3778             cellLayout.onDropChild(view);
3779             CellLayout.LayoutParams lp = (CellLayout.LayoutParams) view.getLayoutParams();
3780             cellLayout.getShortcutsAndWidgets().measureChild(view);
3781 
3782             LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screenId,
3783                     lp.cellX, lp.cellY);
3784 
3785             if (d.dragView != null) {
3786                 // We wrap the animation call in the temporary set and reset of the current
3787                 // cellLayout to its final transform -- this means we animate the drag view to
3788                 // the correct final location.
3789                 setFinalTransitionTransform(cellLayout);
3790                 mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, view,
3791                         exitSpringLoadedRunnable, this);
3792                 resetTransitionTransform(cellLayout);
3793             }
3794         }
3795     }
3796 
3797     public Bitmap createWidgetBitmap(ItemInfo widgetInfo, View layout) {
3798         int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(widgetInfo.spanX,
3799                 widgetInfo.spanY, widgetInfo, false);
3800         int visibility = layout.getVisibility();
3801         layout.setVisibility(VISIBLE);
3802 
3803         int width = MeasureSpec.makeMeasureSpec(unScaledSize[0], MeasureSpec.EXACTLY);
3804         int height = MeasureSpec.makeMeasureSpec(unScaledSize[1], MeasureSpec.EXACTLY);
3805         Bitmap b = Bitmap.createBitmap(unScaledSize[0], unScaledSize[1],
3806                 Bitmap.Config.ARGB_8888);
3807         Canvas c = new Canvas(b);
3808 
3809         layout.measure(width, height);
3810         layout.layout(0, 0, unScaledSize[0], unScaledSize[1]);
3811         layout.draw(c);
3812         c.setBitmap(null);
3813         layout.setVisibility(visibility);
3814         return b;
3815     }
3816 
3817     private void getFinalPositionForDropAnimation(int[] loc, float[] scaleXY,
3818             DragView dragView, CellLayout layout, ItemInfo info, int[] targetCell,
3819             boolean external, boolean scale) {
3820         // Now we animate the dragView, (ie. the widget or shortcut preview) into its final
3821         // location and size on the home screen.
3822         int spanX = info.spanX;
3823         int spanY = info.spanY;
3824 
3825         Rect r = estimateItemPosition(layout, info, targetCell[0], targetCell[1], spanX, spanY);
3826         loc[0] = r.left;
3827         loc[1] = r.top;
3828 
3829         setFinalTransitionTransform(layout);
3830         float cellLayoutScale =
3831                 mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(layout, loc, true);
3832         resetTransitionTransform(layout);
3833 
3834         float dragViewScaleX;
3835         float dragViewScaleY;
3836         if (scale) {
3837             dragViewScaleX = (1.0f * r.width()) / dragView.getMeasuredWidth();
3838             dragViewScaleY = (1.0f * r.height()) / dragView.getMeasuredHeight();
3839         } else {
3840             dragViewScaleX = 1f;
3841             dragViewScaleY = 1f;
3842         }
3843 
3844         // The animation will scale the dragView about its center, so we need to center about
3845         // the final location.
3846         loc[0] -= (dragView.getMeasuredWidth() - cellLayoutScale * r.width()) / 2;
3847         loc[1] -= (dragView.getMeasuredHeight() - cellLayoutScale * r.height()) / 2;
3848 
3849         scaleXY[0] = dragViewScaleX * cellLayoutScale;
3850         scaleXY[1] = dragViewScaleY * cellLayoutScale;
3851     }
3852 
3853     public void animateWidgetDrop(ItemInfo info, CellLayout cellLayout, DragView dragView,
3854             final Runnable onCompleteRunnable, int animationType, final View finalView,
3855             boolean external) {
3856         Rect from = new Rect();
3857         mLauncher.getDragLayer().getViewRectRelativeToSelf(dragView, from);
3858 
3859         int[] finalPos = new int[2];
3860         float scaleXY[] = new float[2];
3861         boolean scalePreview = !(info instanceof PendingAddShortcutInfo);
3862         getFinalPositionForDropAnimation(finalPos, scaleXY, dragView, cellLayout, info, mTargetCell,
3863                 external, scalePreview);
3864 
3865         Resources res = mLauncher.getResources();
3866         final int duration = res.getInteger(R.integer.config_dropAnimMaxDuration) - 200;
3867 
3868         // In the case where we&#x27;ve prebound the widget, we remove it from the DragLayer
3869         if (finalView instanceof AppWidgetHostView &amp;&amp; external) {
3870             Log.d(TAG, &quot;6557954 Animate widget drop, final view is appWidgetHostView&quot;);
3871             mLauncher.getDragLayer().removeView(finalView);
3872         }
3873         if ((animationType == ANIMATE_INTO_POSITION_AND_RESIZE || external) &amp;&amp; finalView != null) {
3874             Bitmap crossFadeBitmap = createWidgetBitmap(info, finalView);
3875             dragView.setCrossFadeBitmap(crossFadeBitmap);
3876             dragView.crossFade((int) (duration * 0.8f));
3877         } else if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp; external) {
3878             scaleXY[0] = scaleXY[1] = Math.min(scaleXY[0],  scaleXY[1]);
3879         }
3880 
3881         DragLayer dragLayer = mLauncher.getDragLayer();
3882         if (animationType == CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION) {
3883             mLauncher.getDragLayer().animateViewIntoPosition(dragView, finalPos, 0f, 0.1f, 0.1f,
3884                     DragLayer.ANIMATION_END_DISAPPEAR, onCompleteRunnable, duration);
3885         } else {
3886             int endStyle;
3887             if (animationType == ANIMATE_INTO_POSITION_AND_REMAIN) {
3888                 endStyle = DragLayer.ANIMATION_END_REMAIN_VISIBLE;
3889             } else {
3890                 endStyle = DragLayer.ANIMATION_END_DISAPPEAR;;
3891             }
3892 
3893             Runnable onComplete = new Runnable() {
3894                 @Override
3895                 public void run() {
3896                     if (finalView != null) {
3897                         finalView.setVisibility(VISIBLE);
3898                     }
3899                     if (onCompleteRunnable != null) {
3900                         onCompleteRunnable.run();
3901                     }
3902                 }
3903             };
3904             dragLayer.animateViewIntoPosition(dragView, from.left, from.top, finalPos[0],
3905                     finalPos[1], 1, 1, 1, scaleXY[0], scaleXY[1], onComplete, endStyle,
3906                     duration, this);
3907         }
3908     }
3909 
3910     public void setFinalTransitionTransform(CellLayout layout) {
3911         if (isSwitchingState()) {
3912             mCurrentScale = getScaleX();
3913             setScaleX(mNewScale);
3914             setScaleY(mNewScale);
3915         }
3916     }
3917     public void resetTransitionTransform(CellLayout layout) {
3918         if (isSwitchingState()) {
3919             setScaleX(mCurrentScale);
3920             setScaleY(mCurrentScale);
3921         }
3922     }
3923 
3924     /**
3925      * Return the current {@link CellLayout}, correctly picking the destination
3926      * screen while a scroll is in progress.
3927      */
3928     public CellLayout getCurrentDropLayout() {
3929         return (CellLayout) getChildAt(getNextPage());
3930     }
3931 
3932     /**
3933      * Return the current CellInfo describing our current drag; this method exists
3934      * so that Launcher can sync this object with the correct info when the activity is created/
3935      * destroyed
3936      *
3937      */
3938     public CellLayout.CellInfo getDragInfo() {
3939         return mDragInfo;
3940     }
3941 
3942     public int getRestorePage() {
3943         return getNextPage() - numCustomPages();
3944     }
3945 
3946     /**
3947      * Calculate the nearest cell where the given object would be dropped.
3948      *
3949      * pixelX and pixelY should be in the coordinate system of layout
3950      */
3951     private int[] findNearestArea(int pixelX, int pixelY,
3952             int spanX, int spanY, CellLayout layout, int[] recycle) {
3953         return layout.findNearestArea(
3954                 pixelX, pixelY, spanX, spanY, recycle);
3955     }
3956 
3957     void setup(DragController dragController) {
3958         mSpringLoadedDragController = new SpringLoadedDragController(mLauncher);
3959         mDragController = dragController;
3960 
3961         // hardware layers on children are enabled on startup, but should be disabled until
3962         // needed
3963         updateChildrenLayersEnabled(false);
3964         setWallpaperDimension();
3965     }
3966 
3967     /**
3968      * Called at the end of a drag which originated on the workspace.
3969      */
3970     public void onDropCompleted(final View target, final DragObject d,
3971             final boolean isFlingToDelete, final boolean success) {
3972         if (mDeferDropAfterUninstall) {
3973             mDeferredAction = new Runnable() {
3974                 public void run() {
3975                     onDropCompleted(target, d, isFlingToDelete, success);
3976                     mDeferredAction = null;
3977                 }
3978             };
3979             return;
3980         }
3981 
3982         boolean beingCalledAfterUninstall = mDeferredAction != null;
3983 
3984         if (success &amp;&amp; !(beingCalledAfterUninstall &amp;&amp; !mUninstallSuccessful)) {
3985             if (target != this &amp;&amp; mDragInfo != null) {
3986                 CellLayout parentCell = getParentCellLayoutForView(mDragInfo.cell);
3987                 if (parentCell != null) {
3988                     parentCell.removeView(mDragInfo.cell);
3989                 }
3990                 if (mDragInfo.cell instanceof DropTarget) {
3991                     mDragController.removeDropTarget((DropTarget) mDragInfo.cell);
3992                 }
3993                 // If we move the item to anything not on the Workspace, check if any empty
3994                 // screens need to be removed. If we dropped back on the workspace, this will
3995                 // be done post drop animation.
3996                 removeExtraEmptyScreen(true, null, 0, true);
3997             }
3998         } else if (mDragInfo != null) {
3999             CellLayout cellLayout;
4000             if (mLauncher.isHotseatLayout(target)) {
4001                 cellLayout = mLauncher.getHotseat().getLayout();
4002             } else {
4003                 cellLayout = getScreenWithId(mDragInfo.screenId);
4004             }
4005             cellLayout.onDropChild(mDragInfo.cell);
4006         }
4007         if ((d.cancelled || (beingCalledAfterUninstall &amp;&amp; !mUninstallSuccessful))
4008                 &amp;&amp; mDragInfo.cell != null) {
4009             mDragInfo.cell.setVisibility(VISIBLE);
4010         }
4011         mDragOutline = null;
4012         mDragInfo = null;
4013     }
4014 
4015     public void deferCompleteDropAfterUninstallActivity() {
4016         mDeferDropAfterUninstall = true;
4017     }
4018 
4019     /// maybe move this into a smaller part
4020     public void onUninstallActivityReturned(boolean success) {
4021         mDeferDropAfterUninstall = false;
4022         mUninstallSuccessful = success;
4023         if (mDeferredAction != null) {
4024             mDeferredAction.run();
4025         }
4026     }
4027 
4028     void updateItemLocationsInDatabase(CellLayout cl) {
4029         int count = cl.getShortcutsAndWidgets().getChildCount();
4030 
4031         long screenId = getIdForScreen(cl);
4032         int container = Favorites.CONTAINER_DESKTOP;
4033 
4034         if (mLauncher.isHotseatLayout(cl)) {
4035             screenId = -1;
4036             container = Favorites.CONTAINER_HOTSEAT;
4037         }
4038 
4039         for (int i = 0; i &lt; count; i++) {
4040             View v = cl.getShortcutsAndWidgets().getChildAt(i);
4041             ItemInfo info = (ItemInfo) v.getTag();
4042             // Null check required as the AllApps button doesn&#x27;t have an item info
4043             if (info != null &amp;&amp; info.requiresDbUpdate) {
4044                 info.requiresDbUpdate = false;
4045                 LauncherModel.modifyItemInDatabase(mLauncher, info, container, screenId, info.cellX,
4046                         info.cellY, info.spanX, info.spanY);
4047             }
4048         }
4049     }
4050 
<abbr title="4051     ArrayList&lt;ComponentName&gt; getUniqueComponents(boolean stripDuplicates, ArrayList&lt;ComponentName&gt; duplicates) {">4051     ArrayList&lt;ComponentName&gt; getUniqueComponents(boolean stripDuplicates, ArrayList&lt;ComponentName&gt; duplic🔵</abbr>
4052         ArrayList&lt;ComponentName&gt; uniqueIntents = new ArrayList&lt;ComponentName&gt;();
<abbr title="4053         getUniqueIntents((CellLayout) mLauncher.getHotseat().getLayout(), uniqueIntents, duplicates, false);">4053         getUniqueIntents((CellLayout) mLauncher.getHotseat().getLayout(), uniqueIntents, duplicates, fals🔵</abbr>
4054         int count = getChildCount();
4055         for (int i = 0; i &lt; count; i++) {
4056             CellLayout cl = (CellLayout) getChildAt(i);
4057             getUniqueIntents(cl, uniqueIntents, duplicates, false);
4058         }
4059         return uniqueIntents;
4060     }
4061 
4062     void getUniqueIntents(CellLayout cl, ArrayList&lt;ComponentName&gt; uniqueIntents,
4063             ArrayList&lt;ComponentName&gt; duplicates, boolean stripDuplicates) {
4064         int count = cl.getShortcutsAndWidgets().getChildCount();
4065 
4066         ArrayList&lt;View&gt; children = new ArrayList&lt;View&gt;();
4067         for (int i = 0; i &lt; count; i++) {
4068             View v = cl.getShortcutsAndWidgets().getChildAt(i);
4069             children.add(v);
4070         }
4071 
4072         for (int i = 0; i &lt; count; i++) {
4073             View v = children.get(i);
4074             ItemInfo info = (ItemInfo) v.getTag();
4075             // Null check required as the AllApps button doesn&#x27;t have an item info
4076             if (info instanceof ShortcutInfo) {
4077                 ShortcutInfo si = (ShortcutInfo) info;
4078                 ComponentName cn = si.intent.getComponent();
4079 
4080                 Uri dataUri = si.intent.getData();
4081                 // If dataUri is not null / empty or if this component isn&#x27;t one that would
4082                 // have previously showed up in the AllApps list, then this is a widget-type
4083                 // shortcut, so ignore it.
4084                 if (dataUri != null &amp;&amp; !dataUri.equals(Uri.EMPTY)) {
4085                     continue;
4086                 }
4087 
4088                 if (!uniqueIntents.contains(cn)) {
4089                     uniqueIntents.add(cn);
4090                 } else {
4091                     if (stripDuplicates) {
4092                         cl.removeViewInLayout(v);
4093                         LauncherModel.deleteItemFromDatabase(mLauncher, si);
4094                     }
4095                     if (duplicates != null) {
4096                         duplicates.add(cn);
4097                     }
4098                 }
4099             }
4100             if (v instanceof FolderIcon) {
4101                 FolderIcon fi = (FolderIcon) v;
4102                 ArrayList&lt;View&gt; items = fi.getFolder().getItemsInReadingOrder();
4103                 for (int j = 0; j &lt; items.size(); j++) {
4104                     if (items.get(j).getTag() instanceof ShortcutInfo) {
4105                         ShortcutInfo si = (ShortcutInfo) items.get(j).getTag();
4106                         ComponentName cn = si.intent.getComponent();
4107 
4108                         Uri dataUri = si.intent.getData();
4109                         // If dataUri is not null / empty or if this component isn&#x27;t one that would
4110                         // have previously showed up in the AllApps list, then this is a widget-type
4111                         // shortcut, so ignore it.
4112                         if (dataUri != null &amp;&amp; !dataUri.equals(Uri.EMPTY)) {
4113                             continue;
4114                         }
4115 
4116                         if (!uniqueIntents.contains(cn)) {
4117                             uniqueIntents.add(cn);
4118                         }  else {
4119                             if (stripDuplicates) {
4120                                 fi.getFolderInfo().remove(si);
4121                                 LauncherModel.deleteItemFromDatabase(mLauncher, si);
4122                             }
4123                             if (duplicates != null) {
4124                                 duplicates.add(cn);
4125                             }
4126                         }
4127                     }
4128                 }
4129             }
4130         }
4131     }
4132 
4133     void saveWorkspaceToDb() {
4134         saveWorkspaceScreenToDb((CellLayout) mLauncher.getHotseat().getLayout());
4135         int count = getChildCount();
4136         for (int i = 0; i &lt; count; i++) {
4137             CellLayout cl = (CellLayout) getChildAt(i);
4138             saveWorkspaceScreenToDb(cl);
4139         }
4140     }
4141 
4142     void saveWorkspaceScreenToDb(CellLayout cl) {
4143         int count = cl.getShortcutsAndWidgets().getChildCount();
4144 
4145         long screenId = getIdForScreen(cl);
4146         int container = Favorites.CONTAINER_DESKTOP;
4147 
4148         Hotseat hotseat = mLauncher.getHotseat();
4149         if (mLauncher.isHotseatLayout(cl)) {
4150             screenId = -1;
4151             container = Favorites.CONTAINER_HOTSEAT;
4152         }
4153 
4154         for (int i = 0; i &lt; count; i++) {
4155             View v = cl.getShortcutsAndWidgets().getChildAt(i);
4156             ItemInfo info = (ItemInfo) v.getTag();
4157             // Null check required as the AllApps button doesn&#x27;t have an item info
4158             if (info != null) {
4159                 int cellX = info.cellX;
4160                 int cellY = info.cellY;
4161                 if (container == Favorites.CONTAINER_HOTSEAT) {
4162                     cellX = hotseat.getCellXFromOrder((int) info.screenId);
4163                     cellY = hotseat.getCellYFromOrder((int) info.screenId);
4164                 }
4165                 LauncherModel.addItemToDatabase(mLauncher, info, container, screenId, cellX,
4166                         cellY, false);
4167             }
4168             if (v instanceof FolderIcon) {
4169                 FolderIcon fi = (FolderIcon) v;
4170                 fi.getFolder().addItemLocationsInDatabase();
4171             }
4172         }
4173     }
4174 
4175     @Override
4176     public float getIntrinsicIconScaleFactor() {
4177         return 1f;
4178     }
4179 
4180     @Override
4181     public boolean supportsFlingToDelete() {
4182         return true;
4183     }
4184 
4185     @Override
4186     public void onFlingToDelete(DragObject d, int x, int y, PointF vec) {
4187         // Do nothing
4188     }
4189 
4190     @Override
4191     public void onFlingToDeleteCompleted() {
4192         // Do nothing
4193     }
4194 
4195     public boolean isDropEnabled() {
4196         return true;
4197     }
4198 
4199     @Override
4200     protected void onRestoreInstanceState(Parcelable state) {
4201         super.onRestoreInstanceState(state);
4202         Launcher.setScreen(mCurrentPage);
4203     }
4204 
4205     @Override
4206     protected void dispatchRestoreInstanceState(SparseArray&lt;Parcelable&gt; container) {
4207         // We don&#x27;t dispatch restoreInstanceState to our children using this code path.
4208         // Some pages will be restored immediately as their items are bound immediately, and
4209         // others we will need to wait until after their items are bound.
4210         mSavedStates = container;
4211     }
4212 
4213     public void restoreInstanceStateForChild(int child) {
4214         if (mSavedStates != null) {
4215             mRestoredPages.add(child);
4216             CellLayout cl = (CellLayout) getChildAt(child);
4217             cl.restoreInstanceState(mSavedStates);
4218         }
4219     }
4220 
4221     public void restoreInstanceStateForRemainingPages() {
4222         int count = getChildCount();
4223         for (int i = 0; i &lt; count; i++) {
4224             if (!mRestoredPages.contains(i)) {
4225                 restoreInstanceStateForChild(i);
4226             }
4227         }
4228         mRestoredPages.clear();
4229         mSavedStates = null;
4230     }
4231 
4232     @Override
4233     public void scrollLeft() {
4234         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
4235             super.scrollLeft();
4236         }
4237         Folder openFolder = getOpenFolder();
4238         if (openFolder != null) {
4239             openFolder.completeDragExit();
4240         }
4241     }
4242 
4243     @Override
4244     public void scrollRight() {
4245         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
4246             super.scrollRight();
4247         }
4248         Folder openFolder = getOpenFolder();
4249         if (openFolder != null) {
4250             openFolder.completeDragExit();
4251         }
4252     }
4253 
4254     @Override
4255     public boolean onEnterScrollArea(int x, int y, int direction) {
4256         // Ignore the scroll area if we are dragging over the hot seat
4257         boolean isPortrait = !LauncherAppState.isScreenLandscape(getContext());
4258         if (mLauncher.getHotseat() != null &amp;&amp; isPortrait) {
4259             Rect r = new Rect();
4260             mLauncher.getHotseat().getHitRect(r);
4261             if (r.contains(x, y)) {
4262                 return false;
4263             }
4264         }
4265 
4266         boolean result = false;
4267         if (!isSmall() &amp;&amp; !mIsSwitchingState &amp;&amp; getOpenFolder() == null) {
4268             mInScrollArea = true;
4269 
4270             final int page = getNextPage() +
4271                        (direction == DragController.SCROLL_LEFT ? -1 : 1);
4272             // We always want to exit the current layout to ensure parity of enter / exit
4273             setCurrentDropLayout(null);
4274 
4275             if (0 &lt;= page &amp;&amp; page &lt; getChildCount()) {
4276                 // Ensure that we are not dragging over to the custom content screen
4277                 if (getScreenIdForPageIndex(page) == CUSTOM_CONTENT_SCREEN_ID) {
4278                     return false;
4279                 }
4280 
4281                 CellLayout layout = (CellLayout) getChildAt(page);
4282                 setCurrentDragOverlappingLayout(layout);
4283 
4284                 // Workspace is responsible for drawing the edge glow on adjacent pages,
4285                 // so we need to redraw the workspace when this may have changed.
4286                 invalidate();
4287                 result = true;
4288             }
4289         }
4290         return result;
4291     }
4292 
4293     @Override
4294     public boolean onExitScrollArea() {
4295         boolean result = false;
4296         if (mInScrollArea) {
4297             invalidate();
4298             CellLayout layout = getCurrentDropLayout();
4299             setCurrentDropLayout(layout);
4300             setCurrentDragOverlappingLayout(layout);
4301 
4302             result = true;
4303             mInScrollArea = false;
4304         }
4305         return result;
4306     }
4307 
4308     private void onResetScrollArea() {
4309         setCurrentDragOverlappingLayout(null);
4310         mInScrollArea = false;
4311     }
4312 
4313     /**
4314      * Returns a specific CellLayout
4315      */
4316     CellLayout getParentCellLayoutForView(View v) {
4317         ArrayList&lt;CellLayout&gt; layouts = getWorkspaceAndHotseatCellLayouts();
4318         for (CellLayout layout : layouts) {
4319             if (layout.getShortcutsAndWidgets().indexOfChild(v) &gt; -1) {
4320                 return layout;
4321             }
4322         }
4323         return null;
4324     }
4325 
4326     /**
4327      * Returns a list of all the CellLayouts in the workspace.
4328      */
4329     ArrayList&lt;CellLayout&gt; getWorkspaceAndHotseatCellLayouts() {
4330         ArrayList&lt;CellLayout&gt; layouts = new ArrayList&lt;CellLayout&gt;();
4331         int screenCount = getChildCount();
4332         for (int screen = 0; screen &lt; screenCount; screen++) {
4333             layouts.add(((CellLayout) getChildAt(screen)));
4334         }
4335         if (mLauncher.getHotseat() != null) {
4336             layouts.add(mLauncher.getHotseat().getLayout());
4337         }
4338         return layouts;
4339     }
4340 
4341     /**
4342      * We should only use this to search for specific children.  Do not use this method to modify
4343      * ShortcutsAndWidgetsContainer directly. Includes ShortcutAndWidgetContainers from
4344      * the hotseat and workspace pages
4345      */
4346     ArrayList&lt;ShortcutAndWidgetContainer&gt; getAllShortcutAndWidgetContainers() {
4347         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4348                 new ArrayList&lt;ShortcutAndWidgetContainer&gt;();
4349         int screenCount = getChildCount();
4350         for (int screen = 0; screen &lt; screenCount; screen++) {
4351             childrenLayouts.add(((CellLayout) getChildAt(screen)).getShortcutsAndWidgets());
4352         }
4353         if (mLauncher.getHotseat() != null) {
4354             childrenLayouts.add(mLauncher.getHotseat().getLayout().getShortcutsAndWidgets());
4355         }
4356         return childrenLayouts;
4357     }
4358 
4359     public Folder getFolderForTag(Object tag) {
4360         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4361                 getAllShortcutAndWidgetContainers();
4362         for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4363             int count = layout.getChildCount();
4364             for (int i = 0; i &lt; count; i++) {
4365                 View child = layout.getChildAt(i);
4366                 if (child instanceof Folder) {
4367                     Folder f = (Folder) child;
4368                     if (f.getInfo() == tag &amp;&amp; f.getInfo().opened) {
4369                         return f;
4370                     }
4371                 }
4372             }
4373         }
4374         return null;
4375     }
4376 
4377     public View getViewForTag(Object tag) {
4378         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4379                 getAllShortcutAndWidgetContainers();
4380         for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4381             int count = layout.getChildCount();
4382             for (int i = 0; i &lt; count; i++) {
4383                 View child = layout.getChildAt(i);
4384                 if (child.getTag() == tag) {
4385                     return child;
4386                 }
4387             }
4388         }
4389         return null;
4390     }
4391 
4392     void clearDropTargets() {
4393         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4394                 getAllShortcutAndWidgetContainers();
4395         for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4396             int childCount = layout.getChildCount();
4397             for (int j = 0; j &lt; childCount; j++) {
4398                 View v = layout.getChildAt(j);
4399                 if (v instanceof DropTarget) {
4400                     mDragController.removeDropTarget((DropTarget) v);
4401                 }
4402             }
4403         }
4404     }
4405 
4406     // Removes ALL items that match a given package name, this is usually called when a package
4407     // has been removed and we want to remove all components (widgets, shortcuts, apps) that
4408     // belong to that package.
4409     void removeItemsByPackageName(final ArrayList&lt;String&gt; packages) {
4410         final HashSet&lt;String&gt; packageNames = new HashSet&lt;String&gt;();
4411         packageNames.addAll(packages);
4412 
4413         // Filter out all the ItemInfos that this is going to affect
4414         final HashSet&lt;ItemInfo&gt; infos = new HashSet&lt;ItemInfo&gt;();
4415         final HashSet&lt;ComponentName&gt; cns = new HashSet&lt;ComponentName&gt;();
4416         ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
4417         for (CellLayout layoutParent : cellLayouts) {
4418             ViewGroup layout = layoutParent.getShortcutsAndWidgets();
4419             int childCount = layout.getChildCount();
4420             for (int i = 0; i &lt; childCount; ++i) {
4421                 View view = layout.getChildAt(i);
4422                 infos.add((ItemInfo) view.getTag());
4423             }
4424         }
4425         LauncherModel.ItemInfoFilter filter = new LauncherModel.ItemInfoFilter() {
4426             @Override
4427             public boolean filterItem(ItemInfo parent, ItemInfo info,
4428                                       ComponentName cn) {
4429                 if (packageNames.contains(cn.getPackageName())) {
4430                     cns.add(cn);
4431                     return true;
4432                 }
4433                 return false;
4434             }
4435         };
4436         LauncherModel.filterItemInfos(infos, filter);
4437 
4438         // Remove the affected components
4439         removeItemsByComponentName(cns);
4440     }
4441 
4442     // Removes items that match the application info specified, when applications are removed
4443     // as a part of an update, this is called to ensure that other widgets and application
4444     // shortcuts are not removed.
4445     void removeItemsByApplicationInfo(final ArrayList&lt;AppInfo&gt; appInfos) {
4446         // Just create a hash table of all the specific components that this will affect
4447         HashSet&lt;ComponentName&gt; cns = new HashSet&lt;ComponentName&gt;();
4448         for (AppInfo info : appInfos) {
4449             cns.add(info.componentName);
4450         }
4451 
4452         // Remove all the things
4453         removeItemsByComponentName(cns);
4454     }
4455 
4456     void removeItemsByComponentName(final HashSet&lt;ComponentName&gt; componentNames) {
4457         ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
4458         for (final CellLayout layoutParent: cellLayouts) {
4459             final ViewGroup layout = layoutParent.getShortcutsAndWidgets();
4460 
4461             final HashMap&lt;ItemInfo, View&gt; children = new HashMap&lt;ItemInfo, View&gt;();
4462             for (int j = 0; j &lt; layout.getChildCount(); j++) {
4463                 final View view = layout.getChildAt(j);
4464                 children.put((ItemInfo) view.getTag(), view);
4465             }
4466 
4467             final ArrayList&lt;View&gt; childrenToRemove = new ArrayList&lt;View&gt;();
4468             final HashMap&lt;FolderInfo, ArrayList&lt;ShortcutInfo&gt;&gt; folderAppsToRemove =
4469                     new HashMap&lt;FolderInfo, ArrayList&lt;ShortcutInfo&gt;&gt;();
4470             LauncherModel.ItemInfoFilter filter = new LauncherModel.ItemInfoFilter() {
4471                 @Override
4472                 public boolean filterItem(ItemInfo parent, ItemInfo info,
4473                                           ComponentName cn) {
4474                     if (parent instanceof FolderInfo) {
4475                         if (componentNames.contains(cn)) {
4476                             FolderInfo folder = (FolderInfo) parent;
4477                             ArrayList&lt;ShortcutInfo&gt; appsToRemove;
4478                             if (folderAppsToRemove.containsKey(folder)) {
4479                                 appsToRemove = folderAppsToRemove.get(folder);
4480                             } else {
4481                                 appsToRemove = new ArrayList&lt;ShortcutInfo&gt;();
4482                                 folderAppsToRemove.put(folder, appsToRemove);
4483                             }
4484                             appsToRemove.add((ShortcutInfo) info);
4485                             return true;
4486                         }
4487                     } else {
4488                         if (componentNames.contains(cn)) {
4489                             childrenToRemove.add(children.get(info));
4490                             return true;
4491                         }
4492                     }
4493                     return false;
4494                 }
4495             };
4496             LauncherModel.filterItemInfos(children.keySet(), filter);
4497 
4498             // Remove all the apps from their folders
4499             for (FolderInfo folder : folderAppsToRemove.keySet()) {
4500                 ArrayList&lt;ShortcutInfo&gt; appsToRemove = folderAppsToRemove.get(folder);
4501                 for (ShortcutInfo info : appsToRemove) {
4502                     folder.remove(info);
4503                 }
4504             }
4505 
4506             // Remove all the other children
4507             for (View child : childrenToRemove) {
4508                 // Note: We can not remove the view directly from CellLayoutChildren as this
4509                 // does not re-mark the spaces as unoccupied.
4510                 layoutParent.removeViewInLayout(child);
4511                 if (child instanceof DropTarget) {
4512                     mDragController.removeDropTarget((DropTarget) child);
4513                 }
4514             }
4515 
4516             if (childrenToRemove.size() &gt; 0) {
4517                 layout.requestLayout();
4518                 layout.invalidate();
4519             }
4520         }
4521 
4522         // Strip all the empty screens
4523         stripEmptyScreens();
4524     }
4525 
4526     private void updateShortcut(HashMap&lt;ComponentName, AppInfo&gt; appsMap, ItemInfo info,
4527                                 View child) {
4528         ComponentName cn = info.getIntent().getComponent();
4529         if (cn != null) {
4530             AppInfo appInfo = appsMap.get(info.getIntent().getComponent());
4531             if ((appInfo != null) &amp;&amp; LauncherModel.isShortcutInfoUpdateable(info)) {
4532                 ShortcutInfo shortcutInfo = (ShortcutInfo) info;
4533                 BubbleTextView shortcut = (BubbleTextView) child;
4534                 shortcutInfo.updateIcon(mIconCache);
4535                 shortcutInfo.title = appInfo.title.toString();
4536                 shortcut.applyFromShortcutInfo(shortcutInfo, mIconCache);
4537             }
4538         }
4539     }
4540 
4541     void updateShortcuts(ArrayList&lt;AppInfo&gt; apps) {
4542         // Create a map of the apps to test against
4543         final HashMap&lt;ComponentName, AppInfo&gt; appsMap = new HashMap&lt;ComponentName, AppInfo&gt;();
4544         for (AppInfo ai : apps) {
4545             appsMap.put(ai.componentName, ai);
4546         }
4547 
4548         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts = getAllShortcutAndWidgetContainers();
4549         for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4550             // Update all the children shortcuts
4551             final HashMap&lt;ItemInfo, View&gt; children = new HashMap&lt;ItemInfo, View&gt;();
4552             for (int j = 0; j &lt; layout.getChildCount(); j++) {
4553                 View v = layout.getChildAt(j);
4554                 ItemInfo info = (ItemInfo) v.getTag();
4555                 if (info instanceof FolderInfo &amp;&amp; v instanceof FolderIcon) {
4556                     FolderIcon folder = (FolderIcon) v;
4557                     ArrayList&lt;View&gt; folderChildren = folder.getFolder().getItemsInReadingOrder();
4558                     for (View fv : folderChildren) {
4559                         info = (ItemInfo) fv.getTag();
4560                         updateShortcut(appsMap, info, fv);
4561                     }
4562                     folder.invalidate();
4563                 } else if (info instanceof ShortcutInfo) {
4564                     updateShortcut(appsMap, info, v);
4565                 }
4566             }
4567         }
4568     }
4569 
4570     private void moveToScreen(int page, boolean animate) {
4571         if (!isSmall()) {
4572             if (animate) {
4573                 snapToPage(page);
4574             } else {
4575                 setCurrentPage(page);
4576             }
4577         }
4578         View child = getChildAt(page);
4579         if (child != null) {
4580             child.requestFocus();
4581         }
4582     }
4583 
4584     void moveToDefaultScreen(boolean animate) {
4585         moveToScreen(mDefaultPage, animate);
4586     }
4587 
4588     void moveToCustomContentScreen(boolean animate) {
4589         if (hasCustomContent()) {
4590             int ccIndex = getPageIndexForScreenId(CUSTOM_CONTENT_SCREEN_ID);
4591             if (animate) {
4592                 snapToPage(ccIndex);
4593             } else {
4594                 setCurrentPage(ccIndex);
4595             }
4596             View child = getChildAt(ccIndex);
4597             if (child != null) {
4598                 child.requestFocus();
4599             }
4600          }
4601         exitWidgetResizeMode();
4602     }
4603 
4604     @Override
4605     protected PageIndicator.PageMarkerResources getPageIndicatorMarker(int pageIndex) {
4606         long screenId = getScreenIdForPageIndex(pageIndex);
4607         if (screenId == EXTRA_EMPTY_SCREEN_ID) {
4608             int count = mScreenOrder.size() - numCustomPages();
4609             if (count &gt; 1) {
4610                 return new PageIndicator.PageMarkerResources(R.drawable.ic_pageindicator_current,
4611                         R.drawable.ic_pageindicator_add);
4612             }
4613         }
4614 
4615         return super.getPageIndicatorMarker(pageIndex);
4616     }
4617 
4618     @Override
4619     public void syncPages() {
4620     }
4621 
4622     @Override
4623     public void syncPageItems(int page, boolean immediate) {
4624     }
4625 
4626     protected String getPageIndicatorDescription() {
4627         String settings = getResources().getString(R.string.settings_button_text);
4628         return getCurrentPageDescription() + &quot;, &quot; + settings;
4629     }
4630 
4631     protected String getCurrentPageDescription() {
4632         int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
4633         int delta = numCustomPages();
4634         if (hasCustomContent() &amp;&amp; getNextPage() == 0) {
4635             return mCustomContentDescription;
4636         }
4637         return String.format(getContext().getString(R.string.workspace_scroll_format),
4638                 page + 1 - delta, getChildCount() - delta);
4639     }
4640 
4641     public void getLocationInDragLayer(int[] loc) {
4642         mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
4643     }
4644 }
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2008 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.animation.Animator.AnimatorListener;
  19 import android.animation.Animator;
  20 import android.animation.AnimatorListenerAdapter;
  21 import android.animation.AnimatorSet;
  22 import android.animation.LayoutTransition;
  23 import android.animation.ObjectAnimator;
  24 import android.animation.PropertyValuesHolder;
  25 import android.animation.TimeInterpolator;
  26 import android.animation.ValueAnimator.AnimatorUpdateListener;
  27 import android.animation.ValueAnimator;
  28 import android.app.WallpaperManager;
  29 import android.appwidget.AppWidgetHostView;
  30 import android.appwidget.AppWidgetProviderInfo;
  31 import android.content.ComponentName;
  32 import android.content.Context;
  33 import android.content.Intent;
  34 import android.content.SharedPreferences;
  35 import android.content.res.Resources;
  36 import android.content.res.TypedArray;
  37 import android.graphics.Bitmap;
  38 import android.graphics.Canvas;
  39 import android.graphics.Matrix;
  40 import android.graphics.Point;
  41 import android.graphics.PointF;
  42 import android.graphics.Rect;
  43 import android.graphics.Region.Op;
  44 import android.graphics.drawable.Drawable;
  45 import android.net.Uri;
  46 import android.os.IBinder;
  47 import android.os.Parcelable;
  48 import android.support.v4.view.ViewCompat;
  49 import android.util.AttributeSet;
  50 import android.util.Log;
  51 import android.util.SparseArray;
  52 import android.view.Choreographer;
  53 import android.view.Display;
  54 import android.view.MotionEvent;
  55 import android.view.View.OnClickListener;
  56 import android.view.View;
  57 import android.view.ViewGroup;
  58 import android.view.accessibility.AccessibilityEvent;
  59 import android.view.accessibility.AccessibilityManager;
  60 import android.view.accessibility.AccessibilityNodeInfo;
  61 import android.view.animation.DecelerateInterpolator;
  62 import android.view.animation.Interpolator;
  63 import android.widget.TextView;
  64 import com.android.launcher3.FolderIcon.FolderRingAnimator;
  65 import com.android.launcher3.Launcher.CustomContentCallbacks;
  66 import com.android.launcher3.LauncherSettings.Favorites;
  67 import java.util.ArrayList;
  68 import java.util.HashMap;
  69 import java.util.HashSet;
  70 import java.util.Iterator;
  71 
  72 
  73 /**
  74  * The workspace is a wide area with a wallpaper and a finite number of pages.
  75  * Each page contains a number of icons, folders or widgets the user can
  76  * interact with. A workspace is meant to be used with a fixed width only.
  77  */
<abbr title="  78 public class Workspace extends SmoothPagedView implements DropTarget , DragSource , DragScroller , View.OnTouchListener , DragController.DragListener , LauncherTransitionable , ViewGroup.OnHierarchyChangeListener , Insettable {">  78 public class Workspace extends SmoothPagedView implements DropTarget , DragSource , DragScroller , View.O🔵</abbr>
  79     private static final String TAG = &quot;Launcher.Workspace&quot;;
  80 
  81     // Y rotation to apply to the workspace screens
  82     // Y rotation to apply to the workspace screens
  83     private static final float WORKSPACE_OVERSCROLL_ROTATION = 24f;
  84 
  85     private static final int CHILDREN_OUTLINE_FADE_OUT_DELAY = 0;
  86 
  87     private static final int CHILDREN_OUTLINE_FADE_OUT_DURATION = 375;
  88 
  89     private static final int CHILDREN_OUTLINE_FADE_IN_DURATION = 100;
  90 
  91     protected static final int SNAP_OFF_EMPTY_SCREEN_DURATION = 400;
  92 
  93     protected static final int FADE_EMPTY_SCREEN_DURATION = 150;
  94 
  95     private static final int BACKGROUND_FADE_OUT_DURATION = 350;
  96 
  97     private static final int ADJACENT_SCREEN_DROP_DURATION = 300;
  98 
  99     private static final int FLING_THRESHOLD_VELOCITY = 500;
 100 
 101     private static final float ALPHA_CUTOFF_THRESHOLD = 0.01f;
 102 
 103     // These animators are used to fade the children&#x27;s outlines
 104     // These animators are used to fade the children&#x27;s outlines
 105     private ObjectAnimator mChildrenOutlineFadeInAnimation;
 106 
 107     private ObjectAnimator mChildrenOutlineFadeOutAnimation;
 108 
 109     private float mChildrenOutlineAlpha = 0;
 110 
 111     // These properties refer to the background protection gradient used for AllApps and Customize
 112     // These properties refer to the background protection gradient used for AllApps and Customize
 113     private ValueAnimator mBackgroundFadeInAnimation;
 114 
 115     private ValueAnimator mBackgroundFadeOutAnimation;
 116 
 117     private Drawable mBackground;
 118 
 119     boolean mDrawBackground = true;
 120 
 121     private float mBackgroundAlpha = 0;
 122 
 123     private static final long CUSTOM_CONTENT_GESTURE_DELAY = 200;
 124 
 125     private long mTouchDownTime = -1;
 126 
 127     private long mCustomContentShowTime = -1;
 128 
 129     private LayoutTransition mLayoutTransition;
 130 
 131     private final WallpaperManager mWallpaperManager;
 132 
 133     private IBinder mWindowToken;
 134 
 135     private int mOriginalDefaultPage;
 136 
 137     private int mDefaultPage;
 138 
 139     private ShortcutAndWidgetContainer mDragSourceInternal;
 140 
 141     private static boolean sAccessibilityEnabled;
 142 
 143     // The screen id used for the empty screen always present to the right.
 144     // The screen id used for the empty screen always present to the right.
 145     private final static long EXTRA_EMPTY_SCREEN_ID = -201;
 146 
 147     private final static long CUSTOM_CONTENT_SCREEN_ID = -301;
 148 
 149     private HashMap&lt;Long, CellLayout&gt; mWorkspaceScreens = new HashMap&lt;Long, CellLayout&gt;();
 150 
 151     private ArrayList&lt;Long&gt; mScreenOrder = new ArrayList&lt;Long&gt;();
 152 
 153     private Runnable mRemoveEmptyScreenRunnable;
 154 
 155     /**
 156      * CellInfo for the cell that is currently being dragged
 157      */
 158     private CellLayout.CellInfo mDragInfo;
 159 
 160     /**
 161      * Target drop area calculated during last acceptDrop call.
 162      */
 163     private int[] mTargetCell = new int[2];
 164 
 165     private int mDragOverX = -1;
 166 
 167     private int mDragOverY = -1;
 168 
 169     static Rect mLandscapeCellLayoutMetrics = null;
 170 
 171     static Rect mPortraitCellLayoutMetrics = null;
 172 
 173     CustomContentCallbacks mCustomContentCallbacks;
 174 
 175     boolean mCustomContentShowing;
 176 
 177     private float mLastCustomContentScrollProgress = -1f;
 178 
 179     private String mCustomContentDescription = &quot;&quot;;
 180 
 181     /**
 182      * The CellLayout that is currently being dragged over
 183      */
 184     private CellLayout mDragTargetLayout = null;
 185 
 186     /**
 187      * The CellLayout that we will show as glowing
 188      */
 189     private CellLayout mDragOverlappingLayout = null;
 190 
 191     /**
 192      * The CellLayout which will be dropped to
 193      */
 194     private CellLayout mDropToLayout = null;
 195 
 196     private Launcher mLauncher;
 197 
 198     private IconCache mIconCache;
 199 
 200     private DragController mDragController;
 201 
 202     // These are temporary variables to prevent having to allocate a new object just to
 203     // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
 204     private int[] mTempCell = new int[2];
 205 
 206     private int[] mTempPt = new int[2];
 207 
 208     private int[] mTempEstimate = new int[2];
 209 
 210     private float[] mDragViewVisualCenter = new float[2];
 211 
 212     private float[] mTempCellLayoutCenterCoordinates = new float[2];
 213 
 214     private Matrix mTempInverseMatrix = new Matrix();
 215 
 216     private SpringLoadedDragController mSpringLoadedDragController;
 217 
 218     private float mSpringLoadedShrinkFactor;
 219 
 220     private float mOverviewModeShrinkFactor;
 221 
 222     // State variable that indicates whether the pages are small (ie when you&#x27;re
 223     // in all apps or customize mode)
 224     enum State {
 225 
 226         NORMAL,
 227         SPRING_LOADED,
 228         SMALL,
 229         OVERVIEW;}
 230 
 231     private State mState = State.NORMAL;
 232 
 233     private boolean mIsSwitchingState = false;
 234 
 235     boolean mAnimatingViewIntoPlace = false;
 236 
 237     boolean mIsDragOccuring = false;
 238 
 239     boolean mChildrenLayersEnabled = true;
 240 
 241     private boolean mStripScreensOnPageStopMoving = false;
 242 
 243     /** Is the user is dragging an item near the edge of a page? */
 244     private boolean mInScrollArea = false;
 245 
 246     private HolographicOutlineHelper mOutlineHelper;
 247 
 248     private Bitmap mDragOutline = null;
 249 
 250     private final Rect mTempRect = new Rect();
 251 
 252     private final int[] mTempXY = new int[2];
 253 
 254     private int[] mTempVisiblePagesRange = new int[2];
 255 
 256     private boolean mOverscrollTransformsSet;
 257 
 258     private float mLastOverscrollPivotX;
 259 
 260     public static final int DRAG_BITMAP_PADDING = 2;
 261 
 262     private boolean mWorkspaceFadeInAdjacentScreens;
 263 
 264     WallpaperOffsetInterpolator mWallpaperOffset;
 265 
 266     private Runnable mDelayedResizeRunnable;
 267 
 268     private Runnable mDelayedSnapToPageRunnable;
 269 
 270     private Point mDisplaySize = new Point();
 271 
 272     private int mCameraDistance;
 273 
 274     // Variables relating to the creation of user folders by hovering shortcuts over shortcuts
 275     // Variables relating to the creation of user folders by hovering shortcuts over shortcuts
 276     private static final int FOLDER_CREATION_TIMEOUT = 0;
 277 
 278     private static final int REORDER_TIMEOUT = 250;
 279 
 280     private final Alarm mFolderCreationAlarm = new Alarm();
 281 
 282     private final Alarm mReorderAlarm = new Alarm();
 283 
 284     private FolderRingAnimator mDragFolderRingAnimator = null;
 285 
 286     private FolderIcon mDragOverFolderIcon = null;
 287 
 288     private boolean mCreateUserFolderOnDrop = false;
 289 
 290     private boolean mAddToExistingFolderOnDrop = false;
 291 
 292     private DropTarget.DragEnforcer mDragEnforcer;
 293 
 294     private float mMaxDistanceForFolderCreation;
 295 
 296     // Variables relating to touch disambiguation (scrolling workspace vs. scrolling a widget)
 297     // Variables relating to touch disambiguation (scrolling workspace vs. scrolling a widget)
 298     private float mXDown;
 299 
 300     private float mYDown;
 301 
 302     final static float START_DAMPING_TOUCH_SLOP_ANGLE = (float) Math.PI / 6;
 303 
 304     final static float MAX_SWIPE_ANGLE = (float) Math.PI / 3;
 305 
 306     final static float TOUCH_SLOP_DAMPING_FACTOR = 4;
 307 
 308     // Relating to the animation of items being dropped externally
 309     // Relating to the animation of items being dropped externally
 310     public static final int ANIMATE_INTO_POSITION_AND_DISAPPEAR = 0;
 311 
 312     public static final int ANIMATE_INTO_POSITION_AND_REMAIN = 1;
 313 
 314     public static final int ANIMATE_INTO_POSITION_AND_RESIZE = 2;
 315 
 316     public static final int COMPLETE_TWO_STAGE_WIDGET_DROP_ANIMATION = 3;
 317 
 318     public static final int CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION = 4;
 319 
 320     // Related to dragging, folder creation and reordering
 321     private static final int DRAG_MODE_NONE = 0;
 322 
 323     private static final int DRAG_MODE_CREATE_FOLDER = 1;
 324 
 325     private static final int DRAG_MODE_ADD_TO_FOLDER = 2;
 326 
 327     private static final int DRAG_MODE_REORDER = 3;
 328 
 329     private int mDragMode = DRAG_MODE_NONE;
 330 
 331     private int mLastReorderX = -1;
 332 
 333     private int mLastReorderY = -1;
 334 
 335     private SparseArray&lt;Parcelable&gt; mSavedStates;
 336 
 337     private final ArrayList&lt;Integer&gt; mRestoredPages = new ArrayList&lt;Integer&gt;();
 338 
 339     // These variables are used for storing the initial and final values during workspace animations
 340     // These variables are used for storing the initial and final values during workspace animations
 341     private int mSavedScrollX;
 342 
 343     private float mSavedRotationY;
 344 
 345     private float mSavedTranslationX;
 346 
 347     private float mCurrentScale;
 348 
 349     private float mNewScale;
 350 
 351     private float[] mOldBackgroundAlphas;
 352 
 353     private float[] mOldAlphas;
 354 
 355     private float[] mNewBackgroundAlphas;
 356 
 357     private float[] mNewAlphas;
 358 
 359     private int mLastChildCount = -1;
 360 
 361     private float mTransitionProgress;
 362 
 363     private Runnable mDeferredAction;
 364 
 365     private boolean mDeferDropAfterUninstall;
 366 
 367     private boolean mUninstallSuccessful;
 368 
 369     private final Runnable mBindPages = new Runnable() {
 370         @Override
 371         public void run() {
 372             mLauncher.getModel().bindRemainingSynchronousPages();
 373         }
 374     };
 375 
 376     /**
 377      * Used to inflate the Workspace from XML.
 378      *
 379      * @param context
 380      * 		The application&#x27;s context.
 381      * @param attrs
 382      * 		The attributes set containing the Workspace&#x27;s customization values.
 383      */
 384     public Workspace(Context context, AttributeSet attrs) {
 385         this(context, attrs, 0);
 386     }
 387 
 388     /**
 389      * Used to inflate the Workspace from XML.
 390      *
 391      * @param context
 392      * 		The application&#x27;s context.
 393      * @param attrs
 394      * 		The attributes set containing the Workspace&#x27;s customization values.
 395      * @param defStyle
 396      * 		Unused.
 397      */
 398     public Workspace(Context context, AttributeSet attrs, int defStyle) {
 399         super(context, attrs, defStyle);
 400         mContentIsRefreshable = false;
 401         mOutlineHelper = HolographicOutlineHelper.obtain(context);
 402         mDragEnforcer = new DropTarget.DragEnforcer(context);
 403         // With workspace, data is available straight from the get-go
 404         setDataIsReady();
 405         mLauncher = ((Launcher) (context));
 406         final Resources res = getResources();
<abbr title=" 407         mWorkspaceFadeInAdjacentScreens = LauncherAppState.getInstance().getDynamicGrid().getDeviceProfile().shouldFadeAdjacentWorkspaceScreens();"> 407         mWorkspaceFadeInAdjacentScreens = LauncherAppState.getInstance().getDynamicGrid().getDeviceProfil🔵</abbr>
 408         mFadeInAdjacentScreens = false;
 409         mWallpaperManager = WallpaperManager.getInstance(context);
 410         LauncherAppState app = LauncherAppState.getInstance();
 411         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 412         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.Workspace, defStyle, 0);
<abbr title=" 413         mSpringLoadedShrinkFactor = res.getInteger(R.integer.config_workspaceSpringLoadShrinkPercentage) / 100.0F;"> 413         mSpringLoadedShrinkFactor = res.getInteger(R.integer.config_workspaceSpringLoadShrinkPercentage) 🔵</abbr>
 414         mOverviewModeShrinkFactor = grid.getOverviewModeScale();
 415         mCameraDistance = res.getInteger(R.integer.config_cameraDistance);
 416         mOriginalDefaultPage = mDefaultPage = a.getInt(R.styleable.Workspace_defaultScreen, 1);
 417         a.recycle();
 418         setOnHierarchyChangeListener(this);
 419         setHapticFeedbackEnabled(false);
 420         initWorkspace();
 421         // Disable multitouch across the workspace/all apps/customize tray
 422         setMotionEventSplittingEnabled(true);
 423         setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
 424     }
 425 
 426     @Override
 427     public void setInsets(Rect insets) {
 428         mInsets.set(insets);
 429     }
 430 
 431     // estimate the size of a widget with spans hSpan, vSpan. return MAX_VALUE for each
 432     // dimension if unsuccessful
 433     public int[] estimateItemSize(int hSpan, int vSpan,
 434             ItemInfo itemInfo, boolean springLoaded) {
 435         int[] size = new int[2];
 436         if (getChildCount() &gt; 0) {
 437             // Use the first non-custom page to estimate the child position
 438             CellLayout cl = (CellLayout) getChildAt(numCustomPages());
 439             Rect r = estimateItemPosition(cl, itemInfo, 0, 0, hSpan, vSpan);
 440             size[0] = r.width();
 441             size[1] = r.height();
 442             if (springLoaded) {
 443                 size[0] *= mSpringLoadedShrinkFactor;
 444                 size[1] *= mSpringLoadedShrinkFactor;
 445             }
 446             return size;
 447         } else {
 448             size[0] = Integer.MAX_VALUE;
 449             size[1] = Integer.MAX_VALUE;
 450             return size;
 451         }
 452     }
 453 
 454     public Rect estimateItemPosition(CellLayout cl, ItemInfo pendingInfo,
 455             int hCell, int vCell, int hSpan, int vSpan) {
 456         Rect r = new Rect();
 457         cl.cellToRect(hCell, vCell, hSpan, vSpan, r);
 458         return r;
 459     }
 460 
 461     public void onDragStart(final DragSource source, Object info, int dragAction) {
 462         mIsDragOccuring = true;
 463         updateChildrenLayersEnabled(false);
 464         mLauncher.lockScreenOrientation();
 465         mLauncher.onInteractionBegin();
 466         setChildrenBackgroundAlphaMultipliers(1f);
 467         // Prevent any Un/InstallShortcutReceivers from updating the db while we are dragging
 468         InstallShortcutReceiver.enableInstallQueue();
 469         UninstallShortcutReceiver.enableUninstallQueue();
 470         post(new Runnable() {
 471             @Override
 472             public void run() {
 473                 if (mIsDragOccuring) {
 474                     addExtraEmptyScreenOnDrag();
 475                 }
 476             }
 477         });
 478     }
 479 
 480     public void onDragEnd() {
 481         mIsDragOccuring = false;
 482         updateChildrenLayersEnabled(false);
 483         mLauncher.unlockScreenOrientation(false);
 484 
 485         // Re-enable any Un/InstallShortcutReceiver and now process any queued items
 486         InstallShortcutReceiver.disableAndFlushInstallQueue(getContext());
 487         UninstallShortcutReceiver.disableAndFlushUninstallQueue(getContext());
 488 
 489         mDragSourceInternal = null;
 490         mLauncher.onInteractionEnd();
 491     }
 492 
 493     /**
 494      * Initializes various states for this workspace.
 495      */
 496     protected void initWorkspace() {
 497         Context context = getContext();
 498         mCurrentPage = mDefaultPage;
 499         Launcher.setScreen(mCurrentPage);
 500         LauncherAppState app = LauncherAppState.getInstance();
 501         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 502         mIconCache = app.getIconCache();
 503         setWillNotDraw(false);
 504         setClipChildren(false);
 505         setClipToPadding(false);
 506         setChildrenDrawnWithCacheEnabled(true);
 507 
 508         setMinScale(mOverviewModeShrinkFactor);
 509         setupLayoutTransition();
 510 
 511         final Resources res = getResources();
 512         try {
 513             mBackground = res.getDrawable(R.drawable.apps_customize_bg);
 514         } catch (Resources.NotFoundException e) {
 515             // In this case, we will skip drawing background protection
 516         }
 517 
 518         mWallpaperOffset = new WallpaperOffsetInterpolator();
 519         Display display = mLauncher.getWindowManager().getDefaultDisplay();
 520         display.getSize(mDisplaySize);
 521 
 522         mMaxDistanceForFolderCreation = (0.55f * grid.iconSizePx);
 523         mFlingThresholdVelocity = (int) (FLING_THRESHOLD_VELOCITY * mDensity);
 524     }
 525 
 526     private void setupLayoutTransition() {
 527         // We want to show layout transitions when pages are deleted, to close the gap.
 528         mLayoutTransition = new LayoutTransition();
 529         mLayoutTransition.enableTransitionType(LayoutTransition.DISAPPEARING);
 530         mLayoutTransition.enableTransitionType(LayoutTransition.CHANGE_DISAPPEARING);
 531         mLayoutTransition.disableTransitionType(LayoutTransition.APPEARING);
 532         mLayoutTransition.disableTransitionType(LayoutTransition.CHANGE_APPEARING);
 533         setLayoutTransition(mLayoutTransition);
 534     }
 535 
 536     void enableLayoutTransitions() {
 537         setLayoutTransition(mLayoutTransition);
 538     }
 539 
 540     void disableLayoutTransitions() {
 541         setLayoutTransition(null);
 542     }
 543 
 544     @Override
 545     protected int getScrollMode() {
 546         return SmoothPagedView.X_LARGE_MODE;
 547     }
 548 
 549     @Override
 550     public void onChildViewAdded(View parent, View child) {
 551         if (!(child instanceof CellLayout)) {
 552             throw new IllegalArgumentException(&quot;A Workspace can only have CellLayout children.&quot;);
 553         }
 554         CellLayout cl = ((CellLayout) child);
 555         cl.setOnInterceptTouchListener(this);
 556         cl.setClickable(true);
 557         cl.setImportantForAccessibility(ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_NO);
 558         super.onChildViewAdded(parent, child);
 559     }
 560 
 561     protected boolean shouldDrawChild(View child) {
 562         final CellLayout cl = (CellLayout) child;
 563         return super.shouldDrawChild(child) &amp;&amp;
 564             (mIsSwitchingState ||
 565              cl.getShortcutsAndWidgets().getAlpha() &gt; 0 ||
 566              cl.getBackgroundAlpha() &gt; 0);
 567     }
 568 
 569     /**
 570      * @return The open folder on the current screen, or null if there is none
 571      */
 572     Folder getOpenFolder() {
 573         DragLayer dragLayer = mLauncher.getDragLayer();
 574         int count = dragLayer.getChildCount();
 575         for (int i = 0; i &lt; count; i++) {
 576             View child = dragLayer.getChildAt(i);
 577             if (child instanceof Folder) {
 578                 Folder folder = (Folder) child;
 579                 if (folder.getInfo().opened)
 580                     return folder;
 581             }
 582         }
 583         return null;
 584     }
 585 
 586     boolean isTouchActive() {
 587         return mTouchState != TOUCH_STATE_REST;
 588     }
 589 
 590     public void removeAllWorkspaceScreens() {
 591         // Disable all layout transitions before removing all pages to ensure that we don&#x27;t get the
 592         // transition animations competing with us changing the scroll when we add pages or the
 593         // custom content screen
 594         disableLayoutTransitions();
 595 
 596         // Since we increment the current page when we call addCustomContentPage via bindScreens
 597         // (and other places), we need to adjust the current page back when we clear the pages
 598         if (hasCustomContent()) {
 599             removeCustomContentPage();
 600         }
 601 
 602         // Remove the pages and clear the screen models
 603         removeAllViews();
 604         mScreenOrder.clear();
 605         mWorkspaceScreens.clear();
 606 
 607         // Re-enable the layout transitions
 608         enableLayoutTransitions();
 609     }
 610 
 611     public long insertNewWorkspaceScreenBeforeEmptyScreen(long screenId) {
 612         // Find the index to insert this view into.  If the empty screen exists, then
 613         // insert it before that.
 614         int insertIndex = mScreenOrder.indexOf(EXTRA_EMPTY_SCREEN_ID);
 615         if (insertIndex &lt; 0) {
 616             insertIndex = mScreenOrder.size();
 617         }
 618         return insertNewWorkspaceScreen(screenId, insertIndex);
 619     }
 620 
 621     public long insertNewWorkspaceScreen(long screenId) {
 622         return insertNewWorkspaceScreen(screenId, getChildCount());
 623     }
 624 
 625     public long insertNewWorkspaceScreen(long screenId, int insertIndex) {
 626         if (mWorkspaceScreens.containsKey(screenId)) {
 627             throw new RuntimeException(&quot;Screen id &quot; + screenId + &quot; already exists!&quot;);
 628         }
 629 
 630         CellLayout newScreen = (CellLayout)
 631                 mLauncher.getLayoutInflater().inflate(R.layout.workspace_screen, null);
 632 
 633         newScreen.setOnLongClickListener(mLongClickListener);
 634         newScreen.setOnClickListener(mLauncher);
 635         newScreen.setSoundEffectsEnabled(false);
 636         mWorkspaceScreens.put(screenId, newScreen);
 637         mScreenOrder.add(insertIndex, screenId);
 638         addView(newScreen, insertIndex);
 639         return screenId;
 640     }
 641 
 642     public void createCustomContentPage() {
 643         CellLayout customScreen = (CellLayout)
 644                 mLauncher.getLayoutInflater().inflate(R.layout.workspace_screen, null);
 645 
 646         mWorkspaceScreens.put(CUSTOM_CONTENT_SCREEN_ID, customScreen);
 647         mScreenOrder.add(0, CUSTOM_CONTENT_SCREEN_ID);
 648 
 649         // We want no padding on the custom content
 650         customScreen.setPadding(0, 0, 0, 0);
 651 
 652         addFullScreenPage(customScreen);
 653 
 654         // Ensure that the current page and default page are maintained.
 655         mDefaultPage = mOriginalDefaultPage + 1;
 656 
 657         // Update the custom content hint
 658         mLauncher.updateCustomContentHintVisibility();
 659         if (mRestorePage != INVALID_RESTORE_PAGE) {
 660             mRestorePage = mRestorePage + 1;
 661         } else {
 662             setCurrentPage(getCurrentPage() + 1);
 663         }
 664     }
 665 
 666     public void removeCustomContentPage() {
 667         CellLayout customScreen = getScreenWithId(CUSTOM_CONTENT_SCREEN_ID);
 668         if (customScreen == null) {
 669             throw new RuntimeException(&quot;Expected custom content screen to exist&quot;);
 670         }
 671 
 672         mWorkspaceScreens.remove(CUSTOM_CONTENT_SCREEN_ID);
 673         mScreenOrder.remove(CUSTOM_CONTENT_SCREEN_ID);
 674         removeView(customScreen);
 675 
 676         if (mCustomContentCallbacks != null) {
 677             mCustomContentCallbacks.onScrollProgressChanged(0);
 678             mCustomContentCallbacks.onHide();
 679         }
 680 
 681         mCustomContentCallbacks = null;
 682 
 683         // Ensure that the current page and default page are maintained.
 684         mDefaultPage = mOriginalDefaultPage - 1;
 685 
 686         // Update the custom content hint
 687         mLauncher.updateCustomContentHintVisibility();
 688         if (mRestorePage != INVALID_RESTORE_PAGE) {
 689             mRestorePage = mRestorePage - 1;
 690         } else {
 691             setCurrentPage(getCurrentPage() - 1);
 692         }
 693     }
 694 
 695     public void addToCustomContentPage(View customContent, CustomContentCallbacks callbacks,
 696             String description) {
 697         if (getPageIndexForScreenId(CUSTOM_CONTENT_SCREEN_ID) &lt; 0) {
 698             throw new RuntimeException(&quot;Expected custom content screen to exist&quot;);
 699         }
 700 
 701         // Add the custom content to the full screen custom page
 702         CellLayout customScreen = getScreenWithId(CUSTOM_CONTENT_SCREEN_ID);
 703         int spanX = customScreen.getCountX();
 704         int spanY = customScreen.getCountY();
 705         CellLayout.LayoutParams lp = new CellLayout.LayoutParams(0, 0, spanX, spanY);
 706         lp.canReorder  = false;
 707         lp.isFullscreen = true;
 708         if (customContent instanceof Insettable) {
 709             ((Insettable)customContent).setInsets(mInsets);
 710         }
 711         customScreen.removeAllViews();
 712         customScreen.addViewToCellLayout(customContent, 0, 0, lp, true);
 713         mCustomContentDescription = description;
 714 
 715         mCustomContentCallbacks = callbacks;
 716     }
 717 
 718     public void addExtraEmptyScreenOnDrag() {
 719         boolean lastChildOnScreen = false;
 720         boolean childOnFinalScreen = false;
 721 
 722         // Cancel any pending removal of empty screen
 723         mRemoveEmptyScreenRunnable = null;
 724 
 725         if (mDragSourceInternal != null) {
 726             if (mDragSourceInternal.getChildCount() == 1) {
 727                 lastChildOnScreen = true;
 728             }
 729             CellLayout cl = (CellLayout) mDragSourceInternal.getParent();
 730             if (indexOfChild(cl) == getChildCount() - 1) {
 731                 childOnFinalScreen = true;
 732             }
 733         }
 734 
 735         // If this is the last item on the final screen
 736         if (lastChildOnScreen &amp;&amp; childOnFinalScreen) {
 737             return;
 738         }
 739         if (!mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID)) {
 740             insertNewWorkspaceScreen(EXTRA_EMPTY_SCREEN_ID);
 741         }
 742     }
 743 
 744     public boolean addExtraEmptyScreen() {
 745         if (!mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID)) {
 746             insertNewWorkspaceScreen(EXTRA_EMPTY_SCREEN_ID);
 747             return true;
 748         }
 749         return false;
 750     }
 751 
 752     private void convertFinalScreenToEmptyScreenIfNecessary() {
 753         if (hasExtraEmptyScreen() || mScreenOrder.size() == 0) return;
 754         long finalScreenId = mScreenOrder.get(mScreenOrder.size() - 1);
 755 
 756         if (finalScreenId == CUSTOM_CONTENT_SCREEN_ID) return;
 757         CellLayout finalScreen = mWorkspaceScreens.get(finalScreenId);
 758 
 759         // If the final screen is empty, convert it to the extra empty screen
 760         if (finalScreen.getShortcutsAndWidgets().getChildCount() == 0 &amp;&amp;
 761                 !finalScreen.isDropPending()) {
 762             mWorkspaceScreens.remove(finalScreenId);
 763             mScreenOrder.remove(finalScreenId);
 764 
 765             // if this is the last non-custom content screen, convert it to the empty screen
 766             mWorkspaceScreens.put(EXTRA_EMPTY_SCREEN_ID, finalScreen);
 767             mScreenOrder.add(EXTRA_EMPTY_SCREEN_ID);
 768         }
 769     }
 770 
 771     public void removeExtraEmptyScreen(final boolean animate, final Runnable onComplete) {
 772         removeExtraEmptyScreen(animate, onComplete, 0, false);
 773     }
 774 
 775     public void removeExtraEmptyScreen(final boolean animate, final Runnable onComplete,
 776             final int delay, final boolean stripEmptyScreens) {
 777         if (delay &gt; 0) {
 778             postDelayed(new Runnable() {
 779                 @Override
 780                 public void run() {
 781                     removeExtraEmptyScreen(animate, onComplete, 0, stripEmptyScreens);
 782                 }
 783 
 784             }, delay);
 785             return;
 786         }
 787 
 788         convertFinalScreenToEmptyScreenIfNecessary();
 789         if (hasExtraEmptyScreen()) {
 790             int emptyIndex = mScreenOrder.indexOf(EXTRA_EMPTY_SCREEN_ID);
 791             if (getNextPage() == emptyIndex) {
 792                 snapToPage(getNextPage() - 1, SNAP_OFF_EMPTY_SCREEN_DURATION);
 793                 fadeAndRemoveEmptyScreen(SNAP_OFF_EMPTY_SCREEN_DURATION, FADE_EMPTY_SCREEN_DURATION,
 794                         onComplete, stripEmptyScreens);
 795             } else {
 796                 fadeAndRemoveEmptyScreen(0, FADE_EMPTY_SCREEN_DURATION,
 797                         onComplete, stripEmptyScreens);
 798             }
 799             return;
 800         }
 801         if (onComplete != null) {
 802             onComplete.run();
 803         }
 804     }
 805 
 806     private void fadeAndRemoveEmptyScreen(int delay, int duration, final Runnable onComplete,
 807             final boolean stripEmptyScreens) {
 808         PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0f);
 809         PropertyValuesHolder bgAlpha = PropertyValuesHolder.ofFloat(&quot;backgroundAlpha&quot;, 0f);
 810 
 811         final CellLayout cl = mWorkspaceScreens.get(EXTRA_EMPTY_SCREEN_ID);
 812 
 813         mRemoveEmptyScreenRunnable = new Runnable() {
 814             @Override
 815             public void run() {
 816                 if (hasExtraEmptyScreen()) {
 817                     mWorkspaceScreens.remove(EXTRA_EMPTY_SCREEN_ID);
 818                     mScreenOrder.remove(EXTRA_EMPTY_SCREEN_ID);
 819                     removeView(cl);
 820                     if (stripEmptyScreens) {
 821                         stripEmptyScreens();
 822                     }
 823                 }
 824             }
 825         };
 826 
 827         ObjectAnimator oa = ObjectAnimator.ofPropertyValuesHolder(cl, alpha, bgAlpha);
 828         oa.setDuration(duration);
 829         oa.setStartDelay(delay);
 830         oa.addListener(new AnimatorListenerAdapter() {
 831             @Override
 832             public void onAnimationEnd(Animator animation) {
 833                 if (mRemoveEmptyScreenRunnable != null) {
 834                     mRemoveEmptyScreenRunnable.run();
 835                 }
 836                 if (onComplete != null) {
 837                     onComplete.run();
 838                 }
 839             }
 840         });
 841         oa.start();
 842     }
 843 
 844     public boolean hasExtraEmptyScreen() {
 845         int nScreens = getChildCount();
 846         nScreens = nScreens - numCustomPages();
 847         return mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID) &amp;&amp; nScreens &gt; 1;
 848     }
 849 
 850     public long commitExtraEmptyScreen() {
 851         int index = getPageIndexForScreenId(EXTRA_EMPTY_SCREEN_ID);
 852         CellLayout cl = mWorkspaceScreens.get(EXTRA_EMPTY_SCREEN_ID);
 853         mWorkspaceScreens.remove(EXTRA_EMPTY_SCREEN_ID);
 854         mScreenOrder.remove(EXTRA_EMPTY_SCREEN_ID);
 855 
 856         long newId = LauncherAppState.getLauncherProvider().generateNewScreenId();
 857         mWorkspaceScreens.put(newId, cl);
 858         mScreenOrder.add(newId);
 859 
 860         // Update the page indicator marker
 861         if (getPageIndicator() != null) {
 862             getPageIndicator().updateMarker(index, getPageIndicatorMarker(index));
 863         }
 864 
 865         // Update the model for the new screen
 866         mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
 867 
 868         return newId;
 869     }
 870 
 871     public CellLayout getScreenWithId(long screenId) {
 872         CellLayout layout = mWorkspaceScreens.get(screenId);
 873         return layout;
 874     }
 875 
 876     public long getIdForScreen(CellLayout layout) {
 877         Iterator&lt;Long&gt; iter = mWorkspaceScreens.keySet().iterator();
 878         while (iter.hasNext()) {
 879             long id = iter.next();
 880             if (mWorkspaceScreens.get(id) == layout) {
 881                 return id;
 882             }
 883         }
 884         return -1;
 885     }
 886 
 887     public int getPageIndexForScreenId(long screenId) {
 888         return indexOfChild(mWorkspaceScreens.get(screenId));
 889     }
 890 
 891     public long getScreenIdForPageIndex(int index) {
 892         if (0 &lt;= index &amp;&amp; index &lt; mScreenOrder.size()) {
 893             return mScreenOrder.get(index);
 894         }
 895         return -1;
 896     }
 897 
 898     ArrayList&lt;Long&gt; getScreenOrder() {
 899         return mScreenOrder;
 900     }
 901 
 902     public void stripEmptyScreens() {
 903         if (isPageMoving()) {
 904             mStripScreensOnPageStopMoving = true;
 905             return;
 906         }
 907 
 908         int currentPage = getNextPage();
 909         ArrayList&lt;Long&gt; removeScreens = new ArrayList&lt;Long&gt;();
 910         for (Long id: mWorkspaceScreens.keySet()) {
 911             CellLayout cl = mWorkspaceScreens.get(id);
 912             if (id &gt;= 0 &amp;&amp; cl.getShortcutsAndWidgets().getChildCount() == 0) {
 913                 removeScreens.add(id);
 914             }
 915         }
 916 
 917         // We enforce at least one page to add new items to. In the case that we remove the last
 918         // such screen, we convert the last screen to the empty screen
 919         int minScreens = 1 + numCustomPages();
 920 
 921         int pageShift = 0;
 922         for (Long id: removeScreens) {
 923             CellLayout cl = mWorkspaceScreens.get(id);
 924             mWorkspaceScreens.remove(id);
 925             mScreenOrder.remove(id);
 926 
 927             if (getChildCount() &gt; minScreens) {
 928                 if (indexOfChild(cl) &lt; currentPage) {
 929                     pageShift++;
 930                 }
 931                 removeView(cl);
 932             } else {
 933                 // if this is the last non-custom content screen, convert it to the empty screen
 934                 mRemoveEmptyScreenRunnable = null;
 935                 mWorkspaceScreens.put(EXTRA_EMPTY_SCREEN_ID, cl);
 936                 mScreenOrder.add(EXTRA_EMPTY_SCREEN_ID);
 937             }
 938         }
 939 
 940         if (!removeScreens.isEmpty()) {
 941             // Update the model if we have changed any screens
 942             mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
 943         }
 944 
 945         if (pageShift &gt;= 0) {
 946             setCurrentPage(currentPage - pageShift);
 947         }
 948     }
 949 
 950     // See implementation for parameter definition.
 951     void addInScreen(View child, long container, long screenId,
 952             int x, int y, int spanX, int spanY) {
 953         addInScreen(child, container, screenId, x, y, spanX, spanY, false, false);
 954     }
 955 
 956     // At bind time, we use the rank (screenId) to compute x and y for hotseat items.
 957     // See implementation for parameter definition.
 958     void addInScreenFromBind(View child, long container, long screenId, int x, int y,
 959             int spanX, int spanY) {
 960         addInScreen(child, container, screenId, x, y, spanX, spanY, false, true);
 961     }
 962 
 963     // See implementation for parameter definition.
 964     void addInScreen(View child, long container, long screenId, int x, int y, int spanX, int spanY,
 965             boolean insert) {
 966         addInScreen(child, container, screenId, x, y, spanX, spanY, insert, false);
 967     }
 968 
 969     /**
 970      * Adds the specified child in the specified screen. The position and dimension of
 971      * the child are defined by x, y, spanX and spanY.
 972      *
 973      * @param child The child to add in one of the workspace&#x27;s screens.
 974      * @param screenId The screen in which to add the child.
 975      * @param x The X position of the child in the screen&#x27;s grid.
 976      * @param y The Y position of the child in the screen&#x27;s grid.
 977      * @param spanX The number of cells spanned horizontally by the child.
 978      * @param spanY The number of cells spanned vertically by the child.
 979      * @param insert When true, the child is inserted at the beginning of the children list.
 980      * @param computeXYFromRank When true, we use the rank (stored in screenId) to compute
 981      *                          the x and y position in which to place hotseat items. Otherwise
 982      *                          we use the x and y position to compute the rank.
 983      */
<abbr title=" 984     void addInScreen(View child, long container, long screenId, int x, int y, int spanX, int spanY, boolean insert, boolean computeXYFromRank) {"> 984     void addInScreen(View child, long container, long screenId, int x, int y, int spanX, int spanY, boole🔵</abbr>
 985         if (container == Favorites.CONTAINER_DESKTOP) {
 986             if (getScreenWithId(screenId) == null) {
 987                 Log.e(TAG, (&quot;Skipping child, screenId &quot; + screenId) + &quot; not found&quot;);
 988                 // DEBUGGING - Print out the stack trace to see where we are adding from
 989                 new Throwable().printStackTrace();
 990                 return;
 991             }
 992         }
 993         if (screenId == EXTRA_EMPTY_SCREEN_ID) {
 994             // This should never happen
 995             throw new RuntimeException(&quot;Screen id should not be EXTRA_EMPTY_SCREEN_ID&quot;);
 996         }
 997         final CellLayout layout;
 998         if (container == Favorites.CONTAINER_HOTSEAT) {
 999             layout = mLauncher.getHotseat().getLayout();
1000             child.setOnKeyListener(null);
1001             // Hide folder title in the hotseat
1002             if (child instanceof FolderIcon) {
1003                 ((FolderIcon) (child)).setTextVisible(false);
1004             }
1005             if (computeXYFromRank) {
1006                 x = mLauncher.getHotseat().getCellXFromOrder(((int) (screenId)));
1007                 y = mLauncher.getHotseat().getCellYFromOrder(((int) (screenId)));
1008             } else {
1009                 screenId = mLauncher.getHotseat().getOrderInHotseat(x, y);
1010             }
1011         } else {
1012             // Show folder title if not in the hotseat
1013             if (child instanceof FolderIcon) {
1014                 ((FolderIcon) (child)).setTextVisible(true);
1015             }
1016             layout = getScreenWithId(screenId);
1017             child.setOnKeyListener(new IconKeyEventListener());
1018         }
1019         ViewGroup.LayoutParams genericLp = child.getLayoutParams();
1020         CellLayout.LayoutParams lp;
1021         if ((genericLp == null) || (!(genericLp instanceof CellLayout.LayoutParams))) {
1022             lp = new CellLayout.LayoutParams(x, y, spanX, spanY);
1023         } else {
1024             lp = ((CellLayout.LayoutParams) (genericLp));
1025             lp.cellX = x;
1026             lp.cellY = y;
1027             lp.cellHSpan = spanX;
1028             lp.cellVSpan = spanY;
1029         }
1030         if ((spanX &lt; 0) &amp;&amp; (spanY &lt; 0)) {
1031             lp.isLockedToGrid = false;
1032         }
1033         // Get the canonical child id to uniquely represent this view in this screen
1034         ItemInfo info = ((ItemInfo) (child.getTag()));
1035         int childId = mLauncher.getViewIdForItem(info);
1036         boolean markCellsAsOccupied = !(child instanceof Folder);
1037         if (!layout.addViewToCellLayout(child, insert ? 0 : -1, childId, lp, markCellsAsOccupied)) {
1038             // TODO: This branch occurs when the workspace is adding views
1039             // outside of the defined grid
1040             // maybe we should be deleting these items from the LauncherModel?
<abbr title="1041             Launcher.addDumpLog(TAG, (((&quot;Failed to add to item at (&quot; + lp.cellX) + &quot;,&quot;) + lp.cellY) + &quot;) to CellLayout&quot;, true);">1041             Launcher.addDumpLog(TAG, (((&quot;Failed to add to item at (&quot; + lp.cellX) + &quot;,&quot;) + lp.cellY) + &quot;) 🔵</abbr>
1042         }
1043         if (!(child instanceof Folder)) {
1044             child.setHapticFeedbackEnabled(false);
1045             child.setOnLongClickListener(mLongClickListener);
1046         }
1047         if (child instanceof DropTarget) {
1048             mDragController.addDropTarget(((DropTarget) (child)));
1049         }
1050     }
1051 
1052     /**
1053      * Called directly from a CellLayout (not by the framework), after we&#x27;ve been added as a
1054      * listener via setOnInterceptTouchEventListener(). This allows us to tell the CellLayout
1055      * that it should intercept touch events, which is not something that is normally supported.
1056      */
1057     @Override
1058     public boolean onTouch(View v, MotionEvent event) {
1059         return (isSmall() || !isFinishedSwitchingState())
1060                 || (!isSmall() &amp;&amp; indexOfChild(v) != mCurrentPage);
1061     }
1062 
1063     public boolean isSwitchingState() {
1064         return mIsSwitchingState;
1065     }
1066 
1067     /** This differs from isSwitchingState in that we take into account how far the transition
1068      *  has completed. */
1069     public boolean isFinishedSwitchingState() {
1070         return !mIsSwitchingState || (mTransitionProgress &gt; 0.5f);
1071     }
1072 
1073     protected void onWindowVisibilityChanged (int visibility) {
1074         mLauncher.onWindowVisibilityChanged(visibility);
1075     }
1076 
1077     @Override
1078     public boolean dispatchUnhandledMove(View focused, int direction) {
1079         if (isSmall() || !isFinishedSwitchingState()) {
1080             // when the home screens are shrunken, shouldn&#x27;t allow side-scrolling
1081             return false;
1082         }
1083         return super.dispatchUnhandledMove(focused, direction);
1084     }
1085 
1086     @Override
1087     public boolean onInterceptTouchEvent(MotionEvent ev) {
1088         switch (ev.getAction() &amp; MotionEvent.ACTION_MASK) {
1089         case MotionEvent.ACTION_DOWN:
1090             mXDown = ev.getX();
1091             mYDown = ev.getY();
1092             mTouchDownTime = System.currentTimeMillis();
1093             break;
1094         case MotionEvent.ACTION_POINTER_UP:
1095         case MotionEvent.ACTION_UP:
1096             if (mTouchState == TOUCH_STATE_REST) {
1097                 final CellLayout currentPage = (CellLayout) getChildAt(mCurrentPage);
1098                 if (!currentPage.lastDownOnOccupiedCell()) {
1099                     onWallpaperTap(ev);
1100                 }
1101             }
1102         }
1103         return super.onInterceptTouchEvent(ev);
1104     }
1105 
1106     protected void reinflateWidgetsIfNecessary() {
1107         final int clCount = getChildCount();
1108         for (int i = 0; i &lt; clCount; i++) {
1109             CellLayout cl = (CellLayout) getChildAt(i);
1110             ShortcutAndWidgetContainer swc = cl.getShortcutsAndWidgets();
1111             final int itemCount = swc.getChildCount();
1112             for (int j = 0; j &lt; itemCount; j++) {
1113                 View v = swc.getChildAt(j);
1114 
1115                 if (v.getTag() instanceof LauncherAppWidgetInfo) {
1116                     LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) v.getTag();
1117                     LauncherAppWidgetHostView lahv = (LauncherAppWidgetHostView) info.hostView;
1118                     if (lahv != null &amp;&amp; lahv.orientationChangedSincedInflation()) {
1119                         mLauncher.removeAppWidget(info);
1120                         // Remove the current widget which is inflated with the wrong orientation
1121                         cl.removeView(lahv);
1122                         mLauncher.bindAppWidget(info);
1123                     }
1124                 }
1125             }
1126         }
1127     }
1128 
1129     @Override
1130     protected void determineScrollingStart(MotionEvent ev) {
1131         if (!isFinishedSwitchingState()) return;
1132 
1133         float deltaX = ev.getX() - mXDown;
1134         float absDeltaX = Math.abs(deltaX);
1135         float absDeltaY = Math.abs(ev.getY() - mYDown);
1136 
1137         if (Float.compare(absDeltaX, 0f) == 0) return;
1138 
1139         float slope = absDeltaY / absDeltaX;
1140         float theta = (float) Math.atan(slope);
1141 
1142         if (absDeltaX &gt; mTouchSlop || absDeltaY &gt; mTouchSlop) {
1143             cancelCurrentPageLongPress();
1144         }
1145 
1146         boolean passRightSwipesToCustomContent =
1147                 (mTouchDownTime - mCustomContentShowTime) &gt; CUSTOM_CONTENT_GESTURE_DELAY;
1148 
1149         boolean swipeInIgnoreDirection = isLayoutRtl() ? deltaX &lt; 0 : deltaX &gt; 0;
1150         if (swipeInIgnoreDirection &amp;&amp; getScreenIdForPageIndex(getCurrentPage()) ==
1151                 CUSTOM_CONTENT_SCREEN_ID &amp;&amp; passRightSwipesToCustomContent) {
1152             // Pass swipes to the right to the custom content page.
1153             return;
1154         }
1155 
1156         if (theta &gt; MAX_SWIPE_ANGLE) {
1157             // Above MAX_SWIPE_ANGLE, we don&#x27;t want to ever start scrolling the workspace
1158             return;
1159         } else if (theta &gt; START_DAMPING_TOUCH_SLOP_ANGLE) {
1160             // Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to
1161             // increase the touch slop to make it harder to begin scrolling the workspace. This
1162             // results in vertically scrolling widgets to more easily. The higher the angle, the
1163             // more we increase touch slop.
1164             theta -= START_DAMPING_TOUCH_SLOP_ANGLE;
1165             float extraRatio = (float)
1166                     Math.sqrt((theta / (MAX_SWIPE_ANGLE - START_DAMPING_TOUCH_SLOP_ANGLE)));
1167             super.determineScrollingStart(ev, 1 + TOUCH_SLOP_DAMPING_FACTOR * extraRatio);
1168         } else {
1169             // Below START_DAMPING_TOUCH_SLOP_ANGLE, we don&#x27;t do anything special
1170             super.determineScrollingStart(ev);
1171         }
1172     }
1173 
1174     protected void onPageBeginMoving() {
1175         super.onPageBeginMoving();
1176 
1177         if (isHardwareAccelerated()) {
1178             updateChildrenLayersEnabled(false);
1179         } else {
1180             if (mNextPage != INVALID_PAGE) {
1181                 // we&#x27;re snapping to a particular screen
1182                 enableChildrenCache(mCurrentPage, mNextPage);
1183             } else {
1184                 // this is when user is actively dragging a particular screen, they might
1185                 // swipe it either left or right (but we won&#x27;t advance by more than one screen)
1186                 enableChildrenCache(mCurrentPage - 1, mCurrentPage + 1);
1187             }
1188         }
1189 
1190         // Only show page outlines as we pan if we are on large screen
1191         if (LauncherAppState.getInstance().isScreenLarge()) {
1192             showOutlines();
1193         }
1194 
1195         // If we are not fading in adjacent screens, we still need to restore the alpha in case the
1196         // user scrolls while we are transitioning (should not affect dispatchDraw optimizations)
1197         if (!mWorkspaceFadeInAdjacentScreens) {
1198             for (int i = 0; i &lt; getChildCount(); ++i) {
1199                 ((CellLayout) getPageAt(i)).setShortcutAndWidgetAlpha(1f);
1200             }
1201         }
1202     }
1203 
1204     protected void onPageEndMoving() {
1205         super.onPageEndMoving();
1206 
1207         if (isHardwareAccelerated()) {
1208             updateChildrenLayersEnabled(false);
1209         } else {
1210             clearChildrenCache();
1211         }
1212 
1213         if (mDragController.isDragging()) {
1214             if (isSmall()) {
1215                 // If we are in springloaded mode, then force an event to check if the current touch
1216                 // is under a new page (to scroll to)
1217                 mDragController.forceTouchMove();
1218             }
1219         } else {
1220             // If we are not mid-dragging, hide the page outlines if we are on a large screen
1221             if (LauncherAppState.getInstance().isScreenLarge()) {
1222                 hideOutlines();
1223             }
1224         }
1225 
1226         if (mDelayedResizeRunnable != null) {
1227             mDelayedResizeRunnable.run();
1228             mDelayedResizeRunnable = null;
1229         }
1230 
1231         if (mDelayedSnapToPageRunnable != null) {
1232             mDelayedSnapToPageRunnable.run();
1233             mDelayedSnapToPageRunnable = null;
1234         }
1235         if (mStripScreensOnPageStopMoving) {
1236             stripEmptyScreens();
1237             mStripScreensOnPageStopMoving = false;
1238         }
1239     }
1240 
1241     @Override
1242     protected void notifyPageSwitchListener() {
1243         super.notifyPageSwitchListener();
1244         Launcher.setScreen(mCurrentPage);
1245 
1246         if (hasCustomContent() &amp;&amp; getNextPage() == 0 &amp;&amp; !mCustomContentShowing) {
1247             mCustomContentShowing = true;
1248             if (mCustomContentCallbacks != null) {
1249                 mCustomContentCallbacks.onShow();
1250                 mCustomContentShowTime = System.currentTimeMillis();
1251                 mLauncher.updateVoiceButtonProxyVisible(false);
1252             }
1253         } else if (hasCustomContent() &amp;&amp; getNextPage() != 0 &amp;&amp; mCustomContentShowing) {
1254             mCustomContentShowing = false;
1255             if (mCustomContentCallbacks != null) {
1256                 mCustomContentCallbacks.onHide();
1257                 mLauncher.resetQSBScroll();
1258                 mLauncher.updateVoiceButtonProxyVisible(false);
1259             }
1260         }
1261         if (getPageIndicator() != null) {
1262             getPageIndicator().setContentDescription(getPageIndicatorDescription());
1263         }
1264     }
1265 
1266     protected CustomContentCallbacks getCustomContentCallbacks() {
1267         return mCustomContentCallbacks;
1268     }
1269 
1270     protected void setWallpaperDimension() {
1271         String spKey = WallpaperCropActivity.getSharedPreferencesKey();
1272         SharedPreferences sp = mLauncher.getSharedPreferences(spKey, Context.MODE_MULTI_PROCESS);
1273         WallpaperPickerActivity.suggestWallpaperDimension(mLauncher.getResources(),
1274                 sp, mLauncher.getWindowManager(), mWallpaperManager);
1275     }
1276 
1277     protected void snapToPage(int whichPage, Runnable r) {
1278         snapToPage(whichPage, SLOW_PAGE_SNAP_ANIMATION_DURATION, r);
1279     }
1280 
1281     protected void snapToPage(int whichPage, int duration, Runnable r) {
1282         if (mDelayedSnapToPageRunnable != null) {
1283             mDelayedSnapToPageRunnable.run();
1284         }
1285         mDelayedSnapToPageRunnable = r;
1286         snapToPage(whichPage, duration);
1287     }
1288 
1289     protected void snapToScreenId(long screenId, Runnable r) {
1290         snapToPage(getPageIndexForScreenId(screenId), r);
1291     }
1292 
1293     class WallpaperOffsetInterpolator implements Choreographer.FrameCallback {
1294         float mFinalOffset = 0.0F;
1295 
1296         float mCurrentOffset = 0.5F;// to force an initial update
1297 
1298 
1299         boolean mWaitingForUpdate;
1300 
1301         Choreographer mChoreographer;
1302 
1303         Interpolator mInterpolator;
1304 
1305         boolean mAnimating;
1306 
1307         long mAnimationStartTime;
1308 
1309         float mAnimationStartOffset;
1310 
1311         private final int ANIMATION_DURATION = 250;
1312 
1313         // Don&#x27;t use all the wallpaper for parallax until you have at least this many pages
1314         private final int MIN_PARALLAX_PAGE_SPAN = 3;
1315 
1316         int mNumScreens;
1317 
1318         public WallpaperOffsetInterpolator() {
1319             mChoreographer = Choreographer.getInstance();
1320             mInterpolator = new DecelerateInterpolator(1.5F);
1321         }
1322 
1323         @Override
1324         public void doFrame(long frameTimeNanos) {
1325             updateOffset(false);
1326         }
1327 
1328         private void updateOffset(boolean force) {
1329             if (mWaitingForUpdate || force) {
1330                 mWaitingForUpdate = false;
1331                 if (computeScrollOffset() &amp;&amp; (mWindowToken != null)) {
1332                     try {
<abbr title="1333                         mWallpaperManager.setWallpaperOffsets(mWindowToken, mWallpaperOffset.getCurrX(), 0.5F);">1333                         mWallpaperManager.setWallpaperOffsets(mWindowToken, mWallpaperOffset.getCurrX(), 🔵</abbr>
1334                         setWallpaperOffsetSteps();
1335                     } catch (java.lang.IllegalArgumentException e) {
1336                         Log.e(TAG, &quot;Error updating wallpaper offset: &quot; + e);
1337                     }
1338                 }
1339             }
1340         }
1341 
1342         public boolean computeScrollOffset() {
1343             final float oldOffset = mCurrentOffset;
1344             if (mAnimating) {
1345                 long durationSinceAnimation = System.currentTimeMillis() - mAnimationStartTime;
1346                 float t0 = durationSinceAnimation / ((float) (ANIMATION_DURATION));
1347                 float t1 = mInterpolator.getInterpolation(t0);
1348                 mCurrentOffset = mAnimationStartOffset + ((mFinalOffset - mAnimationStartOffset) * t1);
1349                 mAnimating = durationSinceAnimation &lt; ANIMATION_DURATION;
1350             } else {
1351                 mCurrentOffset = mFinalOffset;
1352             }
1353             if (Math.abs(mCurrentOffset - mFinalOffset) &gt; 1.0E-7F) {
1354                 scheduleUpdate();
1355             }
1356             if (Math.abs(oldOffset - mCurrentOffset) &gt; 1.0E-7F) {
1357                 return true;
1358             }
1359             return false;
1360         }
1361 
1362         private float wallpaperOffsetForCurrentScroll() {
1363             if (getChildCount() &lt;= 1) {
1364                 return 0;
1365             }
1366             // Exclude the leftmost page
1367             int emptyExtraPages = numEmptyScreensToIgnore();
1368             int firstIndex = numCustomPages();
1369             // Exclude the last extra empty screen (if we have &gt; MIN_PARALLAX_PAGE_SPAN pages)
1370             int lastIndex = (getChildCount() - 1) - emptyExtraPages;
1371             if (isLayoutRtl()) {
1372                 int temp = firstIndex;
1373                 firstIndex = lastIndex;
1374                 lastIndex = temp;
1375             }
1376             int firstPageScrollX = getScrollForPage(firstIndex);
1377             int scrollRange = getScrollForPage(lastIndex) - firstPageScrollX;
1378             if (scrollRange == 0) {
1379                 return 0;
1380             } else {
1381                 // TODO: do different behavior if it&#x27;s  a live wallpaper?
1382                 // Sometimes the left parameter of the pages is animated during a layout transition;
1383                 // this parameter offsets it to keep the wallpaper from animating as well
<abbr title="1384                 int adjustedScroll = (getScrollX() - firstPageScrollX) - getLayoutTransitionOffsetForPage(0);">1384                 int adjustedScroll = (getScrollX() - firstPageScrollX) - getLayoutTransitionOffsetForPage🔵</abbr>
1385                 float offset = Math.min(1, adjustedScroll / ((float) (scrollRange)));
1386                 offset = Math.max(0, offset);
1387                 // Don&#x27;t use up all the wallpaper parallax until you have at least
1388                 // MIN_PARALLAX_PAGE_SPAN pages
1389                 int numScrollingPages = getNumScreensExcludingEmptyAndCustom();
1390                 int parallaxPageSpan = Math.max(MIN_PARALLAX_PAGE_SPAN, numScrollingPages - 1);
1391                 // On RTL devices, push the wallpaper offset to the right if we don&#x27;t have enough
1392                 // pages (ie if numScrollingPages &lt; MIN_PARALLAX_PAGE_SPAN)
1393                 int padding = (isLayoutRtl()) ? (parallaxPageSpan - numScrollingPages) + 1 : 0;
1394                 return (offset * ((padding + numScrollingPages) - 1)) / parallaxPageSpan;
1395             }
1396         }
1397 
1398         private int numEmptyScreensToIgnore() {
1399             int numScrollingPages = getChildCount() - numCustomPages();
1400             if ((numScrollingPages &gt;= MIN_PARALLAX_PAGE_SPAN) &amp;&amp; hasExtraEmptyScreen()) {
1401                 return 1;
1402             } else {
1403                 return 0;
1404             }
1405         }
1406 
1407         private int getNumScreensExcludingEmptyAndCustom() {
1408             int numScrollingPages = (getChildCount() - numEmptyScreensToIgnore()) - numCustomPages();
1409             return numScrollingPages;
1410         }
1411 
1412         public void syncWithScroll() {
1413             float offset = wallpaperOffsetForCurrentScroll();
1414             mWallpaperOffset.setFinalX(offset);
1415             updateOffset(true);
1416         }
1417 
1418         public float getCurrX() {
1419             return mCurrentOffset;
1420         }
1421 
1422         public float getFinalX() {
1423             return mFinalOffset;
1424         }
1425 
1426         private void animateToFinal() {
1427             mAnimating = true;
1428             mAnimationStartOffset = mCurrentOffset;
1429             mAnimationStartTime = System.currentTimeMillis();
1430         }
1431 
1432         private void setWallpaperOffsetSteps() {
1433             // Set wallpaper offset steps (1 / (number of screens - 1))
1434             mWallpaperManager.setWallpaperOffsetSteps(1.0F / (getChildCount() - 1), 1.0F);
1435         }
1436 
1437         public void setFinalX(float x) {
1438             scheduleUpdate();
1439             mFinalOffset = Math.max(0.0F, Math.min(x, 1.0F));
1440             if (getNumScreensExcludingEmptyAndCustom() != mNumScreens) {
1441                 if (mNumScreens &gt; 0) {
1442                     // Don&#x27;t animate if we&#x27;re going from 0 screens
1443                     animateToFinal();
1444                 }
1445                 mNumScreens = getNumScreensExcludingEmptyAndCustom();
1446             }
1447         }
1448 
1449         private void scheduleUpdate() {
1450             if (!mWaitingForUpdate) {
1451                 mChoreographer.postFrameCallback(this);
1452                 mWaitingForUpdate = true;
1453             }
1454         }
1455 
1456         public void jumpToFinal() {
1457             mCurrentOffset = mFinalOffset;
1458         }
1459     }
1460 
1461     @Override
1462     public void computeScroll() {
1463         super.computeScroll();
1464         mWallpaperOffset.syncWithScroll();
1465     }
1466 
1467     void showOutlines() {
1468         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1469             if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
1470             if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
<abbr title="1471             mChildrenOutlineFadeInAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 1.0f);">1471             mChildrenOutlineFadeInAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 1.0🔵</abbr>
1472             mChildrenOutlineFadeInAnimation.setDuration(CHILDREN_OUTLINE_FADE_IN_DURATION);
1473             mChildrenOutlineFadeInAnimation.start();
1474         }
1475     }
1476 
1477     void hideOutlines() {
1478         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1479             if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1480             if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
<abbr title="1481             mChildrenOutlineFadeOutAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.0f);">1481             mChildrenOutlineFadeOutAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.🔵</abbr>
1482             mChildrenOutlineFadeOutAnimation.setDuration(CHILDREN_OUTLINE_FADE_OUT_DURATION);
1483             mChildrenOutlineFadeOutAnimation.setStartDelay(CHILDREN_OUTLINE_FADE_OUT_DELAY);
1484             mChildrenOutlineFadeOutAnimation.start();
1485         }
1486     }
1487 
1488     public void showOutlinesTemporarily() {
1489         if (!mIsPageMoving &amp;&amp; !isTouchActive()) {
1490             snapToPage(mCurrentPage);
1491         }
1492     }
1493 
1494     public void setChildrenOutlineAlpha(float alpha) {
1495         mChildrenOutlineAlpha = alpha;
1496         for (int i = 0; i &lt; getChildCount(); i++) {
1497             CellLayout cl = (CellLayout) getChildAt(i);
1498             cl.setBackgroundAlpha(alpha);
1499         }
1500     }
1501 
1502     public float getChildrenOutlineAlpha() {
1503         return mChildrenOutlineAlpha;
1504     }
1505 
1506     void disableBackground() {
1507         mDrawBackground = false;
1508     }
1509 
1510     void enableBackground() {
1511         mDrawBackground = true;
1512     }
1513 
1514     private void animateBackgroundGradient(float finalAlpha, boolean animated) {
1515         if (mBackground == null) return;
1516         if (mBackgroundFadeInAnimation != null) {
1517             mBackgroundFadeInAnimation.cancel();
1518             mBackgroundFadeInAnimation = null;
1519         }
1520         if (mBackgroundFadeOutAnimation != null) {
1521             mBackgroundFadeOutAnimation.cancel();
1522             mBackgroundFadeOutAnimation = null;
1523         }
1524         float startAlpha = getBackgroundAlpha();
1525         if (finalAlpha != startAlpha) {
1526             if (animated) {
1527                 mBackgroundFadeOutAnimation =
1528                         LauncherAnimUtils.ofFloat(this, startAlpha, finalAlpha);
1529                 mBackgroundFadeOutAnimation.addUpdateListener(new AnimatorUpdateListener() {
1530                     public void onAnimationUpdate(ValueAnimator animation) {
1531                         setBackgroundAlpha(((Float) animation.getAnimatedValue()).floatValue());
1532                     }
1533                 });
1534                 mBackgroundFadeOutAnimation.setInterpolator(new DecelerateInterpolator(1.5f));
1535                 mBackgroundFadeOutAnimation.setDuration(BACKGROUND_FADE_OUT_DURATION);
1536                 mBackgroundFadeOutAnimation.start();
1537             } else {
1538                 setBackgroundAlpha(finalAlpha);
1539             }
1540         }
1541     }
1542 
1543     public void setBackgroundAlpha(float alpha) {
1544         if (alpha != mBackgroundAlpha) {
1545             mBackgroundAlpha = alpha;
1546             invalidate();
1547         }
1548     }
1549 
1550     public float getBackgroundAlpha() {
1551         return mBackgroundAlpha;
1552     }
1553 
1554     float backgroundAlphaInterpolator(float r) {
1555         float pivotA = 0.1f;
1556         float pivotB = 0.4f;
1557         if (r &lt; pivotA) {
1558             return 0;
1559         } else if (r &gt; pivotB) {
1560             return 1.0f;
1561         } else {
1562             return (r - pivotA)/(pivotB - pivotA);
1563         }
1564     }
1565 
1566     private void updatePageAlphaValues(int screenCenter) {
1567         boolean isInOverscroll = mOverScrollX &lt; 0 || mOverScrollX &gt; mMaxScrollX;
1568         if (mWorkspaceFadeInAdjacentScreens &amp;&amp;
1569                 mState == State.NORMAL &amp;&amp;
1570                 !mIsSwitchingState &amp;&amp;
1571                 !isInOverscroll) {
1572             for (int i = numCustomPages(); i &lt; getChildCount(); i++) {
1573                 CellLayout child = (CellLayout) getChildAt(i);
1574                 if (child != null) {
1575                     float scrollProgress = getScrollProgress(screenCenter, child, i);
1576                     float alpha = 1 - Math.abs(scrollProgress);
1577                     child.getShortcutsAndWidgets().setAlpha(alpha);
1578                 }
1579             }
1580         }
1581     }
1582 
1583     private void setChildrenBackgroundAlphaMultipliers(float a) {
1584         for (int i = 0; i &lt; getChildCount(); i++) {
1585             CellLayout child = (CellLayout) getChildAt(i);
1586             child.setBackgroundAlphaMultiplier(a);
1587         }
1588     }
1589 
1590     public boolean hasCustomContent() {
1591         return (mScreenOrder.size() &gt; 0 &amp;&amp; mScreenOrder.get(0) == CUSTOM_CONTENT_SCREEN_ID);
1592     }
1593 
1594     public int numCustomPages() {
1595         return hasCustomContent() ? 1 : 0;
1596     }
1597 
1598     public boolean isOnOrMovingToCustomContent() {
1599         return hasCustomContent() &amp;&amp; getNextPage() == 0;
1600     }
1601 
1602     private void updateStateForCustomContent(int screenCenter) {
1603         float translationX = 0;
1604         float progress = 0;
1605         if (hasCustomContent()) {
1606             int index = mScreenOrder.indexOf(CUSTOM_CONTENT_SCREEN_ID);
1607 
1608             int scrollDelta = getScrollX() - getScrollForPage(index) -
1609                     getLayoutTransitionOffsetForPage(index);
1610             float scrollRange = getScrollForPage(index + 1) - getScrollForPage(index);
1611             translationX = scrollRange - scrollDelta;
1612             progress = (scrollRange - scrollDelta) / scrollRange;
1613 
1614             if (isLayoutRtl()) {
1615                 translationX = Math.min(0, translationX);
1616             } else {
1617                 translationX = Math.max(0, translationX);
1618             }
1619             progress = Math.max(0, progress);
1620         }
1621 
1622         if (Float.compare(progress, mLastCustomContentScrollProgress) == 0) return;
1623 
1624         CellLayout cc = mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID);
1625         if (progress &gt; 0 &amp;&amp; cc.getVisibility() != VISIBLE &amp;&amp; !isSmall()) {
1626             cc.setVisibility(VISIBLE);
1627         }
1628 
1629         mLastCustomContentScrollProgress = progress;
1630 
1631         setBackgroundAlpha(progress * 0.8f);
1632 
1633         if (mLauncher.getHotseat() != null) {
1634             mLauncher.getHotseat().setTranslationX(translationX);
1635         }
1636 
1637         if (getPageIndicator() != null) {
1638             getPageIndicator().setTranslationX(translationX);
1639         }
1640 
1641         if (mCustomContentCallbacks != null) {
1642             mCustomContentCallbacks.onScrollProgressChanged(progress);
1643         }
1644     }
1645 
1646     @Override
1647     protected OnClickListener getPageIndicatorClickListener() {
1648         AccessibilityManager am = (AccessibilityManager)
1649                 getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
1650         if (!am.isTouchExplorationEnabled()) {
1651             return null;
1652         }
1653         OnClickListener listener = new OnClickListener() {
1654             @Override
1655             public void onClick(View arg0) {
1656                 enterOverviewMode();
1657             }
1658         };
1659         return listener;
1660     }
1661 
1662     @Override
1663     protected void screenScrolled(int screenCenter) {
1664         final boolean isRtl = isLayoutRtl();
1665         super.screenScrolled(screenCenter);
1666 
1667         updatePageAlphaValues(screenCenter);
1668         updateStateForCustomContent(screenCenter);
1669         enableHwLayersOnVisiblePages();
1670 
1671         boolean shouldOverScroll = (mOverScrollX &lt; 0 &amp;&amp; (!hasCustomContent() || isLayoutRtl())) ||
1672                 (mOverScrollX &gt; mMaxScrollX &amp;&amp; (!hasCustomContent() || !isLayoutRtl()));
1673 
1674         if (shouldOverScroll) {
1675             int index = 0;
1676             float pivotX = 0f;
1677             final float leftBiasedPivot = 0.25f;
1678             final float rightBiasedPivot = 0.75f;
1679             final int lowerIndex = 0;
1680             final int upperIndex = getChildCount() - 1;
1681 
1682             final boolean isLeftPage = mOverScrollX &lt; 0;
1683             index = (!isRtl &amp;&amp; isLeftPage) || (isRtl &amp;&amp; !isLeftPage) ? lowerIndex : upperIndex;
1684             pivotX = isLeftPage ? rightBiasedPivot : leftBiasedPivot;
1685 
1686             CellLayout cl = (CellLayout) getChildAt(index);
1687             float scrollProgress = getScrollProgress(screenCenter, cl, index);
1688             cl.setOverScrollAmount(Math.abs(scrollProgress), isLeftPage);
1689             float rotation = -WORKSPACE_OVERSCROLL_ROTATION * scrollProgress;
1690             cl.setRotationY(rotation);
1691 
1692             if (!mOverscrollTransformsSet || Float.compare(mLastOverscrollPivotX, pivotX) != 0) {
1693                 mOverscrollTransformsSet = true;
1694                 mLastOverscrollPivotX = pivotX;
1695                 cl.setCameraDistance(mDensity * mCameraDistance);
1696                 cl.setPivotX(cl.getMeasuredWidth() * pivotX);
1697                 cl.setPivotY(cl.getMeasuredHeight() * 0.5f);
1698                 cl.setOverscrollTransformsDirty(true);
1699             }
1700         } else {
1701             if (mOverscrollTransformsSet) {
1702                 mOverscrollTransformsSet = false;
1703                 ((CellLayout) getChildAt(0)).resetOverscrollTransforms();
1704                 ((CellLayout) getChildAt(getChildCount() - 1)).resetOverscrollTransforms();
1705             }
1706         }
1707     }
1708 
1709     @Override
1710     protected void overScroll(float amount) {
1711         acceleratedOverScroll(amount);
1712     }
1713 
1714     protected void onAttachedToWindow() {
1715         super.onAttachedToWindow();
1716         mWindowToken = getWindowToken();
1717         computeScroll();
1718         mDragController.setWindowToken(mWindowToken);
1719     }
1720 
1721     protected void onDetachedFromWindow() {
1722         super.onDetachedFromWindow();
1723         mWindowToken = null;
1724     }
1725 
1726     protected void onResume() {
1727         if (getPageIndicator() != null) {
1728             // In case accessibility state has changed, we need to perform this on every
1729             // attach to window
1730             OnClickListener listener = getPageIndicatorClickListener();
1731             if (listener != null) {
1732                 getPageIndicator().setOnClickListener(listener);
1733             }
1734         }
1735         AccessibilityManager am = (AccessibilityManager)
1736                 getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
1737         sAccessibilityEnabled = am.isEnabled();
1738     }
1739 
1740     @Override
1741     protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
1742         if (mFirstLayout &amp;&amp; mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getChildCount()) {
1743             mWallpaperOffset.syncWithScroll();
1744             mWallpaperOffset.jumpToFinal();
1745         }
1746         super.onLayout(changed, left, top, right, bottom);
1747     }
1748 
1749     @Override
1750     protected void onDraw(Canvas canvas) {
1751         // Draw the background gradient if necessary
1752         if (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground) {
1753             int alpha = (int) (mBackgroundAlpha * 255);
1754             mBackground.setAlpha(alpha);
1755             mBackground.setBounds(getScrollX(), 0, getScrollX() + getMeasuredWidth(),
1756                     getMeasuredHeight());
1757             mBackground.draw(canvas);
1758         }
1759 
1760         super.onDraw(canvas);
1761 
1762         // Call back to LauncherModel to finish binding after the first draw
1763         post(mBindPages);
1764     }
1765 
1766     boolean isDrawingBackgroundGradient() {
1767         return (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground);
1768     }
1769 
1770     @Override
1771     protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1772         if (!mLauncher.isAllAppsVisible()) {
1773             final Folder openFolder = getOpenFolder();
1774             if (openFolder != null) {
1775                 return openFolder.requestFocus(direction, previouslyFocusedRect);
1776             } else {
1777                 return super.onRequestFocusInDescendants(direction, previouslyFocusedRect);
1778             }
1779         }
1780         return false;
1781     }
1782 
1783     @Override
1784     public int getDescendantFocusability() {
1785         if (isSmall()) {
1786             return ViewGroup.FOCUS_BLOCK_DESCENDANTS;
1787         }
1788         return super.getDescendantFocusability();
1789     }
1790 
1791     @Override
1792     public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1793         if (!mLauncher.isAllAppsVisible()) {
1794             final Folder openFolder = getOpenFolder();
1795             if (openFolder != null) {
1796                 openFolder.addFocusables(views, direction);
1797             } else {
1798                 super.addFocusables(views, direction, focusableMode);
1799             }
1800         }
1801     }
1802 
1803     public boolean isSmall() {
1804         return mState == State.SMALL || mState == State.SPRING_LOADED || mState == State.OVERVIEW;
1805     }
1806 
1807     void enableChildrenCache(int fromPage, int toPage) {
1808         if (fromPage &gt; toPage) {
1809             final int temp = fromPage;
1810             fromPage = toPage;
1811             toPage = temp;
1812         }
1813 
1814         final int screenCount = getChildCount();
1815 
1816         fromPage = Math.max(fromPage, 0);
1817         toPage = Math.min(toPage, screenCount - 1);
1818 
1819         for (int i = fromPage; i &lt;= toPage; i++) {
1820             final CellLayout layout = (CellLayout) getChildAt(i);
1821             layout.setChildrenDrawnWithCacheEnabled(true);
1822             layout.setChildrenDrawingCacheEnabled(true);
1823         }
1824     }
1825 
1826     void clearChildrenCache() {
1827         final int screenCount = getChildCount();
1828         for (int i = 0; i &lt; screenCount; i++) {
1829             final CellLayout layout = (CellLayout) getChildAt(i);
1830             layout.setChildrenDrawnWithCacheEnabled(false);
1831             // In software mode, we don&#x27;t want the items to continue to be drawn into bitmaps
1832             if (!isHardwareAccelerated()) {
1833                 layout.setChildrenDrawingCacheEnabled(false);
1834             }
1835         }
1836     }
1837 
1838     private void updateChildrenLayersEnabled(boolean force) {
1839         boolean small = mState == State.SMALL || mState == State.OVERVIEW || mIsSwitchingState;
1840         boolean enableChildrenLayers = force || small || mAnimatingViewIntoPlace || isPageMoving();
1841 
1842         if (enableChildrenLayers != mChildrenLayersEnabled) {
1843             mChildrenLayersEnabled = enableChildrenLayers;
1844             if (mChildrenLayersEnabled) {
1845                 enableHwLayersOnVisiblePages();
1846             } else {
1847                 for (int i = 0; i &lt; getPageCount(); i++) {
1848                     final CellLayout cl = (CellLayout) getChildAt(i);
1849                     cl.enableHardwareLayer(false);
1850                 }
1851             }
1852         }
1853     }
1854 
1855     private void enableHwLayersOnVisiblePages() {
1856         if (mChildrenLayersEnabled) {
1857             final int screenCount = getChildCount();
1858             getVisiblePages(mTempVisiblePagesRange);
1859             int leftScreen = mTempVisiblePagesRange[0];
1860             int rightScreen = mTempVisiblePagesRange[1];
1861             if (leftScreen == rightScreen) {
1862                 // make sure we&#x27;re caching at least two pages always
1863                 if (rightScreen &lt; screenCount - 1) {
1864                     rightScreen++;
1865                 } else if (leftScreen &gt; 0) {
1866                     leftScreen--;
1867                 }
1868             }
1869 
1870             final CellLayout customScreen = mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID);
1871             for (int i = 0; i &lt; screenCount; i++) {
1872                 final CellLayout layout = (CellLayout) getPageAt(i);
1873 
1874                 // enable layers between left and right screen inclusive, except for the
1875                 // customScreen, which may animate its content during transitions.
1876                 boolean enableLayer = layout != customScreen &amp;&amp;
1877                         leftScreen &lt;= i &amp;&amp; i &lt;= rightScreen &amp;&amp; shouldDrawChild(layout);
1878                 layout.enableHardwareLayer(enableLayer);
1879             }
1880         }
1881     }
1882 
1883     public void buildPageHardwareLayers() {
1884         // force layers to be enabled just for the call to buildLayer
1885         updateChildrenLayersEnabled(true);
1886         if (getWindowToken() != null) {
1887             final int childCount = getChildCount();
1888             for (int i = 0; i &lt; childCount; i++) {
1889                 CellLayout cl = (CellLayout) getChildAt(i);
1890                 cl.buildHardwareLayer();
1891             }
1892         }
1893         updateChildrenLayersEnabled(false);
1894     }
1895 
1896     protected void onWallpaperTap(MotionEvent ev) {
1897         final int[] position = mTempCell;
1898         getLocationOnScreen(position);
1899 
1900         int pointerIndex = ev.getActionIndex();
1901         position[0] += (int) ev.getX(pointerIndex);
1902         position[1] += (int) ev.getY(pointerIndex);
1903 
1904         mWallpaperManager.sendWallpaperCommand(getWindowToken(),
1905                 ev.getAction() == MotionEvent.ACTION_UP
1906                         ? WallpaperManager.COMMAND_TAP : WallpaperManager.COMMAND_SECONDARY_TAP,
1907                 position[0], position[1], 0, null);
1908     }
1909 
1910     /* This interpolator emulates the rate at which the perceived scale of an object changes
1911     as its distance from a camera increases. When this interpolator is applied to a scale
1912     animation on a view, it evokes the sense that the object is shrinking due to moving away
1913     from the camera.
1914      */
1915     static class ZInterpolator implements TimeInterpolator {
1916         private float focalLength;
1917 
1918         public ZInterpolator(float foc) {
1919             focalLength = foc;
1920         }
1921 
1922         public float getInterpolation(float input) {
<abbr title="1923             return (1.0F - (focalLength / (focalLength + input))) / (1.0F - (focalLength / (focalLength + 1.0F)));">1923             return (1.0F - (focalLength / (focalLength + input))) / (1.0F - (focalLength / (focalLength +🔵</abbr>
1924         }
1925     }
1926 
1927     /* The exact reverse of ZInterpolator. */
1928     static class InverseZInterpolator implements TimeInterpolator {
1929         private ZInterpolator zInterpolator;
1930 
1931         public InverseZInterpolator(float foc) {
1932             zInterpolator = new ZInterpolator(foc);
1933         }
1934 
1935         public float getInterpolation(float input) {
1936             return 1 - zInterpolator.getInterpolation(1 - input);
1937         }
1938     }
1939 
1940     /* ZInterpolator compounded with an ease-out. */
1941     static class ZoomOutInterpolator implements TimeInterpolator {
1942         private final DecelerateInterpolator decelerate = new DecelerateInterpolator(0.75F);
1943 
1944         private final ZInterpolator zInterpolator = new ZInterpolator(0.13F);
1945 
1946         public float getInterpolation(float input) {
1947             return decelerate.getInterpolation(zInterpolator.getInterpolation(input));
1948         }
1949     }
1950 
1951     /* InvereZInterpolator compounded with an ease-out. */
1952     static class ZoomInInterpolator implements TimeInterpolator {
1953         private final InverseZInterpolator inverseZInterpolator = new InverseZInterpolator(0.35F);
1954 
1955         private final DecelerateInterpolator decelerate = new DecelerateInterpolator(3.0F);
1956 
1957         public float getInterpolation(float input) {
1958             return decelerate.getInterpolation(inverseZInterpolator.getInterpolation(input));
1959         }
1960     }
1961 
1962     private final ZoomInInterpolator mZoomInInterpolator = new ZoomInInterpolator();
1963 
1964     /*
1965     *
1966     * We call these methods (onDragStartedWithItemSpans/onDragStartedWithSize) whenever we
1967     * start a drag in Launcher, regardless of whether the drag has ever entered the Workspace
1968     *
1969     * These methods mark the appropriate pages as accepting drops (which alters their visual
1970     * appearance).
1971     *
1972     */
1973     public void onDragStartedWithItem(View v) {
1974         final Canvas canvas = new Canvas();
1975 
1976         // The outline is used to visualize where the item will land if dropped
1977         mDragOutline = createDragOutline(v, canvas, DRAG_BITMAP_PADDING);
1978     }
1979 
1980     public void onDragStartedWithItem(PendingAddItemInfo info, Bitmap b, boolean clipAlpha) {
1981         final Canvas canvas = new Canvas();
1982 
1983         int[] size = estimateItemSize(info.spanX, info.spanY, info, false);
1984 
1985         // The outline is used to visualize where the item will land if dropped
1986         mDragOutline = createDragOutline(b, canvas, DRAG_BITMAP_PADDING, size[0],
1987                 size[1], clipAlpha);
1988     }
1989 
1990     public void exitWidgetResizeMode() {
1991         DragLayer dragLayer = mLauncher.getDragLayer();
1992         dragLayer.clearAllResizeFrames();
1993     }
1994 
1995     private void initAnimationArrays() {
1996         final int childCount = getChildCount();
1997         if (mLastChildCount == childCount) return;
1998 
1999         mOldBackgroundAlphas = new float[childCount];
2000         mOldAlphas = new float[childCount];
2001         mNewBackgroundAlphas = new float[childCount];
2002         mNewAlphas = new float[childCount];
2003     }
2004 
2005     Animator getChangeStateAnimation(final State state, boolean animated) {
2006         return getChangeStateAnimation(state, animated, 0, -1);
2007     }
2008 
2009     @Override
2010     protected void getOverviewModePages(int[] range) {
2011         int start = numCustomPages();
2012         int end = getChildCount() - 1;
2013 
2014         range[0] = Math.max(0, Math.min(start, getChildCount() - 1));
2015         range[1] = Math.max(0,  end);
2016      }
2017 
2018     protected void onStartReordering() {
2019         super.onStartReordering();
2020         showOutlines();
2021         // Reordering handles its own animations, disable the automatic ones.
2022         disableLayoutTransitions();
2023     }
2024 
2025     protected void onEndReordering() {
2026         super.onEndReordering();
2027 
2028         hideOutlines();
2029         mScreenOrder.clear();
2030         int count = getChildCount();
2031         for (int i = 0; i &lt; count; i++) {
2032             CellLayout cl = ((CellLayout) getChildAt(i));
2033             mScreenOrder.add(getIdForScreen(cl));
2034         }
2035 
2036         mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
2037 
2038         // Re-enable auto layout transitions for page deletion.
2039         enableLayoutTransitions();
2040     }
2041 
2042     public boolean isInOverviewMode() {
2043         return mState == State.OVERVIEW;
2044     }
2045 
2046     public boolean enterOverviewMode() {
2047         if (mTouchState != TOUCH_STATE_REST) {
2048             return false;
2049         }
2050         enableOverviewMode(true, -1, true);
2051         return true;
2052     }
2053 
2054     public void exitOverviewMode(boolean animated) {
2055         exitOverviewMode(-1, animated);
2056     }
2057 
2058     public void exitOverviewMode(int snapPage, boolean animated) {
2059         enableOverviewMode(false, snapPage, animated);
2060     }
2061 
2062     private void enableOverviewMode(boolean enable, int snapPage, boolean animated) {
2063         State finalState = Workspace.State.OVERVIEW;
2064         if (!enable) {
2065             finalState = Workspace.State.NORMAL;
2066         }
2067 
2068         Animator workspaceAnim = getChangeStateAnimation(finalState, animated, 0, snapPage);
2069         if (workspaceAnim != null) {
2070             onTransitionPrepare();
2071             workspaceAnim.addListener(new AnimatorListenerAdapter() {
2072                 @Override
2073                 public void onAnimationEnd(Animator arg0) {
2074                     onTransitionEnd();
2075                 }
2076             });
2077             workspaceAnim.start();
2078         }
2079     }
2080 
2081     int getOverviewModeTranslationY() {
2082         LauncherAppState app = LauncherAppState.getInstance();
2083         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2084         Rect overviewBar = grid.getOverviewModeButtonBarRect();
2085 
2086         int availableHeight = getViewportHeight();
2087         int scaledHeight = (int) (mOverviewModeShrinkFactor * getNormalChildHeight());
2088         int offsetFromTopEdge = (availableHeight - scaledHeight) / 2;
2089         int offsetToCenterInOverview = (availableHeight - mInsets.top - overviewBar.height()
2090                 - scaledHeight) / 2;
2091 
2092         return -offsetFromTopEdge + mInsets.top + offsetToCenterInOverview;
2093     }
2094 
2095     boolean shouldVoiceButtonProxyBeVisible() {
2096         if (isOnOrMovingToCustomContent()) {
2097             return false;
2098         }
2099         if (mState != State.NORMAL) {
2100             return false;
2101         }
2102         return true;
2103     }
2104 
2105     public void updateInteractionForState() {
2106         if (mState != State.NORMAL) {
2107             mLauncher.onInteractionBegin();
2108         } else {
2109             mLauncher.onInteractionEnd();
2110         }
2111     }
2112 
2113     private void setState(State state) {
2114         mState = state;
2115         updateInteractionForState();
2116         updateAccessibilityFlags();
2117     }
2118 
2119     private void updateAccessibilityFlags() {
2120         int accessible = mState == State.NORMAL ?
2121                 ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES :
2122                 ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS;
2123         setImportantForAccessibility(accessible);
2124     }
2125 
2126     Animator getChangeStateAnimation(final State state, boolean animated, int delay, int snapPage) {
2127         if (mState == state) {
2128             return null;
2129         }
2130         // Initialize animation arrays for the first time if necessary
2131         initAnimationArrays();
2132         AnimatorSet anim = (animated) ? LauncherAnimUtils.createAnimatorSet() : null;
2133         final State oldState = mState;
2134         final boolean oldStateIsNormal = oldState == State.NORMAL;
2135         final boolean oldStateIsSpringLoaded = oldState == State.SPRING_LOADED;
2136         final boolean oldStateIsSmall = oldState == State.SMALL;
2137         final boolean oldStateIsOverview = oldState == State.OVERVIEW;
2138         setState(state);
2139         final boolean stateIsNormal = state == State.NORMAL;
2140         final boolean stateIsSpringLoaded = state == State.SPRING_LOADED;
2141         final boolean stateIsSmall = state == State.SMALL;
2142         final boolean stateIsOverview = state == State.OVERVIEW;
2143         float finalBackgroundAlpha = (stateIsSpringLoaded || stateIsOverview) ? 1.0F : 0.0F;
2144         float finalHotseatAndPageIndicatorAlpha = (stateIsOverview || stateIsSmall) ? 0.0F : 1.0F;
2145         float finalOverviewPanelAlpha = (stateIsOverview) ? 1.0F : 0.0F;
2146         float finalSearchBarAlpha = (!stateIsNormal) ? 0.0F : 1.0F;
2147         float finalWorkspaceTranslationY = (stateIsOverview) ? getOverviewModeTranslationY() : 0;
2148         boolean workspaceToAllApps = oldStateIsNormal &amp;&amp; stateIsSmall;
2149         boolean allAppsToWorkspace = oldStateIsSmall &amp;&amp; stateIsNormal;
2150         boolean workspaceToOverview = oldStateIsNormal &amp;&amp; stateIsOverview;
2151         boolean overviewToWorkspace = oldStateIsOverview &amp;&amp; stateIsNormal;
2152         mNewScale = 1.0F;
2153         if (oldStateIsOverview) {
2154             disableFreeScroll(snapPage);
2155         } else if (stateIsOverview) {
2156             enableFreeScroll();
2157         }
2158         if (state != State.NORMAL) {
2159             if (stateIsSpringLoaded) {
2160                 mNewScale = mSpringLoadedShrinkFactor;
2161             } else if (stateIsOverview) {
2162                 mNewScale = mOverviewModeShrinkFactor;
2163             } else if (stateIsSmall) {
2164                 mNewScale = mOverviewModeShrinkFactor - 0.3F;
2165             }
2166             if (workspaceToAllApps) {
2167                 updateChildrenLayersEnabled(false);
2168             }
2169         }
2170         final int duration;
2171         if (workspaceToAllApps) {
2172             duration = getResources().getInteger(R.integer.config_workspaceUnshrinkTime);
2173         } else if (workspaceToOverview || overviewToWorkspace) {
2174             duration = getResources().getInteger(R.integer.config_overviewTransitionTime);
2175         } else {
2176             duration = getResources().getInteger(R.integer.config_appsCustomizeWorkspaceShrinkTime);
2177         }
2178         for (int i = 0; i &lt; getChildCount(); i++) {
2179             final CellLayout cl = ((CellLayout) (getChildAt(i)));
2180             boolean isCurrentPage = i == getNextPage();
2181             float initialAlpha = cl.getShortcutsAndWidgets().getAlpha();
2182             float finalAlpha;
2183             if (stateIsSmall) {
2184                 finalAlpha = 0.0F;
2185             } else if (stateIsNormal &amp;&amp; mWorkspaceFadeInAdjacentScreens) {
2186                 finalAlpha = ((i == getNextPage()) || (i &lt; numCustomPages())) ? 1.0F : 0.0F;
2187             } else {
2188                 finalAlpha = 1.0F;
2189             }
2190             // If we are animating to/from the small state, then hide the side pages and fade the
2191             // current page in
2192             if (!mIsSwitchingState) {
2193                 if (workspaceToAllApps || allAppsToWorkspace) {
2194                     if (allAppsToWorkspace &amp;&amp; isCurrentPage) {
2195                         initialAlpha = 0.0F;
2196                     } else if (!isCurrentPage) {
2197                         initialAlpha = finalAlpha = 0.0F;
2198                     }
2199                     cl.setShortcutAndWidgetAlpha(initialAlpha);
2200                 }
2201             }
2202             mOldAlphas[i] = initialAlpha;
2203             mNewAlphas[i] = finalAlpha;
2204             if (animated) {
2205                 mOldBackgroundAlphas[i] = cl.getBackgroundAlpha();
2206                 mNewBackgroundAlphas[i] = finalBackgroundAlpha;
2207             } else {
2208                 cl.setBackgroundAlpha(finalBackgroundAlpha);
2209                 cl.setShortcutAndWidgetAlpha(finalAlpha);
2210             }
2211         }
2212         final View searchBar = mLauncher.getQsbBar();
2213         final View overviewPanel = mLauncher.getOverviewPanel();
2214         final View hotseat = mLauncher.getHotseat();
2215         if (animated) {
2216             anim.setDuration(duration);
2217             LauncherViewPropertyAnimator scale = new LauncherViewPropertyAnimator(this);
<abbr title="2218             scale.scaleX(mNewScale).scaleY(mNewScale).translationY(finalWorkspaceTranslationY).setInterpolator(mZoomInInterpolator);">2218             scale.scaleX(mNewScale).scaleY(mNewScale).translationY(finalWorkspaceTranslationY).setInterpo🔵</abbr>
2219             anim.play(scale);
2220             for (int index = 0; index &lt; getChildCount(); index++) {
2221                 final int i = index;
2222                 final CellLayout cl = ((CellLayout) (getChildAt(i)));
2223                 float currentAlpha = cl.getShortcutsAndWidgets().getAlpha();
2224                 if ((mOldAlphas[i] == 0) &amp;&amp; (mNewAlphas[i] == 0)) {
2225                     cl.setBackgroundAlpha(mNewBackgroundAlphas[i]);
2226                     cl.setShortcutAndWidgetAlpha(mNewAlphas[i]);
2227                 } else {
2228                     if ((mOldAlphas[i] != mNewAlphas[i]) || (currentAlpha != mNewAlphas[i])) {
<abbr title="2229                         LauncherViewPropertyAnimator alphaAnim = new LauncherViewPropertyAnimator(cl.getShortcutsAndWidgets());">2229                         LauncherViewPropertyAnimator alphaAnim = new LauncherViewPropertyAnimator(cl.getS🔵</abbr>
2230                         alphaAnim.alpha(mNewAlphas[i]).setInterpolator(mZoomInInterpolator);
2231                         anim.play(alphaAnim);
2232                     }
2233                     if ((mOldBackgroundAlphas[i] != 0) || (mNewBackgroundAlphas[i] != 0)) {
2234                         ValueAnimator bgAnim = LauncherAnimUtils.ofFloat(cl, 0.0F, 1.0F);
2235                         bgAnim.setInterpolator(mZoomInInterpolator);
2236                         bgAnim.addUpdateListener(new LauncherAnimatorUpdateListener() {
2237                             public void onAnimationUpdate(float a, float b) {
<abbr title="2238                                 cl.setBackgroundAlpha((a * mOldBackgroundAlphas[i]) + (b * mNewBackgroundAlphas[i]));">2238                                 cl.setBackgroundAlpha((a * mOldBackgroundAlphas[i]) + (b * mNewBackground🔵</abbr>
2239                             }
2240                         });
2241                         anim.play(bgAnim);
2242                     }
2243                 }
2244             }
2245             ObjectAnimator pageIndicatorAlpha = null;
2246             if (getPageIndicator() != null) {
<abbr title="2247                 pageIndicatorAlpha = ObjectAnimator.ofFloat(getPageIndicator(), &quot;alpha&quot;, finalHotseatAndPageIndicatorAlpha);">2247                 pageIndicatorAlpha = ObjectAnimator.ofFloat(getPageIndicator(), &quot;alpha&quot;, finalHotseatAndP🔵</abbr>
2248             }
<abbr title="2249             ObjectAnimator hotseatAlpha = ObjectAnimator.ofFloat(hotseat, &quot;alpha&quot;, finalHotseatAndPageIndicatorAlpha);">2249             ObjectAnimator hotseatAlpha = ObjectAnimator.ofFloat(hotseat, &quot;alpha&quot;, finalHotseatAndPageInd🔵</abbr>
<abbr title="2250             ObjectAnimator searchBarAlpha = ObjectAnimator.ofFloat(searchBar, &quot;alpha&quot;, finalSearchBarAlpha);">2250             ObjectAnimator searchBarAlpha = ObjectAnimator.ofFloat(searchBar, &quot;alpha&quot;, finalSearchBarAlph🔵</abbr>
<abbr title="2251             ObjectAnimator overviewPanelAlpha = ObjectAnimator.ofFloat(overviewPanel, &quot;alpha&quot;, finalOverviewPanelAlpha);">2251             ObjectAnimator overviewPanelAlpha = ObjectAnimator.ofFloat(overviewPanel, &quot;alpha&quot;, finalOverv🔵</abbr>
2252             overviewPanelAlpha.addListener(new AlphaUpdateListener(overviewPanel));
2253             hotseatAlpha.addListener(new AlphaUpdateListener(hotseat));
2254             searchBarAlpha.addListener(new AlphaUpdateListener(searchBar));
2255             if (workspaceToOverview) {
2256                 hotseatAlpha.setInterpolator(new DecelerateInterpolator(2));
2257             } else if (overviewToWorkspace) {
2258                 overviewPanelAlpha.setInterpolator(new DecelerateInterpolator(2));
2259             }
2260             if (getPageIndicator() != null) {
2261                 pageIndicatorAlpha.addListener(new AlphaUpdateListener(getPageIndicator()));
2262             }
2263             anim.play(overviewPanelAlpha);
2264             anim.play(hotseatAlpha);
2265             anim.play(searchBarAlpha);
2266             anim.play(pageIndicatorAlpha);
2267             anim.setStartDelay(delay);
2268         } else {
2269             overviewPanel.setAlpha(finalOverviewPanelAlpha);
2270             AlphaUpdateListener.updateVisibility(overviewPanel);
2271             hotseat.setAlpha(finalHotseatAndPageIndicatorAlpha);
2272             AlphaUpdateListener.updateVisibility(hotseat);
2273             if (getPageIndicator() != null) {
2274                 getPageIndicator().setAlpha(finalHotseatAndPageIndicatorAlpha);
2275                 AlphaUpdateListener.updateVisibility(getPageIndicator());
2276             }
2277             searchBar.setAlpha(finalSearchBarAlpha);
2278             AlphaUpdateListener.updateVisibility(searchBar);
2279             updateCustomContentVisibility();
2280             setScaleX(mNewScale);
2281             setScaleY(mNewScale);
2282             setTranslationY(finalWorkspaceTranslationY);
2283         }
2284         mLauncher.updateVoiceButtonProxyVisible(false);
2285         if (stateIsSpringLoaded) {
2286             // Right now we&#x27;re covered by Apps Customize
2287             // Show the background gradient immediately, so the gradient will
2288             // be showing once AppsCustomize disappears
<abbr title="2289             animateBackgroundGradient(getResources().getInteger(R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100.0F, false);">2289             animateBackgroundGradient(getResources().getInteger(R.integer.config_appsCustomizeSpringLoade🔵</abbr>
2290         } else if (stateIsOverview) {
<abbr title="2291             animateBackgroundGradient(getResources().getInteger(R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100.0F, true);">2291             animateBackgroundGradient(getResources().getInteger(R.integer.config_appsCustomizeSpringLoade🔵</abbr>
2292         } else {
2293             // Fade the background gradient away
2294             animateBackgroundGradient(0.0F, animated);
2295         }
2296         return anim;
2297     }
2298 
2299     static class AlphaUpdateListener implements AnimatorUpdateListener , AnimatorListener {
2300         View view;
2301 
2302         public AlphaUpdateListener(View v) {
2303             view = v;
2304         }
2305 
2306         @Override
2307         public void onAnimationUpdate(ValueAnimator arg0) {
2308             updateVisibility(view);
2309         }
2310 
2311         public static void updateVisibility(View view) {
2312             // We want to avoid the extra layout pass by setting the views to GONE unless
2313             // accessibility is on, in which case not setting them to GONE causes a glitch.
2314             int invisibleState = (sAccessibilityEnabled) ? GONE : INVISIBLE;
2315             if ((view.getAlpha() &lt; ALPHA_CUTOFF_THRESHOLD) &amp;&amp; (view.getVisibility() != invisibleState)) {
2316                 view.setVisibility(invisibleState);
2317             } else if ((view.getAlpha() &gt; ALPHA_CUTOFF_THRESHOLD) &amp;&amp; (view.getVisibility() != VISIBLE)) {
2318                 view.setVisibility(VISIBLE);
2319             }
2320         }
2321 
2322         @Override
2323         public void onAnimationCancel(Animator arg0) {
2324         }
2325 
2326         @Override
2327         public void onAnimationEnd(Animator arg0) {
2328             updateVisibility(view);
2329         }
2330 
2331         @Override
2332         public void onAnimationRepeat(Animator arg0) {
2333         }
2334 
2335         @Override
2336         public void onAnimationStart(Animator arg0) {
2337             // We want the views to be visible for animation, so fade-in/out is visible
2338             view.setVisibility(VISIBLE);
2339         }
2340     }
2341 
2342     @Override
2343     public void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace) {
2344         onTransitionPrepare();
2345     }
2346 
2347     @Override
2348     public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
2349     }
2350 
2351     @Override
2352     public void onLauncherTransitionStep(Launcher l, float t) {
2353         mTransitionProgress = t;
2354     }
2355 
2356     @Override
2357     public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
2358         onTransitionEnd();
2359     }
2360 
2361     private void onTransitionPrepare() {
2362         mIsSwitchingState = true;
2363 
2364         // Invalidate here to ensure that the pages are rendered during the state change transition.
2365         invalidate();
2366 
2367         updateChildrenLayersEnabled(false);
2368         hideCustomContentIfNecessary();
2369     }
2370 
2371     void updateCustomContentVisibility() {
2372         int visibility = mState == Workspace.State.NORMAL ? VISIBLE : INVISIBLE;
2373         if (hasCustomContent()) {
2374             mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(visibility);
2375         }
2376     }
2377 
2378     void showCustomContentIfNecessary() {
2379         boolean show  = mState == Workspace.State.NORMAL;
2380         if (show &amp;&amp; hasCustomContent()) {
2381             mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(VISIBLE);
2382         }
2383     }
2384 
2385     void hideCustomContentIfNecessary() {
2386         boolean hide  = mState != Workspace.State.NORMAL;
2387         if (hide &amp;&amp; hasCustomContent()) {
2388             mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(INVISIBLE);
2389         }
2390     }
2391 
2392     private void onTransitionEnd() {
2393         mIsSwitchingState = false;
2394         updateChildrenLayersEnabled(false);
2395         // The code in getChangeStateAnimation to determine initialAlpha and finalAlpha will ensure
2396         // ensure that only the current page is visible during (and subsequently, after) the
2397         // transition animation.  If fade adjacent pages is disabled, then re-enable the page
2398         // visibility after the transition animation.
2399         if (!mWorkspaceFadeInAdjacentScreens) {
2400             for (int i = 0; i &lt; getChildCount(); i++) {
2401                 final CellLayout cl = ((CellLayout) (getChildAt(i)));
2402                 cl.setShortcutAndWidgetAlpha(1.0F);
2403             }
2404         } else {
2405             for (int i = 0; i &lt; numCustomPages(); i++) {
2406                 final CellLayout cl = ((CellLayout) (getChildAt(i)));
2407                 cl.setShortcutAndWidgetAlpha(1.0F);
2408             }
2409         }
2410         showCustomContentIfNecessary();
2411     }
2412 
2413     @Override
2414     public View getContent() {
2415         return this;
2416     }
2417 
2418     /**
2419      * Draw the View v into the given Canvas.
2420      *
2421      * @param v the view to draw
2422      * @param destCanvas the canvas to draw on
2423      * @param padding the horizontal and vertical padding to use when drawing
2424      */
2425     private void drawDragView(View v, Canvas destCanvas, int padding, boolean pruneToDrawable) {
2426         final Rect clipRect = mTempRect;
2427         v.getDrawingRect(clipRect);
2428 
2429         boolean textVisible = false;
2430 
2431         destCanvas.save();
2432         if (v instanceof TextView &amp;&amp; pruneToDrawable) {
2433             Drawable d = ((TextView) v).getCompoundDrawables()[1];
2434             clipRect.set(0, 0, d.getIntrinsicWidth() + padding, d.getIntrinsicHeight() + padding);
2435             destCanvas.translate(padding / 2, padding / 2);
2436             d.draw(destCanvas);
2437         } else {
2438             if (v instanceof FolderIcon) {
2439                 // For FolderIcons the text can bleed into the icon area, and so we need to
2440                 // hide the text completely (which can&#x27;t be achieved by clipping).
2441                 if (((FolderIcon) v).getTextVisible()) {
2442                     ((FolderIcon) v).setTextVisible(false);
2443                     textVisible = true;
2444                 }
2445             } else if (v instanceof BubbleTextView) {
2446                 final BubbleTextView tv = (BubbleTextView) v;
2447                 clipRect.bottom = tv.getExtendedPaddingTop() - (int) BubbleTextView.PADDING_V +
2448                         tv.getLayout().getLineTop(0);
2449             } else if (v instanceof TextView) {
2450                 final TextView tv = (TextView) v;
2451                 clipRect.bottom = tv.getExtendedPaddingTop() - tv.getCompoundDrawablePadding() +
2452                         tv.getLayout().getLineTop(0);
2453             }
2454             destCanvas.translate(-v.getScrollX() + padding / 2, -v.getScrollY() + padding / 2);
2455             destCanvas.clipRect(clipRect, Op.REPLACE);
2456             v.draw(destCanvas);
2457 
2458             // Restore text visibility of FolderIcon if necessary
2459             if (textVisible) {
2460                 ((FolderIcon) v).setTextVisible(true);
2461             }
2462         }
2463         destCanvas.restore();
2464     }
2465 
2466     /**
2467      * Returns a new bitmap to show when the given View is being dragged around.
2468      * Responsibility for the bitmap is transferred to the caller.
2469      */
2470     public Bitmap createDragBitmap(View v, Canvas canvas, int padding) {
2471         Bitmap b;
2472 
2473         if (v instanceof TextView) {
2474             Drawable d = ((TextView) v).getCompoundDrawables()[1];
2475             b = Bitmap.createBitmap(d.getIntrinsicWidth() + padding,
2476                     d.getIntrinsicHeight() + padding, Bitmap.Config.ARGB_8888);
2477         } else {
2478             b = Bitmap.createBitmap(
2479                     v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
2480         }
2481 
2482         canvas.setBitmap(b);
2483         drawDragView(v, canvas, padding, true);
2484         canvas.setBitmap(null);
2485 
2486         return b;
2487     }
2488 
2489     /**
2490      * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
2491      * Responsibility for the bitmap is transferred to the caller.
2492      */
2493     private Bitmap createDragOutline(View v, Canvas canvas, int padding) {
2494         final int outlineColor = getResources().getColor(R.color.outline_color);
2495         final Bitmap b = Bitmap.createBitmap(
2496                 v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
2497 
2498         canvas.setBitmap(b);
2499         drawDragView(v, canvas, padding, true);
2500         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
2501         canvas.setBitmap(null);
2502         return b;
2503     }
2504 
2505     /**
2506      * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
2507      * Responsibility for the bitmap is transferred to the caller.
2508      */
2509     private Bitmap createDragOutline(Bitmap orig, Canvas canvas, int padding, int w, int h,
2510             boolean clipAlpha) {
2511         final int outlineColor = getResources().getColor(R.color.outline_color);
2512         final Bitmap b = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
2513         canvas.setBitmap(b);
2514 
2515         Rect src = new Rect(0, 0, orig.getWidth(), orig.getHeight());
2516         float scaleFactor = Math.min((w - padding) / (float) orig.getWidth(),
2517                 (h - padding) / (float) orig.getHeight());
2518         int scaledWidth = (int) (scaleFactor * orig.getWidth());
2519         int scaledHeight = (int) (scaleFactor * orig.getHeight());
2520         Rect dst = new Rect(0, 0, scaledWidth, scaledHeight);
2521 
2522         // center the image
2523         dst.offset((w - scaledWidth) / 2, (h - scaledHeight) / 2);
2524 
2525         canvas.drawBitmap(orig, src, dst, null);
2526         mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor,
2527                 clipAlpha);
2528         canvas.setBitmap(null);
2529 
2530         return b;
2531     }
2532 
2533     void startDrag(CellLayout.CellInfo cellInfo) {
2534         View child = cellInfo.cell;
2535 
2536         // Make sure the drag was started by a long press as opposed to a long click.
2537         if (!child.isInTouchMode()) {
2538             return;
2539         }
2540 
2541         mDragInfo = cellInfo;
2542         child.setVisibility(INVISIBLE);
2543         CellLayout layout = (CellLayout) child.getParent().getParent();
2544         layout.prepareChildForDrag(child);
2545 
2546         child.clearFocus();
2547         child.setPressed(false);
2548 
2549         final Canvas canvas = new Canvas();
2550 
2551         // The outline is used to visualize where the item will land if dropped
2552         mDragOutline = createDragOutline(child, canvas, DRAG_BITMAP_PADDING);
2553         beginDragShared(child, this);
2554     }
2555 
2556     public void beginDragShared(View child, DragSource source) {
2557         // The drag bitmap follows the touch point around on the screen
2558         final Bitmap b = createDragBitmap(child, new Canvas(), DRAG_BITMAP_PADDING);
2559         final int bmpWidth = b.getWidth();
2560         final int bmpHeight = b.getHeight();
2561         float scale = mLauncher.getDragLayer().getLocationInDragLayer(child, mTempXY);
2562         int dragLayerX = Math.round(mTempXY[0] - ((bmpWidth - (scale * child.getWidth())) / 2));
<abbr title="2563         int dragLayerY = Math.round((mTempXY[1] - ((bmpHeight - (scale * bmpHeight)) / 2)) - (DRAG_BITMAP_PADDING / 2));">2563         int dragLayerY = Math.round((mTempXY[1] - ((bmpHeight - (scale * bmpHeight)) / 2)) - (DRAG_BITMAP🔵</abbr>
2564         LauncherAppState app = LauncherAppState.getInstance();
2565         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2566         Point dragVisualizeOffset = null;
2567         Rect dragRect = null;
2568         if ((child instanceof BubbleTextView) || (child instanceof PagedViewIcon)) {
2569             int iconSize = grid.iconSizePx;
2570             int top = child.getPaddingTop();
2571             int left = (bmpWidth - iconSize) / 2;
2572             int right = left + iconSize;
2573             int bottom = top + iconSize;
2574             dragLayerY += top;
2575             // Note: The drag region is used to calculate drag layer offsets, but the
2576             // dragVisualizeOffset in addition to the dragRect (the size) to position the outline.
2577             dragVisualizeOffset = new Point((-DRAG_BITMAP_PADDING) / 2, DRAG_BITMAP_PADDING / 2);
2578             dragRect = new Rect(left, top, right, bottom);
2579         } else if (child instanceof FolderIcon) {
2580             int previewSize = grid.folderIconSizePx;
2581             dragRect = new Rect(0, child.getPaddingTop(), child.getWidth(), previewSize);
2582         }
2583         // Clear the pressed state if necessary
2584         if (child instanceof BubbleTextView) {
2585             BubbleTextView icon = ((BubbleTextView) (child));
2586             icon.clearPressedOrFocusedBackground();
2587         }
2588 
2589 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2590         if (child.getTag() == null || !(child.getTag() instanceof ItemInfo)) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2591             String msg = &quot;Drag started with a view that has no tag set. This &quot;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2592                     + &quot;will cause a crash (issue 11627249) down the line. &quot;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2593                     + &quot;View: &quot; + child + &quot;  tag: &quot; + child.getTag();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2594             throw new IllegalStateException(msg);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2595         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2596 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2597         mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">2598                 DragController.DRAG_ACTION_MOVE, dragVisualizeOffset, dragRect, scale);</span>
2599 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title="2600 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/">2600 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
2601 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2602 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2603         DragView dv = mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2604                 DragController.DRAG_ACTION_MOVE, dragVisualizeOffset, dragRect, scale);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">2605         dv.setIntrinsicIconScaleFactor(source.getIntrinsicIconScaleFactor());</span>
2606 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
2607 
2608         if (child.getParent() instanceof ShortcutAndWidgetContainer) {
2609             mDragSourceInternal = ((ShortcutAndWidgetContainer) (child.getParent()));
2610         }
2611         b.recycle();
2612     }
2613 
2614     void addApplicationShortcut(ShortcutInfo info, CellLayout target, long container, long screenId,
2615             int cellX, int cellY, boolean insertAtFirst, int intersectX, int intersectY) {
2616         View view = mLauncher.createShortcut(R.layout.application, target, (ShortcutInfo) info);
2617 
2618         final int[] cellXY = new int[2];
2619         target.findCellForSpanThatIntersects(cellXY, 1, 1, intersectX, intersectY);
2620         addInScreen(view, container, screenId, cellXY[0], cellXY[1], 1, 1, insertAtFirst);
2621 
2622         LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screenId, cellXY[0],
2623                 cellXY[1]);
2624     }
2625 
2626     public boolean transitionStateShouldAllowDrop() {
2627         return ((!isSwitchingState() || mTransitionProgress &gt; 0.5f) &amp;&amp; mState != State.SMALL);
2628     }
2629 
2630     /**
2631      * {@inheritDoc}
2632      */
2633     public boolean acceptDrop(DragObject d) {
2634         // If it&#x27;s an external drop (e.g. from All Apps), check if it should be accepted
2635         CellLayout dropTargetLayout = mDropToLayout;
2636         if (d.dragSource != this) {
2637             // Don&#x27;t accept the drop if we&#x27;re not over a screen at time of drop
2638             if (dropTargetLayout == null) {
2639                 return false;
2640             }
2641             if (!transitionStateShouldAllowDrop()) return false;
2642 
2643             mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
2644                     d.dragView, mDragViewVisualCenter);
2645 
2646             // We want the point to be mapped to the dragTarget.
2647             if (mLauncher.isHotseatLayout(dropTargetLayout)) {
2648                 mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
2649             } else {
2650                 mapPointFromSelfToChild(dropTargetLayout, mDragViewVisualCenter, null);
2651             }
2652 
2653             int spanX = 1;
2654             int spanY = 1;
2655             if (mDragInfo != null) {
2656                 final CellLayout.CellInfo dragCellInfo = mDragInfo;
2657                 spanX = dragCellInfo.spanX;
2658                 spanY = dragCellInfo.spanY;
2659             } else {
2660                 final ItemInfo dragInfo = (ItemInfo) d.dragInfo;
2661                 spanX = dragInfo.spanX;
2662                 spanY = dragInfo.spanY;
2663             }
2664 
2665             int minSpanX = spanX;
2666             int minSpanY = spanY;
2667             if (d.dragInfo instanceof PendingAddWidgetInfo) {
2668                 minSpanX = ((PendingAddWidgetInfo) d.dragInfo).minSpanX;
2669                 minSpanY = ((PendingAddWidgetInfo) d.dragInfo).minSpanY;
2670             }
2671 
2672             mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
2673                     (int) mDragViewVisualCenter[1], minSpanX, minSpanY, dropTargetLayout,
2674                     mTargetCell);
2675             float distance = dropTargetLayout.getDistanceFromCell(mDragViewVisualCenter[0],
2676                     mDragViewVisualCenter[1], mTargetCell);
2677             if (willCreateUserFolder((ItemInfo) d.dragInfo, dropTargetLayout,
2678                     mTargetCell, distance, true)) {
2679                 return true;
2680             }
2681             if (willAddToExistingUserFolder((ItemInfo) d.dragInfo, dropTargetLayout,
2682                     mTargetCell, distance)) {
2683                 return true;
2684             }
2685 
2686             int[] resultSpan = new int[2];
2687             mTargetCell = dropTargetLayout.createArea((int) mDragViewVisualCenter[0],
2688                     (int) mDragViewVisualCenter[1], minSpanX, minSpanY, spanX, spanY,
2689                     null, mTargetCell, resultSpan, CellLayout.MODE_ACCEPT_DROP);
2690             boolean foundCell = mTargetCell[0] &gt;= 0 &amp;&amp; mTargetCell[1] &gt;= 0;
2691 
2692             // Don&#x27;t accept the drop if there&#x27;s no room for the item
2693             if (!foundCell) {
2694                 // Don&#x27;t show the message if we are dropping on the AllApps button and the hotseat
2695                 // is full
2696                 boolean isHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
2697                 if (mTargetCell != null &amp;&amp; isHotseat) {
2698                     Hotseat hotseat = mLauncher.getHotseat();
2699                     if (hotseat.isAllAppsButtonRank(
2700                             hotseat.getOrderInHotseat(mTargetCell[0], mTargetCell[1]))) {
2701                         return false;
2702                     }
2703                 }
2704 
2705                 mLauncher.showOutOfSpaceMessage(isHotseat);
2706                 return false;
2707             }
2708         }
2709 
2710         long screenId = getIdForScreen(dropTargetLayout);
2711         if (screenId == EXTRA_EMPTY_SCREEN_ID) {
2712             commitExtraEmptyScreen();
2713         }
2714 
2715         return true;
2716     }
2717 
2718     boolean willCreateUserFolder(ItemInfo info, CellLayout target, int[] targetCell, float
2719             distance, boolean considerTimeout) {
2720         if (distance &gt; mMaxDistanceForFolderCreation) return false;
2721         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2722 
2723         if (dropOverView != null) {
2724             CellLayout.LayoutParams lp = (CellLayout.LayoutParams) dropOverView.getLayoutParams();
2725             if (lp.useTmpCoords &amp;&amp; (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.tmpCellY)) {
2726                 return false;
2727             }
2728         }
2729 
2730         boolean hasntMoved = false;
2731         if (mDragInfo != null) {
2732             hasntMoved = dropOverView == mDragInfo.cell;
2733         }
2734 
2735         if (dropOverView == null || hasntMoved || (considerTimeout &amp;&amp; !mCreateUserFolderOnDrop)) {
2736             return false;
2737         }
2738 
2739         boolean aboveShortcut = (dropOverView.getTag() instanceof ShortcutInfo);
2740         boolean willBecomeShortcut =
2741                 (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
2742                 info.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT);
2743 
2744         return (aboveShortcut &amp;&amp; willBecomeShortcut);
2745     }
2746 
2747     boolean willAddToExistingUserFolder(Object dragInfo, CellLayout target, int[] targetCell,
2748             float distance) {
2749         if (distance &gt; mMaxDistanceForFolderCreation) return false;
2750         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2751 
2752         if (dropOverView != null) {
2753             CellLayout.LayoutParams lp = (CellLayout.LayoutParams) dropOverView.getLayoutParams();
2754             if (lp.useTmpCoords &amp;&amp; (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.tmpCellY)) {
2755                 return false;
2756             }
2757         }
2758 
2759         if (dropOverView instanceof FolderIcon) {
2760             FolderIcon fi = (FolderIcon) dropOverView;
2761             if (fi.acceptDrop(dragInfo)) {
2762                 return true;
2763             }
2764         }
2765         return false;
2766     }
2767 
2768     boolean createUserFolderIfNecessary(View newView, long container, CellLayout target,
2769             int[] targetCell, float distance, boolean external, DragView dragView,
2770             Runnable postAnimationRunnable) {
2771         if (distance &gt; mMaxDistanceForFolderCreation) return false;
2772         View v = target.getChildAt(targetCell[0], targetCell[1]);
2773 
2774         boolean hasntMoved = false;
2775         if (mDragInfo != null) {
2776             CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2777             hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2778                     mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2779         }
2780 
2781         if (v == null || hasntMoved || !mCreateUserFolderOnDrop) return false;
2782         mCreateUserFolderOnDrop = false;
2783         final long screenId = (targetCell == null) ? mDragInfo.screenId : getIdForScreen(target);
2784 
2785         boolean aboveShortcut = (v.getTag() instanceof ShortcutInfo);
2786         boolean willBecomeShortcut = (newView.getTag() instanceof ShortcutInfo);
2787 
2788         if (aboveShortcut &amp;&amp; willBecomeShortcut) {
2789             ShortcutInfo sourceInfo = (ShortcutInfo) newView.getTag();
2790             ShortcutInfo destInfo = (ShortcutInfo) v.getTag();
2791             // if the drag started here, we need to remove it from the workspace
2792             if (!external) {
2793                 getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2794             }
2795 
2796             Rect folderLocation = new Rect();
2797             float scale = mLauncher.getDragLayer().getDescendantRectRelativeToSelf(v, folderLocation);
2798             target.removeView(v);
2799 
2800             FolderIcon fi =
2801                 mLauncher.addFolder(target, container, screenId, targetCell[0], targetCell[1]);
2802             destInfo.cellX = -1;
2803             destInfo.cellY = -1;
2804             sourceInfo.cellX = -1;
2805             sourceInfo.cellY = -1;
2806 
2807             // If the dragView is null, we can&#x27;t animate
2808             boolean animate = dragView != null;
2809             if (animate) {
2810                 fi.performCreateAnimation(destInfo, v, sourceInfo, dragView, folderLocation, scale,
2811                         postAnimationRunnable);
2812             } else {
2813                 fi.addItem(destInfo);
2814                 fi.addItem(sourceInfo);
2815             }
2816             return true;
2817         }
2818         return false;
2819     }
2820 
2821     boolean addToExistingFolderIfNecessary(View newView, CellLayout target, int[] targetCell,
2822             float distance, DragObject d, boolean external) {
2823         if (distance &gt; mMaxDistanceForFolderCreation) return false;
2824 
2825         View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2826         if (!mAddToExistingFolderOnDrop) return false;
2827         mAddToExistingFolderOnDrop = false;
2828 
2829         if (dropOverView instanceof FolderIcon) {
2830             FolderIcon fi = (FolderIcon) dropOverView;
2831             if (fi.acceptDrop(d.dragInfo)) {
2832                 fi.onDrop(d);
2833 
2834                 // if the drag started here, we need to remove it from the workspace
2835                 if (!external) {
2836                     getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2837                 }
2838                 return true;
2839             }
2840         }
2841         return false;
2842     }
2843 
2844     public void onDrop(final DragObject d) {
<abbr title="2845         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView, mDragViewVisualCenter);">2845         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView, mDrag🔵</abbr>
2846         CellLayout dropTargetLayout = mDropToLayout;
2847         // We want the point to be mapped to the dragTarget.
2848         if (dropTargetLayout != null) {
2849             if (mLauncher.isHotseatLayout(dropTargetLayout)) {
2850                 mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
2851             } else {
2852                 mapPointFromSelfToChild(dropTargetLayout, mDragViewVisualCenter, null);
2853             }
2854         }
2855         int snapScreen = -1;
2856         boolean resizeOnDrop = false;
2857         if (d.dragSource != this) {
<abbr title="2858             final int[] touchXY = new int[]{ ((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCenter[1])) };">2858             final int[] touchXY = new int[]{ ((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualC🔵</abbr>
2859             onDropExternal(touchXY, d.dragInfo, dropTargetLayout, false, d);
2860         } else if (mDragInfo != null) {
2861             final View cell = mDragInfo.cell;
2862             Runnable resizeRunnable = null;
2863             if ((dropTargetLayout != null) &amp;&amp; (!d.cancelled)) {
2864                 // Move internally
2865                 boolean hasMovedLayouts = getParentCellLayoutForView(cell) != dropTargetLayout;
2866                 boolean hasMovedIntoHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
<abbr title="2867                 long container = (hasMovedIntoHotseat) ? Favorites.CONTAINER_HOTSEAT : Favorites.CONTAINER_DESKTOP;">2867                 long container = (hasMovedIntoHotseat) ? Favorites.CONTAINER_HOTSEAT : Favorites.CONTAINE🔵</abbr>
<abbr title="2868                 long screenId = (mTargetCell[0] &lt; 0) ? mDragInfo.screenId : getIdForScreen(dropTargetLayout);">2868                 long screenId = (mTargetCell[0] &lt; 0) ? mDragInfo.screenId : getIdForScreen(dropTargetLayo🔵</abbr>
2869                 int spanX = (mDragInfo != null) ? mDragInfo.spanX : 1;
2870                 int spanY = (mDragInfo != null) ? mDragInfo.spanY : 1;
2871                 // First we find the cell nearest to point at which the item is
2872                 // dropped, without any consideration to whether there is an item there.
<abbr title="2873                 mTargetCell = findNearestArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCenter[1])), spanX, spanY, dropTargetLayout, mTargetCell);">2873                 mTargetCell = findNearestArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisual🔵</abbr>
<abbr title="2874                 float distance = dropTargetLayout.getDistanceFromCell(mDragViewVisualCenter[0], mDragViewVisualCenter[1], mTargetCell);">2874                 float distance = dropTargetLayout.getDistanceFromCell(mDragViewVisualCenter[0], mDragView🔵</abbr>
2875                 // If the item being dropped is a shortcut and the nearest drop
2876                 // cell also contains a shortcut, then create a folder with the two shortcuts.
<abbr title="2877                 if ((!mInScrollArea) &amp;&amp; createUserFolderIfNecessary(cell, container, dropTargetLayout, mTargetCell, distance, false, d.dragView, null)) {">2877                 if ((!mInScrollArea) &amp;&amp; createUserFolderIfNecessary(cell, container, dropTargetLayout, mT🔵</abbr>
2878                     removeExtraEmptyScreen(true, null, 0, true);
2879                     return;
2880                 }
<abbr title="2881                 if (addToExistingFolderIfNecessary(cell, dropTargetLayout, mTargetCell, distance, d, false)) {">2881                 if (addToExistingFolderIfNecessary(cell, dropTargetLayout, mTargetCell, distance, d, fals🔵</abbr>
2882                     removeExtraEmptyScreen(true, null, 0, true);
2883                     return;
2884                 }
2885                 // Aside from the special case where we&#x27;re dropping a shortcut onto a shortcut,
2886                 // we need to find the nearest cell location that is vacant
2887                 ItemInfo item = ((ItemInfo) (d.dragInfo));
2888                 int minSpanX = item.spanX;
2889                 int minSpanY = item.spanY;
2890                 if ((item.minSpanX &gt; 0) &amp;&amp; (item.minSpanY &gt; 0)) {
2891                     minSpanX = item.minSpanX;
2892                     minSpanY = item.minSpanY;
2893                 }
2894                 int[] resultSpan = new int[2];
<abbr title="2895                 mTargetCell = dropTargetLayout.createArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCenter[1])), minSpanX, minSpanY, spanX, spanY, cell, mTargetCell, resultSpan, CellLayout.MODE_ON_DROP);">2895                 mTargetCell = dropTargetLayout.createArea(((int) (mDragViewVisualCenter[0])), ((int) (mDr🔵</abbr>
2896                 boolean foundCell = (mTargetCell[0] &gt;= 0) &amp;&amp; (mTargetCell[1] &gt;= 0);
2897                 // if the widget resizes on drop
<abbr title="2898                 if ((foundCell &amp;&amp; (cell instanceof AppWidgetHostView)) &amp;&amp; ((resultSpan[0] != item.spanX) || (resultSpan[1] != item.spanY))) {">2898                 if ((foundCell &amp;&amp; (cell instanceof AppWidgetHostView)) &amp;&amp; ((resultSpan[0] != item.spanX) 🔵</abbr>
2899                     resizeOnDrop = true;
2900                     item.spanX = resultSpan[0];
2901                     item.spanY = resultSpan[1];
2902                     AppWidgetHostView awhv = ((AppWidgetHostView) (cell));
<abbr title="2903                     AppWidgetResizeFrame.updateWidgetSizeRanges(awhv, mLauncher, resultSpan[0], resultSpan[1]);">2903                     AppWidgetResizeFrame.updateWidgetSizeRanges(awhv, mLauncher, resultSpan[0], resultSpa🔵</abbr>
2904                 }
2905                 if ((getScreenIdForPageIndex(mCurrentPage) != screenId) &amp;&amp; (!hasMovedIntoHotseat)) {
2906                     snapScreen = getPageIndexForScreenId(screenId);
2907                     snapToPage(snapScreen);
2908                 }
2909                 if (foundCell) {
2910                     final ItemInfo info = ((ItemInfo) (cell.getTag()));
2911                     if (hasMovedLayouts) {
2912                         // Reparent the view
2913                         getParentCellLayoutForView(cell).removeView(cell);
<abbr title="2914                         addInScreen(cell, container, screenId, mTargetCell[0], mTargetCell[1], info.spanX, info.spanY);">2914                         addInScreen(cell, container, screenId, mTargetCell[0], mTargetCell[1], info.spanX🔵</abbr>
2915                     }
2916                     // update the item&#x27;s position after drop
2917                     CellLayout.LayoutParams lp = ((CellLayout.LayoutParams) (cell.getLayoutParams()));
2918                     lp.cellX = lp.tmpCellX = mTargetCell[0];
2919                     lp.cellY = lp.tmpCellY = mTargetCell[1];
2920                     lp.cellHSpan = item.spanX;
2921                     lp.cellVSpan = item.spanY;
2922                     lp.isLockedToGrid = true;
<abbr title="2923                     if ((container != Favorites.CONTAINER_HOTSEAT) &amp;&amp; (cell instanceof LauncherAppWidgetHostView)) {">2923                     if ((container != Favorites.CONTAINER_HOTSEAT) &amp;&amp; (cell instanceof LauncherAppWidgetH🔵</abbr>
2924                         final CellLayout cellLayout = dropTargetLayout;
2925                         // We post this call so that the widget has a chance to be placed
2926                         // in its final location
2927                         final LauncherAppWidgetHostView hostView = ((LauncherAppWidgetHostView) (cell));
2928                         AppWidgetProviderInfo pinfo = hostView.getAppWidgetInfo();
2929                         if ((pinfo != null) &amp;&amp; (pinfo.resizeMode != AppWidgetProviderInfo.RESIZE_NONE)) {
2930                             final Runnable addResizeFrame = new Runnable() {
2931                                 public void run() {
2932                                     DragLayer dragLayer = mLauncher.getDragLayer();
2933                                     dragLayer.addResizeFrame(info, hostView, cellLayout);
2934                                 }
2935                             };
2936                             resizeRunnable = new Runnable() {
2937                                 public void run() {
2938                                     if (!isPageMoving()) {
2939                                         addResizeFrame.run();
2940                                     } else {
2941                                         mDelayedResizeRunnable = addResizeFrame;
2942                                     }
2943                                 }
2944                             };
2945                         }
2946                     }
<abbr title="2947                     LauncherModel.modifyItemInDatabase(mLauncher, info, container, screenId, lp.cellX, lp.cellY, item.spanX, item.spanY);">2947                     LauncherModel.modifyItemInDatabase(mLauncher, info, container, screenId, lp.cellX, lp🔵</abbr>
2948                 } else {
2949                     // If we can&#x27;t find a drop location, we return the item to its original position
2950                     CellLayout.LayoutParams lp = ((CellLayout.LayoutParams) (cell.getLayoutParams()));
2951                     mTargetCell[0] = lp.cellX;
2952                     mTargetCell[1] = lp.cellY;
2953                     CellLayout layout = ((CellLayout) (cell.getParent().getParent()));
2954                     layout.markCellsAsOccupiedForView(cell);
2955                 }
2956             }
2957             final CellLayout parent = ((CellLayout) (cell.getParent().getParent()));
2958             final Runnable finalResizeRunnable = resizeRunnable;
2959             // Prepare it to be animated into its new position
2960             // This must be called after the view has been re-parented
2961             final Runnable onCompleteRunnable = new Runnable() {
2962                 @Override
2963                 public void run() {
2964                     mAnimatingViewIntoPlace = false;
2965                     updateChildrenLayersEnabled(false);
2966                     if (finalResizeRunnable != null) {
2967                         finalResizeRunnable.run();
2968                     }
2969                     removeExtraEmptyScreen(true, null, 0, true);
2970                 }
2971             };
2972             mAnimatingViewIntoPlace = true;
2973             if (d.dragView.hasDrawn()) {
2974                 final ItemInfo info = ((ItemInfo) (cell.getTag()));
2975                 if (info.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
<abbr title="2976                     int animationType = (resizeOnDrop) ? ANIMATE_INTO_POSITION_AND_RESIZE : ANIMATE_INTO_POSITION_AND_DISAPPEAR;">2976                     int animationType = (resizeOnDrop) ? ANIMATE_INTO_POSITION_AND_RESIZE : ANIMATE_INTO_🔵</abbr>
<abbr title="2977                     animateWidgetDrop(info, parent, d.dragView, onCompleteRunnable, animationType, cell, false);">2977                     animateWidgetDrop(info, parent, d.dragView, onCompleteRunnable, animationType, cell, 🔵</abbr>
2978                 } else {
2979                     int duration = (snapScreen &lt; 0) ? -1 : ADJACENT_SCREEN_DROP_DURATION;
<abbr title="2980                     mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, cell, duration, onCompleteRunnable, this);">2980                     mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, cell, duration, onComple🔵</abbr>
2981                 }
2982             } else {
2983                 d.deferDragViewCleanupPostAnimation = false;
2984                 cell.setVisibility(VISIBLE);
2985             }
2986             parent.onDropChild(cell);
2987         }
2988     }
2989 
2990     public void setFinalScrollForPageChange(int pageIndex) {
2991         CellLayout cl = (CellLayout) getChildAt(pageIndex);
2992         if (cl != null) {
2993             mSavedScrollX = getScrollX();
2994             mSavedTranslationX = cl.getTranslationX();
2995             mSavedRotationY = cl.getRotationY();
2996             final int newX = getScrollForPage(pageIndex);
2997             setScrollX(newX);
2998             cl.setTranslationX(0f);
2999             cl.setRotationY(0f);
3000         }
3001     }
3002 
3003     public void resetFinalScrollForPageChange(int pageIndex) {
3004         if (pageIndex &gt;= 0) {
3005             CellLayout cl = (CellLayout) getChildAt(pageIndex);
3006             setScrollX(mSavedScrollX);
3007             cl.setTranslationX(mSavedTranslationX);
3008             cl.setRotationY(mSavedRotationY);
3009         }
3010     }
3011 
3012     public void getViewLocationRelativeToSelf(View v, int[] location) {
3013         getLocationInWindow(location);
3014         int x = location[0];
3015         int y = location[1];
3016 
3017         v.getLocationInWindow(location);
3018         int vX = location[0];
3019         int vY = location[1];
3020 
3021         location[0] = vX - x;
3022         location[1] = vY - y;
3023     }
3024 
3025     public void onDragEnter(DragObject d) {
3026         mDragEnforcer.onDragEnter();
3027         mCreateUserFolderOnDrop = false;
3028         mAddToExistingFolderOnDrop = false;
3029 
3030         mDropToLayout = null;
3031         CellLayout layout = getCurrentDropLayout();
3032         setCurrentDropLayout(layout);
3033         setCurrentDragOverlappingLayout(layout);
3034 
3035         // Because we don&#x27;t have space in the Phone UI (the CellLayouts run to the edge) we
3036         // don&#x27;t need to show the outlines
3037         if (LauncherAppState.getInstance().isScreenLarge()) {
3038             showOutlines();
3039         }
3040     }
3041 
3042     /** Return a rect that has the cellWidth/cellHeight (left, top), and
3043      * widthGap/heightGap (right, bottom) */
3044     static Rect getCellLayoutMetrics(Launcher launcher, int orientation) {
3045         LauncherAppState app = LauncherAppState.getInstance();
3046         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
3047 
3048         Resources res = launcher.getResources();
3049         Display display = launcher.getWindowManager().getDefaultDisplay();
3050         Point smallestSize = new Point();
3051         Point largestSize = new Point();
3052         display.getCurrentSizeRange(smallestSize, largestSize);
3053         int countX = (int) grid.numColumns;
3054         int countY = (int) grid.numRows;
3055         int constrainedLongEdge = largestSize.y;
3056         int constrainedShortEdge = smallestSize.y;
3057         if (orientation == CellLayout.LANDSCAPE) {
3058             if (mLandscapeCellLayoutMetrics == null) {
3059                 Rect padding = grid.getWorkspacePadding(CellLayout.LANDSCAPE);
3060                 int width = constrainedLongEdge - padding.left - padding.right;
3061                 int height = constrainedShortEdge - padding.top - padding.bottom;
3062                 mLandscapeCellLayoutMetrics = new Rect();
3063                 mLandscapeCellLayoutMetrics.set(
3064                         grid.calculateCellWidth(width, countX),
3065                         grid.calculateCellHeight(height, countY), 0, 0);
3066             }
3067             return mLandscapeCellLayoutMetrics;
3068         } else if (orientation == CellLayout.PORTRAIT) {
3069             if (mPortraitCellLayoutMetrics == null) {
3070                 Rect padding = grid.getWorkspacePadding(CellLayout.PORTRAIT);
3071                 int width = constrainedShortEdge - padding.left - padding.right;
3072                 int height = constrainedLongEdge - padding.top - padding.bottom;
3073                 mPortraitCellLayoutMetrics = new Rect();
3074                 mPortraitCellLayoutMetrics.set(
3075                         grid.calculateCellWidth(width, countX),
3076                         grid.calculateCellHeight(height, countY), 0, 0);
3077             }
3078             return mPortraitCellLayoutMetrics;
3079         }
3080         return null;
3081     }
3082 
3083     public void onDragExit(DragObject d) {
3084         mDragEnforcer.onDragExit();
3085 
3086         // Here we store the final page that will be dropped to, if the workspace in fact
3087         // receives the drop
3088         if (mInScrollArea) {
3089             if (isPageMoving()) {
3090                 // If the user drops while the page is scrolling, we should use that page as the
3091                 // destination instead of the page that is being hovered over.
3092                 mDropToLayout = (CellLayout) getPageAt(getNextPage());
3093             } else {
3094                 mDropToLayout = mDragOverlappingLayout;
3095             }
3096         } else {
3097             mDropToLayout = mDragTargetLayout;
3098         }
3099 
3100         if (mDragMode == DRAG_MODE_CREATE_FOLDER) {
3101             mCreateUserFolderOnDrop = true;
3102         } else if (mDragMode == DRAG_MODE_ADD_TO_FOLDER) {
3103             mAddToExistingFolderOnDrop = true;
3104         }
3105 
3106         // Reset the scroll area and previous drag target
3107         onResetScrollArea();
3108         setCurrentDropLayout(null);
3109         setCurrentDragOverlappingLayout(null);
3110 
3111         mSpringLoadedDragController.cancel();
3112 
3113         if (!mIsPageMoving) {
3114             hideOutlines();
3115         }
3116     }
3117 
3118     void setCurrentDropLayout(CellLayout layout) {
3119         if (mDragTargetLayout != null) {
3120             mDragTargetLayout.revertTempState();
3121             mDragTargetLayout.onDragExit();
3122         }
3123         mDragTargetLayout = layout;
3124         if (mDragTargetLayout != null) {
3125             mDragTargetLayout.onDragEnter();
3126         }
3127         cleanupReorder(true);
3128         cleanupFolderCreation();
3129         setCurrentDropOverCell(-1, -1);
3130     }
3131 
3132     void setCurrentDragOverlappingLayout(CellLayout layout) {
3133         if (mDragOverlappingLayout != null) {
3134             mDragOverlappingLayout.setIsDragOverlapping(false);
3135         }
3136         mDragOverlappingLayout = layout;
3137         if (mDragOverlappingLayout != null) {
3138             mDragOverlappingLayout.setIsDragOverlapping(true);
3139         }
3140         invalidate();
3141     }
3142 
3143     void setCurrentDropOverCell(int x, int y) {
3144         if (x != mDragOverX || y != mDragOverY) {
3145             mDragOverX = x;
3146             mDragOverY = y;
3147             setDragMode(DRAG_MODE_NONE);
3148         }
3149     }
3150 
3151     void setDragMode(int dragMode) {
3152         if (dragMode != mDragMode) {
3153             if (dragMode == DRAG_MODE_NONE) {
3154                 cleanupAddToFolder();
3155                 // We don&#x27;t want to cancel the re-order alarm every time the target cell changes
3156                 // as this feels to slow / unresponsive.
3157                 cleanupReorder(false);
3158                 cleanupFolderCreation();
3159             } else if (dragMode == DRAG_MODE_ADD_TO_FOLDER) {
3160                 cleanupReorder(true);
3161                 cleanupFolderCreation();
3162             } else if (dragMode == DRAG_MODE_CREATE_FOLDER) {
3163                 cleanupAddToFolder();
3164                 cleanupReorder(true);
3165             } else if (dragMode == DRAG_MODE_REORDER) {
3166                 cleanupAddToFolder();
3167                 cleanupFolderCreation();
3168             }
3169             mDragMode = dragMode;
3170         }
3171     }
3172 
3173     private void cleanupFolderCreation() {
3174         if (mDragFolderRingAnimator != null) {
3175             mDragFolderRingAnimator.animateToNaturalState();
3176             mDragFolderRingAnimator = null;
3177         }
3178         mFolderCreationAlarm.setOnAlarmListener(null);
3179         mFolderCreationAlarm.cancelAlarm();
3180     }
3181 
3182     private void cleanupAddToFolder() {
3183         if (mDragOverFolderIcon != null) {
3184             mDragOverFolderIcon.onDragExit(null);
3185             mDragOverFolderIcon = null;
3186         }
3187     }
3188 
3189     private void cleanupReorder(boolean cancelAlarm) {
3190         // Any pending reorders are canceled
3191         if (cancelAlarm) {
3192             mReorderAlarm.cancelAlarm();
3193         }
3194         mLastReorderX = -1;
3195         mLastReorderY = -1;
3196     }
3197 
3198 /*
3199  *
3200  * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
3201  * coordinate space. The argument xy is modified with the return result.
3202  *
3203  * if cachedInverseMatrix is not null, this method will just use that matrix instead of
3204  * computing it itself; we use this to avoid redundant matrix inversions in
3205  * findMatchingPageForDragOver
3206  *
3207  */
3208 void mapPointFromSelfToChild(View v, float[] xy, Matrix cachedInverseMatrix) {
3209     xy[0] = xy[0] - v.getLeft();
3210     xy[1] = xy[1] - v.getTop();
3211 }
3212 
3213 boolean isPointInSelfOverHotseat(int x, int y, Rect r) {
3214     if (r == null) {
3215         r = new Rect();
3216     }
3217     mTempPt[0] = x;
3218     mTempPt[1] = y;
3219     mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(this, mTempPt, true);
3220 
3221     LauncherAppState app = LauncherAppState.getInstance();
3222     DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
3223     r = grid.getHotseatRect();
3224     if (r.contains(mTempPt[0], mTempPt[1])) {
3225         return true;
3226     }
3227     return false;
3228 }
3229 
3230 void mapPointFromSelfToHotseatLayout(Hotseat hotseat, float[] xy) {
3231     mTempPt[0] = (int) xy[0];
3232     mTempPt[1] = (int) xy[1];
3233     mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(this, mTempPt, true);
3234     mLauncher.getDragLayer().mapCoordInSelfToDescendent(hotseat.getLayout(), mTempPt);
3235 
3236     xy[0] = mTempPt[0];
3237     xy[1] = mTempPt[1];
3238 }
3239 
3240 /*
3241  *
3242  * Convert the 2D coordinate xy from this CellLayout&#x27;s coordinate space to
3243  * the parent View&#x27;s coordinate space. The argument xy is modified with the return result.
3244  *
3245  */
3246 void mapPointFromChildToSelf(View v, float[] xy) {
3247     xy[0] += v.getLeft();
3248     xy[1] += v.getTop();
3249 }
3250 
3251 static private float squaredDistance(float[] point1, float[] point2) {
3252      float distanceX = point1[0] - point2[0];
3253      float distanceY = point2[1] - point2[1];
3254      return distanceX * distanceX + distanceY * distanceY;
3255 }
3256 
3257     /*
3258      *
3259      * This method returns the CellLayout that is currently being dragged to. In order to drag
3260      * to a CellLayout, either the touch point must be directly over the CellLayout, or as a second
3261      * strategy, we see if the dragView is overlapping any CellLayout and choose the closest one
3262      *
3263      * Return null if no CellLayout is currently being dragged over
3264      *
3265      */
3266     private CellLayout findMatchingPageForDragOver(
3267             DragView dragView, float originX, float originY, boolean exact) {
3268         // We loop through all the screens (ie CellLayouts) and see which ones overlap
3269         // with the item being dragged and then choose the one that&#x27;s closest to the touch point
3270         final int screenCount = getChildCount();
3271         CellLayout bestMatchingScreen = null;
3272         float smallestDistSoFar = Float.MAX_VALUE;
3273 
3274         for (int i = 0; i &lt; screenCount; i++) {
3275             // The custom content screen is not a valid drag over option
3276             if (mScreenOrder.get(i) == CUSTOM_CONTENT_SCREEN_ID) {
3277                 continue;
3278             }
3279 
3280             CellLayout cl = (CellLayout) getChildAt(i);
3281 
3282             final float[] touchXy = {originX, originY};
3283             // Transform the touch coordinates to the CellLayout&#x27;s local coordinates
3284             // If the touch point is within the bounds of the cell layout, we can return immediately
3285             cl.getMatrix().invert(mTempInverseMatrix);
3286             mapPointFromSelfToChild(cl, touchXy, mTempInverseMatrix);
3287 
3288             if (touchXy[0] &gt;= 0 &amp;&amp; touchXy[0] &lt;= cl.getWidth() &amp;&amp;
3289                     touchXy[1] &gt;= 0 &amp;&amp; touchXy[1] &lt;= cl.getHeight()) {
3290                 return cl;
3291             }
3292 
3293             if (!exact) {
3294                 // Get the center of the cell layout in screen coordinates
3295                 final float[] cellLayoutCenter = mTempCellLayoutCenterCoordinates;
3296                 cellLayoutCenter[0] = cl.getWidth()/2;
3297                 cellLayoutCenter[1] = cl.getHeight()/2;
3298                 mapPointFromChildToSelf(cl, cellLayoutCenter);
3299 
3300                 touchXy[0] = originX;
3301                 touchXy[1] = originY;
3302 
3303                 // Calculate the distance between the center of the CellLayout
3304                 // and the touch point
3305                 float dist = squaredDistance(touchXy, cellLayoutCenter);
3306 
3307                 if (dist &lt; smallestDistSoFar) {
3308                     smallestDistSoFar = dist;
3309                     bestMatchingScreen = cl;
3310                 }
3311             }
3312         }
3313         return bestMatchingScreen;
3314     }
3315 
3316     // This is used to compute the visual center of the dragView. This point is then
3317     // used to visualize drop locations and determine where to drop an item. The idea is that
3318     // the visual center represents the user&#x27;s interpretation of where the item is, and hence
3319     // is the appropriate point to use when determining drop location.
3320     private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
3321             DragView dragView, float[] recycle) {
3322         float res[];
3323         if (recycle == null) {
3324             res = new float[2];
3325         } else {
3326             res = recycle;
3327         }
3328 
3329         // First off, the drag view has been shifted in a way that is not represented in the
3330         // x and y values or the x/yOffsets. Here we account for that shift.
3331         x += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetX);
3332         y += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
3333 
3334         // These represent the visual top and left of drag view if a dragRect was provided.
3335         // If a dragRect was not provided, then they correspond to the actual view left and
3336         // top, as the dragRect is in that case taken to be the entire dragView.
3337         // R.dimen.dragViewOffsetY.
3338         int left = x - xOffset;
3339         int top = y - yOffset;
3340 
3341         // In order to find the visual center, we shift by half the dragRect
3342         res[0] = left + dragView.getDragRegion().width() / 2;
3343         res[1] = top + dragView.getDragRegion().height() / 2;
3344 
3345         return res;
3346     }
3347 
3348     private boolean isDragWidget(DragObject d) {
3349         return (d.dragInfo instanceof LauncherAppWidgetInfo ||
3350                 d.dragInfo instanceof PendingAddWidgetInfo);
3351     }
3352 
3353     private boolean isExternalDragWidget(DragObject d) {
3354         return d.dragSource != this &amp;&amp; isDragWidget(d);
3355     }
3356 
3357     public void onDragOver(DragObject d) {
3358         // Skip drag over events while we are dragging over side pages
3359         if (mInScrollArea || mIsSwitchingState || mState == State.SMALL) return;
3360 
3361         Rect r = new Rect();
3362         CellLayout layout = null;
3363         ItemInfo item = (ItemInfo) d.dragInfo;
3364 
3365         // Ensure that we have proper spans for the item that we are dropping
3366         if (item.spanX &lt; 0 || item.spanY &lt; 0) throw new RuntimeException(&quot;Improper spans found&quot;);
3367         mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
3368             d.dragView, mDragViewVisualCenter);
3369 
3370         final View child = (mDragInfo == null) ? null : mDragInfo.cell;
3371         // Identify whether we have dragged over a side page
3372         if (isSmall()) {
3373             if (mLauncher.getHotseat() != null &amp;&amp; !isExternalDragWidget(d)) {
3374                 if (isPointInSelfOverHotseat(d.x, d.y, r)) {
3375                     layout = mLauncher.getHotseat().getLayout();
3376                 }
3377             }
3378             if (layout == null) {
3379                 layout = findMatchingPageForDragOver(d.dragView, d.x, d.y, false);
3380             }
3381             if (layout != mDragTargetLayout) {
3382                 setCurrentDropLayout(layout);
3383                 setCurrentDragOverlappingLayout(layout);
3384 
3385                 boolean isInSpringLoadedMode = (mState == State.SPRING_LOADED);
3386                 if (isInSpringLoadedMode) {
3387                     if (mLauncher.isHotseatLayout(layout)) {
3388                         mSpringLoadedDragController.cancel();
3389                     } else {
3390                         mSpringLoadedDragController.setAlarm(mDragTargetLayout);
3391                     }
3392                 }
3393             }
3394         } else {
3395             // Test to see if we are over the hotseat otherwise just use the current page
3396             if (mLauncher.getHotseat() != null &amp;&amp; !isDragWidget(d)) {
3397                 if (isPointInSelfOverHotseat(d.x, d.y, r)) {
3398                     layout = mLauncher.getHotseat().getLayout();
3399                 }
3400             }
3401             if (layout == null) {
3402                 layout = getCurrentDropLayout();
3403             }
3404             if (layout != mDragTargetLayout) {
3405                 setCurrentDropLayout(layout);
3406                 setCurrentDragOverlappingLayout(layout);
3407             }
3408         }
3409 
3410         // Handle the drag over
3411         if (mDragTargetLayout != null) {
3412             // We want the point to be mapped to the dragTarget.
3413             if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
3414                 mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
3415             } else {
3416                 mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
3417             }
3418 
3419             ItemInfo info = (ItemInfo) d.dragInfo;
3420 
3421             int minSpanX = item.spanX;
3422             int minSpanY = item.spanY;
3423             if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
3424                 minSpanX = item.minSpanX;
3425                 minSpanY = item.minSpanY;
3426             }
3427 
3428             mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
3429                     (int) mDragViewVisualCenter[1], minSpanX, minSpanY,
3430                     mDragTargetLayout, mTargetCell);
3431             int reorderX = mTargetCell[0];
3432             int reorderY = mTargetCell[1];
3433 
3434             setCurrentDropOverCell(mTargetCell[0], mTargetCell[1]);
3435 
3436             float targetCellDistance = mDragTargetLayout.getDistanceFromCell(
3437                     mDragViewVisualCenter[0], mDragViewVisualCenter[1], mTargetCell);
3438 
3439             final View dragOverView = mDragTargetLayout.getChildAt(mTargetCell[0],
3440                     mTargetCell[1]);
3441 
3442             manageFolderFeedback(info, mDragTargetLayout, mTargetCell,
3443                     targetCellDistance, dragOverView);
3444 
3445             boolean nearestDropOccupied = mDragTargetLayout.isNearestDropLocationOccupied((int)
3446                     mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1], item.spanX,
3447                     item.spanY, child, mTargetCell);
3448 
3449             if (!nearestDropOccupied) {
3450                 mDragTargetLayout.visualizeDropLocation(child, mDragOutline,
3451                         (int) mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1],
3452                         mTargetCell[0], mTargetCell[1], item.spanX, item.spanY, false,
3453                         d.dragView.getDragVisualizeOffset(), d.dragView.getDragRegion());
3454             } else if ((mDragMode == DRAG_MODE_NONE || mDragMode == DRAG_MODE_REORDER)
3455                     &amp;&amp; !mReorderAlarm.alarmPending() &amp;&amp; (mLastReorderX != reorderX ||
3456                     mLastReorderY != reorderY)) {
3457 
3458                 // Otherwise, if we aren&#x27;t adding to or creating a folder and there&#x27;s no pending
3459                 // reorder, then we schedule a reorder
3460                 ReorderAlarmListener listener = new ReorderAlarmListener(mDragViewVisualCenter,
3461                         minSpanX, minSpanY, item.spanX, item.spanY, d.dragView, child);
3462                 mReorderAlarm.setOnAlarmListener(listener);
3463                 mReorderAlarm.setAlarm(REORDER_TIMEOUT);
3464             }
3465 
3466             if (mDragMode == DRAG_MODE_CREATE_FOLDER || mDragMode == DRAG_MODE_ADD_TO_FOLDER ||
3467                     !nearestDropOccupied) {
3468                 if (mDragTargetLayout != null) {
3469                     mDragTargetLayout.revertTempState();
3470                 }
3471             }
3472         }
3473     }
3474 
3475     private void manageFolderFeedback(ItemInfo info, CellLayout targetLayout,
3476             int[] targetCell, float distance, View dragOverView) {
3477         boolean userFolderPending = willCreateUserFolder(info, targetLayout, targetCell, distance,
3478                 false);
3479 
3480         if (mDragMode == DRAG_MODE_NONE &amp;&amp; userFolderPending &amp;&amp;
3481                 !mFolderCreationAlarm.alarmPending()) {
3482             mFolderCreationAlarm.setOnAlarmListener(new
3483                     FolderCreationAlarmListener(targetLayout, targetCell[0], targetCell[1]));
3484             mFolderCreationAlarm.setAlarm(FOLDER_CREATION_TIMEOUT);
3485             return;
3486         }
3487 
3488         boolean willAddToFolder =
3489                 willAddToExistingUserFolder(info, targetLayout, targetCell, distance);
3490 
3491         if (willAddToFolder &amp;&amp; mDragMode == DRAG_MODE_NONE) {
3492             mDragOverFolderIcon = ((FolderIcon) dragOverView);
3493             mDragOverFolderIcon.onDragEnter(info);
3494             if (targetLayout != null) {
3495                 targetLayout.clearDragOutlines();
3496             }
3497             setDragMode(DRAG_MODE_ADD_TO_FOLDER);
3498             return;
3499         }
3500 
3501         if (mDragMode == DRAG_MODE_ADD_TO_FOLDER &amp;&amp; !willAddToFolder) {
3502             setDragMode(DRAG_MODE_NONE);
3503         }
3504         if (mDragMode == DRAG_MODE_CREATE_FOLDER &amp;&amp; !userFolderPending) {
3505             setDragMode(DRAG_MODE_NONE);
3506         }
3507 
3508         return;
3509     }
3510 
3511     class FolderCreationAlarmListener implements OnAlarmListener {
3512         CellLayout layout;
3513 
3514         int cellX;
3515 
3516         int cellY;
3517 
3518         public FolderCreationAlarmListener(CellLayout layout, int cellX, int cellY) {
3519             this.layout = layout;
3520             this.cellX = cellX;
3521             this.cellY = cellY;
3522         }
3523 
3524         public void onAlarm(Alarm alarm) {
3525             if (mDragFolderRingAnimator != null) {
3526                 // This shouldn&#x27;t happen ever, but just in case, make sure we clean up the mess.
3527                 mDragFolderRingAnimator.animateToNaturalState();
3528             }
3529             mDragFolderRingAnimator = new FolderRingAnimator(mLauncher, null);
3530             mDragFolderRingAnimator.setCell(cellX, cellY);
3531             mDragFolderRingAnimator.setCellLayout(layout);
3532             mDragFolderRingAnimator.animateToAcceptState();
3533             layout.showFolderAccept(mDragFolderRingAnimator);
3534             layout.clearDragOutlines();
3535             setDragMode(DRAG_MODE_CREATE_FOLDER);
3536         }
3537     }
3538 
3539     class ReorderAlarmListener implements OnAlarmListener {
3540         float[] dragViewCenter;
3541 
3542         int minSpanX;
3543 
3544         int minSpanY;
3545 
3546         int spanX;
3547 
3548         int spanY;
3549 
3550         DragView dragView;
3551 
3552         View child;
3553 
<abbr title="3554         public ReorderAlarmListener(float[] dragViewCenter, int minSpanX, int minSpanY, int spanX, int spanY, DragView dragView, View child) {">3554         public ReorderAlarmListener(float[] dragViewCenter, int minSpanX, int minSpanY, int spanX, int sp🔵</abbr>
3555             this.dragViewCenter = dragViewCenter;
3556             this.minSpanX = minSpanX;
3557             this.minSpanY = minSpanY;
3558             this.spanX = spanX;
3559             this.spanY = spanY;
3560             this.child = child;
3561             this.dragView = dragView;
3562         }
3563 
3564         public void onAlarm(Alarm alarm) {
3565             int[] resultSpan = new int[2];
<abbr title="3566             mTargetCell = findNearestArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCenter[1])), minSpanX, minSpanY, mDragTargetLayout, mTargetCell);">3566             mTargetCell = findNearestArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCent🔵</abbr>
3567             mLastReorderX = mTargetCell[0];
3568             mLastReorderY = mTargetCell[1];
<abbr title="3569             mTargetCell = mDragTargetLayout.createArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCenter[1])), minSpanX, minSpanY, spanX, spanY, child, mTargetCell, resultSpan, CellLayout.MODE_DRAG_OVER);">3569             mTargetCell = mDragTargetLayout.createArea(((int) (mDragViewVisualCenter[0])), ((int) (mDragV🔵</abbr>
3570             if ((mTargetCell[0] &lt; 0) || (mTargetCell[1] &lt; 0)) {
3571                 mDragTargetLayout.revertTempState();
3572             } else {
3573                 setDragMode(DRAG_MODE_REORDER);
3574             }
3575             boolean resize = (resultSpan[0] != spanX) || (resultSpan[1] != spanY);
<abbr title="3576             mDragTargetLayout.visualizeDropLocation(child, mDragOutline, ((int) (mDragViewVisualCenter[0])), ((int) (mDragViewVisualCenter[1])), mTargetCell[0], mTargetCell[1], resultSpan[0], resultSpan[1], resize, dragView.getDragVisualizeOffset(), dragView.getDragRegion());">3576             mDragTargetLayout.visualizeDropLocation(child, mDragOutline, ((int) (mDragViewVisualCenter[0]🔵</abbr>
3577         }
3578     }
3579 
3580     @Override
3581     public void getHitRectRelativeToDragLayer(Rect outRect) {
3582         // We want the workspace to have the whole area of the display (it will find the correct
3583         // cell layout to drop to in the existing drag/drop logic.
3584         mLauncher.getDragLayer().getDescendantRectRelativeToSelf(this, outRect);
3585     }
3586 
3587     /**
3588      * Add the item specified by dragInfo to the given layout.
3589      * @return true if successful
3590      */
3591     public boolean addExternalItemToScreen(ItemInfo dragInfo, CellLayout layout) {
3592         if (layout.findCellForSpan(mTempEstimate, dragInfo.spanX, dragInfo.spanY)) {
3593             onDropExternal(dragInfo.dropPos, (ItemInfo) dragInfo, (CellLayout) layout, false);
3594             return true;
3595         }
3596         mLauncher.showOutOfSpaceMessage(mLauncher.isHotseatLayout(layout));
3597         return false;
3598     }
3599 
3600     private void onDropExternal(int[] touchXY, Object dragInfo,
3601             CellLayout cellLayout, boolean insertAtFirst) {
3602         onDropExternal(touchXY, dragInfo, cellLayout, insertAtFirst, null);
3603     }
3604 
3605     /**
3606      * Drop an item that didn&#x27;t originate on one of the workspace screens.
3607      * It may have come from Launcher (e.g. from all apps or customize), or it may have
3608      * come from another app altogether.
3609      *
3610      * NOTE: This can also be called when we are outside of a drag event, when we want
3611      * to add an item to one of the workspace screens.
3612      */
3613     private void onDropExternal(final int[] touchXY, final Object dragInfo,
3614             final CellLayout cellLayout, boolean insertAtFirst, DragObject d) {
3615         final Runnable exitSpringLoadedRunnable = new Runnable() {
3616             @Override
3617             public void run() {
3618                 removeExtraEmptyScreen(false, new Runnable() {
3619                     @Override
3620                     public void run() {
3621                         mLauncher.exitSpringLoadedDragModeDelayed(true,
3622                                 Launcher.EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
3623                     }
3624                 });
3625             }
3626         };
3627 
3628         ItemInfo info = (ItemInfo) dragInfo;
3629         int spanX = info.spanX;
3630         int spanY = info.spanY;
3631         if (mDragInfo != null) {
3632             spanX = mDragInfo.spanX;
3633             spanY = mDragInfo.spanY;
3634         }
3635 
3636         final long container = mLauncher.isHotseatLayout(cellLayout) ?
3637                 LauncherSettings.Favorites.CONTAINER_HOTSEAT :
3638                     LauncherSettings.Favorites.CONTAINER_DESKTOP;
3639         final long screenId = getIdForScreen(cellLayout);
3640         if (!mLauncher.isHotseatLayout(cellLayout)
3641                 &amp;&amp; screenId != getScreenIdForPageIndex(mCurrentPage)
3642                 &amp;&amp; mState != State.SPRING_LOADED) {
3643             snapToScreenId(screenId, null);
3644         }
3645 
3646         if (info instanceof PendingAddItemInfo) {
3647             final PendingAddItemInfo pendingInfo = (PendingAddItemInfo) dragInfo;
3648 
3649             boolean findNearestVacantCell = true;
3650             if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) {
3651                 mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3652                         cellLayout, mTargetCell);
3653                 float distance = cellLayout.getDistanceFromCell(mDragViewVisualCenter[0],
3654                         mDragViewVisualCenter[1], mTargetCell);
3655                 if (willCreateUserFolder((ItemInfo) d.dragInfo, cellLayout, mTargetCell,
3656                         distance, true) || willAddToExistingUserFolder((ItemInfo) d.dragInfo,
3657                                 cellLayout, mTargetCell, distance)) {
3658                     findNearestVacantCell = false;
3659                 }
3660             }
3661 
3662             final ItemInfo item = (ItemInfo) d.dragInfo;
3663             boolean updateWidgetSize = false;
3664             if (findNearestVacantCell) {
3665                 int minSpanX = item.spanX;
3666                 int minSpanY = item.spanY;
3667                 if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
3668                     minSpanX = item.minSpanX;
3669                     minSpanY = item.minSpanY;
3670                 }
3671                 int[] resultSpan = new int[2];
3672                 mTargetCell = cellLayout.createArea((int) mDragViewVisualCenter[0],
3673                         (int) mDragViewVisualCenter[1], minSpanX, minSpanY, info.spanX, info.spanY,
3674                         null, mTargetCell, resultSpan, CellLayout.MODE_ON_DROP_EXTERNAL);
3675 
3676                 if (resultSpan[0] != item.spanX || resultSpan[1] != item.spanY) {
3677                     updateWidgetSize = true;
3678                 }
3679                 item.spanX = resultSpan[0];
3680                 item.spanY = resultSpan[1];
3681             }
3682 
3683             Runnable onAnimationCompleteRunnable = new Runnable() {
3684                 @Override
3685                 public void run() {
3686                     // When dragging and dropping from customization tray, we deal with creating
3687                     // widgets/shortcuts/folders in a slightly different way
3688                     switch (pendingInfo.itemType) {
3689                     case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
3690                         int span[] = new int[2];
3691                         span[0] = item.spanX;
3692                         span[1] = item.spanY;
3693                         mLauncher.addAppWidgetFromDrop((PendingAddWidgetInfo) pendingInfo,
3694                                 container, screenId, mTargetCell, span, null);
3695                         break;
3696                     case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3697                         mLauncher.processShortcutFromDrop(pendingInfo.componentName,
3698                                 container, screenId, mTargetCell, null);
3699                         break;
3700                     default:
3701                         throw new IllegalStateException(&quot;Unknown item type: &quot; +
3702                                 pendingInfo.itemType);
3703                     }
3704                 }
3705             };
3706             View finalView = pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET
3707                     ? ((PendingAddWidgetInfo) pendingInfo).boundWidget : null;
3708 
3709             if (finalView instanceof AppWidgetHostView &amp;&amp; updateWidgetSize) {
3710                 AppWidgetHostView awhv = (AppWidgetHostView) finalView;
3711                 AppWidgetResizeFrame.updateWidgetSizeRanges(awhv, mLauncher, item.spanX,
3712                         item.spanY);
3713             }
3714 
3715             int animationStyle = ANIMATE_INTO_POSITION_AND_DISAPPEAR;
3716             if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;
3717                     ((PendingAddWidgetInfo) pendingInfo).info.configure != null) {
3718                 animationStyle = ANIMATE_INTO_POSITION_AND_REMAIN;
3719             }
3720             animateWidgetDrop(info, cellLayout, d.dragView, onAnimationCompleteRunnable,
3721                     animationStyle, finalView, true);
3722         } else {
3723             // This is for other drag/drop cases, like dragging from All Apps
3724             View view = null;
3725 
3726             switch (info.itemType) {
3727             case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
3728             case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3729                 if (info.container == NO_ID &amp;&amp; info instanceof AppInfo) {
3730                     // Came from all apps -- make a copy
3731                     info = new ShortcutInfo((AppInfo) info);
3732                 }
3733                 view = mLauncher.createShortcut(R.layout.application, cellLayout,
3734                         (ShortcutInfo) info);
3735                 break;
3736             case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
3737                 view = FolderIcon.fromXml(R.layout.folder_icon, mLauncher, cellLayout,
3738                         (FolderInfo) info, mIconCache);
3739                 break;
3740             default:
3741                 throw new IllegalStateException(&quot;Unknown item type: &quot; + info.itemType);
3742             }
3743 
3744             // First we find the cell nearest to point at which the item is
3745             // dropped, without any consideration to whether there is an item there.
3746             if (touchXY != null) {
3747                 mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3748                         cellLayout, mTargetCell);
3749                 float distance = cellLayout.getDistanceFromCell(mDragViewVisualCenter[0],
3750                         mDragViewVisualCenter[1], mTargetCell);
3751                 d.postAnimationRunnable = exitSpringLoadedRunnable;
3752                 if (createUserFolderIfNecessary(view, container, cellLayout, mTargetCell, distance,
3753                         true, d.dragView, d.postAnimationRunnable)) {
3754                     return;
3755                 }
3756                 if (addToExistingFolderIfNecessary(view, cellLayout, mTargetCell, distance, d,
3757                         true)) {
3758                     return;
3759                 }
3760             }
3761 
3762             if (touchXY != null) {
3763                 // when dragging and dropping, just find the closest free spot
3764                 mTargetCell = cellLayout.createArea((int) mDragViewVisualCenter[0],
3765                         (int) mDragViewVisualCenter[1], 1, 1, 1, 1,
3766                         null, mTargetCell, null, CellLayout.MODE_ON_DROP_EXTERNAL);
3767             } else {
3768                 cellLayout.findCellForSpan(mTargetCell, 1, 1);
3769             }
3770             addInScreen(view, container, screenId, mTargetCell[0], mTargetCell[1], info.spanX,
3771                     info.spanY, insertAtFirst);
3772             cellLayout.onDropChild(view);
3773             CellLayout.LayoutParams lp = (CellLayout.LayoutParams) view.getLayoutParams();
3774             cellLayout.getShortcutsAndWidgets().measureChild(view);
3775 
3776             LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screenId,
3777                     lp.cellX, lp.cellY);
3778 
3779             if (d.dragView != null) {
3780                 // We wrap the animation call in the temporary set and reset of the current
3781                 // cellLayout to its final transform -- this means we animate the drag view to
3782                 // the correct final location.
3783                 setFinalTransitionTransform(cellLayout);
3784                 mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, view,
3785                         exitSpringLoadedRunnable, this);
3786                 resetTransitionTransform(cellLayout);
3787             }
3788         }
3789     }
3790 
3791     public Bitmap createWidgetBitmap(ItemInfo widgetInfo, View layout) {
3792         int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(widgetInfo.spanX,
3793                 widgetInfo.spanY, widgetInfo, false);
3794         int visibility = layout.getVisibility();
3795         layout.setVisibility(VISIBLE);
3796 
3797         int width = MeasureSpec.makeMeasureSpec(unScaledSize[0], MeasureSpec.EXACTLY);
3798         int height = MeasureSpec.makeMeasureSpec(unScaledSize[1], MeasureSpec.EXACTLY);
3799         Bitmap b = Bitmap.createBitmap(unScaledSize[0], unScaledSize[1],
3800                 Bitmap.Config.ARGB_8888);
3801         Canvas c = new Canvas(b);
3802 
3803         layout.measure(width, height);
3804         layout.layout(0, 0, unScaledSize[0], unScaledSize[1]);
3805         layout.draw(c);
3806         c.setBitmap(null);
3807         layout.setVisibility(visibility);
3808         return b;
3809     }
3810 
3811     private void getFinalPositionForDropAnimation(int[] loc, float[] scaleXY,
3812             DragView dragView, CellLayout layout, ItemInfo info, int[] targetCell,
3813             boolean external, boolean scale) {
3814         // Now we animate the dragView, (ie. the widget or shortcut preview) into its final
3815         // location and size on the home screen.
3816         int spanX = info.spanX;
3817         int spanY = info.spanY;
3818 
3819         Rect r = estimateItemPosition(layout, info, targetCell[0], targetCell[1], spanX, spanY);
3820         loc[0] = r.left;
3821         loc[1] = r.top;
3822 
3823         setFinalTransitionTransform(layout);
3824         float cellLayoutScale =
3825                 mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(layout, loc, true);
3826         resetTransitionTransform(layout);
3827 
3828         float dragViewScaleX;
3829         float dragViewScaleY;
3830         if (scale) {
3831             dragViewScaleX = (1.0f * r.width()) / dragView.getMeasuredWidth();
3832             dragViewScaleY = (1.0f * r.height()) / dragView.getMeasuredHeight();
3833         } else {
3834             dragViewScaleX = 1f;
3835             dragViewScaleY = 1f;
3836         }
3837 
3838         // The animation will scale the dragView about its center, so we need to center about
3839         // the final location.
3840         loc[0] -= (dragView.getMeasuredWidth() - cellLayoutScale * r.width()) / 2;
3841         loc[1] -= (dragView.getMeasuredHeight() - cellLayoutScale * r.height()) / 2;
3842 
3843         scaleXY[0] = dragViewScaleX * cellLayoutScale;
3844         scaleXY[1] = dragViewScaleY * cellLayoutScale;
3845     }
3846 
3847     public void animateWidgetDrop(ItemInfo info, CellLayout cellLayout, DragView dragView,
3848             final Runnable onCompleteRunnable, int animationType, final View finalView,
3849             boolean external) {
3850         Rect from = new Rect();
3851         mLauncher.getDragLayer().getViewRectRelativeToSelf(dragView, from);
3852 
3853         int[] finalPos = new int[2];
3854         float scaleXY[] = new float[2];
3855         boolean scalePreview = !(info instanceof PendingAddShortcutInfo);
3856         getFinalPositionForDropAnimation(finalPos, scaleXY, dragView, cellLayout, info, mTargetCell,
3857                 external, scalePreview);
3858 
3859         Resources res = mLauncher.getResources();
3860         final int duration = res.getInteger(R.integer.config_dropAnimMaxDuration) - 200;
3861 
3862         // In the case where we&#x27;ve prebound the widget, we remove it from the DragLayer
3863         if (finalView instanceof AppWidgetHostView &amp;&amp; external) {
3864             Log.d(TAG, &quot;6557954 Animate widget drop, final view is appWidgetHostView&quot;);
3865             mLauncher.getDragLayer().removeView(finalView);
3866         }
3867         if ((animationType == ANIMATE_INTO_POSITION_AND_RESIZE || external) &amp;&amp; finalView != null) {
3868             Bitmap crossFadeBitmap = createWidgetBitmap(info, finalView);
3869             dragView.setCrossFadeBitmap(crossFadeBitmap);
3870             dragView.crossFade((int) (duration * 0.8f));
3871         } else if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp; external) {
3872             scaleXY[0] = scaleXY[1] = Math.min(scaleXY[0],  scaleXY[1]);
3873         }
3874 
3875         DragLayer dragLayer = mLauncher.getDragLayer();
3876         if (animationType == CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION) {
3877             mLauncher.getDragLayer().animateViewIntoPosition(dragView, finalPos, 0f, 0.1f, 0.1f,
3878                     DragLayer.ANIMATION_END_DISAPPEAR, onCompleteRunnable, duration);
3879         } else {
3880             int endStyle;
3881             if (animationType == ANIMATE_INTO_POSITION_AND_REMAIN) {
3882                 endStyle = DragLayer.ANIMATION_END_REMAIN_VISIBLE;
3883             } else {
3884                 endStyle = DragLayer.ANIMATION_END_DISAPPEAR;;
3885             }
3886 
3887             Runnable onComplete = new Runnable() {
3888                 @Override
3889                 public void run() {
3890                     if (finalView != null) {
3891                         finalView.setVisibility(VISIBLE);
3892                     }
3893                     if (onCompleteRunnable != null) {
3894                         onCompleteRunnable.run();
3895                     }
3896                 }
3897             };
3898             dragLayer.animateViewIntoPosition(dragView, from.left, from.top, finalPos[0],
3899                     finalPos[1], 1, 1, 1, scaleXY[0], scaleXY[1], onComplete, endStyle,
3900                     duration, this);
3901         }
3902     }
3903 
3904     public void setFinalTransitionTransform(CellLayout layout) {
3905         if (isSwitchingState()) {
3906             mCurrentScale = getScaleX();
3907             setScaleX(mNewScale);
3908             setScaleY(mNewScale);
3909         }
3910     }
3911 
3912     public void resetTransitionTransform(CellLayout layout) {
3913         if (isSwitchingState()) {
3914             setScaleX(mCurrentScale);
3915             setScaleY(mCurrentScale);
3916         }
3917     }
3918 
3919     /**
3920      * Return the current {@link CellLayout}, correctly picking the destination
3921      * screen while a scroll is in progress.
3922      */
3923     public CellLayout getCurrentDropLayout() {
3924         return (CellLayout) getChildAt(getNextPage());
3925     }
3926 
3927     /**
3928      * Return the current CellInfo describing our current drag; this method exists
3929      * so that Launcher can sync this object with the correct info when the activity is created/
3930      * destroyed
3931      *
3932      */
3933     public CellLayout.CellInfo getDragInfo() {
3934         return mDragInfo;
3935     }
3936 
3937     public int getRestorePage() {
3938         return getNextPage() - numCustomPages();
3939     }
3940 
3941     /**
3942      * Calculate the nearest cell where the given object would be dropped.
3943      *
3944      * pixelX and pixelY should be in the coordinate system of layout
3945      */
3946     private int[] findNearestArea(int pixelX, int pixelY,
3947             int spanX, int spanY, CellLayout layout, int[] recycle) {
3948         return layout.findNearestArea(
3949                 pixelX, pixelY, spanX, spanY, recycle);
3950     }
3951 
3952     void setup(DragController dragController) {
3953         mSpringLoadedDragController = new SpringLoadedDragController(mLauncher);
3954         mDragController = dragController;
3955 
3956         // hardware layers on children are enabled on startup, but should be disabled until
3957         // needed
3958         updateChildrenLayersEnabled(false);
3959         setWallpaperDimension();
3960     }
3961 
3962     /**
3963      * Called at the end of a drag which originated on the workspace.
3964      */
3965     public void onDropCompleted(final View target, final DragObject d,
3966             final boolean isFlingToDelete, final boolean success) {
3967         if (mDeferDropAfterUninstall) {
3968             mDeferredAction = new Runnable() {
3969                 public void run() {
3970                     onDropCompleted(target, d, isFlingToDelete, success);
3971                     mDeferredAction = null;
3972                 }
3973             };
3974             return;
3975         }
3976 
3977         boolean beingCalledAfterUninstall = mDeferredAction != null;
3978 
3979         if (success &amp;&amp; !(beingCalledAfterUninstall &amp;&amp; !mUninstallSuccessful)) {
3980             if (target != this &amp;&amp; mDragInfo != null) {
3981                 CellLayout parentCell = getParentCellLayoutForView(mDragInfo.cell);
3982                 if (parentCell != null) {
3983                     parentCell.removeView(mDragInfo.cell);
3984                 }
3985                 if (mDragInfo.cell instanceof DropTarget) {
3986                     mDragController.removeDropTarget((DropTarget) mDragInfo.cell);
3987                 }
3988                 // If we move the item to anything not on the Workspace, check if any empty
3989                 // screens need to be removed. If we dropped back on the workspace, this will
3990                 // be done post drop animation.
3991                 removeExtraEmptyScreen(true, null, 0, true);
3992             }
3993         } else if (mDragInfo != null) {
3994             CellLayout cellLayout;
3995             if (mLauncher.isHotseatLayout(target)) {
3996                 cellLayout = mLauncher.getHotseat().getLayout();
3997             } else {
3998                 cellLayout = getScreenWithId(mDragInfo.screenId);
3999             }
4000             cellLayout.onDropChild(mDragInfo.cell);
4001         }
4002         if ((d.cancelled || (beingCalledAfterUninstall &amp;&amp; !mUninstallSuccessful))
4003                 &amp;&amp; mDragInfo.cell != null) {
4004             mDragInfo.cell.setVisibility(VISIBLE);
4005         }
4006         mDragOutline = null;
4007         mDragInfo = null;
4008     }
4009 
4010     public void deferCompleteDropAfterUninstallActivity() {
4011         mDeferDropAfterUninstall = true;
4012     }
4013 
4014     /// maybe move this into a smaller part
4015     public void onUninstallActivityReturned(boolean success) {
4016         mDeferDropAfterUninstall = false;
4017         mUninstallSuccessful = success;
4018         if (mDeferredAction != null) {
4019             mDeferredAction.run();
4020         }
4021     }
4022 
4023     void updateItemLocationsInDatabase(CellLayout cl) {
4024         int count = cl.getShortcutsAndWidgets().getChildCount();
4025 
4026         long screenId = getIdForScreen(cl);
4027         int container = Favorites.CONTAINER_DESKTOP;
4028 
4029         if (mLauncher.isHotseatLayout(cl)) {
4030             screenId = -1;
4031             container = Favorites.CONTAINER_HOTSEAT;
4032         }
4033 
4034         for (int i = 0; i &lt; count; i++) {
4035             View v = cl.getShortcutsAndWidgets().getChildAt(i);
4036             ItemInfo info = (ItemInfo) v.getTag();
4037             // Null check required as the AllApps button doesn&#x27;t have an item info
4038             if (info != null &amp;&amp; info.requiresDbUpdate) {
4039                 info.requiresDbUpdate = false;
4040                 LauncherModel.modifyItemInDatabase(mLauncher, info, container, screenId, info.cellX,
4041                         info.cellY, info.spanX, info.spanY);
4042             }
4043         }
4044     }
4045 
<abbr title="4046     ArrayList&lt;ComponentName&gt; getUniqueComponents(boolean stripDuplicates, ArrayList&lt;ComponentName&gt; duplicates) {">4046     ArrayList&lt;ComponentName&gt; getUniqueComponents(boolean stripDuplicates, ArrayList&lt;ComponentName&gt; duplic🔵</abbr>
4047         ArrayList&lt;ComponentName&gt; uniqueIntents = new ArrayList&lt;ComponentName&gt;();
<abbr title="4048         getUniqueIntents((CellLayout) mLauncher.getHotseat().getLayout(), uniqueIntents, duplicates, false);">4048         getUniqueIntents((CellLayout) mLauncher.getHotseat().getLayout(), uniqueIntents, duplicates, fals🔵</abbr>
4049         int count = getChildCount();
4050         for (int i = 0; i &lt; count; i++) {
4051             CellLayout cl = (CellLayout) getChildAt(i);
4052             getUniqueIntents(cl, uniqueIntents, duplicates, false);
4053         }
4054         return uniqueIntents;
4055     }
4056 
4057     void getUniqueIntents(CellLayout cl, ArrayList&lt;ComponentName&gt; uniqueIntents,
4058             ArrayList&lt;ComponentName&gt; duplicates, boolean stripDuplicates) {
4059         int count = cl.getShortcutsAndWidgets().getChildCount();
4060 
4061         ArrayList&lt;View&gt; children = new ArrayList&lt;View&gt;();
4062         for (int i = 0; i &lt; count; i++) {
4063             View v = cl.getShortcutsAndWidgets().getChildAt(i);
4064             children.add(v);
4065         }
4066 
4067         for (int i = 0; i &lt; count; i++) {
4068             View v = children.get(i);
4069             ItemInfo info = (ItemInfo) v.getTag();
4070             // Null check required as the AllApps button doesn&#x27;t have an item info
4071             if (info instanceof ShortcutInfo) {
4072                 ShortcutInfo si = (ShortcutInfo) info;
4073                 ComponentName cn = si.intent.getComponent();
4074 
4075                 Uri dataUri = si.intent.getData();
4076                 // If dataUri is not null / empty or if this component isn&#x27;t one that would
4077                 // have previously showed up in the AllApps list, then this is a widget-type
4078                 // shortcut, so ignore it.
4079                 if (dataUri != null &amp;&amp; !dataUri.equals(Uri.EMPTY)) {
4080                     continue;
4081                 }
4082 
4083                 if (!uniqueIntents.contains(cn)) {
4084                     uniqueIntents.add(cn);
4085                 } else {
4086                     if (stripDuplicates) {
4087                         cl.removeViewInLayout(v);
4088                         LauncherModel.deleteItemFromDatabase(mLauncher, si);
4089                     }
4090                     if (duplicates != null) {
4091                         duplicates.add(cn);
4092                     }
4093                 }
4094             }
4095             if (v instanceof FolderIcon) {
4096                 FolderIcon fi = (FolderIcon) v;
4097                 ArrayList&lt;View&gt; items = fi.getFolder().getItemsInReadingOrder();
4098                 for (int j = 0; j &lt; items.size(); j++) {
4099                     if (items.get(j).getTag() instanceof ShortcutInfo) {
4100                         ShortcutInfo si = (ShortcutInfo) items.get(j).getTag();
4101                         ComponentName cn = si.intent.getComponent();
4102 
4103                         Uri dataUri = si.intent.getData();
4104                         // If dataUri is not null / empty or if this component isn&#x27;t one that would
4105                         // have previously showed up in the AllApps list, then this is a widget-type
4106                         // shortcut, so ignore it.
4107                         if (dataUri != null &amp;&amp; !dataUri.equals(Uri.EMPTY)) {
4108                             continue;
4109                         }
4110 
4111                         if (!uniqueIntents.contains(cn)) {
4112                             uniqueIntents.add(cn);
4113                         }  else {
4114                             if (stripDuplicates) {
4115                                 fi.getFolderInfo().remove(si);
4116                                 LauncherModel.deleteItemFromDatabase(mLauncher, si);
4117                             }
4118                             if (duplicates != null) {
4119                                 duplicates.add(cn);
4120                             }
4121                         }
4122                     }
4123                 }
4124             }
4125         }
4126     }
4127 
4128     void saveWorkspaceToDb() {
4129         saveWorkspaceScreenToDb((CellLayout) mLauncher.getHotseat().getLayout());
4130         int count = getChildCount();
4131         for (int i = 0; i &lt; count; i++) {
4132             CellLayout cl = (CellLayout) getChildAt(i);
4133             saveWorkspaceScreenToDb(cl);
4134         }
4135     }
4136 
4137     void saveWorkspaceScreenToDb(CellLayout cl) {
4138         int count = cl.getShortcutsAndWidgets().getChildCount();
4139 
4140         long screenId = getIdForScreen(cl);
4141         int container = Favorites.CONTAINER_DESKTOP;
4142 
4143         Hotseat hotseat = mLauncher.getHotseat();
4144         if (mLauncher.isHotseatLayout(cl)) {
4145             screenId = -1;
4146             container = Favorites.CONTAINER_HOTSEAT;
4147         }
4148 
4149         for (int i = 0; i &lt; count; i++) {
4150             View v = cl.getShortcutsAndWidgets().getChildAt(i);
4151             ItemInfo info = (ItemInfo) v.getTag();
4152             // Null check required as the AllApps button doesn&#x27;t have an item info
4153             if (info != null) {
4154                 int cellX = info.cellX;
4155                 int cellY = info.cellY;
4156                 if (container == Favorites.CONTAINER_HOTSEAT) {
4157                     cellX = hotseat.getCellXFromOrder((int) info.screenId);
4158                     cellY = hotseat.getCellYFromOrder((int) info.screenId);
4159                 }
4160                 LauncherModel.addItemToDatabase(mLauncher, info, container, screenId, cellX,
4161                         cellY, false);
4162             }
4163             if (v instanceof FolderIcon) {
4164                 FolderIcon fi = (FolderIcon) v;
4165                 fi.getFolder().addItemLocationsInDatabase();
4166             }
4167         }
4168     }
4169 
4170     @Override
4171     public float getIntrinsicIconScaleFactor() {
4172         return 1f;
4173     }
4174 
4175     @Override
4176     public boolean supportsFlingToDelete() {
4177         return true;
4178     }
4179 
4180     @Override
4181     public void onFlingToDelete(DragObject d, int x, int y, PointF vec) {
4182         // Do nothing
4183     }
4184 
4185     @Override
4186     public void onFlingToDeleteCompleted() {
4187         // Do nothing
4188     }
4189 
4190     public boolean isDropEnabled() {
4191         return true;
4192     }
4193 
4194     @Override
4195     protected void onRestoreInstanceState(Parcelable state) {
4196         super.onRestoreInstanceState(state);
4197         Launcher.setScreen(mCurrentPage);
4198     }
4199 
4200     @Override
4201     protected void dispatchRestoreInstanceState(SparseArray&lt;Parcelable&gt; container) {
4202         // We don&#x27;t dispatch restoreInstanceState to our children using this code path.
4203         // Some pages will be restored immediately as their items are bound immediately, and
4204         // others we will need to wait until after their items are bound.
4205         mSavedStates = container;
4206     }
4207 
4208     public void restoreInstanceStateForChild(int child) {
4209         if (mSavedStates != null) {
4210             mRestoredPages.add(child);
4211             CellLayout cl = (CellLayout) getChildAt(child);
4212             cl.restoreInstanceState(mSavedStates);
4213         }
4214     }
4215 
4216     public void restoreInstanceStateForRemainingPages() {
4217         int count = getChildCount();
4218         for (int i = 0; i &lt; count; i++) {
4219             if (!mRestoredPages.contains(i)) {
4220                 restoreInstanceStateForChild(i);
4221             }
4222         }
4223         mRestoredPages.clear();
4224         mSavedStates = null;
4225     }
4226 
4227     @Override
4228     public void scrollLeft() {
4229         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
4230             super.scrollLeft();
4231         }
4232         Folder openFolder = getOpenFolder();
4233         if (openFolder != null) {
4234             openFolder.completeDragExit();
4235         }
4236     }
4237 
4238     @Override
4239     public void scrollRight() {
4240         if (!isSmall() &amp;&amp; !mIsSwitchingState) {
4241             super.scrollRight();
4242         }
4243         Folder openFolder = getOpenFolder();
4244         if (openFolder != null) {
4245             openFolder.completeDragExit();
4246         }
4247     }
4248 
4249     @Override
4250     public boolean onEnterScrollArea(int x, int y, int direction) {
4251         // Ignore the scroll area if we are dragging over the hot seat
4252         boolean isPortrait = !LauncherAppState.isScreenLandscape(getContext());
4253         if (mLauncher.getHotseat() != null &amp;&amp; isPortrait) {
4254             Rect r = new Rect();
4255             mLauncher.getHotseat().getHitRect(r);
4256             if (r.contains(x, y)) {
4257                 return false;
4258             }
4259         }
4260 
4261         boolean result = false;
4262         if (!isSmall() &amp;&amp; !mIsSwitchingState &amp;&amp; getOpenFolder() == null) {
4263             mInScrollArea = true;
4264 
4265             final int page = getNextPage() +
4266                        (direction == DragController.SCROLL_LEFT ? -1 : 1);
4267             // We always want to exit the current layout to ensure parity of enter / exit
4268             setCurrentDropLayout(null);
4269 
4270             if (0 &lt;= page &amp;&amp; page &lt; getChildCount()) {
4271                 // Ensure that we are not dragging over to the custom content screen
4272                 if (getScreenIdForPageIndex(page) == CUSTOM_CONTENT_SCREEN_ID) {
4273                     return false;
4274                 }
4275 
4276                 CellLayout layout = (CellLayout) getChildAt(page);
4277                 setCurrentDragOverlappingLayout(layout);
4278 
4279                 // Workspace is responsible for drawing the edge glow on adjacent pages,
4280                 // so we need to redraw the workspace when this may have changed.
4281                 invalidate();
4282                 result = true;
4283             }
4284         }
4285         return result;
4286     }
4287 
4288     @Override
4289     public boolean onExitScrollArea() {
4290         boolean result = false;
4291         if (mInScrollArea) {
4292             invalidate();
4293             CellLayout layout = getCurrentDropLayout();
4294             setCurrentDropLayout(layout);
4295             setCurrentDragOverlappingLayout(layout);
4296 
4297             result = true;
4298             mInScrollArea = false;
4299         }
4300         return result;
4301     }
4302 
4303     private void onResetScrollArea() {
4304         setCurrentDragOverlappingLayout(null);
4305         mInScrollArea = false;
4306     }
4307 
4308     /**
4309      * Returns a specific CellLayout
4310      */
4311     CellLayout getParentCellLayoutForView(View v) {
4312         ArrayList&lt;CellLayout&gt; layouts = getWorkspaceAndHotseatCellLayouts();
4313         for (CellLayout layout : layouts) {
4314             if (layout.getShortcutsAndWidgets().indexOfChild(v) &gt; -1) {
4315                 return layout;
4316             }
4317         }
4318         return null;
4319     }
4320 
4321     /**
4322      * Returns a list of all the CellLayouts in the workspace.
4323      */
4324     ArrayList&lt;CellLayout&gt; getWorkspaceAndHotseatCellLayouts() {
4325         ArrayList&lt;CellLayout&gt; layouts = new ArrayList&lt;CellLayout&gt;();
4326         int screenCount = getChildCount();
4327         for (int screen = 0; screen &lt; screenCount; screen++) {
4328             layouts.add(((CellLayout) getChildAt(screen)));
4329         }
4330         if (mLauncher.getHotseat() != null) {
4331             layouts.add(mLauncher.getHotseat().getLayout());
4332         }
4333         return layouts;
4334     }
4335 
4336     /**
4337      * We should only use this to search for specific children.  Do not use this method to modify
4338      * ShortcutsAndWidgetsContainer directly. Includes ShortcutAndWidgetContainers from
4339      * the hotseat and workspace pages
4340      */
4341     ArrayList&lt;ShortcutAndWidgetContainer&gt; getAllShortcutAndWidgetContainers() {
4342         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4343                 new ArrayList&lt;ShortcutAndWidgetContainer&gt;();
4344         int screenCount = getChildCount();
4345         for (int screen = 0; screen &lt; screenCount; screen++) {
4346             childrenLayouts.add(((CellLayout) getChildAt(screen)).getShortcutsAndWidgets());
4347         }
4348         if (mLauncher.getHotseat() != null) {
4349             childrenLayouts.add(mLauncher.getHotseat().getLayout().getShortcutsAndWidgets());
4350         }
4351         return childrenLayouts;
4352     }
4353 
4354     public Folder getFolderForTag(Object tag) {
4355         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4356                 getAllShortcutAndWidgetContainers();
4357         for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4358             int count = layout.getChildCount();
4359             for (int i = 0; i &lt; count; i++) {
4360                 View child = layout.getChildAt(i);
4361                 if (child instanceof Folder) {
4362                     Folder f = (Folder) child;
4363                     if (f.getInfo() == tag &amp;&amp; f.getInfo().opened) {
4364                         return f;
4365                     }
4366                 }
4367             }
4368         }
4369         return null;
4370     }
4371 
4372     public View getViewForTag(Object tag) {
4373         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4374                 getAllShortcutAndWidgetContainers();
4375         for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4376             int count = layout.getChildCount();
4377             for (int i = 0; i &lt; count; i++) {
4378                 View child = layout.getChildAt(i);
4379                 if (child.getTag() == tag) {
4380                     return child;
4381                 }
4382             }
4383         }
4384         return null;
4385     }
4386 
4387     void clearDropTargets() {
4388         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4389                 getAllShortcutAndWidgetContainers();
4390         for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4391             int childCount = layout.getChildCount();
4392             for (int j = 0; j &lt; childCount; j++) {
4393                 View v = layout.getChildAt(j);
4394                 if (v instanceof DropTarget) {
4395                     mDragController.removeDropTarget((DropTarget) v);
4396                 }
4397             }
4398         }
4399     }
4400 
4401     // Removes ALL items that match a given package name, this is usually called when a package
4402     // has been removed and we want to remove all components (widgets, shortcuts, apps) that
4403     // belong to that package.
4404     void removeItemsByPackageName(final ArrayList&lt;String&gt; packages) {
4405         final HashSet&lt;String&gt; packageNames = new HashSet&lt;String&gt;();
4406         packageNames.addAll(packages);
4407 
4408         // Filter out all the ItemInfos that this is going to affect
4409         final HashSet&lt;ItemInfo&gt; infos = new HashSet&lt;ItemInfo&gt;();
4410         final HashSet&lt;ComponentName&gt; cns = new HashSet&lt;ComponentName&gt;();
4411         ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
4412         for (CellLayout layoutParent : cellLayouts) {
4413             ViewGroup layout = layoutParent.getShortcutsAndWidgets();
4414             int childCount = layout.getChildCount();
4415             for (int i = 0; i &lt; childCount; ++i) {
4416                 View view = layout.getChildAt(i);
4417                 infos.add((ItemInfo) view.getTag());
4418             }
4419         }
4420         LauncherModel.ItemInfoFilter filter = new LauncherModel.ItemInfoFilter() {
4421             @Override
4422             public boolean filterItem(ItemInfo parent, ItemInfo info,
4423                                       ComponentName cn) {
4424                 if (packageNames.contains(cn.getPackageName())) {
4425                     cns.add(cn);
4426                     return true;
4427                 }
4428                 return false;
4429             }
4430         };
4431         LauncherModel.filterItemInfos(infos, filter);
4432 
4433         // Remove the affected components
4434         removeItemsByComponentName(cns);
4435     }
4436 
4437     // Removes items that match the application info specified, when applications are removed
4438     // as a part of an update, this is called to ensure that other widgets and application
4439     // shortcuts are not removed.
4440     void removeItemsByApplicationInfo(final ArrayList&lt;AppInfo&gt; appInfos) {
4441         // Just create a hash table of all the specific components that this will affect
4442         HashSet&lt;ComponentName&gt; cns = new HashSet&lt;ComponentName&gt;();
4443         for (AppInfo info : appInfos) {
4444             cns.add(info.componentName);
4445         }
4446 
4447         // Remove all the things
4448         removeItemsByComponentName(cns);
4449     }
4450 
4451     void removeItemsByComponentName(final HashSet&lt;ComponentName&gt; componentNames) {
4452         ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
4453         for (final CellLayout layoutParent: cellLayouts) {
4454             final ViewGroup layout = layoutParent.getShortcutsAndWidgets();
4455 
4456             final HashMap&lt;ItemInfo, View&gt; children = new HashMap&lt;ItemInfo, View&gt;();
4457             for (int j = 0; j &lt; layout.getChildCount(); j++) {
4458                 final View view = layout.getChildAt(j);
4459                 children.put((ItemInfo) view.getTag(), view);
4460             }
4461 
4462             final ArrayList&lt;View&gt; childrenToRemove = new ArrayList&lt;View&gt;();
4463             final HashMap&lt;FolderInfo, ArrayList&lt;ShortcutInfo&gt;&gt; folderAppsToRemove =
4464                     new HashMap&lt;FolderInfo, ArrayList&lt;ShortcutInfo&gt;&gt;();
4465             LauncherModel.ItemInfoFilter filter = new LauncherModel.ItemInfoFilter() {
4466                 @Override
4467                 public boolean filterItem(ItemInfo parent, ItemInfo info,
4468                                           ComponentName cn) {
4469                     if (parent instanceof FolderInfo) {
4470                         if (componentNames.contains(cn)) {
4471                             FolderInfo folder = (FolderInfo) parent;
4472                             ArrayList&lt;ShortcutInfo&gt; appsToRemove;
4473                             if (folderAppsToRemove.containsKey(folder)) {
4474                                 appsToRemove = folderAppsToRemove.get(folder);
4475                             } else {
4476                                 appsToRemove = new ArrayList&lt;ShortcutInfo&gt;();
4477                                 folderAppsToRemove.put(folder, appsToRemove);
4478                             }
4479                             appsToRemove.add((ShortcutInfo) info);
4480                             return true;
4481                         }
4482                     } else {
4483                         if (componentNames.contains(cn)) {
4484                             childrenToRemove.add(children.get(info));
4485                             return true;
4486                         }
4487                     }
4488                     return false;
4489                 }
4490             };
4491             LauncherModel.filterItemInfos(children.keySet(), filter);
4492 
4493             // Remove all the apps from their folders
4494             for (FolderInfo folder : folderAppsToRemove.keySet()) {
4495                 ArrayList&lt;ShortcutInfo&gt; appsToRemove = folderAppsToRemove.get(folder);
4496                 for (ShortcutInfo info : appsToRemove) {
4497                     folder.remove(info);
4498                 }
4499             }
4500 
4501             // Remove all the other children
4502             for (View child : childrenToRemove) {
4503                 // Note: We can not remove the view directly from CellLayoutChildren as this
4504                 // does not re-mark the spaces as unoccupied.
4505                 layoutParent.removeViewInLayout(child);
4506                 if (child instanceof DropTarget) {
4507                     mDragController.removeDropTarget((DropTarget) child);
4508                 }
4509             }
4510 
4511             if (childrenToRemove.size() &gt; 0) {
4512                 layout.requestLayout();
4513                 layout.invalidate();
4514             }
4515         }
4516 
4517         // Strip all the empty screens
4518         stripEmptyScreens();
4519     }
4520 
4521     private void updateShortcut(HashMap&lt;ComponentName, AppInfo&gt; appsMap, ItemInfo info,
4522                                 View child) {
4523         ComponentName cn = info.getIntent().getComponent();
4524         if (cn != null) {
4525             AppInfo appInfo = appsMap.get(info.getIntent().getComponent());
4526             if ((appInfo != null) &amp;&amp; LauncherModel.isShortcutInfoUpdateable(info)) {
4527                 ShortcutInfo shortcutInfo = (ShortcutInfo) info;
4528                 BubbleTextView shortcut = (BubbleTextView) child;
4529                 shortcutInfo.updateIcon(mIconCache);
4530                 shortcutInfo.title = appInfo.title.toString();
4531                 shortcut.applyFromShortcutInfo(shortcutInfo, mIconCache);
4532             }
4533         }
4534     }
4535 
4536     void updateShortcuts(ArrayList&lt;AppInfo&gt; apps) {
4537         // Create a map of the apps to test against
4538         final HashMap&lt;ComponentName, AppInfo&gt; appsMap = new HashMap&lt;ComponentName, AppInfo&gt;();
4539         for (AppInfo ai : apps) {
4540             appsMap.put(ai.componentName, ai);
4541         }
4542 
4543         ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts = getAllShortcutAndWidgetContainers();
4544         for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4545             // Update all the children shortcuts
4546             final HashMap&lt;ItemInfo, View&gt; children = new HashMap&lt;ItemInfo, View&gt;();
4547             for (int j = 0; j &lt; layout.getChildCount(); j++) {
4548                 View v = layout.getChildAt(j);
4549                 ItemInfo info = (ItemInfo) v.getTag();
4550                 if (info instanceof FolderInfo &amp;&amp; v instanceof FolderIcon) {
4551                     FolderIcon folder = (FolderIcon) v;
4552                     ArrayList&lt;View&gt; folderChildren = folder.getFolder().getItemsInReadingOrder();
4553                     for (View fv : folderChildren) {
4554                         info = (ItemInfo) fv.getTag();
4555                         updateShortcut(appsMap, info, fv);
4556                     }
4557                     folder.invalidate();
4558                 } else if (info instanceof ShortcutInfo) {
4559                     updateShortcut(appsMap, info, v);
4560                 }
4561             }
4562         }
4563     }
4564 
4565     private void moveToScreen(int page, boolean animate) {
4566         if (!isSmall()) {
4567             if (animate) {
4568                 snapToPage(page);
4569             } else {
4570                 setCurrentPage(page);
4571             }
4572         }
4573         View child = getChildAt(page);
4574         if (child != null) {
4575             child.requestFocus();
4576         }
4577     }
4578 
4579     void moveToDefaultScreen(boolean animate) {
4580         moveToScreen(mDefaultPage, animate);
4581     }
4582 
4583     void moveToCustomContentScreen(boolean animate) {
4584         if (hasCustomContent()) {
4585             int ccIndex = getPageIndexForScreenId(CUSTOM_CONTENT_SCREEN_ID);
4586             if (animate) {
4587                 snapToPage(ccIndex);
4588             } else {
4589                 setCurrentPage(ccIndex);
4590             }
4591             View child = getChildAt(ccIndex);
4592             if (child != null) {
4593                 child.requestFocus();
4594             }
4595         }
4596         exitWidgetResizeMode();
4597     }
4598 
4599     @Override
4600     protected PageIndicator.PageMarkerResources getPageIndicatorMarker(int pageIndex) {
4601         long screenId = getScreenIdForPageIndex(pageIndex);
4602         if (screenId == EXTRA_EMPTY_SCREEN_ID) {
4603             int count = mScreenOrder.size() - numCustomPages();
4604             if (count &gt; 1) {
4605                 return new PageIndicator.PageMarkerResources(R.drawable.ic_pageindicator_current,
4606                         R.drawable.ic_pageindicator_add);
4607             }
4608         }
4609 
4610         return super.getPageIndicatorMarker(pageIndex);
4611     }
4612 
4613     @Override
4614     public void syncPages() {
4615     }
4616 
4617     @Override
4618     public void syncPageItems(int page, boolean immediate) {
4619     }
4620 
4621     protected String getPageIndicatorDescription() {
4622         String settings = getResources().getString(R.string.settings_button_text);
4623         return getCurrentPageDescription() + &quot;, &quot; + settings;
4624     }
4625 
4626     protected String getCurrentPageDescription() {
4627         int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
4628         int delta = numCustomPages();
4629         if (hasCustomContent() &amp;&amp; getNextPage() == 0) {
4630             return mCustomContentDescription;
4631         }
4632         return String.format(getContext().getString(R.string.workspace_scroll_format),
4633                 page + 1 - delta, getChildCount() - delta);
4634     }
4635 
4636     public void getLocationInDragLayer(int[] loc) {
4637         mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
4638     }
4639 }
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.animation.Animator;
  20  import android.animation.Animator.AnimatorListener;
  21  import android.animation.AnimatorListenerAdapter;
  22  import android.animation.AnimatorSet;
  23  import android.animation.LayoutTransition;
  24  import android.animation.ObjectAnimator;
  25  import android.animation.PropertyValuesHolder;
  26  import android.animation.TimeInterpolator;
  27  import android.animation.ValueAnimator;
  28  import android.animation.ValueAnimator.AnimatorUpdateListener;
  29  import android.app.WallpaperManager;
  30  import android.appwidget.AppWidgetHostView;
  31  import android.appwidget.AppWidgetProviderInfo;
  32  import android.content.ComponentName;
  33  import android.content.Context;
  34  import android.content.Intent;
  35  import android.content.SharedPreferences;
  36  import android.content.res.Resources;
  37  import android.content.res.TypedArray;
  38  import android.graphics.Bitmap;
  39  import android.graphics.Canvas;
  40  import android.graphics.Matrix;
  41  import android.graphics.Point;
  42  import android.graphics.PointF;
  43  import android.graphics.Rect;
  44  import android.graphics.Region.Op;
  45  import android.graphics.drawable.Drawable;
  46  import android.net.Uri;
  47  import android.os.IBinder;
  48  import android.os.Parcelable;
  49  import android.support.v4.view.ViewCompat;
  50  import android.util.AttributeSet;
  51  import android.util.Log;
  52  import android.util.SparseArray;
  53  import android.view.Choreographer;
  54  import android.view.Display;
  55  import android.view.MotionEvent;
  56  import android.view.View;
  57  import android.view.ViewGroup;
  58  import android.view.View.OnClickListener;
  59  import android.view.accessibility.AccessibilityEvent;
  60  import android.view.accessibility.AccessibilityManager;
  61  import android.view.accessibility.AccessibilityNodeInfo;
  62  import android.view.animation.DecelerateInterpolator;
  63  import android.view.animation.Interpolator;
  64  import android.widget.TextView;
  65  
  66  import com.android.launcher3.FolderIcon.FolderRingAnimator;
  67  import com.android.launcher3.Launcher.CustomContentCallbacks;
  68  import com.android.launcher3.LauncherSettings.Favorites;
  69  
  70  import java.util.ArrayList;
  71  import java.util.HashMap;
  72  import java.util.HashSet;
  73  import java.util.Iterator;
  74  
  75  /**
  76   * The workspace is a wide area with a wallpaper and a finite number of pages.
  77   * Each page contains a number of icons, folders or widgets the user can
  78   * interact with. A workspace is meant to be used with a fixed width only.
  79   */
  80  public class Workspace extends SmoothPagedView
  81          implements DropTarget, DragSource, DragScroller, View.OnTouchListener,
  82          DragController.DragListener, LauncherTransitionable, ViewGroup.OnHierarchyChangeListener,
  83          Insettable {
  84      private static final String TAG = &quot;Launcher.Workspace&quot;;
  85  
  86      // Y rotation to apply to the workspace screens
  87      private static final float WORKSPACE_OVERSCROLL_ROTATION = 24f;
  88  
  89      private static final int CHILDREN_OUTLINE_FADE_OUT_DELAY = 0;
  90      private static final int CHILDREN_OUTLINE_FADE_OUT_DURATION = 375;
  91      private static final int CHILDREN_OUTLINE_FADE_IN_DURATION = 100;
  92  
  93      protected static final int SNAP_OFF_EMPTY_SCREEN_DURATION = 400;
  94      protected static final int FADE_EMPTY_SCREEN_DURATION = 150;
  95  
  96      private static final int BACKGROUND_FADE_OUT_DURATION = 350;
  97      private static final int ADJACENT_SCREEN_DROP_DURATION = 300;
  98      private static final int FLING_THRESHOLD_VELOCITY = 500;
  99  
 100      private static final float ALPHA_CUTOFF_THRESHOLD = 0.01f;
 101  
 102      // These animators are used to fade the children&#x27;s outlines
 103      private ObjectAnimator mChildrenOutlineFadeInAnimation;
 104      private ObjectAnimator mChildrenOutlineFadeOutAnimation;
 105      private float mChildrenOutlineAlpha = 0;
 106  
 107      // These properties refer to the background protection gradient used for AllApps and Customize
 108      private ValueAnimator mBackgroundFadeInAnimation;
 109      private ValueAnimator mBackgroundFadeOutAnimation;
 110      private Drawable mBackground;
 111      boolean mDrawBackground = true;
 112      private float mBackgroundAlpha = 0;
 113  
 114      private static final long CUSTOM_CONTENT_GESTURE_DELAY = 200;
 115      private long mTouchDownTime = -1;
 116      private long mCustomContentShowTime = -1;
 117  
 118      private LayoutTransition mLayoutTransition;
 119      private final WallpaperManager mWallpaperManager;
 120      private IBinder mWindowToken;
 121  
 122      private int mOriginalDefaultPage;
 123      private int mDefaultPage;
 124  
 125      private ShortcutAndWidgetContainer mDragSourceInternal;
 126      private static boolean sAccessibilityEnabled;
 127  
 128      // The screen id used for the empty screen always present to the right.
 129      private final static long EXTRA_EMPTY_SCREEN_ID = -201;
 130      private final static long CUSTOM_CONTENT_SCREEN_ID = -301;
 131  
 132      private HashMap&lt;Long, CellLayout&gt; mWorkspaceScreens = new HashMap&lt;Long, CellLayout&gt;();
 133      private ArrayList&lt;Long&gt; mScreenOrder = new ArrayList&lt;Long&gt;();
 134  
 135      private Runnable mRemoveEmptyScreenRunnable;
 136  
 137      /**
 138       * CellInfo for the cell that is currently being dragged
 139       */
 140      private CellLayout.CellInfo mDragInfo;
 141  
 142      /**
 143       * Target drop area calculated during last acceptDrop call.
 144       */
 145      private int[] mTargetCell = new int[2];
 146      private int mDragOverX = -1;
 147      private int mDragOverY = -1;
 148  
 149      static Rect mLandscapeCellLayoutMetrics = null;
 150      static Rect mPortraitCellLayoutMetrics = null;
 151  
 152      CustomContentCallbacks mCustomContentCallbacks;
 153      boolean mCustomContentShowing;
 154      private float mLastCustomContentScrollProgress = -1f;
 155      private String mCustomContentDescription = &quot;&quot;;
 156  
 157      /**
 158       * The CellLayout that is currently being dragged over
 159       */
 160      private CellLayout mDragTargetLayout = null;
 161      /**
 162       * The CellLayout that we will show as glowing
 163       */
 164      private CellLayout mDragOverlappingLayout = null;
 165  
 166      /**
 167       * The CellLayout which will be dropped to
 168       */
 169      private CellLayout mDropToLayout = null;
 170  
 171      private Launcher mLauncher;
 172      private IconCache mIconCache;
 173      private DragController mDragController;
 174  
 175      // These are temporary variables to prevent having to allocate a new object just to
 176      // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
 177      private int[] mTempCell = new int[2];
 178      private int[] mTempPt = new int[2];
 179      private int[] mTempEstimate = new int[2];
 180      private float[] mDragViewVisualCenter = new float[2];
 181      private float[] mTempCellLayoutCenterCoordinates = new float[2];
 182      private Matrix mTempInverseMatrix = new Matrix();
 183  
 184      private SpringLoadedDragController mSpringLoadedDragController;
 185      private float mSpringLoadedShrinkFactor;
 186      private float mOverviewModeShrinkFactor;
 187  
 188      // State variable that indicates whether the pages are small (ie when you&#x27;re
 189      // in all apps or customize mode)
 190  
 191      enum State { NORMAL, SPRING_LOADED, SMALL, OVERVIEW};
 192      private State mState = State.NORMAL;
 193      private boolean mIsSwitchingState = false;
 194  
 195      boolean mAnimatingViewIntoPlace = false;
 196      boolean mIsDragOccuring = false;
 197      boolean mChildrenLayersEnabled = true;
 198  
 199      private boolean mStripScreensOnPageStopMoving = false;
 200  
 201      /** Is the user is dragging an item near the edge of a page? */
 202      private boolean mInScrollArea = false;
 203  
 204      private HolographicOutlineHelper mOutlineHelper;
 205      private Bitmap mDragOutline = null;
 206      private final Rect mTempRect = new Rect();
 207      private final int[] mTempXY = new int[2];
 208      private int[] mTempVisiblePagesRange = new int[2];
 209      private boolean mOverscrollTransformsSet;
 210      private float mLastOverscrollPivotX;
 211      public static final int DRAG_BITMAP_PADDING = 2;
 212      private boolean mWorkspaceFadeInAdjacentScreens;
 213  
 214      WallpaperOffsetInterpolator mWallpaperOffset;
 215      private Runnable mDelayedResizeRunnable;
 216      private Runnable mDelayedSnapToPageRunnable;
 217      private Point mDisplaySize = new Point();
 218      private int mCameraDistance;
 219  
 220      // Variables relating to the creation of user folders by hovering shortcuts over shortcuts
 221      private static final int FOLDER_CREATION_TIMEOUT = 0;
 222      private static final int REORDER_TIMEOUT = 250;
 223      private final Alarm mFolderCreationAlarm = new Alarm();
 224      private final Alarm mReorderAlarm = new Alarm();
 225      private FolderRingAnimator mDragFolderRingAnimator = null;
 226      private FolderIcon mDragOverFolderIcon = null;
 227      private boolean mCreateUserFolderOnDrop = false;
 228      private boolean mAddToExistingFolderOnDrop = false;
 229      private DropTarget.DragEnforcer mDragEnforcer;
 230      private float mMaxDistanceForFolderCreation;
 231  
 232      // Variables relating to touch disambiguation (scrolling workspace vs. scrolling a widget)
 233      private float mXDown;
 234      private float mYDown;
 235      final static float START_DAMPING_TOUCH_SLOP_ANGLE = (float) Math.PI / 6;
 236      final static float MAX_SWIPE_ANGLE = (float) Math.PI / 3;
 237      final static float TOUCH_SLOP_DAMPING_FACTOR = 4;
 238  
 239      // Relating to the animation of items being dropped externally
 240      public static final int ANIMATE_INTO_POSITION_AND_DISAPPEAR = 0;
 241      public static final int ANIMATE_INTO_POSITION_AND_REMAIN = 1;
 242      public static final int ANIMATE_INTO_POSITION_AND_RESIZE = 2;
 243      public static final int COMPLETE_TWO_STAGE_WIDGET_DROP_ANIMATION = 3;
 244      public static final int CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION = 4;
 245  
 246      // Related to dragging, folder creation and reordering
 247      private static final int DRAG_MODE_NONE = 0;
 248      private static final int DRAG_MODE_CREATE_FOLDER = 1;
 249      private static final int DRAG_MODE_ADD_TO_FOLDER = 2;
 250      private static final int DRAG_MODE_REORDER = 3;
 251      private int mDragMode = DRAG_MODE_NONE;
 252      private int mLastReorderX = -1;
 253      private int mLastReorderY = -1;
 254  
 255      private SparseArray&lt;Parcelable&gt; mSavedStates;
 256      private final ArrayList&lt;Integer&gt; mRestoredPages = new ArrayList&lt;Integer&gt;();
 257  
 258      // These variables are used for storing the initial and final values during workspace animations
 259      private int mSavedScrollX;
 260      private float mSavedRotationY;
 261      private float mSavedTranslationX;
 262  
 263      private float mCurrentScale;
 264      private float mNewScale;
 265      private float[] mOldBackgroundAlphas;
 266      private float[] mOldAlphas;
 267      private float[] mNewBackgroundAlphas;
 268      private float[] mNewAlphas;
 269      private int mLastChildCount = -1;
 270      private float mTransitionProgress;
 271  
 272      private Runnable mDeferredAction;
 273      private boolean mDeferDropAfterUninstall;
 274      private boolean mUninstallSuccessful;
 275  
 276      private final Runnable mBindPages = new Runnable() {
 277          @Override
 278          public void run() {
 279              mLauncher.getModel().bindRemainingSynchronousPages();
 280          }
 281      };
 282  
 283      /**
 284       * Used to inflate the Workspace from XML.
 285       *
 286       * @param context The application&#x27;s context.
 287       * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 288       */
 289      public Workspace(Context context, AttributeSet attrs) {
 290          this(context, attrs, 0);
 291      }
 292  
 293      /**
 294       * Used to inflate the Workspace from XML.
 295       *
 296       * @param context The application&#x27;s context.
 297       * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 298       * @param defStyle Unused.
 299       */
 300      public Workspace(Context context, AttributeSet attrs, int defStyle) {
 301          super(context, attrs, defStyle);
 302          mContentIsRefreshable = false;
 303  
 304          mOutlineHelper = HolographicOutlineHelper.obtain(context);
 305  
 306          mDragEnforcer = new DropTarget.DragEnforcer(context);
 307          // With workspace, data is available straight from the get-go
 308          setDataIsReady();
 309  
 310          mLauncher = (Launcher) context;
 311          final Resources res = getResources();
 312          mWorkspaceFadeInAdjacentScreens = LauncherAppState.getInstance().getDynamicGrid().
 313                  getDeviceProfile().shouldFadeAdjacentWorkspaceScreens();
 314          mFadeInAdjacentScreens = false;
 315          mWallpaperManager = WallpaperManager.getInstance(context);
 316  
 317          LauncherAppState app = LauncherAppState.getInstance();
 318          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 319          TypedArray a = context.obtainStyledAttributes(attrs,
 320                  R.styleable.Workspace, defStyle, 0);
 321          mSpringLoadedShrinkFactor =
 322              res.getInteger(R.integer.config_workspaceSpringLoadShrinkPercentage) / 100.0f;
 323          mOverviewModeShrinkFactor = grid.getOverviewModeScale();
 324          mCameraDistance = res.getInteger(R.integer.config_cameraDistance);
 325          mOriginalDefaultPage = mDefaultPage = a.getInt(R.styleable.Workspace_defaultScreen, 1);
 326          a.recycle();
 327  
 328          setOnHierarchyChangeListener(this);
 329          setHapticFeedbackEnabled(false);
 330  
 331          initWorkspace();
 332  
 333          // Disable multitouch across the workspace/all apps/customize tray
 334          setMotionEventSplittingEnabled(true);
 335          setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
 336      }
 337  
 338      @Override
 339      public void setInsets(Rect insets) {
 340          mInsets.set(insets);
 341      }
 342  
 343      // estimate the size of a widget with spans hSpan, vSpan. return MAX_VALUE for each
 344      // dimension if unsuccessful
 345      public int[] estimateItemSize(int hSpan, int vSpan,
 346              ItemInfo itemInfo, boolean springLoaded) {
 347          int[] size = new int[2];
 348          if (getChildCount() &gt; 0) {
 349              // Use the first non-custom page to estimate the child position
 350              CellLayout cl = (CellLayout) getChildAt(numCustomPages());
 351              Rect r = estimateItemPosition(cl, itemInfo, 0, 0, hSpan, vSpan);
 352              size[0] = r.width();
 353              size[1] = r.height();
 354              if (springLoaded) {
 355                  size[0] *= mSpringLoadedShrinkFactor;
 356                  size[1] *= mSpringLoadedShrinkFactor;
 357              }
 358              return size;
 359          } else {
 360              size[0] = Integer.MAX_VALUE;
 361              size[1] = Integer.MAX_VALUE;
 362              return size;
 363          }
 364      }
 365  
 366      public Rect estimateItemPosition(CellLayout cl, ItemInfo pendingInfo,
 367              int hCell, int vCell, int hSpan, int vSpan) {
 368          Rect r = new Rect();
 369          cl.cellToRect(hCell, vCell, hSpan, vSpan, r);
 370          return r;
 371      }
 372  
 373      public void onDragStart(final DragSource source, Object info, int dragAction) {
 374          mIsDragOccuring = true;
 375          updateChildrenLayersEnabled(false);
 376          mLauncher.lockScreenOrientation();
 377          mLauncher.onInteractionBegin();
 378          setChildrenBackgroundAlphaMultipliers(1f);
 379          // Prevent any Un/InstallShortcutReceivers from updating the db while we are dragging
 380          InstallShortcutReceiver.enableInstallQueue();
 381          UninstallShortcutReceiver.enableUninstallQueue();
 382          post(new Runnable() {
 383              @Override
 384              public void run() {
 385                  if (mIsDragOccuring) {
 386                      addExtraEmptyScreenOnDrag();
 387                  }
 388              }
 389          });
 390      }
 391  
 392      public void onDragEnd() {
 393          mIsDragOccuring = false;
 394          updateChildrenLayersEnabled(false);
 395          mLauncher.unlockScreenOrientation(false);
 396  
 397          // Re-enable any Un/InstallShortcutReceiver and now process any queued items
 398          InstallShortcutReceiver.disableAndFlushInstallQueue(getContext());
 399          UninstallShortcutReceiver.disableAndFlushUninstallQueue(getContext());
 400  
 401          mDragSourceInternal = null;
 402          mLauncher.onInteractionEnd();
 403      }
 404  
 405      /**
 406       * Initializes various states for this workspace.
 407       */
 408      protected void initWorkspace() {
 409          Context context = getContext();
 410          mCurrentPage = mDefaultPage;
 411          Launcher.setScreen(mCurrentPage);
 412          LauncherAppState app = LauncherAppState.getInstance();
 413          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 414          mIconCache = app.getIconCache();
 415          setWillNotDraw(false);
 416          setClipChildren(false);
 417          setClipToPadding(false);
 418          setChildrenDrawnWithCacheEnabled(true);
 419  
 420          setMinScale(mOverviewModeShrinkFactor);
 421          setupLayoutTransition();
 422  
 423          final Resources res = getResources();
 424          try {
 425              mBackground = res.getDrawable(R.drawable.apps_customize_bg);
 426          } catch (Resources.NotFoundException e) {
 427              // In this case, we will skip drawing background protection
 428          }
 429  
 430          mWallpaperOffset = new WallpaperOffsetInterpolator();
 431          Display display = mLauncher.getWindowManager().getDefaultDisplay();
 432          display.getSize(mDisplaySize);
 433  
 434          mMaxDistanceForFolderCreation = (0.55f * grid.iconSizePx);
 435          mFlingThresholdVelocity = (int) (FLING_THRESHOLD_VELOCITY * mDensity);
 436      }
 437  
 438      private void setupLayoutTransition() {
 439          // We want to show layout transitions when pages are deleted, to close the gap.
 440          mLayoutTransition = new LayoutTransition();
 441          mLayoutTransition.enableTransitionType(LayoutTransition.DISAPPEARING);
 442          mLayoutTransition.enableTransitionType(LayoutTransition.CHANGE_DISAPPEARING);
 443          mLayoutTransition.disableTransitionType(LayoutTransition.APPEARING);
 444          mLayoutTransition.disableTransitionType(LayoutTransition.CHANGE_APPEARING);
 445          setLayoutTransition(mLayoutTransition);
 446      }
 447  
 448      void enableLayoutTransitions() {
 449          setLayoutTransition(mLayoutTransition);
 450      }
 451      void disableLayoutTransitions() {
 452          setLayoutTransition(null);
 453      }
 454  
 455      @Override
 456      protected int getScrollMode() {
 457          return SmoothPagedView.X_LARGE_MODE;
 458      }
 459  
 460      @Override
 461      public void onChildViewAdded(View parent, View child) {
 462          if (!(child instanceof CellLayout)) {
 463              throw new IllegalArgumentException(&quot;A Workspace can only have CellLayout children.&quot;);
 464          }
 465          CellLayout cl = ((CellLayout) child);
 466          cl.setOnInterceptTouchListener(this);
 467          cl.setClickable(true);
 468          cl.setImportantForAccessibility(ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_NO);
 469          super.onChildViewAdded(parent, child);
 470      }
 471  
 472      protected boolean shouldDrawChild(View child) {
 473          final CellLayout cl = (CellLayout) child;
 474          return super.shouldDrawChild(child) &amp;&amp;
 475              (mIsSwitchingState ||
 476               cl.getShortcutsAndWidgets().getAlpha() &gt; 0 ||
 477               cl.getBackgroundAlpha() &gt; 0);
 478      }
 479  
 480      /**
 481       * @return The open folder on the current screen, or null if there is none
 482       */
 483      Folder getOpenFolder() {
 484          DragLayer dragLayer = mLauncher.getDragLayer();
 485          int count = dragLayer.getChildCount();
 486          for (int i = 0; i &lt; count; i++) {
 487              View child = dragLayer.getChildAt(i);
 488              if (child instanceof Folder) {
 489                  Folder folder = (Folder) child;
 490                  if (folder.getInfo().opened)
 491                      return folder;
 492              }
 493          }
 494          return null;
 495      }
 496  
 497      boolean isTouchActive() {
 498          return mTouchState != TOUCH_STATE_REST;
 499      }
 500  
 501      public void removeAllWorkspaceScreens() {
 502          // Disable all layout transitions before removing all pages to ensure that we don&#x27;t get the
 503          // transition animations competing with us changing the scroll when we add pages or the
 504          // custom content screen
 505          disableLayoutTransitions();
 506  
 507          // Since we increment the current page when we call addCustomContentPage via bindScreens
 508          // (and other places), we need to adjust the current page back when we clear the pages
 509          if (hasCustomContent()) {
 510              removeCustomContentPage();
 511          }
 512  
 513          // Remove the pages and clear the screen models
 514          removeAllViews();
 515          mScreenOrder.clear();
 516          mWorkspaceScreens.clear();
 517  
 518          // Re-enable the layout transitions
 519          enableLayoutTransitions();
 520      }
 521  
 522      public long insertNewWorkspaceScreenBeforeEmptyScreen(long screenId) {
 523          // Find the index to insert this view into.  If the empty screen exists, then
 524          // insert it before that.
 525          int insertIndex = mScreenOrder.indexOf(EXTRA_EMPTY_SCREEN_ID);
 526          if (insertIndex &lt; 0) {
 527              insertIndex = mScreenOrder.size();
 528          }
 529          return insertNewWorkspaceScreen(screenId, insertIndex);
 530      }
 531  
 532      public long insertNewWorkspaceScreen(long screenId) {
 533          return insertNewWorkspaceScreen(screenId, getChildCount());
 534      }
 535  
 536      public long insertNewWorkspaceScreen(long screenId, int insertIndex) {
 537          if (mWorkspaceScreens.containsKey(screenId)) {
 538              throw new RuntimeException(&quot;Screen id &quot; + screenId + &quot; already exists!&quot;);
 539          }
 540  
 541          CellLayout newScreen = (CellLayout)
 542                  mLauncher.getLayoutInflater().inflate(R.layout.workspace_screen, null);
 543  
 544          newScreen.setOnLongClickListener(mLongClickListener);
 545          newScreen.setOnClickListener(mLauncher);
 546          newScreen.setSoundEffectsEnabled(false);
 547          mWorkspaceScreens.put(screenId, newScreen);
 548          mScreenOrder.add(insertIndex, screenId);
 549          addView(newScreen, insertIndex);
 550          return screenId;
 551      }
 552  
 553      public void createCustomContentPage() {
 554          CellLayout customScreen = (CellLayout)
 555                  mLauncher.getLayoutInflater().inflate(R.layout.workspace_screen, null);
 556  
 557          mWorkspaceScreens.put(CUSTOM_CONTENT_SCREEN_ID, customScreen);
 558          mScreenOrder.add(0, CUSTOM_CONTENT_SCREEN_ID);
 559  
 560          // We want no padding on the custom content
 561          customScreen.setPadding(0, 0, 0, 0);
 562  
 563          addFullScreenPage(customScreen);
 564  
 565          // Ensure that the current page and default page are maintained.
 566          mDefaultPage = mOriginalDefaultPage + 1;
 567  
 568          // Update the custom content hint
 569          mLauncher.updateCustomContentHintVisibility();
 570          if (mRestorePage != INVALID_RESTORE_PAGE) {
 571              mRestorePage = mRestorePage + 1;
 572          } else {
 573              setCurrentPage(getCurrentPage() + 1);
 574          }
 575      }
 576  
 577      public void removeCustomContentPage() {
 578          CellLayout customScreen = getScreenWithId(CUSTOM_CONTENT_SCREEN_ID);
 579          if (customScreen == null) {
 580              throw new RuntimeException(&quot;Expected custom content screen to exist&quot;);
 581          }
 582  
 583          mWorkspaceScreens.remove(CUSTOM_CONTENT_SCREEN_ID);
 584          mScreenOrder.remove(CUSTOM_CONTENT_SCREEN_ID);
 585          removeView(customScreen);
 586  
 587          if (mCustomContentCallbacks != null) {
 588              mCustomContentCallbacks.onScrollProgressChanged(0);
 589              mCustomContentCallbacks.onHide();
 590          }
 591  
 592          mCustomContentCallbacks = null;
 593  
 594          // Ensure that the current page and default page are maintained.
 595          mDefaultPage = mOriginalDefaultPage - 1;
 596  
 597          // Update the custom content hint
 598          mLauncher.updateCustomContentHintVisibility();
 599          if (mRestorePage != INVALID_RESTORE_PAGE) {
 600              mRestorePage = mRestorePage - 1;
 601          } else {
 602              setCurrentPage(getCurrentPage() - 1);
 603          }
 604      }
 605  
 606      public void addToCustomContentPage(View customContent, CustomContentCallbacks callbacks,
 607              String description) {
 608          if (getPageIndexForScreenId(CUSTOM_CONTENT_SCREEN_ID) &lt; 0) {
 609              throw new RuntimeException(&quot;Expected custom content screen to exist&quot;);
 610          }
 611  
 612          // Add the custom content to the full screen custom page
 613          CellLayout customScreen = getScreenWithId(CUSTOM_CONTENT_SCREEN_ID);
 614          int spanX = customScreen.getCountX();
 615          int spanY = customScreen.getCountY();
 616          CellLayout.LayoutParams lp = new CellLayout.LayoutParams(0, 0, spanX, spanY);
 617          lp.canReorder  = false;
 618          lp.isFullscreen = true;
 619          if (customContent instanceof Insettable) {
 620              ((Insettable)customContent).setInsets(mInsets);
 621          }
 622          customScreen.removeAllViews();
 623          customScreen.addViewToCellLayout(customContent, 0, 0, lp, true);
 624          mCustomContentDescription = description;
 625  
 626          mCustomContentCallbacks = callbacks;
 627      }
 628  
 629      public void addExtraEmptyScreenOnDrag() {
 630          boolean lastChildOnScreen = false;
 631          boolean childOnFinalScreen = false;
 632  
 633          // Cancel any pending removal of empty screen
 634          mRemoveEmptyScreenRunnable = null;
 635  
 636          if (mDragSourceInternal != null) {
 637              if (mDragSourceInternal.getChildCount() == 1) {
 638                  lastChildOnScreen = true;
 639              }
 640              CellLayout cl = (CellLayout) mDragSourceInternal.getParent();
 641              if (indexOfChild(cl) == getChildCount() - 1) {
 642                  childOnFinalScreen = true;
 643              }
 644          }
 645  
 646          // If this is the last item on the final screen
 647          if (lastChildOnScreen &amp;&amp; childOnFinalScreen) {
 648              return;
 649          }
 650          if (!mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID)) {
 651              insertNewWorkspaceScreen(EXTRA_EMPTY_SCREEN_ID);
 652          }
 653      }
 654  
 655      public boolean addExtraEmptyScreen() {
 656          if (!mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID)) {
 657              insertNewWorkspaceScreen(EXTRA_EMPTY_SCREEN_ID);
 658              return true;
 659          }
 660          return false;
 661      }
 662  
 663      private void convertFinalScreenToEmptyScreenIfNecessary() {
 664          if (hasExtraEmptyScreen() || mScreenOrder.size() == 0) return;
 665          long finalScreenId = mScreenOrder.get(mScreenOrder.size() - 1);
 666  
 667          if (finalScreenId == CUSTOM_CONTENT_SCREEN_ID) return;
 668          CellLayout finalScreen = mWorkspaceScreens.get(finalScreenId);
 669  
 670          // If the final screen is empty, convert it to the extra empty screen
 671          if (finalScreen.getShortcutsAndWidgets().getChildCount() == 0 &amp;&amp;
 672                  !finalScreen.isDropPending()) {
 673              mWorkspaceScreens.remove(finalScreenId);
 674              mScreenOrder.remove(finalScreenId);
 675  
 676              // if this is the last non-custom content screen, convert it to the empty screen
 677              mWorkspaceScreens.put(EXTRA_EMPTY_SCREEN_ID, finalScreen);
 678              mScreenOrder.add(EXTRA_EMPTY_SCREEN_ID);
 679          }
 680      }
 681  
 682      public void removeExtraEmptyScreen(final boolean animate, final Runnable onComplete) {
 683          removeExtraEmptyScreen(animate, onComplete, 0, false);
 684      }
 685  
 686      public void removeExtraEmptyScreen(final boolean animate, final Runnable onComplete,
 687              final int delay, final boolean stripEmptyScreens) {
 688          if (delay &gt; 0) {
 689              postDelayed(new Runnable() {
 690                  @Override
 691                  public void run() {
 692                      removeExtraEmptyScreen(animate, onComplete, 0, stripEmptyScreens);
 693                  }
 694  
 695              }, delay);
 696              return;
 697          }
 698  
 699          convertFinalScreenToEmptyScreenIfNecessary();
 700          if (hasExtraEmptyScreen()) {
 701              int emptyIndex = mScreenOrder.indexOf(EXTRA_EMPTY_SCREEN_ID);
 702              if (getNextPage() == emptyIndex) {
 703                  snapToPage(getNextPage() - 1, SNAP_OFF_EMPTY_SCREEN_DURATION);
 704                  fadeAndRemoveEmptyScreen(SNAP_OFF_EMPTY_SCREEN_DURATION, FADE_EMPTY_SCREEN_DURATION,
 705                          onComplete, stripEmptyScreens);
 706              } else {
 707                  fadeAndRemoveEmptyScreen(0, FADE_EMPTY_SCREEN_DURATION,
 708                          onComplete, stripEmptyScreens);
 709              }
 710              return;
 711          }
 712          if (onComplete != null) {
 713              onComplete.run();
 714          }
 715      }
 716  
 717      private void fadeAndRemoveEmptyScreen(int delay, int duration, final Runnable onComplete,
 718              final boolean stripEmptyScreens) {
 719          PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0f);
 720          PropertyValuesHolder bgAlpha = PropertyValuesHolder.ofFloat(&quot;backgroundAlpha&quot;, 0f);
 721  
 722          final CellLayout cl = mWorkspaceScreens.get(EXTRA_EMPTY_SCREEN_ID);
 723  
 724          mRemoveEmptyScreenRunnable = new Runnable() {
 725              @Override
 726              public void run() {
 727                  if (hasExtraEmptyScreen()) {
 728                      mWorkspaceScreens.remove(EXTRA_EMPTY_SCREEN_ID);
 729                      mScreenOrder.remove(EXTRA_EMPTY_SCREEN_ID);
 730                      removeView(cl);
 731                      if (stripEmptyScreens) {
 732                          stripEmptyScreens();
 733                      }
 734                  }
 735              }
 736          };
 737  
 738          ObjectAnimator oa = ObjectAnimator.ofPropertyValuesHolder(cl, alpha, bgAlpha);
 739          oa.setDuration(duration);
 740          oa.setStartDelay(delay);
 741          oa.addListener(new AnimatorListenerAdapter() {
 742              @Override
 743              public void onAnimationEnd(Animator animation) {
 744                  if (mRemoveEmptyScreenRunnable != null) {
 745                      mRemoveEmptyScreenRunnable.run();
 746                  }
 747                  if (onComplete != null) {
 748                      onComplete.run();
 749                  }
 750              }
 751          });
 752          oa.start();
 753      }
 754  
 755      public boolean hasExtraEmptyScreen() {
 756          int nScreens = getChildCount();
 757          nScreens = nScreens - numCustomPages();
 758          return mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID) &amp;&amp; nScreens &gt; 1;
 759      }
 760  
 761      public long commitExtraEmptyScreen() {
 762          int index = getPageIndexForScreenId(EXTRA_EMPTY_SCREEN_ID);
 763          CellLayout cl = mWorkspaceScreens.get(EXTRA_EMPTY_SCREEN_ID);
 764          mWorkspaceScreens.remove(EXTRA_EMPTY_SCREEN_ID);
 765          mScreenOrder.remove(EXTRA_EMPTY_SCREEN_ID);
 766  
 767          long newId = LauncherAppState.getLauncherProvider().generateNewScreenId();
 768          mWorkspaceScreens.put(newId, cl);
 769          mScreenOrder.add(newId);
 770  
 771          // Update the page indicator marker
 772          if (getPageIndicator() != null) {
 773              getPageIndicator().updateMarker(index, getPageIndicatorMarker(index));
 774          }
 775  
 776          // Update the model for the new screen
 777          mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
 778  
 779          return newId;
 780      }
 781  
 782      public CellLayout getScreenWithId(long screenId) {
 783          CellLayout layout = mWorkspaceScreens.get(screenId);
 784          return layout;
 785      }
 786  
 787      public long getIdForScreen(CellLayout layout) {
 788          Iterator&lt;Long&gt; iter = mWorkspaceScreens.keySet().iterator();
 789          while (iter.hasNext()) {
 790              long id = iter.next();
 791              if (mWorkspaceScreens.get(id) == layout) {
 792                  return id;
 793              }
 794          }
 795          return -1;
 796      }
 797  
 798      public int getPageIndexForScreenId(long screenId) {
 799          return indexOfChild(mWorkspaceScreens.get(screenId));
 800      }
 801  
 802      public long getScreenIdForPageIndex(int index) {
 803          if (0 &lt;= index &amp;&amp; index &lt; mScreenOrder.size()) {
 804              return mScreenOrder.get(index);
 805          }
 806          return -1;
 807      }
 808  
 809      ArrayList&lt;Long&gt; getScreenOrder() {
 810          return mScreenOrder;
 811      }
 812  
 813      public void stripEmptyScreens() {
 814          if (isPageMoving()) {
 815              mStripScreensOnPageStopMoving = true;
 816              return;
 817          }
 818  
 819          int currentPage = getNextPage();
 820          ArrayList&lt;Long&gt; removeScreens = new ArrayList&lt;Long&gt;();
 821          for (Long id: mWorkspaceScreens.keySet()) {
 822              CellLayout cl = mWorkspaceScreens.get(id);
 823              if (id &gt;= 0 &amp;&amp; cl.getShortcutsAndWidgets().getChildCount() == 0) {
 824                  removeScreens.add(id);
 825              }
 826          }
 827  
 828          // We enforce at least one page to add new items to. In the case that we remove the last
 829          // such screen, we convert the last screen to the empty screen
 830          int minScreens = 1 + numCustomPages();
 831  
 832          int pageShift = 0;
 833          for (Long id: removeScreens) {
 834              CellLayout cl = mWorkspaceScreens.get(id);
 835              mWorkspaceScreens.remove(id);
 836              mScreenOrder.remove(id);
 837  
 838              if (getChildCount() &gt; minScreens) {
 839                  if (indexOfChild(cl) &lt; currentPage) {
 840                      pageShift++;
 841                  }
 842                  removeView(cl);
 843              } else {
 844                  // if this is the last non-custom content screen, convert it to the empty screen
 845                  mRemoveEmptyScreenRunnable = null;
 846                  mWorkspaceScreens.put(EXTRA_EMPTY_SCREEN_ID, cl);
 847                  mScreenOrder.add(EXTRA_EMPTY_SCREEN_ID);
 848              }
 849          }
 850  
 851          if (!removeScreens.isEmpty()) {
 852              // Update the model if we have changed any screens
 853              mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
 854          }
 855  
 856          if (pageShift &gt;= 0) {
 857              setCurrentPage(currentPage - pageShift);
 858          }
 859      }
 860  
 861      // See implementation for parameter definition.
 862      void addInScreen(View child, long container, long screenId,
 863              int x, int y, int spanX, int spanY) {
 864          addInScreen(child, container, screenId, x, y, spanX, spanY, false, false);
 865      }
 866  
 867      // At bind time, we use the rank (screenId) to compute x and y for hotseat items.
 868      // See implementation for parameter definition.
 869      void addInScreenFromBind(View child, long container, long screenId, int x, int y,
 870              int spanX, int spanY) {
 871          addInScreen(child, container, screenId, x, y, spanX, spanY, false, true);
 872      }
 873  
 874      // See implementation for parameter definition.
 875      void addInScreen(View child, long container, long screenId, int x, int y, int spanX, int spanY,
 876              boolean insert) {
 877          addInScreen(child, container, screenId, x, y, spanX, spanY, insert, false);
 878      }
 879  
 880      /**
 881       * Adds the specified child in the specified screen. The position and dimension of
 882       * the child are defined by x, y, spanX and spanY.
 883       *
 884       * @param child The child to add in one of the workspace&#x27;s screens.
 885       * @param screenId The screen in which to add the child.
 886       * @param x The X position of the child in the screen&#x27;s grid.
 887       * @param y The Y position of the child in the screen&#x27;s grid.
 888       * @param spanX The number of cells spanned horizontally by the child.
 889       * @param spanY The number of cells spanned vertically by the child.
 890       * @param insert When true, the child is inserted at the beginning of the children list.
 891       * @param computeXYFromRank When true, we use the rank (stored in screenId) to compute
 892       *                          the x and y position in which to place hotseat items. Otherwise
 893       *                          we use the x and y position to compute the rank.
 894       */
 895      void addInScreen(View child, long container, long screenId, int x, int y, int spanX, int spanY,
 896              boolean insert, boolean computeXYFromRank) {
 897          if (container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 898              if (getScreenWithId(screenId) == null) {
 899                  Log.e(TAG, &quot;Skipping child, screenId &quot; + screenId + &quot; not found&quot;);
 900                  // DEBUGGING - Print out the stack trace to see where we are adding from
 901                  new Throwable().printStackTrace();
 902                  return;
 903              }
 904          }
 905          if (screenId == EXTRA_EMPTY_SCREEN_ID) {
 906              // This should never happen
 907              throw new RuntimeException(&quot;Screen id should not be EXTRA_EMPTY_SCREEN_ID&quot;);
 908          }
 909  
 910          final CellLayout layout;
 911          if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 912              layout = mLauncher.getHotseat().getLayout();
 913              child.setOnKeyListener(null);
 914  
 915              // Hide folder title in the hotseat
 916              if (child instanceof FolderIcon) {
 917                  ((FolderIcon) child).setTextVisible(false);
 918              }
 919  
 920              if (computeXYFromRank) {
 921                  x = mLauncher.getHotseat().getCellXFromOrder((int) screenId);
 922                  y = mLauncher.getHotseat().getCellYFromOrder((int) screenId);
 923              } else {
 924                  screenId = mLauncher.getHotseat().getOrderInHotseat(x, y);
 925              }
 926          } else {
 927              // Show folder title if not in the hotseat
 928              if (child instanceof FolderIcon) {
 929                  ((FolderIcon) child).setTextVisible(true);
 930              }
 931              layout = getScreenWithId(screenId);
 932              child.setOnKeyListener(new IconKeyEventListener());
 933          }
 934  
 935          ViewGroup.LayoutParams genericLp = child.getLayoutParams();
 936          CellLayout.LayoutParams lp;
 937          if (genericLp == null || !(genericLp instanceof CellLayout.LayoutParams)) {
 938              lp = new CellLayout.LayoutParams(x, y, spanX, spanY);
 939          } else {
 940              lp = (CellLayout.LayoutParams) genericLp;
 941              lp.cellX = x;
 942              lp.cellY = y;
 943              lp.cellHSpan = spanX;
 944              lp.cellVSpan = spanY;
 945          }
 946  
 947          if (spanX &lt; 0 &amp;&amp; spanY &lt; 0) {
 948              lp.isLockedToGrid = false;
 949          }
 950  
 951          // Get the canonical child id to uniquely represent this view in this screen
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 952 -        int childId = LauncherModel.getCellLayoutChildId(container, screenId, x, y, spanX, spanY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 953 +        ItemInfo info = (ItemInfo) child.getTag();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 954 +        int childId = mLauncher.getViewIdForItem(info);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 955 +</span>
 956          boolean markCellsAsOccupied = !(child instanceof Folder);
 957          if (!layout.addViewToCellLayout(child, insert ? 0 : -1, childId, lp, markCellsAsOccupied)) {
 958              // TODO: This branch occurs when the workspace is adding views
 959              // outside of the defined grid
 960              // maybe we should be deleting these items from the LauncherModel?
<abbr title=" 961              Launcher.addDumpLog(TAG, &quot;Failed to add to item at (&quot; + lp.cellX + &quot;,&quot; + lp.cellY + &quot;) to CellLayout&quot;, true);"> 961              Launcher.addDumpLog(TAG, &quot;Failed to add to item at (&quot; + lp.cellX + &quot;,&quot; + lp.cellY + &quot;) to CellLayout&quot;,🔵</abbr>
 962          }
 963  
 964          if (!(child instanceof Folder)) {
 965              child.setHapticFeedbackEnabled(false);
 966              child.setOnLongClickListener(mLongClickListener);
 967          }
 968          if (child instanceof DropTarget) {
 969              mDragController.addDropTarget((DropTarget) child);
 970          }
 971      }
 972  
 973      /**
 974       * Called directly from a CellLayout (not by the framework), after we&#x27;ve been added as a
 975       * listener via setOnInterceptTouchEventListener(). This allows us to tell the CellLayout
 976       * that it should intercept touch events, which is not something that is normally supported.
 977       */
 978      @Override
 979      public boolean onTouch(View v, MotionEvent event) {
 980          return (isSmall() || !isFinishedSwitchingState())
 981                  || (!isSmall() &amp;&amp; indexOfChild(v) != mCurrentPage);
 982      }
 983  
 984      public boolean isSwitchingState() {
 985          return mIsSwitchingState;
 986      }
 987  
 988      /** This differs from isSwitchingState in that we take into account how far the transition
 989       *  has completed. */
 990      public boolean isFinishedSwitchingState() {
 991          return !mIsSwitchingState || (mTransitionProgress &gt; 0.5f);
 992      }
 993  
 994      protected void onWindowVisibilityChanged (int visibility) {
 995          mLauncher.onWindowVisibilityChanged(visibility);
 996      }
 997  
 998      @Override
 999      public boolean dispatchUnhandledMove(View focused, int direction) {
1000          if (isSmall() || !isFinishedSwitchingState()) {
1001              // when the home screens are shrunken, shouldn&#x27;t allow side-scrolling
1002              return false;
1003          }
1004          return super.dispatchUnhandledMove(focused, direction);
1005      }
1006  
1007      @Override
1008      public boolean onInterceptTouchEvent(MotionEvent ev) {
1009          switch (ev.getAction() &amp; MotionEvent.ACTION_MASK) {
1010          case MotionEvent.ACTION_DOWN:
1011              mXDown = ev.getX();
1012              mYDown = ev.getY();
1013              mTouchDownTime = System.currentTimeMillis();
1014              break;
1015          case MotionEvent.ACTION_POINTER_UP:
1016          case MotionEvent.ACTION_UP:
1017              if (mTouchState == TOUCH_STATE_REST) {
1018                  final CellLayout currentPage = (CellLayout) getChildAt(mCurrentPage);
1019                  if (!currentPage.lastDownOnOccupiedCell()) {
1020                      onWallpaperTap(ev);
1021                  }
1022              }
1023          }
1024          return super.onInterceptTouchEvent(ev);
1025      }
1026  
1027      protected void reinflateWidgetsIfNecessary() {
1028          final int clCount = getChildCount();
1029          for (int i = 0; i &lt; clCount; i++) {
1030              CellLayout cl = (CellLayout) getChildAt(i);
1031              ShortcutAndWidgetContainer swc = cl.getShortcutsAndWidgets();
1032              final int itemCount = swc.getChildCount();
1033              for (int j = 0; j &lt; itemCount; j++) {
1034                  View v = swc.getChildAt(j);
1035  
1036                  if (v.getTag() instanceof LauncherAppWidgetInfo) {
1037                      LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) v.getTag();
1038                      LauncherAppWidgetHostView lahv = (LauncherAppWidgetHostView) info.hostView;
1039                      if (lahv != null &amp;&amp; lahv.orientationChangedSincedInflation()) {
1040                          mLauncher.removeAppWidget(info);
1041                          // Remove the current widget which is inflated with the wrong orientation
1042                          cl.removeView(lahv);
1043                          mLauncher.bindAppWidget(info);
1044                      }
1045                  }
1046              }
1047          }
1048      }
1049  
1050      @Override
1051      protected void determineScrollingStart(MotionEvent ev) {
1052          if (!isFinishedSwitchingState()) return;
1053  
1054          float deltaX = ev.getX() - mXDown;
1055          float absDeltaX = Math.abs(deltaX);
1056          float absDeltaY = Math.abs(ev.getY() - mYDown);
1057  
1058          if (Float.compare(absDeltaX, 0f) == 0) return;
1059  
1060          float slope = absDeltaY / absDeltaX;
1061          float theta = (float) Math.atan(slope);
1062  
1063          if (absDeltaX &gt; mTouchSlop || absDeltaY &gt; mTouchSlop) {
1064              cancelCurrentPageLongPress();
1065          }
1066  
1067          boolean passRightSwipesToCustomContent =
1068                  (mTouchDownTime - mCustomContentShowTime) &gt; CUSTOM_CONTENT_GESTURE_DELAY;
1069  
1070          boolean swipeInIgnoreDirection = isLayoutRtl() ? deltaX &lt; 0 : deltaX &gt; 0;
1071          if (swipeInIgnoreDirection &amp;&amp; getScreenIdForPageIndex(getCurrentPage()) ==
1072                  CUSTOM_CONTENT_SCREEN_ID &amp;&amp; passRightSwipesToCustomContent) {
1073              // Pass swipes to the right to the custom content page.
1074              return;
1075          }
1076  
1077          if (theta &gt; MAX_SWIPE_ANGLE) {
1078              // Above MAX_SWIPE_ANGLE, we don&#x27;t want to ever start scrolling the workspace
1079              return;
1080          } else if (theta &gt; START_DAMPING_TOUCH_SLOP_ANGLE) {
1081              // Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to
1082              // increase the touch slop to make it harder to begin scrolling the workspace. This
1083              // results in vertically scrolling widgets to more easily. The higher the angle, the
1084              // more we increase touch slop.
1085              theta -= START_DAMPING_TOUCH_SLOP_ANGLE;
1086              float extraRatio = (float)
1087                      Math.sqrt((theta / (MAX_SWIPE_ANGLE - START_DAMPING_TOUCH_SLOP_ANGLE)));
1088              super.determineScrollingStart(ev, 1 + TOUCH_SLOP_DAMPING_FACTOR * extraRatio);
1089          } else {
1090              // Below START_DAMPING_TOUCH_SLOP_ANGLE, we don&#x27;t do anything special
1091              super.determineScrollingStart(ev);
1092          }
1093      }
1094  
1095      protected void onPageBeginMoving() {
1096          super.onPageBeginMoving();
1097  
1098          if (isHardwareAccelerated()) {
1099              updateChildrenLayersEnabled(false);
1100          } else {
1101              if (mNextPage != INVALID_PAGE) {
1102                  // we&#x27;re snapping to a particular screen
1103                  enableChildrenCache(mCurrentPage, mNextPage);
1104              } else {
1105                  // this is when user is actively dragging a particular screen, they might
1106                  // swipe it either left or right (but we won&#x27;t advance by more than one screen)
1107                  enableChildrenCache(mCurrentPage - 1, mCurrentPage + 1);
1108              }
1109          }
1110  
1111          // Only show page outlines as we pan if we are on large screen
1112          if (LauncherAppState.getInstance().isScreenLarge()) {
1113              showOutlines();
1114          }
1115  
1116          // If we are not fading in adjacent screens, we still need to restore the alpha in case the
1117          // user scrolls while we are transitioning (should not affect dispatchDraw optimizations)
1118          if (!mWorkspaceFadeInAdjacentScreens) {
1119              for (int i = 0; i &lt; getChildCount(); ++i) {
1120                  ((CellLayout) getPageAt(i)).setShortcutAndWidgetAlpha(1f);
1121              }
1122          }
1123      }
1124  
1125      protected void onPageEndMoving() {
1126          super.onPageEndMoving();
1127  
1128          if (isHardwareAccelerated()) {
1129              updateChildrenLayersEnabled(false);
1130          } else {
1131              clearChildrenCache();
1132          }
1133  
1134          if (mDragController.isDragging()) {
1135              if (isSmall()) {
1136                  // If we are in springloaded mode, then force an event to check if the current touch
1137                  // is under a new page (to scroll to)
1138                  mDragController.forceTouchMove();
1139              }
1140          } else {
1141              // If we are not mid-dragging, hide the page outlines if we are on a large screen
1142              if (LauncherAppState.getInstance().isScreenLarge()) {
1143                  hideOutlines();
1144              }
1145          }
1146  
1147          if (mDelayedResizeRunnable != null) {
1148              mDelayedResizeRunnable.run();
1149              mDelayedResizeRunnable = null;
1150          }
1151  
1152          if (mDelayedSnapToPageRunnable != null) {
1153              mDelayedSnapToPageRunnable.run();
1154              mDelayedSnapToPageRunnable = null;
1155          }
1156          if (mStripScreensOnPageStopMoving) {
1157              stripEmptyScreens();
1158              mStripScreensOnPageStopMoving = false;
1159          }
1160      }
1161  
1162      @Override
1163      protected void notifyPageSwitchListener() {
1164          super.notifyPageSwitchListener();
1165          Launcher.setScreen(mCurrentPage);
1166  
1167          if (hasCustomContent() &amp;&amp; getNextPage() == 0 &amp;&amp; !mCustomContentShowing) {
1168              mCustomContentShowing = true;
1169              if (mCustomContentCallbacks != null) {
1170                  mCustomContentCallbacks.onShow();
1171                  mCustomContentShowTime = System.currentTimeMillis();
1172                  mLauncher.updateVoiceButtonProxyVisible(false);
1173              }
1174          } else if (hasCustomContent() &amp;&amp; getNextPage() != 0 &amp;&amp; mCustomContentShowing) {
1175              mCustomContentShowing = false;
1176              if (mCustomContentCallbacks != null) {
1177                  mCustomContentCallbacks.onHide();
1178                  mLauncher.resetQSBScroll();
1179                  mLauncher.updateVoiceButtonProxyVisible(false);
1180              }
1181          }
1182          if (getPageIndicator() != null) {
1183              getPageIndicator().setContentDescription(getPageIndicatorDescription());
1184          }
1185      }
1186  
1187      protected CustomContentCallbacks getCustomContentCallbacks() {
1188          return mCustomContentCallbacks;
1189      }
1190  
1191      protected void setWallpaperDimension() {
1192          String spKey = WallpaperCropActivity.getSharedPreferencesKey();
1193          SharedPreferences sp = mLauncher.getSharedPreferences(spKey, Context.MODE_MULTI_PROCESS);
1194          WallpaperPickerActivity.suggestWallpaperDimension(mLauncher.getResources(),
1195                  sp, mLauncher.getWindowManager(), mWallpaperManager);
1196      }
1197  
1198      protected void snapToPage(int whichPage, Runnable r) {
1199          snapToPage(whichPage, SLOW_PAGE_SNAP_ANIMATION_DURATION, r);
1200      }
1201  
1202      protected void snapToPage(int whichPage, int duration, Runnable r) {
1203          if (mDelayedSnapToPageRunnable != null) {
1204              mDelayedSnapToPageRunnable.run();
1205          }
1206          mDelayedSnapToPageRunnable = r;
1207          snapToPage(whichPage, duration);
1208      }
1209  
1210      protected void snapToScreenId(long screenId, Runnable r) {
1211          snapToPage(getPageIndexForScreenId(screenId), r);
1212      }
1213  
1214      class WallpaperOffsetInterpolator implements Choreographer.FrameCallback {
1215          float mFinalOffset = 0.0f;
1216          float mCurrentOffset = 0.5f; // to force an initial update
1217          boolean mWaitingForUpdate;
1218          Choreographer mChoreographer;
1219          Interpolator mInterpolator;
1220          boolean mAnimating;
1221          long mAnimationStartTime;
1222          float mAnimationStartOffset;
1223          private final int ANIMATION_DURATION = 250;
1224          // Don&#x27;t use all the wallpaper for parallax until you have at least this many pages
1225          private final int MIN_PARALLAX_PAGE_SPAN = 3;
1226          int mNumScreens;
1227  
1228          public WallpaperOffsetInterpolator() {
1229              mChoreographer = Choreographer.getInstance();
1230              mInterpolator = new DecelerateInterpolator(1.5f);
1231          }
1232  
1233          @Override
1234          public void doFrame(long frameTimeNanos) {
1235              updateOffset(false);
1236          }
1237  
1238          private void updateOffset(boolean force) {
1239              if (mWaitingForUpdate || force) {
1240                  mWaitingForUpdate = false;
1241                  if (computeScrollOffset() &amp;&amp; mWindowToken != null) {
1242                      try {
1243                          mWallpaperManager.setWallpaperOffsets(mWindowToken,
1244                                  mWallpaperOffset.getCurrX(), 0.5f);
1245                          setWallpaperOffsetSteps();
1246                      } catch (IllegalArgumentException e) {
1247                          Log.e(TAG, &quot;Error updating wallpaper offset: &quot; + e);
1248                      }
1249                  }
1250              }
1251          }
1252  
1253          public boolean computeScrollOffset() {
1254              final float oldOffset = mCurrentOffset;
1255              if (mAnimating) {
1256                  long durationSinceAnimation = System.currentTimeMillis() - mAnimationStartTime;
1257                  float t0 = durationSinceAnimation / (float) ANIMATION_DURATION;
1258                  float t1 = mInterpolator.getInterpolation(t0);
1259                  mCurrentOffset = mAnimationStartOffset +
1260                          (mFinalOffset - mAnimationStartOffset) * t1;
1261                  mAnimating = durationSinceAnimation &lt; ANIMATION_DURATION;
1262              } else {
1263                  mCurrentOffset = mFinalOffset;
1264              }
1265  
1266              if (Math.abs(mCurrentOffset - mFinalOffset) &gt; 0.0000001f) {
1267                  scheduleUpdate();
1268              }
1269              if (Math.abs(oldOffset - mCurrentOffset) &gt; 0.0000001f) {
1270                  return true;
1271              }
1272              return false;
1273          }
1274  
1275          private float wallpaperOffsetForCurrentScroll() {
1276              if (getChildCount() &lt;= 1) {
1277                  return 0;
1278              }
1279  
1280              // Exclude the leftmost page
1281              int emptyExtraPages = numEmptyScreensToIgnore();
1282              int firstIndex = numCustomPages();
1283              // Exclude the last extra empty screen (if we have &gt; MIN_PARALLAX_PAGE_SPAN pages)
1284              int lastIndex = getChildCount() - 1 - emptyExtraPages;
1285              if (isLayoutRtl()) {
1286                  int temp = firstIndex;
1287                  firstIndex = lastIndex;
1288                  lastIndex = temp;
1289              }
1290  
1291              int firstPageScrollX = getScrollForPage(firstIndex);
1292              int scrollRange = getScrollForPage(lastIndex) - firstPageScrollX;
1293              if (scrollRange == 0) {
1294                  return 0;
1295              } else {
1296                  // TODO: do different behavior if it&#x27;s  a live wallpaper?
1297                  // Sometimes the left parameter of the pages is animated during a layout transition;
1298                  // this parameter offsets it to keep the wallpaper from animating as well
1299                  int adjustedScroll =
1300                          getScrollX() - firstPageScrollX - getLayoutTransitionOffsetForPage(0);
1301                  float offset = Math.min(1, adjustedScroll / (float) scrollRange);
1302                  offset = Math.max(0, offset);
1303                  // Don&#x27;t use up all the wallpaper parallax until you have at least
1304                  // MIN_PARALLAX_PAGE_SPAN pages
1305                  int numScrollingPages = getNumScreensExcludingEmptyAndCustom();
1306                  int parallaxPageSpan = Math.max(MIN_PARALLAX_PAGE_SPAN, numScrollingPages - 1);
1307                  // On RTL devices, push the wallpaper offset to the right if we don&#x27;t have enough
1308                  // pages (ie if numScrollingPages &lt; MIN_PARALLAX_PAGE_SPAN)
1309                  int padding = isLayoutRtl() ? parallaxPageSpan - numScrollingPages + 1 : 0;
1310                  return offset * (padding + numScrollingPages - 1) / parallaxPageSpan;
1311              }
1312          }
1313  
1314          private int numEmptyScreensToIgnore() {
1315              int numScrollingPages = getChildCount() - numCustomPages();
1316              if (numScrollingPages &gt;= MIN_PARALLAX_PAGE_SPAN &amp;&amp; hasExtraEmptyScreen()) {
1317                  return 1;
1318              } else {
1319                  return 0;
1320              }
1321          }
1322  
1323          private int getNumScreensExcludingEmptyAndCustom() {
1324              int numScrollingPages = getChildCount() - numEmptyScreensToIgnore() - numCustomPages();
1325              return numScrollingPages;
1326          }
1327  
1328          public void syncWithScroll() {
1329              float offset = wallpaperOffsetForCurrentScroll();
1330              mWallpaperOffset.setFinalX(offset);
1331              updateOffset(true);
1332          }
1333  
1334          public float getCurrX() {
1335              return mCurrentOffset;
1336          }
1337  
1338          public float getFinalX() {
1339              return mFinalOffset;
1340          }
1341  
1342          private void animateToFinal() {
1343              mAnimating = true;
1344              mAnimationStartOffset = mCurrentOffset;
1345              mAnimationStartTime = System.currentTimeMillis();
1346          }
1347  
1348          private void setWallpaperOffsetSteps() {
1349              // Set wallpaper offset steps (1 / (number of screens - 1))
1350              mWallpaperManager.setWallpaperOffsetSteps(1.0f / (getChildCount() - 1), 1.0f);
1351          }
1352  
1353          public void setFinalX(float x) {
1354              scheduleUpdate();
1355              mFinalOffset = Math.max(0f, Math.min(x, 1.0f));
1356              if (getNumScreensExcludingEmptyAndCustom() != mNumScreens) {
1357                  if (mNumScreens &gt; 0) {
1358                      // Don&#x27;t animate if we&#x27;re going from 0 screens
1359                      animateToFinal();
1360                  }
1361                  mNumScreens = getNumScreensExcludingEmptyAndCustom();
1362              }
1363          }
1364  
1365          private void scheduleUpdate() {
1366              if (!mWaitingForUpdate) {
1367                  mChoreographer.postFrameCallback(this);
1368                  mWaitingForUpdate = true;
1369              }
1370          }
1371  
1372          public void jumpToFinal() {
1373              mCurrentOffset = mFinalOffset;
1374          }
1375      }
1376  
1377      @Override
1378      public void computeScroll() {
1379          super.computeScroll();
1380          mWallpaperOffset.syncWithScroll();
1381      }
1382  
1383      void showOutlines() {
1384          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1385              if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
1386              if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1387              mChildrenOutlineFadeInAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 1.0f);
1388              mChildrenOutlineFadeInAnimation.setDuration(CHILDREN_OUTLINE_FADE_IN_DURATION);
1389              mChildrenOutlineFadeInAnimation.start();
1390          }
1391      }
1392  
1393      void hideOutlines() {
1394          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1395              if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1396              if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
1397              mChildrenOutlineFadeOutAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.0f);
1398              mChildrenOutlineFadeOutAnimation.setDuration(CHILDREN_OUTLINE_FADE_OUT_DURATION);
1399              mChildrenOutlineFadeOutAnimation.setStartDelay(CHILDREN_OUTLINE_FADE_OUT_DELAY);
1400              mChildrenOutlineFadeOutAnimation.start();
1401          }
1402      }
1403  
1404      public void showOutlinesTemporarily() {
1405          if (!mIsPageMoving &amp;&amp; !isTouchActive()) {
1406              snapToPage(mCurrentPage);
1407          }
1408      }
1409  
1410      public void setChildrenOutlineAlpha(float alpha) {
1411          mChildrenOutlineAlpha = alpha;
1412          for (int i = 0; i &lt; getChildCount(); i++) {
1413              CellLayout cl = (CellLayout) getChildAt(i);
1414              cl.setBackgroundAlpha(alpha);
1415          }
1416      }
1417  
1418      public float getChildrenOutlineAlpha() {
1419          return mChildrenOutlineAlpha;
1420      }
1421  
1422      void disableBackground() {
1423          mDrawBackground = false;
1424      }
1425      void enableBackground() {
1426          mDrawBackground = true;
1427      }
1428  
1429      private void animateBackgroundGradient(float finalAlpha, boolean animated) {
1430          if (mBackground == null) return;
1431          if (mBackgroundFadeInAnimation != null) {
1432              mBackgroundFadeInAnimation.cancel();
1433              mBackgroundFadeInAnimation = null;
1434          }
1435          if (mBackgroundFadeOutAnimation != null) {
1436              mBackgroundFadeOutAnimation.cancel();
1437              mBackgroundFadeOutAnimation = null;
1438          }
1439          float startAlpha = getBackgroundAlpha();
1440          if (finalAlpha != startAlpha) {
1441              if (animated) {
1442                  mBackgroundFadeOutAnimation =
1443                          LauncherAnimUtils.ofFloat(this, startAlpha, finalAlpha);
1444                  mBackgroundFadeOutAnimation.addUpdateListener(new AnimatorUpdateListener() {
1445                      public void onAnimationUpdate(ValueAnimator animation) {
1446                          setBackgroundAlpha(((Float) animation.getAnimatedValue()).floatValue());
1447                      }
1448                  });
1449                  mBackgroundFadeOutAnimation.setInterpolator(new DecelerateInterpolator(1.5f));
1450                  mBackgroundFadeOutAnimation.setDuration(BACKGROUND_FADE_OUT_DURATION);
1451                  mBackgroundFadeOutAnimation.start();
1452              } else {
1453                  setBackgroundAlpha(finalAlpha);
1454              }
1455          }
1456      }
1457  
1458      public void setBackgroundAlpha(float alpha) {
1459          if (alpha != mBackgroundAlpha) {
1460              mBackgroundAlpha = alpha;
1461              invalidate();
1462          }
1463      }
1464  
1465      public float getBackgroundAlpha() {
1466          return mBackgroundAlpha;
1467      }
1468  
1469      float backgroundAlphaInterpolator(float r) {
1470          float pivotA = 0.1f;
1471          float pivotB = 0.4f;
1472          if (r &lt; pivotA) {
1473              return 0;
1474          } else if (r &gt; pivotB) {
1475              return 1.0f;
1476          } else {
1477              return (r - pivotA)/(pivotB - pivotA);
1478          }
1479      }
1480  
1481      private void updatePageAlphaValues(int screenCenter) {
1482          boolean isInOverscroll = mOverScrollX &lt; 0 || mOverScrollX &gt; mMaxScrollX;
1483          if (mWorkspaceFadeInAdjacentScreens &amp;&amp;
1484                  mState == State.NORMAL &amp;&amp;
1485                  !mIsSwitchingState &amp;&amp;
1486                  !isInOverscroll) {
1487              for (int i = numCustomPages(); i &lt; getChildCount(); i++) {
1488                  CellLayout child = (CellLayout) getChildAt(i);
1489                  if (child != null) {
1490                      float scrollProgress = getScrollProgress(screenCenter, child, i);
1491                      float alpha = 1 - Math.abs(scrollProgress);
1492                      child.getShortcutsAndWidgets().setAlpha(alpha);
1493                  }
1494              }
1495          }
1496      }
1497  
1498      private void setChildrenBackgroundAlphaMultipliers(float a) {
1499          for (int i = 0; i &lt; getChildCount(); i++) {
1500              CellLayout child = (CellLayout) getChildAt(i);
1501              child.setBackgroundAlphaMultiplier(a);
1502          }
1503      }
1504  
1505      public boolean hasCustomContent() {
1506          return (mScreenOrder.size() &gt; 0 &amp;&amp; mScreenOrder.get(0) == CUSTOM_CONTENT_SCREEN_ID);
1507      }
1508  
1509      public int numCustomPages() {
1510          return hasCustomContent() ? 1 : 0;
1511      }
1512  
1513      public boolean isOnOrMovingToCustomContent() {
1514          return hasCustomContent() &amp;&amp; getNextPage() == 0;
1515      }
1516  
1517      private void updateStateForCustomContent(int screenCenter) {
1518          float translationX = 0;
1519          float progress = 0;
1520          if (hasCustomContent()) {
1521              int index = mScreenOrder.indexOf(CUSTOM_CONTENT_SCREEN_ID);
1522  
1523              int scrollDelta = getScrollX() - getScrollForPage(index) -
1524                      getLayoutTransitionOffsetForPage(index);
1525              float scrollRange = getScrollForPage(index + 1) - getScrollForPage(index);
1526              translationX = scrollRange - scrollDelta;
1527              progress = (scrollRange - scrollDelta) / scrollRange;
1528  
1529              if (isLayoutRtl()) {
1530                  translationX = Math.min(0, translationX);
1531              } else {
1532                  translationX = Math.max(0, translationX);
1533              }
1534              progress = Math.max(0, progress);
1535          }
1536  
1537          if (Float.compare(progress, mLastCustomContentScrollProgress) == 0) return;
1538  
1539          CellLayout cc = mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID);
1540          if (progress &gt; 0 &amp;&amp; cc.getVisibility() != VISIBLE &amp;&amp; !isSmall()) {
1541              cc.setVisibility(VISIBLE);
1542          }
1543  
1544          mLastCustomContentScrollProgress = progress;
1545  
1546          setBackgroundAlpha(progress * 0.8f);
1547  
1548          if (mLauncher.getHotseat() != null) {
1549              mLauncher.getHotseat().setTranslationX(translationX);
1550          }
1551  
1552          if (getPageIndicator() != null) {
1553              getPageIndicator().setTranslationX(translationX);
1554          }
1555  
1556          if (mCustomContentCallbacks != null) {
1557              mCustomContentCallbacks.onScrollProgressChanged(progress);
1558          }
1559      }
1560  
1561      @Override
1562      protected OnClickListener getPageIndicatorClickListener() {
1563          AccessibilityManager am = (AccessibilityManager)
1564                  getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
1565          if (!am.isTouchExplorationEnabled()) {
1566              return null;
1567          }
1568          OnClickListener listener = new OnClickListener() {
1569              @Override
1570              public void onClick(View arg0) {
1571                  enterOverviewMode();
1572              }
1573          };
1574          return listener;
1575      }
1576  
1577      @Override
1578      protected void screenScrolled(int screenCenter) {
1579          final boolean isRtl = isLayoutRtl();
1580          super.screenScrolled(screenCenter);
1581  
1582          updatePageAlphaValues(screenCenter);
1583          updateStateForCustomContent(screenCenter);
1584          enableHwLayersOnVisiblePages();
1585  
1586          boolean shouldOverScroll = (mOverScrollX &lt; 0 &amp;&amp; (!hasCustomContent() || isLayoutRtl())) ||
1587                  (mOverScrollX &gt; mMaxScrollX &amp;&amp; (!hasCustomContent() || !isLayoutRtl()));
1588  
1589          if (shouldOverScroll) {
1590              int index = 0;
1591              float pivotX = 0f;
1592              final float leftBiasedPivot = 0.25f;
1593              final float rightBiasedPivot = 0.75f;
1594              final int lowerIndex = 0;
1595              final int upperIndex = getChildCount() - 1;
1596  
1597              final boolean isLeftPage = mOverScrollX &lt; 0;
1598              index = (!isRtl &amp;&amp; isLeftPage) || (isRtl &amp;&amp; !isLeftPage) ? lowerIndex : upperIndex;
1599              pivotX = isLeftPage ? rightBiasedPivot : leftBiasedPivot;
1600  
1601              CellLayout cl = (CellLayout) getChildAt(index);
1602              float scrollProgress = getScrollProgress(screenCenter, cl, index);
1603              cl.setOverScrollAmount(Math.abs(scrollProgress), isLeftPage);
1604              float rotation = -WORKSPACE_OVERSCROLL_ROTATION * scrollProgress;
1605              cl.setRotationY(rotation);
1606  
1607              if (!mOverscrollTransformsSet || Float.compare(mLastOverscrollPivotX, pivotX) != 0) {
1608                  mOverscrollTransformsSet = true;
1609                  mLastOverscrollPivotX = pivotX;
1610                  cl.setCameraDistance(mDensity * mCameraDistance);
1611                  cl.setPivotX(cl.getMeasuredWidth() * pivotX);
1612                  cl.setPivotY(cl.getMeasuredHeight() * 0.5f);
1613                  cl.setOverscrollTransformsDirty(true);
1614              }
1615          } else {
1616              if (mOverscrollTransformsSet) {
1617                  mOverscrollTransformsSet = false;
1618                  ((CellLayout) getChildAt(0)).resetOverscrollTransforms();
1619                  ((CellLayout) getChildAt(getChildCount() - 1)).resetOverscrollTransforms();
1620              }
1621          }
1622      }
1623  
1624      @Override
1625      protected void overScroll(float amount) {
1626          acceleratedOverScroll(amount);
1627      }
1628  
1629      protected void onAttachedToWindow() {
1630          super.onAttachedToWindow();
1631          mWindowToken = getWindowToken();
1632          computeScroll();
1633          mDragController.setWindowToken(mWindowToken);
1634      }
1635  
1636      protected void onDetachedFromWindow() {
1637          super.onDetachedFromWindow();
1638          mWindowToken = null;
1639      }
1640  
1641      protected void onResume() {
1642          if (getPageIndicator() != null) {
1643              // In case accessibility state has changed, we need to perform this on every
1644              // attach to window
1645              OnClickListener listener = getPageIndicatorClickListener();
1646              if (listener != null) {
1647                  getPageIndicator().setOnClickListener(listener);
1648              }
1649          }
1650          AccessibilityManager am = (AccessibilityManager)
1651                  getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
1652          sAccessibilityEnabled = am.isEnabled();
1653      }
1654  
1655      @Override
1656      protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
1657          if (mFirstLayout &amp;&amp; mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getChildCount()) {
1658              mWallpaperOffset.syncWithScroll();
1659              mWallpaperOffset.jumpToFinal();
1660          }
1661          super.onLayout(changed, left, top, right, bottom);
1662      }
1663  
1664      @Override
1665      protected void onDraw(Canvas canvas) {
1666          // Draw the background gradient if necessary
1667          if (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground) {
1668              int alpha = (int) (mBackgroundAlpha * 255);
1669              mBackground.setAlpha(alpha);
1670              mBackground.setBounds(getScrollX(), 0, getScrollX() + getMeasuredWidth(),
1671                      getMeasuredHeight());
1672              mBackground.draw(canvas);
1673          }
1674  
1675          super.onDraw(canvas);
1676  
1677          // Call back to LauncherModel to finish binding after the first draw
1678          post(mBindPages);
1679      }
1680  
1681      boolean isDrawingBackgroundGradient() {
1682          return (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground);
1683      }
1684  
1685      @Override
1686      protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1687          if (!mLauncher.isAllAppsVisible()) {
1688              final Folder openFolder = getOpenFolder();
1689              if (openFolder != null) {
1690                  return openFolder.requestFocus(direction, previouslyFocusedRect);
1691              } else {
1692                  return super.onRequestFocusInDescendants(direction, previouslyFocusedRect);
1693              }
1694          }
1695          return false;
1696      }
1697  
1698      @Override
1699      public int getDescendantFocusability() {
1700          if (isSmall()) {
1701              return ViewGroup.FOCUS_BLOCK_DESCENDANTS;
1702          }
1703          return super.getDescendantFocusability();
1704      }
1705  
1706      @Override
1707      public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1708          if (!mLauncher.isAllAppsVisible()) {
1709              final Folder openFolder = getOpenFolder();
1710              if (openFolder != null) {
1711                  openFolder.addFocusables(views, direction);
1712              } else {
1713                  super.addFocusables(views, direction, focusableMode);
1714              }
1715          }
1716      }
1717  
1718      public boolean isSmall() {
1719          return mState == State.SMALL || mState == State.SPRING_LOADED || mState == State.OVERVIEW;
1720      }
1721  
1722      void enableChildrenCache(int fromPage, int toPage) {
1723          if (fromPage &gt; toPage) {
1724              final int temp = fromPage;
1725              fromPage = toPage;
1726              toPage = temp;
1727          }
1728  
1729          final int screenCount = getChildCount();
1730  
1731          fromPage = Math.max(fromPage, 0);
1732          toPage = Math.min(toPage, screenCount - 1);
1733  
1734          for (int i = fromPage; i &lt;= toPage; i++) {
1735              final CellLayout layout = (CellLayout) getChildAt(i);
1736              layout.setChildrenDrawnWithCacheEnabled(true);
1737              layout.setChildrenDrawingCacheEnabled(true);
1738          }
1739      }
1740  
1741      void clearChildrenCache() {
1742          final int screenCount = getChildCount();
1743          for (int i = 0; i &lt; screenCount; i++) {
1744              final CellLayout layout = (CellLayout) getChildAt(i);
1745              layout.setChildrenDrawnWithCacheEnabled(false);
1746              // In software mode, we don&#x27;t want the items to continue to be drawn into bitmaps
1747              if (!isHardwareAccelerated()) {
1748                  layout.setChildrenDrawingCacheEnabled(false);
1749              }
1750          }
1751      }
1752  
1753      private void updateChildrenLayersEnabled(boolean force) {
1754          boolean small = mState == State.SMALL || mState == State.OVERVIEW || mIsSwitchingState;
1755          boolean enableChildrenLayers = force || small || mAnimatingViewIntoPlace || isPageMoving();
1756  
1757          if (enableChildrenLayers != mChildrenLayersEnabled) {
1758              mChildrenLayersEnabled = enableChildrenLayers;
1759              if (mChildrenLayersEnabled) {
1760                  enableHwLayersOnVisiblePages();
1761              } else {
1762                  for (int i = 0; i &lt; getPageCount(); i++) {
1763                      final CellLayout cl = (CellLayout) getChildAt(i);
1764                      cl.enableHardwareLayer(false);
1765                  }
1766              }
1767          }
1768      }
1769  
1770      private void enableHwLayersOnVisiblePages() {
1771          if (mChildrenLayersEnabled) {
1772              final int screenCount = getChildCount();
1773              getVisiblePages(mTempVisiblePagesRange);
1774              int leftScreen = mTempVisiblePagesRange[0];
1775              int rightScreen = mTempVisiblePagesRange[1];
1776              if (leftScreen == rightScreen) {
1777                  // make sure we&#x27;re caching at least two pages always
1778                  if (rightScreen &lt; screenCount - 1) {
1779                      rightScreen++;
1780                  } else if (leftScreen &gt; 0) {
1781                      leftScreen--;
1782                  }
1783              }
1784  
1785              final CellLayout customScreen = mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID);
1786              for (int i = 0; i &lt; screenCount; i++) {
1787                  final CellLayout layout = (CellLayout) getPageAt(i);
1788  
1789                  // enable layers between left and right screen inclusive, except for the
1790                  // customScreen, which may animate its content during transitions.
1791                  boolean enableLayer = layout != customScreen &amp;&amp;
1792                          leftScreen &lt;= i &amp;&amp; i &lt;= rightScreen &amp;&amp; shouldDrawChild(layout);
1793                  layout.enableHardwareLayer(enableLayer);
1794              }
1795          }
1796      }
1797  
1798      public void buildPageHardwareLayers() {
1799          // force layers to be enabled just for the call to buildLayer
1800          updateChildrenLayersEnabled(true);
1801          if (getWindowToken() != null) {
1802              final int childCount = getChildCount();
1803              for (int i = 0; i &lt; childCount; i++) {
1804                  CellLayout cl = (CellLayout) getChildAt(i);
1805                  cl.buildHardwareLayer();
1806              }
1807          }
1808          updateChildrenLayersEnabled(false);
1809      }
1810  
1811      protected void onWallpaperTap(MotionEvent ev) {
1812          final int[] position = mTempCell;
1813          getLocationOnScreen(position);
1814  
1815          int pointerIndex = ev.getActionIndex();
1816          position[0] += (int) ev.getX(pointerIndex);
1817          position[1] += (int) ev.getY(pointerIndex);
1818  
1819          mWallpaperManager.sendWallpaperCommand(getWindowToken(),
1820                  ev.getAction() == MotionEvent.ACTION_UP
1821                          ? WallpaperManager.COMMAND_TAP : WallpaperManager.COMMAND_SECONDARY_TAP,
1822                  position[0], position[1], 0, null);
1823      }
1824  
1825      /*
1826       * This interpolator emulates the rate at which the perceived scale of an object changes
1827       * as its distance from a camera increases. When this interpolator is applied to a scale
1828       * animation on a view, it evokes the sense that the object is shrinking due to moving away
1829       * from the camera.
1830       */
1831      static class ZInterpolator implements TimeInterpolator {
1832          private float focalLength;
1833  
1834          public ZInterpolator(float foc) {
1835              focalLength = foc;
1836          }
1837  
1838          public float getInterpolation(float input) {
1839              return (1.0f - focalLength / (focalLength + input)) /
1840                  (1.0f - focalLength / (focalLength + 1.0f));
1841          }
1842      }
1843  
1844      /*
1845       * The exact reverse of ZInterpolator.
1846       */
1847      static class InverseZInterpolator implements TimeInterpolator {
1848          private ZInterpolator zInterpolator;
1849          public InverseZInterpolator(float foc) {
1850              zInterpolator = new ZInterpolator(foc);
1851          }
1852          public float getInterpolation(float input) {
1853              return 1 - zInterpolator.getInterpolation(1 - input);
1854          }
1855      }
1856  
1857      /*
1858       * ZInterpolator compounded with an ease-out.
1859       */
1860      static class ZoomOutInterpolator implements TimeInterpolator {
1861          private final DecelerateInterpolator decelerate = new DecelerateInterpolator(0.75f);
1862          private final ZInterpolator zInterpolator = new ZInterpolator(0.13f);
1863  
1864          public float getInterpolation(float input) {
1865              return decelerate.getInterpolation(zInterpolator.getInterpolation(input));
1866          }
1867      }
1868  
1869      /*
1870       * InvereZInterpolator compounded with an ease-out.
1871       */
1872      static class ZoomInInterpolator implements TimeInterpolator {
1873          private final InverseZInterpolator inverseZInterpolator = new InverseZInterpolator(0.35f);
1874          private final DecelerateInterpolator decelerate = new DecelerateInterpolator(3.0f);
1875  
1876          public float getInterpolation(float input) {
1877              return decelerate.getInterpolation(inverseZInterpolator.getInterpolation(input));
1878          }
1879      }
1880  
1881      private final ZoomInInterpolator mZoomInInterpolator = new ZoomInInterpolator();
1882  
1883      /*
1884      *
1885      * We call these methods (onDragStartedWithItemSpans/onDragStartedWithSize) whenever we
1886      * start a drag in Launcher, regardless of whether the drag has ever entered the Workspace
1887      *
1888      * These methods mark the appropriate pages as accepting drops (which alters their visual
1889      * appearance).
1890      *
1891      */
1892      public void onDragStartedWithItem(View v) {
1893          final Canvas canvas = new Canvas();
1894  
1895          // The outline is used to visualize where the item will land if dropped
1896          mDragOutline = createDragOutline(v, canvas, DRAG_BITMAP_PADDING);
1897      }
1898  
1899      public void onDragStartedWithItem(PendingAddItemInfo info, Bitmap b, boolean clipAlpha) {
1900          final Canvas canvas = new Canvas();
1901  
1902          int[] size = estimateItemSize(info.spanX, info.spanY, info, false);
1903  
1904          // The outline is used to visualize where the item will land if dropped
1905          mDragOutline = createDragOutline(b, canvas, DRAG_BITMAP_PADDING, size[0],
1906                  size[1], clipAlpha);
1907      }
1908  
1909      public void exitWidgetResizeMode() {
1910          DragLayer dragLayer = mLauncher.getDragLayer();
1911          dragLayer.clearAllResizeFrames();
1912      }
1913  
1914      private void initAnimationArrays() {
1915          final int childCount = getChildCount();
1916          if (mLastChildCount == childCount) return;
1917  
1918          mOldBackgroundAlphas = new float[childCount];
1919          mOldAlphas = new float[childCount];
1920          mNewBackgroundAlphas = new float[childCount];
1921          mNewAlphas = new float[childCount];
1922      }
1923  
1924      Animator getChangeStateAnimation(final State state, boolean animated) {
1925          return getChangeStateAnimation(state, animated, 0, -1);
1926      }
1927  
1928      @Override
1929      protected void getOverviewModePages(int[] range) {
1930          int start = numCustomPages();
1931          int end = getChildCount() - 1;
1932  
1933          range[0] = Math.max(0, Math.min(start, getChildCount() - 1));
1934          range[1] = Math.max(0,  end);
1935       }
1936  
1937      protected void onStartReordering() {
1938          super.onStartReordering();
1939          showOutlines();
1940          // Reordering handles its own animations, disable the automatic ones.
1941          disableLayoutTransitions();
1942      }
1943  
1944      protected void onEndReordering() {
1945          super.onEndReordering();
1946  
1947          hideOutlines();
1948          mScreenOrder.clear();
1949          int count = getChildCount();
1950          for (int i = 0; i &lt; count; i++) {
1951              CellLayout cl = ((CellLayout) getChildAt(i));
1952              mScreenOrder.add(getIdForScreen(cl));
1953          }
1954  
1955          mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
1956  
1957          // Re-enable auto layout transitions for page deletion.
1958          enableLayoutTransitions();
1959      }
1960  
1961      public boolean isInOverviewMode() {
1962          return mState == State.OVERVIEW;
1963      }
1964  
1965      public boolean enterOverviewMode() {
1966          if (mTouchState != TOUCH_STATE_REST) {
1967              return false;
1968          }
1969          enableOverviewMode(true, -1, true);
1970          return true;
1971      }
1972  
1973      public void exitOverviewMode(boolean animated) {
1974          exitOverviewMode(-1, animated);
1975      }
1976  
1977      public void exitOverviewMode(int snapPage, boolean animated) {
1978          enableOverviewMode(false, snapPage, animated);
1979      }
1980  
1981      private void enableOverviewMode(boolean enable, int snapPage, boolean animated) {
1982          State finalState = Workspace.State.OVERVIEW;
1983          if (!enable) {
1984              finalState = Workspace.State.NORMAL;
1985          }
1986  
1987          Animator workspaceAnim = getChangeStateAnimation(finalState, animated, 0, snapPage);
1988          if (workspaceAnim != null) {
1989              onTransitionPrepare();
1990              workspaceAnim.addListener(new AnimatorListenerAdapter() {
1991                  @Override
1992                  public void onAnimationEnd(Animator arg0) {
1993                      onTransitionEnd();
1994                  }
1995              });
1996              workspaceAnim.start();
1997          }
1998      }
1999  
2000      int getOverviewModeTranslationY() {
2001          LauncherAppState app = LauncherAppState.getInstance();
2002          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2003          Rect overviewBar = grid.getOverviewModeButtonBarRect();
2004  
2005          int availableHeight = getViewportHeight();
2006          int scaledHeight = (int) (mOverviewModeShrinkFactor * getNormalChildHeight());
2007          int offsetFromTopEdge = (availableHeight - scaledHeight) / 2;
2008          int offsetToCenterInOverview = (availableHeight - mInsets.top - overviewBar.height()
2009                  - scaledHeight) / 2;
2010  
2011          return -offsetFromTopEdge + mInsets.top + offsetToCenterInOverview;
2012      }
2013  
2014      boolean shouldVoiceButtonProxyBeVisible() {
2015          if (isOnOrMovingToCustomContent()) {
2016              return false;
2017          }
2018          if (mState != State.NORMAL) {
2019              return false;
2020          }
2021          return true;
2022      }
2023  
2024      public void updateInteractionForState() {
2025          if (mState != State.NORMAL) {
2026              mLauncher.onInteractionBegin();
2027          } else {
2028              mLauncher.onInteractionEnd();
2029          }
2030      }
2031  
2032      private void setState(State state) {
2033          mState = state;
2034          updateInteractionForState();
2035          updateAccessibilityFlags();
2036      }
2037  
2038      private void updateAccessibilityFlags() {
2039          int accessible = mState == State.NORMAL ?
2040                  ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES :
2041                  ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS;
2042          setImportantForAccessibility(accessible);
2043      }
2044  
2045      Animator getChangeStateAnimation(final State state, boolean animated, int delay, int snapPage) {
2046          if (mState == state) {
2047              return null;
2048          }
2049  
2050          // Initialize animation arrays for the first time if necessary
2051          initAnimationArrays();
2052  
2053          AnimatorSet anim = animated ? LauncherAnimUtils.createAnimatorSet() : null;
2054  
2055          final State oldState = mState;
2056          final boolean oldStateIsNormal = (oldState == State.NORMAL);
2057          final boolean oldStateIsSpringLoaded = (oldState == State.SPRING_LOADED);
2058          final boolean oldStateIsSmall = (oldState == State.SMALL);
2059          final boolean oldStateIsOverview = (oldState == State.OVERVIEW);
2060          setState(state);
2061          final boolean stateIsNormal = (state == State.NORMAL);
2062          final boolean stateIsSpringLoaded = (state == State.SPRING_LOADED);
2063          final boolean stateIsSmall = (state == State.SMALL);
2064          final boolean stateIsOverview = (state == State.OVERVIEW);
2065          float finalBackgroundAlpha = (stateIsSpringLoaded || stateIsOverview) ? 1.0f : 0f;
2066          float finalHotseatAndPageIndicatorAlpha = (stateIsOverview || stateIsSmall) ? 0f : 1f;
2067          float finalOverviewPanelAlpha = stateIsOverview ? 1f : 0f;
2068          float finalSearchBarAlpha = !stateIsNormal ? 0f : 1f;
2069          float finalWorkspaceTranslationY = stateIsOverview ? getOverviewModeTranslationY() : 0;
2070  
2071          boolean workspaceToAllApps = (oldStateIsNormal &amp;&amp; stateIsSmall);
2072          boolean allAppsToWorkspace = (oldStateIsSmall &amp;&amp; stateIsNormal);
2073          boolean workspaceToOverview = (oldStateIsNormal &amp;&amp; stateIsOverview);
2074          boolean overviewToWorkspace = (oldStateIsOverview &amp;&amp; stateIsNormal);
2075  
2076          mNewScale = 1.0f;
2077  
2078          if (oldStateIsOverview) {
2079              disableFreeScroll(snapPage);
2080          } else if (stateIsOverview) {
2081              enableFreeScroll();
2082          }
2083  
2084          if (state != State.NORMAL) {
2085              if (stateIsSpringLoaded) {
2086                  mNewScale = mSpringLoadedShrinkFactor;
2087              } else if (stateIsOverview) {
2088                  mNewScale = mOverviewModeShrinkFactor;
2089              } else if (stateIsSmall){
2090                  mNewScale = mOverviewModeShrinkFactor - 0.3f;
2091              }
2092              if (workspaceToAllApps) {
2093                  updateChildrenLayersEnabled(false);
2094              }
2095          }
2096  
2097          final int duration;
2098          if (workspaceToAllApps) {
2099              duration = getResources().getInteger(R.integer.config_workspaceUnshrinkTime);
2100          } else if (workspaceToOverview || overviewToWorkspace) {
2101              duration = getResources().getInteger(R.integer.config_overviewTransitionTime);
2102          } else {
2103              duration = getResources().getInteger(R.integer.config_appsCustomizeWorkspaceShrinkTime);
2104          }
2105  
2106          for (int i = 0; i &lt; getChildCount(); i++) {
2107              final CellLayout cl = (CellLayout) getChildAt(i);
2108              boolean isCurrentPage = (i == getNextPage());
2109              float initialAlpha = cl.getShortcutsAndWidgets().getAlpha();
2110              float finalAlpha;
2111              if (stateIsSmall) {
2112                  finalAlpha = 0f;
2113              } else if (stateIsNormal &amp;&amp; mWorkspaceFadeInAdjacentScreens) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2114 -                finalAlpha = i == getNextPage() ? 1f : 0f;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2115 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2116 +                finalAlpha = (i == getNextPage() || i &lt; numCustomPages()) ? 1f : 0f;</span>
2117              } else {
2118                  finalAlpha = 1f;
2119              }
2120  
2121              // If we are animating to/from the small state, then hide the side pages and fade the
2122              // current page in
2123              if (!mIsSwitchingState) {
2124                  if (workspaceToAllApps || allAppsToWorkspace) {
2125                      if (allAppsToWorkspace &amp;&amp; isCurrentPage) {
2126                          initialAlpha = 0f;
2127                      } else if (!isCurrentPage) {
2128                          initialAlpha = finalAlpha = 0f;
2129                      }
2130                      cl.setShortcutAndWidgetAlpha(initialAlpha);
2131                  }
2132              }
2133  
2134              mOldAlphas[i] = initialAlpha;
2135              mNewAlphas[i] = finalAlpha;
2136              if (animated) {
2137                  mOldBackgroundAlphas[i] = cl.getBackgroundAlpha();
2138                  mNewBackgroundAlphas[i] = finalBackgroundAlpha;
2139              } else {
2140                  cl.setBackgroundAlpha(finalBackgroundAlpha);
2141                  cl.setShortcutAndWidgetAlpha(finalAlpha);
2142              }
2143          }
2144  
2145          final View searchBar = mLauncher.getQsbBar();
2146          final View overviewPanel = mLauncher.getOverviewPanel();
2147          final View hotseat = mLauncher.getHotseat();
2148          if (animated) {
2149              anim.setDuration(duration);
2150              LauncherViewPropertyAnimator scale = new LauncherViewPropertyAnimator(this);
2151              scale.scaleX(mNewScale)
2152                  .scaleY(mNewScale)
2153                  .translationY(finalWorkspaceTranslationY)
2154                  .setInterpolator(mZoomInInterpolator);
2155              anim.play(scale);
2156              for (int index = 0; index &lt; getChildCount(); index++) {
2157                  final int i = index;
2158                  final CellLayout cl = (CellLayout) getChildAt(i);
2159                  float currentAlpha = cl.getShortcutsAndWidgets().getAlpha();
2160                  if (mOldAlphas[i] == 0 &amp;&amp; mNewAlphas[i] == 0) {
2161                      cl.setBackgroundAlpha(mNewBackgroundAlphas[i]);
2162                      cl.setShortcutAndWidgetAlpha(mNewAlphas[i]);
2163                  } else {
2164                      if (mOldAlphas[i] != mNewAlphas[i] || currentAlpha != mNewAlphas[i]) {
2165                          LauncherViewPropertyAnimator alphaAnim =
2166                              new LauncherViewPropertyAnimator(cl.getShortcutsAndWidgets());
2167                          alphaAnim.alpha(mNewAlphas[i])
2168                              .setInterpolator(mZoomInInterpolator);
2169                          anim.play(alphaAnim);
2170                      }
2171                      if (mOldBackgroundAlphas[i] != 0 ||
2172                          mNewBackgroundAlphas[i] != 0) {
2173                          ValueAnimator bgAnim =
2174                                  LauncherAnimUtils.ofFloat(cl, 0f, 1f);
2175                          bgAnim.setInterpolator(mZoomInInterpolator);
2176                          bgAnim.addUpdateListener(new LauncherAnimatorUpdateListener() {
2177                                  public void onAnimationUpdate(float a, float b) {
2178                                      cl.setBackgroundAlpha(
2179                                              a * mOldBackgroundAlphas[i] +
2180                                              b * mNewBackgroundAlphas[i]);
2181                                  }
2182                              });
2183                          anim.play(bgAnim);
2184                      }
2185                  }
2186              }
2187              ObjectAnimator pageIndicatorAlpha = null;
2188              if (getPageIndicator() != null) {
2189                  pageIndicatorAlpha = ObjectAnimator.ofFloat(getPageIndicator(), &quot;alpha&quot;,
2190                          finalHotseatAndPageIndicatorAlpha);
2191              }
2192              ObjectAnimator hotseatAlpha = ObjectAnimator.ofFloat(hotseat, &quot;alpha&quot;,
2193                      finalHotseatAndPageIndicatorAlpha);
2194              ObjectAnimator searchBarAlpha = ObjectAnimator.ofFloat(searchBar,
2195                      &quot;alpha&quot;, finalSearchBarAlpha);
2196              ObjectAnimator overviewPanelAlpha = ObjectAnimator.ofFloat(overviewPanel,
2197                      &quot;alpha&quot;, finalOverviewPanelAlpha);
2198  
2199              overviewPanelAlpha.addListener(new AlphaUpdateListener(overviewPanel));
2200              hotseatAlpha.addListener(new AlphaUpdateListener(hotseat));
2201              searchBarAlpha.addListener(new AlphaUpdateListener(searchBar));
2202  
2203              if (workspaceToOverview) {
2204                  hotseatAlpha.setInterpolator(new DecelerateInterpolator(2));
2205              } else if (overviewToWorkspace) {
2206                  overviewPanelAlpha.setInterpolator(new DecelerateInterpolator(2));
2207              }
2208  
2209              if (getPageIndicator() != null) {
2210                  pageIndicatorAlpha.addListener(new AlphaUpdateListener(getPageIndicator()));
2211              }
2212  
2213              anim.play(overviewPanelAlpha);
2214              anim.play(hotseatAlpha);
2215              anim.play(searchBarAlpha);
2216              anim.play(pageIndicatorAlpha);
2217              anim.setStartDelay(delay);
2218          } else {
2219              overviewPanel.setAlpha(finalOverviewPanelAlpha);
2220              AlphaUpdateListener.updateVisibility(overviewPanel);
2221              hotseat.setAlpha(finalHotseatAndPageIndicatorAlpha);
2222              AlphaUpdateListener.updateVisibility(hotseat);
2223              if (getPageIndicator() != null) {
2224                  getPageIndicator().setAlpha(finalHotseatAndPageIndicatorAlpha);
2225                  AlphaUpdateListener.updateVisibility(getPageIndicator());
2226              }
2227              searchBar.setAlpha(finalSearchBarAlpha);
2228              AlphaUpdateListener.updateVisibility(searchBar);
2229              updateCustomContentVisibility();
2230              setScaleX(mNewScale);
2231              setScaleY(mNewScale);
2232              setTranslationY(finalWorkspaceTranslationY);
2233          }
2234          mLauncher.updateVoiceButtonProxyVisible(false);
2235  
2236          if (stateIsSpringLoaded) {
2237              // Right now we&#x27;re covered by Apps Customize
2238              // Show the background gradient immediately, so the gradient will
2239              // be showing once AppsCustomize disappears
2240              animateBackgroundGradient(getResources().getInteger(
2241                      R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100f, false);
2242          } else if (stateIsOverview) {
2243              animateBackgroundGradient(getResources().getInteger(
2244                      R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100f, true);
2245          } else {
2246              // Fade the background gradient away
2247              animateBackgroundGradient(0f, animated);
2248          }
2249          return anim;
2250      }
2251  
2252      static class AlphaUpdateListener implements AnimatorUpdateListener, AnimatorListener {
2253          View view;
2254          public AlphaUpdateListener(View v) {
2255              view = v;
2256          }
2257  
2258          @Override
2259          public void onAnimationUpdate(ValueAnimator arg0) {
2260              updateVisibility(view);
2261          }
2262  
2263          public static void updateVisibility(View view) {
2264              // We want to avoid the extra layout pass by setting the views to GONE unless
2265              // accessibility is on, in which case not setting them to GONE causes a glitch.
2266              int invisibleState = sAccessibilityEnabled ? GONE : INVISIBLE;
2267              if (view.getAlpha() &lt; ALPHA_CUTOFF_THRESHOLD &amp;&amp; view.getVisibility() != invisibleState) {
2268                  view.setVisibility(invisibleState);
2269              } else if (view.getAlpha() &gt; ALPHA_CUTOFF_THRESHOLD
2270                      &amp;&amp; view.getVisibility() != VISIBLE) {
2271                  view.setVisibility(VISIBLE);
2272              }
2273          }
2274  
2275          @Override
2276          public void onAnimationCancel(Animator arg0) {
2277          }
2278  
2279          @Override
2280          public void onAnimationEnd(Animator arg0) {
2281              updateVisibility(view);
2282          }
2283  
2284          @Override
2285          public void onAnimationRepeat(Animator arg0) {
2286          }
2287  
2288          @Override
2289          public void onAnimationStart(Animator arg0) {
2290              // We want the views to be visible for animation, so fade-in/out is visible
2291              view.setVisibility(VISIBLE);
2292          }
2293      }
2294  
2295      @Override
2296      public void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace) {
2297          onTransitionPrepare();
2298      }
2299  
2300      @Override
2301      public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
2302      }
2303  
2304      @Override
2305      public void onLauncherTransitionStep(Launcher l, float t) {
2306          mTransitionProgress = t;
2307      }
2308  
2309      @Override
2310      public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
2311          onTransitionEnd();
2312      }
2313  
2314      private void onTransitionPrepare() {
2315          mIsSwitchingState = true;
2316  
2317          // Invalidate here to ensure that the pages are rendered during the state change transition.
2318          invalidate();
2319  
2320          updateChildrenLayersEnabled(false);
2321          hideCustomContentIfNecessary();
2322      }
2323  
2324      void updateCustomContentVisibility() {
2325          int visibility = mState == Workspace.State.NORMAL ? VISIBLE : INVISIBLE;
2326          if (hasCustomContent()) {
2327              mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(visibility);
2328          }
2329      }
2330  
2331      void showCustomContentIfNecessary() {
2332          boolean show  = mState == Workspace.State.NORMAL;
2333          if (show &amp;&amp; hasCustomContent()) {
2334              mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(VISIBLE);
2335          }
2336      }
2337  
2338      void hideCustomContentIfNecessary() {
2339          boolean hide  = mState != Workspace.State.NORMAL;
2340          if (hide &amp;&amp; hasCustomContent()) {
2341              mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(INVISIBLE);
2342          }
2343      }
2344  
2345      private void onTransitionEnd() {
2346          mIsSwitchingState = false;
2347          updateChildrenLayersEnabled(false);
2348          // The code in getChangeStateAnimation to determine initialAlpha and finalAlpha will ensure
2349          // ensure that only the current page is visible during (and subsequently, after) the
2350          // transition animation.  If fade adjacent pages is disabled, then re-enable the page
2351          // visibility after the transition animation.
2352          if (!mWorkspaceFadeInAdjacentScreens) {
2353              for (int i = 0; i &lt; getChildCount(); i++) {
2354                  final CellLayout cl = (CellLayout) getChildAt(i);
2355                  cl.setShortcutAndWidgetAlpha(1f);
2356              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2357 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2358 +            for (int i = 0; i &lt; numCustomPages(); i++) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2359 +                final CellLayout cl = (CellLayout) getChildAt(i);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2360 +                cl.setShortcutAndWidgetAlpha(1f);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2361 +            }</span>
2362          }
2363          showCustomContentIfNecessary();
2364      }
2365  
2366      @Override
2367      public View getContent() {
2368          return this;
2369      }
2370  
2371      /**
2372       * Draw the View v into the given Canvas.
2373       *
2374       * @param v the view to draw
2375       * @param destCanvas the canvas to draw on
2376       * @param padding the horizontal and vertical padding to use when drawing
2377       */
2378      private void drawDragView(View v, Canvas destCanvas, int padding, boolean pruneToDrawable) {
2379          final Rect clipRect = mTempRect;
2380          v.getDrawingRect(clipRect);
2381  
2382          boolean textVisible = false;
2383  
2384          destCanvas.save();
2385          if (v instanceof TextView &amp;&amp; pruneToDrawable) {
2386              Drawable d = ((TextView) v).getCompoundDrawables()[1];
2387              clipRect.set(0, 0, d.getIntrinsicWidth() + padding, d.getIntrinsicHeight() + padding);
2388              destCanvas.translate(padding / 2, padding / 2);
2389              d.draw(destCanvas);
2390          } else {
2391              if (v instanceof FolderIcon) {
2392                  // For FolderIcons the text can bleed into the icon area, and so we need to
2393                  // hide the text completely (which can&#x27;t be achieved by clipping).
2394                  if (((FolderIcon) v).getTextVisible()) {
2395                      ((FolderIcon) v).setTextVisible(false);
2396                      textVisible = true;
2397                  }
2398              } else if (v instanceof BubbleTextView) {
2399                  final BubbleTextView tv = (BubbleTextView) v;
2400                  clipRect.bottom = tv.getExtendedPaddingTop() - (int) BubbleTextView.PADDING_V +
2401                          tv.getLayout().getLineTop(0);
2402              } else if (v instanceof TextView) {
2403                  final TextView tv = (TextView) v;
2404                  clipRect.bottom = tv.getExtendedPaddingTop() - tv.getCompoundDrawablePadding() +
2405                          tv.getLayout().getLineTop(0);
2406              }
2407              destCanvas.translate(-v.getScrollX() + padding / 2, -v.getScrollY() + padding / 2);
2408              destCanvas.clipRect(clipRect, Op.REPLACE);
2409              v.draw(destCanvas);
2410  
2411              // Restore text visibility of FolderIcon if necessary
2412              if (textVisible) {
2413                  ((FolderIcon) v).setTextVisible(true);
2414              }
2415          }
2416          destCanvas.restore();
2417      }
2418  
2419      /**
2420       * Returns a new bitmap to show when the given View is being dragged around.
2421       * Responsibility for the bitmap is transferred to the caller.
2422       */
2423      public Bitmap createDragBitmap(View v, Canvas canvas, int padding) {
2424          Bitmap b;
2425  
2426          if (v instanceof TextView) {
2427              Drawable d = ((TextView) v).getCompoundDrawables()[1];
2428              b = Bitmap.createBitmap(d.getIntrinsicWidth() + padding,
2429                      d.getIntrinsicHeight() + padding, Bitmap.Config.ARGB_8888);
2430          } else {
2431              b = Bitmap.createBitmap(
2432                      v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
2433          }
2434  
2435          canvas.setBitmap(b);
2436          drawDragView(v, canvas, padding, true);
2437          canvas.setBitmap(null);
2438  
2439          return b;
2440      }
2441  
2442      /**
2443       * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
2444       * Responsibility for the bitmap is transferred to the caller.
2445       */
2446      private Bitmap createDragOutline(View v, Canvas canvas, int padding) {
2447          final int outlineColor = getResources().getColor(R.color.outline_color);
2448          final Bitmap b = Bitmap.createBitmap(
2449                  v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
2450  
2451          canvas.setBitmap(b);
2452          drawDragView(v, canvas, padding, true);
2453          mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
2454          canvas.setBitmap(null);
2455          return b;
2456      }
2457  
2458      /**
2459       * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
2460       * Responsibility for the bitmap is transferred to the caller.
2461       */
2462      private Bitmap createDragOutline(Bitmap orig, Canvas canvas, int padding, int w, int h,
2463              boolean clipAlpha) {
2464          final int outlineColor = getResources().getColor(R.color.outline_color);
2465          final Bitmap b = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
2466          canvas.setBitmap(b);
2467  
2468          Rect src = new Rect(0, 0, orig.getWidth(), orig.getHeight());
2469          float scaleFactor = Math.min((w - padding) / (float) orig.getWidth(),
2470                  (h - padding) / (float) orig.getHeight());
2471          int scaledWidth = (int) (scaleFactor * orig.getWidth());
2472          int scaledHeight = (int) (scaleFactor * orig.getHeight());
2473          Rect dst = new Rect(0, 0, scaledWidth, scaledHeight);
2474  
2475          // center the image
2476          dst.offset((w - scaledWidth) / 2, (h - scaledHeight) / 2);
2477  
2478          canvas.drawBitmap(orig, src, dst, null);
2479          mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor,
2480                  clipAlpha);
2481          canvas.setBitmap(null);
2482  
2483          return b;
2484      }
2485  
2486      void startDrag(CellLayout.CellInfo cellInfo) {
2487          View child = cellInfo.cell;
2488  
2489          // Make sure the drag was started by a long press as opposed to a long click.
2490          if (!child.isInTouchMode()) {
2491              return;
2492          }
2493  
2494          mDragInfo = cellInfo;
2495          child.setVisibility(INVISIBLE);
2496          CellLayout layout = (CellLayout) child.getParent().getParent();
2497          layout.prepareChildForDrag(child);
2498  
2499          child.clearFocus();
2500          child.setPressed(false);
2501  
2502          final Canvas canvas = new Canvas();
2503  
2504          // The outline is used to visualize where the item will land if dropped
2505          mDragOutline = createDragOutline(child, canvas, DRAG_BITMAP_PADDING);
2506          beginDragShared(child, this);
2507      }
2508  
2509      public void beginDragShared(View child, DragSource source) {
2510          // The drag bitmap follows the touch point around on the screen
2511          final Bitmap b = createDragBitmap(child, new Canvas(), DRAG_BITMAP_PADDING);
2512  
2513          final int bmpWidth = b.getWidth();
2514          final int bmpHeight = b.getHeight();
2515  
2516          float scale = mLauncher.getDragLayer().getLocationInDragLayer(child, mTempXY);
2517          int dragLayerX =
2518                  Math.round(mTempXY[0] - (bmpWidth - scale * child.getWidth()) / 2);
2519          int dragLayerY =
2520                  Math.round(mTempXY[1] - (bmpHeight - scale * bmpHeight) / 2
2521                          - DRAG_BITMAP_PADDING / 2);
2522  
2523          LauncherAppState app = LauncherAppState.getInstance();
2524          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2525          Point dragVisualizeOffset = null;
2526          Rect dragRect = null;
2527          if (child instanceof BubbleTextView || child instanceof PagedViewIcon) {
2528              int iconSize = grid.iconSizePx;
2529              int top = child.getPaddingTop();
2530              int left = (bmpWidth - iconSize) / 2;
2531              int right = left + iconSize;
2532              int bottom = top + iconSize;
2533              dragLayerY += top;
2534              // Note: The drag region is used to calculate drag layer offsets, but the
2535              // dragVisualizeOffset in addition to the dragRect (the size) to position the outline.
2536              dragVisualizeOffset = new Point(-DRAG_BITMAP_PADDING / 2, DRAG_BITMAP_PADDING / 2);
2537              dragRect = new Rect(left, top, right, bottom);
2538          } else if (child instanceof FolderIcon) {
2539              int previewSize = grid.folderIconSizePx;
2540              dragRect = new Rect(0, child.getPaddingTop(), child.getWidth(), previewSize);
2541          }
2542  
2543          // Clear the pressed state if necessary
2544          if (child instanceof BubbleTextView) {
2545              BubbleTextView icon = (BubbleTextView) child;
2546              icon.clearPressedOrFocusedBackground();
2547          }
2548  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2549 +        if (child.getTag() == null || !(child.getTag() instanceof ItemInfo)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2550 +            String msg = &quot;Drag started with a view that has no tag set. This &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2551 +                    + &quot;will cause a crash (issue 11627249) down the line. &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2552 +                    + &quot;View: &quot; + child + &quot;  tag: &quot; + child.getTag();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2553 +            throw new IllegalStateException(msg);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2554 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2555 +</span>
2556          mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),

2557                  DragController.DRAG_ACTION_MOVE, dragVisualizeOffset, dragRect, scale);

2558  
2559          if (child.getParent() instanceof ShortcutAndWidgetContainer) {
2560              mDragSourceInternal = (ShortcutAndWidgetContainer) child.getParent();
2561          }
2562  
2563          b.recycle();
2564      }
2565  
2566      void addApplicationShortcut(ShortcutInfo info, CellLayout target, long container, long screenId,
2567              int cellX, int cellY, boolean insertAtFirst, int intersectX, int intersectY) {
2568          View view = mLauncher.createShortcut(R.layout.application, target, (ShortcutInfo) info);
2569  
2570          final int[] cellXY = new int[2];
2571          target.findCellForSpanThatIntersects(cellXY, 1, 1, intersectX, intersectY);
2572          addInScreen(view, container, screenId, cellXY[0], cellXY[1], 1, 1, insertAtFirst);
2573  
2574          LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screenId, cellXY[0],
2575                  cellXY[1]);
2576      }
2577  
2578      public boolean transitionStateShouldAllowDrop() {
2579          return ((!isSwitchingState() || mTransitionProgress &gt; 0.5f) &amp;&amp; mState != State.SMALL);
2580      }
2581  
2582      /**
2583       * {@inheritDoc}
2584       */
2585      public boolean acceptDrop(DragObject d) {
2586          // If it&#x27;s an external drop (e.g. from All Apps), check if it should be accepted
2587          CellLayout dropTargetLayout = mDropToLayout;
2588          if (d.dragSource != this) {
2589              // Don&#x27;t accept the drop if we&#x27;re not over a screen at time of drop
2590              if (dropTargetLayout == null) {
2591                  return false;
2592              }
2593              if (!transitionStateShouldAllowDrop()) return false;
2594  
2595              mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
2596                      d.dragView, mDragViewVisualCenter);
2597  
2598              // We want the point to be mapped to the dragTarget.
2599              if (mLauncher.isHotseatLayout(dropTargetLayout)) {
2600                  mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
2601              } else {
2602                  mapPointFromSelfToChild(dropTargetLayout, mDragViewVisualCenter, null);
2603              }
2604  
2605              int spanX = 1;
2606              int spanY = 1;
2607              if (mDragInfo != null) {
2608                  final CellLayout.CellInfo dragCellInfo = mDragInfo;
2609                  spanX = dragCellInfo.spanX;
2610                  spanY = dragCellInfo.spanY;
2611              } else {
2612                  final ItemInfo dragInfo = (ItemInfo) d.dragInfo;
2613                  spanX = dragInfo.spanX;
2614                  spanY = dragInfo.spanY;
2615              }
2616  
2617              int minSpanX = spanX;
2618              int minSpanY = spanY;
2619              if (d.dragInfo instanceof PendingAddWidgetInfo) {
2620                  minSpanX = ((PendingAddWidgetInfo) d.dragInfo).minSpanX;
2621                  minSpanY = ((PendingAddWidgetInfo) d.dragInfo).minSpanY;
2622              }
2623  
2624              mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
2625                      (int) mDragViewVisualCenter[1], minSpanX, minSpanY, dropTargetLayout,
2626                      mTargetCell);
2627              float distance = dropTargetLayout.getDistanceFromCell(mDragViewVisualCenter[0],
2628                      mDragViewVisualCenter[1], mTargetCell);
2629              if (willCreateUserFolder((ItemInfo) d.dragInfo, dropTargetLayout,
2630                      mTargetCell, distance, true)) {
2631                  return true;
2632              }
2633              if (willAddToExistingUserFolder((ItemInfo) d.dragInfo, dropTargetLayout,
2634                      mTargetCell, distance)) {
2635                  return true;
2636              }
2637  
2638              int[] resultSpan = new int[2];
2639              mTargetCell = dropTargetLayout.createArea((int) mDragViewVisualCenter[0],
2640                      (int) mDragViewVisualCenter[1], minSpanX, minSpanY, spanX, spanY,
2641                      null, mTargetCell, resultSpan, CellLayout.MODE_ACCEPT_DROP);
2642              boolean foundCell = mTargetCell[0] &gt;= 0 &amp;&amp; mTargetCell[1] &gt;= 0;
2643  
2644              // Don&#x27;t accept the drop if there&#x27;s no room for the item
2645              if (!foundCell) {
2646                  // Don&#x27;t show the message if we are dropping on the AllApps button and the hotseat
2647                  // is full
2648                  boolean isHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
2649                  if (mTargetCell != null &amp;&amp; isHotseat) {
2650                      Hotseat hotseat = mLauncher.getHotseat();
2651                      if (hotseat.isAllAppsButtonRank(
2652                              hotseat.getOrderInHotseat(mTargetCell[0], mTargetCell[1]))) {
2653                          return false;
2654                      }
2655                  }
2656  
2657                  mLauncher.showOutOfSpaceMessage(isHotseat);
2658                  return false;
2659              }
2660          }
2661  
2662          long screenId = getIdForScreen(dropTargetLayout);
2663          if (screenId == EXTRA_EMPTY_SCREEN_ID) {
2664              commitExtraEmptyScreen();
2665          }
2666  
2667          return true;
2668      }
2669  
2670      boolean willCreateUserFolder(ItemInfo info, CellLayout target, int[] targetCell, float
2671              distance, boolean considerTimeout) {
2672          if (distance &gt; mMaxDistanceForFolderCreation) return false;
2673          View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2674  
2675          if (dropOverView != null) {
2676              CellLayout.LayoutParams lp = (CellLayout.LayoutParams) dropOverView.getLayoutParams();
2677              if (lp.useTmpCoords &amp;&amp; (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.tmpCellY)) {
2678                  return false;
2679              }
2680          }
2681  
2682          boolean hasntMoved = false;
2683          if (mDragInfo != null) {
2684              hasntMoved = dropOverView == mDragInfo.cell;
2685          }
2686  
2687          if (dropOverView == null || hasntMoved || (considerTimeout &amp;&amp; !mCreateUserFolderOnDrop)) {
2688              return false;
2689          }
2690  
2691          boolean aboveShortcut = (dropOverView.getTag() instanceof ShortcutInfo);
2692          boolean willBecomeShortcut =
2693                  (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
2694                  info.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT);
2695  
2696          return (aboveShortcut &amp;&amp; willBecomeShortcut);
2697      }
2698  
2699      boolean willAddToExistingUserFolder(Object dragInfo, CellLayout target, int[] targetCell,
2700              float distance) {
2701          if (distance &gt; mMaxDistanceForFolderCreation) return false;
2702          View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2703  
2704          if (dropOverView != null) {
2705              CellLayout.LayoutParams lp = (CellLayout.LayoutParams) dropOverView.getLayoutParams();
2706              if (lp.useTmpCoords &amp;&amp; (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.tmpCellY)) {
2707                  return false;
2708              }
2709          }
2710  
2711          if (dropOverView instanceof FolderIcon) {
2712              FolderIcon fi = (FolderIcon) dropOverView;
2713              if (fi.acceptDrop(dragInfo)) {
2714                  return true;
2715              }
2716          }
2717          return false;
2718      }
2719  
2720      boolean createUserFolderIfNecessary(View newView, long container, CellLayout target,
2721              int[] targetCell, float distance, boolean external, DragView dragView,
2722              Runnable postAnimationRunnable) {
2723          if (distance &gt; mMaxDistanceForFolderCreation) return false;
2724          View v = target.getChildAt(targetCell[0], targetCell[1]);
2725  
2726          boolean hasntMoved = false;
2727          if (mDragInfo != null) {
2728              CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2729              hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2730                      mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2731          }
2732  
2733          if (v == null || hasntMoved || !mCreateUserFolderOnDrop) return false;
2734          mCreateUserFolderOnDrop = false;
2735          final long screenId = (targetCell == null) ? mDragInfo.screenId : getIdForScreen(target);
2736  
2737          boolean aboveShortcut = (v.getTag() instanceof ShortcutInfo);
2738          boolean willBecomeShortcut = (newView.getTag() instanceof ShortcutInfo);
2739  
2740          if (aboveShortcut &amp;&amp; willBecomeShortcut) {
2741              ShortcutInfo sourceInfo = (ShortcutInfo) newView.getTag();
2742              ShortcutInfo destInfo = (ShortcutInfo) v.getTag();
2743              // if the drag started here, we need to remove it from the workspace
2744              if (!external) {
2745                  getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2746              }
2747  
2748              Rect folderLocation = new Rect();
2749              float scale = mLauncher.getDragLayer().getDescendantRectRelativeToSelf(v, folderLocation);
2750              target.removeView(v);
2751  
2752              FolderIcon fi =
2753                  mLauncher.addFolder(target, container, screenId, targetCell[0], targetCell[1]);
2754              destInfo.cellX = -1;
2755              destInfo.cellY = -1;
2756              sourceInfo.cellX = -1;
2757              sourceInfo.cellY = -1;
2758  
2759              // If the dragView is null, we can&#x27;t animate
2760              boolean animate = dragView != null;
2761              if (animate) {
2762                  fi.performCreateAnimation(destInfo, v, sourceInfo, dragView, folderLocation, scale,
2763                          postAnimationRunnable);
2764              } else {
2765                  fi.addItem(destInfo);
2766                  fi.addItem(sourceInfo);
2767              }
2768              return true;
2769          }
2770          return false;
2771      }
2772  
2773      boolean addToExistingFolderIfNecessary(View newView, CellLayout target, int[] targetCell,
2774              float distance, DragObject d, boolean external) {
2775          if (distance &gt; mMaxDistanceForFolderCreation) return false;
2776  
2777          View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2778          if (!mAddToExistingFolderOnDrop) return false;
2779          mAddToExistingFolderOnDrop = false;
2780  
2781          if (dropOverView instanceof FolderIcon) {
2782              FolderIcon fi = (FolderIcon) dropOverView;
2783              if (fi.acceptDrop(d.dragInfo)) {
2784                  fi.onDrop(d);
2785  
2786                  // if the drag started here, we need to remove it from the workspace
2787                  if (!external) {
2788                      getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2789                  }
2790                  return true;
2791              }
2792          }
2793          return false;
2794      }
2795  
2796      public void onDrop(final DragObject d) {
2797          mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView,
2798                  mDragViewVisualCenter);
2799  
2800          CellLayout dropTargetLayout = mDropToLayout;
2801  
2802          // We want the point to be mapped to the dragTarget.
2803          if (dropTargetLayout != null) {
2804              if (mLauncher.isHotseatLayout(dropTargetLayout)) {
2805                  mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
2806              } else {
2807                  mapPointFromSelfToChild(dropTargetLayout, mDragViewVisualCenter, null);
2808              }
2809          }
2810  
2811          int snapScreen = -1;
2812          boolean resizeOnDrop = false;
2813          if (d.dragSource != this) {
2814              final int[] touchXY = new int[] { (int) mDragViewVisualCenter[0],
2815                      (int) mDragViewVisualCenter[1] };
2816              onDropExternal(touchXY, d.dragInfo, dropTargetLayout, false, d);
2817          } else if (mDragInfo != null) {
2818              final View cell = mDragInfo.cell;
2819  
2820              Runnable resizeRunnable = null;
2821              if (dropTargetLayout != null &amp;&amp; !d.cancelled) {
2822                  // Move internally
2823                  boolean hasMovedLayouts = (getParentCellLayoutForView(cell) != dropTargetLayout);
2824                  boolean hasMovedIntoHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
2825                  long container = hasMovedIntoHotseat ?
2826                          LauncherSettings.Favorites.CONTAINER_HOTSEAT :
2827                          LauncherSettings.Favorites.CONTAINER_DESKTOP;
2828                  long screenId = (mTargetCell[0] &lt; 0) ?
2829                          mDragInfo.screenId : getIdForScreen(dropTargetLayout);
2830                  int spanX = mDragInfo != null ? mDragInfo.spanX : 1;
2831                  int spanY = mDragInfo != null ? mDragInfo.spanY : 1;
2832                  // First we find the cell nearest to point at which the item is
2833                  // dropped, without any consideration to whether there is an item there.
2834  
2835                  mTargetCell = findNearestArea((int) mDragViewVisualCenter[0], (int)
2836                          mDragViewVisualCenter[1], spanX, spanY, dropTargetLayout, mTargetCell);
2837                  float distance = dropTargetLayout.getDistanceFromCell(mDragViewVisualCenter[0],
2838                          mDragViewVisualCenter[1], mTargetCell);
2839  
2840                  // If the item being dropped is a shortcut and the nearest drop
2841                  // cell also contains a shortcut, then create a folder with the two shortcuts.
2842                  if (!mInScrollArea &amp;&amp; createUserFolderIfNecessary(cell, container,
2843                          dropTargetLayout, mTargetCell, distance, false, d.dragView, null)) {
2844                      removeExtraEmptyScreen(true, null, 0, true);
2845                      return;
2846                  }
2847  
2848                  if (addToExistingFolderIfNecessary(cell, dropTargetLayout, mTargetCell,
2849                          distance, d, false)) {
2850                      removeExtraEmptyScreen(true, null, 0, true);
2851                      return;
2852                  }
2853  
2854                  // Aside from the special case where we&#x27;re dropping a shortcut onto a shortcut,
2855                  // we need to find the nearest cell location that is vacant
2856                  ItemInfo item = (ItemInfo) d.dragInfo;
2857                  int minSpanX = item.spanX;
2858                  int minSpanY = item.spanY;
2859                  if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
2860                      minSpanX = item.minSpanX;
2861                      minSpanY = item.minSpanY;
2862                  }
2863  
2864                  int[] resultSpan = new int[2];
2865                  mTargetCell = dropTargetLayout.createArea((int) mDragViewVisualCenter[0],
2866                          (int) mDragViewVisualCenter[1], minSpanX, minSpanY, spanX, spanY, cell,
2867                          mTargetCell, resultSpan, CellLayout.MODE_ON_DROP);
2868  
2869                  boolean foundCell = mTargetCell[0] &gt;= 0 &amp;&amp; mTargetCell[1] &gt;= 0;
2870  
2871                  // if the widget resizes on drop
2872                  if (foundCell &amp;&amp; (cell instanceof AppWidgetHostView) &amp;&amp;
2873                          (resultSpan[0] != item.spanX || resultSpan[1] != item.spanY)) {
2874                      resizeOnDrop = true;
2875                      item.spanX = resultSpan[0];
2876                      item.spanY = resultSpan[1];
2877                      AppWidgetHostView awhv = (AppWidgetHostView) cell;
2878                      AppWidgetResizeFrame.updateWidgetSizeRanges(awhv, mLauncher, resultSpan[0],
2879                              resultSpan[1]);
2880                  }
2881  
2882                  if (getScreenIdForPageIndex(mCurrentPage) != screenId &amp;&amp; !hasMovedIntoHotseat) {
2883                      snapScreen = getPageIndexForScreenId(screenId);
2884                      snapToPage(snapScreen);
2885                  }
2886  
2887                  if (foundCell) {
2888                      final ItemInfo info = (ItemInfo) cell.getTag();
2889                      if (hasMovedLayouts) {
2890                          // Reparent the view
2891                          getParentCellLayoutForView(cell).removeView(cell);
2892                          addInScreen(cell, container, screenId, mTargetCell[0], mTargetCell[1],
2893                                  info.spanX, info.spanY);
2894                      }
2895  
2896                      // update the item&#x27;s position after drop
2897                      CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();
2898                      lp.cellX = lp.tmpCellX = mTargetCell[0];
2899                      lp.cellY = lp.tmpCellY = mTargetCell[1];
2900                      lp.cellHSpan = item.spanX;
2901                      lp.cellVSpan = item.spanY;
2902                      lp.isLockedToGrid = true;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2903 -                    cell.setId(LauncherModel.getCellLayoutChildId(container, mDragInfo.screenId,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2904 -                            mTargetCell[0], mTargetCell[1], mDragInfo.spanX, mDragInfo.spanY));</span>
2905  
2906                      if (container != LauncherSettings.Favorites.CONTAINER_HOTSEAT &amp;&amp;
2907                              cell instanceof LauncherAppWidgetHostView) {
2908                          final CellLayout cellLayout = dropTargetLayout;
2909                          // We post this call so that the widget has a chance to be placed
2910                          // in its final location
2911  
2912                          final LauncherAppWidgetHostView hostView = (LauncherAppWidgetHostView) cell;
2913                          AppWidgetProviderInfo pinfo = hostView.getAppWidgetInfo();
2914                          if (pinfo != null &amp;&amp;
2915                                  pinfo.resizeMode != AppWidgetProviderInfo.RESIZE_NONE) {
2916                              final Runnable addResizeFrame = new Runnable() {
2917                                  public void run() {
2918                                      DragLayer dragLayer = mLauncher.getDragLayer();
2919                                      dragLayer.addResizeFrame(info, hostView, cellLayout);
2920                                  }
2921                              };
2922                              resizeRunnable = (new Runnable() {
2923                                  public void run() {
2924                                      if (!isPageMoving()) {
2925                                          addResizeFrame.run();
2926                                      } else {
2927                                          mDelayedResizeRunnable = addResizeFrame;
2928                                      }
2929                                  }
2930                              });
2931                          }
2932                      }
2933  
2934                      LauncherModel.modifyItemInDatabase(mLauncher, info, container, screenId, lp.cellX,
2935                              lp.cellY, item.spanX, item.spanY);
2936                  } else {
2937                      // If we can&#x27;t find a drop location, we return the item to its original position
2938                      CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();
2939                      mTargetCell[0] = lp.cellX;
2940                      mTargetCell[1] = lp.cellY;
2941                      CellLayout layout = (CellLayout) cell.getParent().getParent();
2942                      layout.markCellsAsOccupiedForView(cell);
2943                  }
2944              }
2945  
2946              final CellLayout parent = (CellLayout) cell.getParent().getParent();
2947              final Runnable finalResizeRunnable = resizeRunnable;
2948              // Prepare it to be animated into its new position
2949              // This must be called after the view has been re-parented
2950              final Runnable onCompleteRunnable = new Runnable() {
2951                  @Override
2952                  public void run() {
2953                      mAnimatingViewIntoPlace = false;
2954                      updateChildrenLayersEnabled(false);
2955                      if (finalResizeRunnable != null) {
2956                          finalResizeRunnable.run();
2957                      }
2958                      removeExtraEmptyScreen(true, null, 0, true);
2959                  }
2960              };
2961              mAnimatingViewIntoPlace = true;
2962              if (d.dragView.hasDrawn()) {
2963                  final ItemInfo info = (ItemInfo) cell.getTag();
2964                  if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET) {
2965                      int animationType = resizeOnDrop ? ANIMATE_INTO_POSITION_AND_RESIZE :
2966                              ANIMATE_INTO_POSITION_AND_DISAPPEAR;
2967                      animateWidgetDrop(info, parent, d.dragView,
2968                              onCompleteRunnable, animationType, cell, false);
2969                  } else {
2970                      int duration = snapScreen &lt; 0 ? -1 : ADJACENT_SCREEN_DROP_DURATION;
2971                      mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, cell, duration,
2972                              onCompleteRunnable, this);
2973                  }
2974              } else {
2975                  d.deferDragViewCleanupPostAnimation = false;
2976                  cell.setVisibility(VISIBLE);
2977              }
2978              parent.onDropChild(cell);
2979          }
2980      }
2981  
2982      public void setFinalScrollForPageChange(int pageIndex) {
2983          CellLayout cl = (CellLayout) getChildAt(pageIndex);
2984          if (cl != null) {
2985              mSavedScrollX = getScrollX();
2986              mSavedTranslationX = cl.getTranslationX();
2987              mSavedRotationY = cl.getRotationY();
2988              final int newX = getScrollForPage(pageIndex);
2989              setScrollX(newX);
2990              cl.setTranslationX(0f);
2991              cl.setRotationY(0f);
2992          }
2993      }
2994  
2995      public void resetFinalScrollForPageChange(int pageIndex) {
2996          if (pageIndex &gt;= 0) {
2997              CellLayout cl = (CellLayout) getChildAt(pageIndex);
2998              setScrollX(mSavedScrollX);
2999              cl.setTranslationX(mSavedTranslationX);
3000              cl.setRotationY(mSavedRotationY);
3001          }
3002      }
3003  
3004      public void getViewLocationRelativeToSelf(View v, int[] location) {
3005          getLocationInWindow(location);
3006          int x = location[0];
3007          int y = location[1];
3008  
3009          v.getLocationInWindow(location);
3010          int vX = location[0];
3011          int vY = location[1];
3012  
3013          location[0] = vX - x;
3014          location[1] = vY - y;
3015      }
3016  
3017      public void onDragEnter(DragObject d) {
3018          mDragEnforcer.onDragEnter();
3019          mCreateUserFolderOnDrop = false;
3020          mAddToExistingFolderOnDrop = false;
3021  
3022          mDropToLayout = null;
3023          CellLayout layout = getCurrentDropLayout();
3024          setCurrentDropLayout(layout);
3025          setCurrentDragOverlappingLayout(layout);
3026  
3027          // Because we don&#x27;t have space in the Phone UI (the CellLayouts run to the edge) we
3028          // don&#x27;t need to show the outlines
3029          if (LauncherAppState.getInstance().isScreenLarge()) {
3030              showOutlines();
3031          }
3032      }
3033  
3034      /** Return a rect that has the cellWidth/cellHeight (left, top), and
3035       * widthGap/heightGap (right, bottom) */
3036      static Rect getCellLayoutMetrics(Launcher launcher, int orientation) {
3037          LauncherAppState app = LauncherAppState.getInstance();
3038          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
3039  
3040          Resources res = launcher.getResources();
3041          Display display = launcher.getWindowManager().getDefaultDisplay();
3042          Point smallestSize = new Point();
3043          Point largestSize = new Point();
3044          display.getCurrentSizeRange(smallestSize, largestSize);
3045          int countX = (int) grid.numColumns;
3046          int countY = (int) grid.numRows;
3047          int constrainedLongEdge = largestSize.y;
3048          int constrainedShortEdge = smallestSize.y;
3049          if (orientation == CellLayout.LANDSCAPE) {
3050              if (mLandscapeCellLayoutMetrics == null) {
3051                  Rect padding = grid.getWorkspacePadding(CellLayout.LANDSCAPE);
3052                  int width = constrainedLongEdge - padding.left - padding.right;
3053                  int height = constrainedShortEdge - padding.top - padding.bottom;
3054                  mLandscapeCellLayoutMetrics = new Rect();
3055                  mLandscapeCellLayoutMetrics.set(
3056                          grid.calculateCellWidth(width, countX),
3057                          grid.calculateCellHeight(height, countY), 0, 0);
3058              }
3059              return mLandscapeCellLayoutMetrics;
3060          } else if (orientation == CellLayout.PORTRAIT) {
3061              if (mPortraitCellLayoutMetrics == null) {
3062                  Rect padding = grid.getWorkspacePadding(CellLayout.PORTRAIT);
3063                  int width = constrainedShortEdge - padding.left - padding.right;
3064                  int height = constrainedLongEdge - padding.top - padding.bottom;
3065                  mPortraitCellLayoutMetrics = new Rect();
3066                  mPortraitCellLayoutMetrics.set(
3067                          grid.calculateCellWidth(width, countX),
3068                          grid.calculateCellHeight(height, countY), 0, 0);
3069              }
3070              return mPortraitCellLayoutMetrics;
3071          }
3072          return null;
3073      }
3074  
3075      public void onDragExit(DragObject d) {
3076          mDragEnforcer.onDragExit();
3077  
3078          // Here we store the final page that will be dropped to, if the workspace in fact
3079          // receives the drop
3080          if (mInScrollArea) {
3081              if (isPageMoving()) {
3082                  // If the user drops while the page is scrolling, we should use that page as the
3083                  // destination instead of the page that is being hovered over.
3084                  mDropToLayout = (CellLayout) getPageAt(getNextPage());
3085              } else {
3086                  mDropToLayout = mDragOverlappingLayout;
3087              }
3088          } else {
3089              mDropToLayout = mDragTargetLayout;
3090          }
3091  
3092          if (mDragMode == DRAG_MODE_CREATE_FOLDER) {
3093              mCreateUserFolderOnDrop = true;
3094          } else if (mDragMode == DRAG_MODE_ADD_TO_FOLDER) {
3095              mAddToExistingFolderOnDrop = true;
3096          }
3097  
3098          // Reset the scroll area and previous drag target
3099          onResetScrollArea();
3100          setCurrentDropLayout(null);
3101          setCurrentDragOverlappingLayout(null);
3102  
3103          mSpringLoadedDragController.cancel();
3104  
3105          if (!mIsPageMoving) {
3106              hideOutlines();
3107          }
3108      }
3109  
3110      void setCurrentDropLayout(CellLayout layout) {
3111          if (mDragTargetLayout != null) {
3112              mDragTargetLayout.revertTempState();
3113              mDragTargetLayout.onDragExit();
3114          }
3115          mDragTargetLayout = layout;
3116          if (mDragTargetLayout != null) {
3117              mDragTargetLayout.onDragEnter();
3118          }
3119          cleanupReorder(true);
3120          cleanupFolderCreation();
3121          setCurrentDropOverCell(-1, -1);
3122      }
3123  
3124      void setCurrentDragOverlappingLayout(CellLayout layout) {
3125          if (mDragOverlappingLayout != null) {
3126              mDragOverlappingLayout.setIsDragOverlapping(false);
3127          }
3128          mDragOverlappingLayout = layout;
3129          if (mDragOverlappingLayout != null) {
3130              mDragOverlappingLayout.setIsDragOverlapping(true);
3131          }
3132          invalidate();
3133      }
3134  
3135      void setCurrentDropOverCell(int x, int y) {
3136          if (x != mDragOverX || y != mDragOverY) {
3137              mDragOverX = x;
3138              mDragOverY = y;
3139              setDragMode(DRAG_MODE_NONE);
3140          }
3141      }
3142  
3143      void setDragMode(int dragMode) {
3144          if (dragMode != mDragMode) {
3145              if (dragMode == DRAG_MODE_NONE) {
3146                  cleanupAddToFolder();
3147                  // We don&#x27;t want to cancel the re-order alarm every time the target cell changes
3148                  // as this feels to slow / unresponsive.
3149                  cleanupReorder(false);
3150                  cleanupFolderCreation();
3151              } else if (dragMode == DRAG_MODE_ADD_TO_FOLDER) {
3152                  cleanupReorder(true);
3153                  cleanupFolderCreation();
3154              } else if (dragMode == DRAG_MODE_CREATE_FOLDER) {
3155                  cleanupAddToFolder();
3156                  cleanupReorder(true);
3157              } else if (dragMode == DRAG_MODE_REORDER) {
3158                  cleanupAddToFolder();
3159                  cleanupFolderCreation();
3160              }
3161              mDragMode = dragMode;
3162          }
3163      }
3164  
3165      private void cleanupFolderCreation() {
3166          if (mDragFolderRingAnimator != null) {
3167              mDragFolderRingAnimator.animateToNaturalState();
3168              mDragFolderRingAnimator = null;
3169          }
3170          mFolderCreationAlarm.setOnAlarmListener(null);
3171          mFolderCreationAlarm.cancelAlarm();
3172      }
3173  
3174      private void cleanupAddToFolder() {
3175          if (mDragOverFolderIcon != null) {
3176              mDragOverFolderIcon.onDragExit(null);
3177              mDragOverFolderIcon = null;
3178          }
3179      }
3180  
3181      private void cleanupReorder(boolean cancelAlarm) {
3182          // Any pending reorders are canceled
3183          if (cancelAlarm) {
3184              mReorderAlarm.cancelAlarm();
3185          }
3186          mLastReorderX = -1;
3187          mLastReorderY = -1;
3188      }
3189  
3190     /*
3191      *
3192      * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
3193      * coordinate space. The argument xy is modified with the return result.
3194      *
3195      * if cachedInverseMatrix is not null, this method will just use that matrix instead of
3196      * computing it itself; we use this to avoid redundant matrix inversions in
3197      * findMatchingPageForDragOver
3198      *
3199      */
3200     void mapPointFromSelfToChild(View v, float[] xy, Matrix cachedInverseMatrix) {
3201         xy[0] = xy[0] - v.getLeft();
3202         xy[1] = xy[1] - v.getTop();
3203     }
3204  
3205     boolean isPointInSelfOverHotseat(int x, int y, Rect r) {
3206         if (r == null) {
3207             r = new Rect();
3208         }
3209         mTempPt[0] = x;
3210         mTempPt[1] = y;
3211         mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(this, mTempPt, true);
3212  
3213         LauncherAppState app = LauncherAppState.getInstance();
3214         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
3215         r = grid.getHotseatRect();
3216         if (r.contains(mTempPt[0], mTempPt[1])) {
3217             return true;
3218         }
3219         return false;
3220     }
3221  
3222     void mapPointFromSelfToHotseatLayout(Hotseat hotseat, float[] xy) {
3223         mTempPt[0] = (int) xy[0];
3224         mTempPt[1] = (int) xy[1];
3225         mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(this, mTempPt, true);
3226         mLauncher.getDragLayer().mapCoordInSelfToDescendent(hotseat.getLayout(), mTempPt);
3227  
3228         xy[0] = mTempPt[0];
3229         xy[1] = mTempPt[1];
3230     }
3231  
3232     /*
3233      *
3234      * Convert the 2D coordinate xy from this CellLayout&#x27;s coordinate space to
3235      * the parent View&#x27;s coordinate space. The argument xy is modified with the return result.
3236      *
3237      */
3238     void mapPointFromChildToSelf(View v, float[] xy) {
3239         xy[0] += v.getLeft();
3240         xy[1] += v.getTop();
3241     }
3242  
3243     static private float squaredDistance(float[] point1, float[] point2) {
3244          float distanceX = point1[0] - point2[0];
3245          float distanceY = point2[1] - point2[1];
3246          return distanceX * distanceX + distanceY * distanceY;
3247     }
3248  
3249      /*
3250       *
3251       * This method returns the CellLayout that is currently being dragged to. In order to drag
3252       * to a CellLayout, either the touch point must be directly over the CellLayout, or as a second
3253       * strategy, we see if the dragView is overlapping any CellLayout and choose the closest one
3254       *
3255       * Return null if no CellLayout is currently being dragged over
3256       *
3257       */
3258      private CellLayout findMatchingPageForDragOver(
3259              DragView dragView, float originX, float originY, boolean exact) {
3260          // We loop through all the screens (ie CellLayouts) and see which ones overlap
3261          // with the item being dragged and then choose the one that&#x27;s closest to the touch point
3262          final int screenCount = getChildCount();
3263          CellLayout bestMatchingScreen = null;
3264          float smallestDistSoFar = Float.MAX_VALUE;
3265  
3266          for (int i = 0; i &lt; screenCount; i++) {
3267              // The custom content screen is not a valid drag over option
3268              if (mScreenOrder.get(i) == CUSTOM_CONTENT_SCREEN_ID) {
3269                  continue;
3270              }
3271  
3272              CellLayout cl = (CellLayout) getChildAt(i);
3273  
3274              final float[] touchXy = {originX, originY};
3275              // Transform the touch coordinates to the CellLayout&#x27;s local coordinates
3276              // If the touch point is within the bounds of the cell layout, we can return immediately
3277              cl.getMatrix().invert(mTempInverseMatrix);
3278              mapPointFromSelfToChild(cl, touchXy, mTempInverseMatrix);
3279  
3280              if (touchXy[0] &gt;= 0 &amp;&amp; touchXy[0] &lt;= cl.getWidth() &amp;&amp;
3281                      touchXy[1] &gt;= 0 &amp;&amp; touchXy[1] &lt;= cl.getHeight()) {
3282                  return cl;
3283              }
3284  
3285              if (!exact) {
3286                  // Get the center of the cell layout in screen coordinates
3287                  final float[] cellLayoutCenter = mTempCellLayoutCenterCoordinates;
3288                  cellLayoutCenter[0] = cl.getWidth()/2;
3289                  cellLayoutCenter[1] = cl.getHeight()/2;
3290                  mapPointFromChildToSelf(cl, cellLayoutCenter);
3291  
3292                  touchXy[0] = originX;
3293                  touchXy[1] = originY;
3294  
3295                  // Calculate the distance between the center of the CellLayout
3296                  // and the touch point
3297                  float dist = squaredDistance(touchXy, cellLayoutCenter);
3298  
3299                  if (dist &lt; smallestDistSoFar) {
3300                      smallestDistSoFar = dist;
3301                      bestMatchingScreen = cl;
3302                  }
3303              }
3304          }
3305          return bestMatchingScreen;
3306      }
3307  
3308      // This is used to compute the visual center of the dragView. This point is then
3309      // used to visualize drop locations and determine where to drop an item. The idea is that
3310      // the visual center represents the user&#x27;s interpretation of where the item is, and hence
3311      // is the appropriate point to use when determining drop location.
3312      private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
3313              DragView dragView, float[] recycle) {
3314          float res[];
3315          if (recycle == null) {
3316              res = new float[2];
3317          } else {
3318              res = recycle;
3319          }
3320  
3321          // First off, the drag view has been shifted in a way that is not represented in the
3322          // x and y values or the x/yOffsets. Here we account for that shift.
3323          x += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetX);
3324          y += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
3325  
3326          // These represent the visual top and left of drag view if a dragRect was provided.
3327          // If a dragRect was not provided, then they correspond to the actual view left and
3328          // top, as the dragRect is in that case taken to be the entire dragView.
3329          // R.dimen.dragViewOffsetY.
3330          int left = x - xOffset;
3331          int top = y - yOffset;
3332  
3333          // In order to find the visual center, we shift by half the dragRect
3334          res[0] = left + dragView.getDragRegion().width() / 2;
3335          res[1] = top + dragView.getDragRegion().height() / 2;
3336  
3337          return res;
3338      }
3339  
3340      private boolean isDragWidget(DragObject d) {
3341          return (d.dragInfo instanceof LauncherAppWidgetInfo ||
3342                  d.dragInfo instanceof PendingAddWidgetInfo);
3343      }
3344      private boolean isExternalDragWidget(DragObject d) {
3345          return d.dragSource != this &amp;&amp; isDragWidget(d);
3346      }
3347  
3348      public void onDragOver(DragObject d) {
3349          // Skip drag over events while we are dragging over side pages
3350          if (mInScrollArea || mIsSwitchingState || mState == State.SMALL) return;
3351  
3352          Rect r = new Rect();
3353          CellLayout layout = null;
3354          ItemInfo item = (ItemInfo) d.dragInfo;
3355  
3356          // Ensure that we have proper spans for the item that we are dropping
3357          if (item.spanX &lt; 0 || item.spanY &lt; 0) throw new RuntimeException(&quot;Improper spans found&quot;);
3358          mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
3359              d.dragView, mDragViewVisualCenter);
3360  
3361          final View child = (mDragInfo == null) ? null : mDragInfo.cell;
3362          // Identify whether we have dragged over a side page
3363          if (isSmall()) {
3364              if (mLauncher.getHotseat() != null &amp;&amp; !isExternalDragWidget(d)) {
3365                  if (isPointInSelfOverHotseat(d.x, d.y, r)) {
3366                      layout = mLauncher.getHotseat().getLayout();
3367                  }
3368              }
3369              if (layout == null) {
3370                  layout = findMatchingPageForDragOver(d.dragView, d.x, d.y, false);
3371              }
3372              if (layout != mDragTargetLayout) {
3373                  setCurrentDropLayout(layout);
3374                  setCurrentDragOverlappingLayout(layout);
3375  
3376                  boolean isInSpringLoadedMode = (mState == State.SPRING_LOADED);
3377                  if (isInSpringLoadedMode) {
3378                      if (mLauncher.isHotseatLayout(layout)) {
3379                          mSpringLoadedDragController.cancel();
3380                      } else {
3381                          mSpringLoadedDragController.setAlarm(mDragTargetLayout);
3382                      }
3383                  }
3384              }
3385          } else {
3386              // Test to see if we are over the hotseat otherwise just use the current page
3387              if (mLauncher.getHotseat() != null &amp;&amp; !isDragWidget(d)) {
3388                  if (isPointInSelfOverHotseat(d.x, d.y, r)) {
3389                      layout = mLauncher.getHotseat().getLayout();
3390                  }
3391              }
3392              if (layout == null) {
3393                  layout = getCurrentDropLayout();
3394              }
3395              if (layout != mDragTargetLayout) {
3396                  setCurrentDropLayout(layout);
3397                  setCurrentDragOverlappingLayout(layout);
3398              }
3399          }
3400  
3401          // Handle the drag over
3402          if (mDragTargetLayout != null) {
3403              // We want the point to be mapped to the dragTarget.
3404              if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
3405                  mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
3406              } else {
3407                  mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
3408              }
3409  
3410              ItemInfo info = (ItemInfo) d.dragInfo;
3411  
3412              int minSpanX = item.spanX;
3413              int minSpanY = item.spanY;
3414              if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
3415                  minSpanX = item.minSpanX;
3416                  minSpanY = item.minSpanY;
3417              }
3418  
3419              mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
3420                      (int) mDragViewVisualCenter[1], minSpanX, minSpanY,
3421                      mDragTargetLayout, mTargetCell);
3422              int reorderX = mTargetCell[0];
3423              int reorderY = mTargetCell[1];
3424  
3425              setCurrentDropOverCell(mTargetCell[0], mTargetCell[1]);
3426  
3427              float targetCellDistance = mDragTargetLayout.getDistanceFromCell(
3428                      mDragViewVisualCenter[0], mDragViewVisualCenter[1], mTargetCell);
3429  
3430              final View dragOverView = mDragTargetLayout.getChildAt(mTargetCell[0],
3431                      mTargetCell[1]);
3432  
3433              manageFolderFeedback(info, mDragTargetLayout, mTargetCell,
3434                      targetCellDistance, dragOverView);
3435  
3436              boolean nearestDropOccupied = mDragTargetLayout.isNearestDropLocationOccupied((int)
3437                      mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1], item.spanX,
3438                      item.spanY, child, mTargetCell);
3439  
3440              if (!nearestDropOccupied) {
3441                  mDragTargetLayout.visualizeDropLocation(child, mDragOutline,
3442                          (int) mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1],
3443                          mTargetCell[0], mTargetCell[1], item.spanX, item.spanY, false,
3444                          d.dragView.getDragVisualizeOffset(), d.dragView.getDragRegion());
3445              } else if ((mDragMode == DRAG_MODE_NONE || mDragMode == DRAG_MODE_REORDER)
3446                      &amp;&amp; !mReorderAlarm.alarmPending() &amp;&amp; (mLastReorderX != reorderX ||
3447                      mLastReorderY != reorderY)) {
3448  
3449                  // Otherwise, if we aren&#x27;t adding to or creating a folder and there&#x27;s no pending
3450                  // reorder, then we schedule a reorder
3451                  ReorderAlarmListener listener = new ReorderAlarmListener(mDragViewVisualCenter,
3452                          minSpanX, minSpanY, item.spanX, item.spanY, d.dragView, child);
3453                  mReorderAlarm.setOnAlarmListener(listener);
3454                  mReorderAlarm.setAlarm(REORDER_TIMEOUT);
3455              }
3456  
3457              if (mDragMode == DRAG_MODE_CREATE_FOLDER || mDragMode == DRAG_MODE_ADD_TO_FOLDER ||
3458                      !nearestDropOccupied) {
3459                  if (mDragTargetLayout != null) {
3460                      mDragTargetLayout.revertTempState();
3461                  }
3462              }
3463          }
3464      }
3465  
3466      private void manageFolderFeedback(ItemInfo info, CellLayout targetLayout,
3467              int[] targetCell, float distance, View dragOverView) {
3468          boolean userFolderPending = willCreateUserFolder(info, targetLayout, targetCell, distance,
3469                  false);
3470  
3471          if (mDragMode == DRAG_MODE_NONE &amp;&amp; userFolderPending &amp;&amp;
3472                  !mFolderCreationAlarm.alarmPending()) {
3473              mFolderCreationAlarm.setOnAlarmListener(new
3474                      FolderCreationAlarmListener(targetLayout, targetCell[0], targetCell[1]));
3475              mFolderCreationAlarm.setAlarm(FOLDER_CREATION_TIMEOUT);
3476              return;
3477          }
3478  
3479          boolean willAddToFolder =
3480                  willAddToExistingUserFolder(info, targetLayout, targetCell, distance);
3481  
3482          if (willAddToFolder &amp;&amp; mDragMode == DRAG_MODE_NONE) {
3483              mDragOverFolderIcon = ((FolderIcon) dragOverView);
3484              mDragOverFolderIcon.onDragEnter(info);
3485              if (targetLayout != null) {
3486                  targetLayout.clearDragOutlines();
3487              }
3488              setDragMode(DRAG_MODE_ADD_TO_FOLDER);
3489              return;
3490          }
3491  
3492          if (mDragMode == DRAG_MODE_ADD_TO_FOLDER &amp;&amp; !willAddToFolder) {
3493              setDragMode(DRAG_MODE_NONE);
3494          }
3495          if (mDragMode == DRAG_MODE_CREATE_FOLDER &amp;&amp; !userFolderPending) {
3496              setDragMode(DRAG_MODE_NONE);
3497          }
3498  
3499          return;
3500      }
3501  
3502      class FolderCreationAlarmListener implements OnAlarmListener {
3503          CellLayout layout;
3504          int cellX;
3505          int cellY;
3506  
3507          public FolderCreationAlarmListener(CellLayout layout, int cellX, int cellY) {
3508              this.layout = layout;
3509              this.cellX = cellX;
3510              this.cellY = cellY;
3511          }
3512  
3513          public void onAlarm(Alarm alarm) {
3514              if (mDragFolderRingAnimator != null) {
3515                  // This shouldn&#x27;t happen ever, but just in case, make sure we clean up the mess.
3516                  mDragFolderRingAnimator.animateToNaturalState();
3517              }
3518              mDragFolderRingAnimator = new FolderRingAnimator(mLauncher, null);
3519              mDragFolderRingAnimator.setCell(cellX, cellY);
3520              mDragFolderRingAnimator.setCellLayout(layout);
3521              mDragFolderRingAnimator.animateToAcceptState();
3522              layout.showFolderAccept(mDragFolderRingAnimator);
3523              layout.clearDragOutlines();
3524              setDragMode(DRAG_MODE_CREATE_FOLDER);
3525          }
3526      }
3527  
3528      class ReorderAlarmListener implements OnAlarmListener {
3529          float[] dragViewCenter;
3530          int minSpanX, minSpanY, spanX, spanY;
3531          DragView dragView;
3532          View child;
3533  
3534          public ReorderAlarmListener(float[] dragViewCenter, int minSpanX, int minSpanY, int spanX,
3535                  int spanY, DragView dragView, View child) {
3536              this.dragViewCenter = dragViewCenter;
3537              this.minSpanX = minSpanX;
3538              this.minSpanY = minSpanY;
3539              this.spanX = spanX;
3540              this.spanY = spanY;
3541              this.child = child;
3542              this.dragView = dragView;
3543          }
3544  
3545          public void onAlarm(Alarm alarm) {
3546              int[] resultSpan = new int[2];
3547              mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
3548                      (int) mDragViewVisualCenter[1], minSpanX, minSpanY, mDragTargetLayout,
3549                      mTargetCell);
3550              mLastReorderX = mTargetCell[0];
3551              mLastReorderY = mTargetCell[1];
3552  
3553              mTargetCell = mDragTargetLayout.createArea((int) mDragViewVisualCenter[0],
3554                  (int) mDragViewVisualCenter[1], minSpanX, minSpanY, spanX, spanY,
3555                  child, mTargetCell, resultSpan, CellLayout.MODE_DRAG_OVER);
3556  
3557              if (mTargetCell[0] &lt; 0 || mTargetCell[1] &lt; 0) {
3558                  mDragTargetLayout.revertTempState();
3559              } else {
3560                  setDragMode(DRAG_MODE_REORDER);
3561              }
3562  
3563              boolean resize = resultSpan[0] != spanX || resultSpan[1] != spanY;
3564              mDragTargetLayout.visualizeDropLocation(child, mDragOutline,
3565                  (int) mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1],
3566                  mTargetCell[0], mTargetCell[1], resultSpan[0], resultSpan[1], resize,
3567                  dragView.getDragVisualizeOffset(), dragView.getDragRegion());
3568          }
3569      }
3570  
3571      @Override
3572      public void getHitRectRelativeToDragLayer(Rect outRect) {
3573          // We want the workspace to have the whole area of the display (it will find the correct
3574          // cell layout to drop to in the existing drag/drop logic.
3575          mLauncher.getDragLayer().getDescendantRectRelativeToSelf(this, outRect);
3576      }
3577  
3578      /**
3579       * Add the item specified by dragInfo to the given layout.
3580       * @return true if successful
3581       */
3582      public boolean addExternalItemToScreen(ItemInfo dragInfo, CellLayout layout) {
3583          if (layout.findCellForSpan(mTempEstimate, dragInfo.spanX, dragInfo.spanY)) {
3584              onDropExternal(dragInfo.dropPos, (ItemInfo) dragInfo, (CellLayout) layout, false);
3585              return true;
3586          }
3587          mLauncher.showOutOfSpaceMessage(mLauncher.isHotseatLayout(layout));
3588          return false;
3589      }
3590  
3591      private void onDropExternal(int[] touchXY, Object dragInfo,
3592              CellLayout cellLayout, boolean insertAtFirst) {
3593          onDropExternal(touchXY, dragInfo, cellLayout, insertAtFirst, null);
3594      }
3595  
3596      /**
3597       * Drop an item that didn&#x27;t originate on one of the workspace screens.
3598       * It may have come from Launcher (e.g. from all apps or customize), or it may have
3599       * come from another app altogether.
3600       *
3601       * NOTE: This can also be called when we are outside of a drag event, when we want
3602       * to add an item to one of the workspace screens.
3603       */
3604      private void onDropExternal(final int[] touchXY, final Object dragInfo,
3605              final CellLayout cellLayout, boolean insertAtFirst, DragObject d) {
3606          final Runnable exitSpringLoadedRunnable = new Runnable() {
3607              @Override
3608              public void run() {
3609                  removeExtraEmptyScreen(false, new Runnable() {
3610                      @Override
3611                      public void run() {
3612                          mLauncher.exitSpringLoadedDragModeDelayed(true,
3613                                  Launcher.EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
3614                      }
3615                  });
3616              }
3617          };
3618  
3619          ItemInfo info = (ItemInfo) dragInfo;
3620          int spanX = info.spanX;
3621          int spanY = info.spanY;
3622          if (mDragInfo != null) {
3623              spanX = mDragInfo.spanX;
3624              spanY = mDragInfo.spanY;
3625          }
3626  
3627          final long container = mLauncher.isHotseatLayout(cellLayout) ?
3628                  LauncherSettings.Favorites.CONTAINER_HOTSEAT :
3629                      LauncherSettings.Favorites.CONTAINER_DESKTOP;
3630          final long screenId = getIdForScreen(cellLayout);
3631          if (!mLauncher.isHotseatLayout(cellLayout)
3632                  &amp;&amp; screenId != getScreenIdForPageIndex(mCurrentPage)
3633                  &amp;&amp; mState != State.SPRING_LOADED) {
3634              snapToScreenId(screenId, null);
3635          }
3636  
3637          if (info instanceof PendingAddItemInfo) {
3638              final PendingAddItemInfo pendingInfo = (PendingAddItemInfo) dragInfo;
3639  
3640              boolean findNearestVacantCell = true;
3641              if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) {
3642                  mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3643                          cellLayout, mTargetCell);
3644                  float distance = cellLayout.getDistanceFromCell(mDragViewVisualCenter[0],
3645                          mDragViewVisualCenter[1], mTargetCell);
3646                  if (willCreateUserFolder((ItemInfo) d.dragInfo, cellLayout, mTargetCell,
3647                          distance, true) || willAddToExistingUserFolder((ItemInfo) d.dragInfo,
3648                                  cellLayout, mTargetCell, distance)) {
3649                      findNearestVacantCell = false;
3650                  }
3651              }
3652  
3653              final ItemInfo item = (ItemInfo) d.dragInfo;
3654              boolean updateWidgetSize = false;
3655              if (findNearestVacantCell) {
3656                  int minSpanX = item.spanX;
3657                  int minSpanY = item.spanY;
3658                  if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
3659                      minSpanX = item.minSpanX;
3660                      minSpanY = item.minSpanY;
3661                  }
3662                  int[] resultSpan = new int[2];
3663                  mTargetCell = cellLayout.createArea((int) mDragViewVisualCenter[0],
3664                          (int) mDragViewVisualCenter[1], minSpanX, minSpanY, info.spanX, info.spanY,
3665                          null, mTargetCell, resultSpan, CellLayout.MODE_ON_DROP_EXTERNAL);
3666  
3667                  if (resultSpan[0] != item.spanX || resultSpan[1] != item.spanY) {
3668                      updateWidgetSize = true;
3669                  }
3670                  item.spanX = resultSpan[0];
3671                  item.spanY = resultSpan[1];
3672              }
3673  
3674              Runnable onAnimationCompleteRunnable = new Runnable() {
3675                  @Override
3676                  public void run() {
3677                      // When dragging and dropping from customization tray, we deal with creating
3678                      // widgets/shortcuts/folders in a slightly different way
3679                      switch (pendingInfo.itemType) {
3680                      case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
3681                          int span[] = new int[2];
3682                          span[0] = item.spanX;
3683                          span[1] = item.spanY;
3684                          mLauncher.addAppWidgetFromDrop((PendingAddWidgetInfo) pendingInfo,
3685                                  container, screenId, mTargetCell, span, null);
3686                          break;
3687                      case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3688                          mLauncher.processShortcutFromDrop(pendingInfo.componentName,
3689                                  container, screenId, mTargetCell, null);
3690                          break;
3691                      default:
3692                          throw new IllegalStateException(&quot;Unknown item type: &quot; +
3693                                  pendingInfo.itemType);
3694                      }
3695                  }
3696              };
3697              View finalView = pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET
3698                      ? ((PendingAddWidgetInfo) pendingInfo).boundWidget : null;
3699  
3700              if (finalView instanceof AppWidgetHostView &amp;&amp; updateWidgetSize) {
3701                  AppWidgetHostView awhv = (AppWidgetHostView) finalView;
3702                  AppWidgetResizeFrame.updateWidgetSizeRanges(awhv, mLauncher, item.spanX,
3703                          item.spanY);
3704              }
3705  
3706              int animationStyle = ANIMATE_INTO_POSITION_AND_DISAPPEAR;
3707              if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;
3708                      ((PendingAddWidgetInfo) pendingInfo).info.configure != null) {
3709                  animationStyle = ANIMATE_INTO_POSITION_AND_REMAIN;
3710              }
3711              animateWidgetDrop(info, cellLayout, d.dragView, onAnimationCompleteRunnable,
3712                      animationStyle, finalView, true);
3713          } else {
3714              // This is for other drag/drop cases, like dragging from All Apps
3715              View view = null;
3716  
3717              switch (info.itemType) {
3718              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
3719              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3720                  if (info.container == NO_ID &amp;&amp; info instanceof AppInfo) {
3721                      // Came from all apps -- make a copy
3722                      info = new ShortcutInfo((AppInfo) info);
3723                  }
3724                  view = mLauncher.createShortcut(R.layout.application, cellLayout,
3725                          (ShortcutInfo) info);
3726                  break;
3727              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
3728                  view = FolderIcon.fromXml(R.layout.folder_icon, mLauncher, cellLayout,
3729                          (FolderInfo) info, mIconCache);
3730                  break;
3731              default:
3732                  throw new IllegalStateException(&quot;Unknown item type: &quot; + info.itemType);
3733              }
3734  
3735              // First we find the cell nearest to point at which the item is
3736              // dropped, without any consideration to whether there is an item there.
3737              if (touchXY != null) {
3738                  mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3739                          cellLayout, mTargetCell);
3740                  float distance = cellLayout.getDistanceFromCell(mDragViewVisualCenter[0],
3741                          mDragViewVisualCenter[1], mTargetCell);
3742                  d.postAnimationRunnable = exitSpringLoadedRunnable;
3743                  if (createUserFolderIfNecessary(view, container, cellLayout, mTargetCell, distance,
3744                          true, d.dragView, d.postAnimationRunnable)) {
3745                      return;
3746                  }
3747                  if (addToExistingFolderIfNecessary(view, cellLayout, mTargetCell, distance, d,
3748                          true)) {
3749                      return;
3750                  }
3751              }
3752  
3753              if (touchXY != null) {
3754                  // when dragging and dropping, just find the closest free spot
3755                  mTargetCell = cellLayout.createArea((int) mDragViewVisualCenter[0],
3756                          (int) mDragViewVisualCenter[1], 1, 1, 1, 1,
3757                          null, mTargetCell, null, CellLayout.MODE_ON_DROP_EXTERNAL);
3758              } else {
3759                  cellLayout.findCellForSpan(mTargetCell, 1, 1);
3760              }
3761              addInScreen(view, container, screenId, mTargetCell[0], mTargetCell[1], info.spanX,
3762                      info.spanY, insertAtFirst);
3763              cellLayout.onDropChild(view);
3764              CellLayout.LayoutParams lp = (CellLayout.LayoutParams) view.getLayoutParams();
3765              cellLayout.getShortcutsAndWidgets().measureChild(view);
3766  
3767              LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screenId,
3768                      lp.cellX, lp.cellY);
3769  
3770              if (d.dragView != null) {
3771                  // We wrap the animation call in the temporary set and reset of the current
3772                  // cellLayout to its final transform -- this means we animate the drag view to
3773                  // the correct final location.
3774                  setFinalTransitionTransform(cellLayout);
3775                  mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, view,
3776                          exitSpringLoadedRunnable, this);
3777                  resetTransitionTransform(cellLayout);
3778              }
3779          }
3780      }
3781  
3782      public Bitmap createWidgetBitmap(ItemInfo widgetInfo, View layout) {
3783          int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(widgetInfo.spanX,
3784                  widgetInfo.spanY, widgetInfo, false);
3785          int visibility = layout.getVisibility();
3786          layout.setVisibility(VISIBLE);
3787  
3788          int width = MeasureSpec.makeMeasureSpec(unScaledSize[0], MeasureSpec.EXACTLY);
3789          int height = MeasureSpec.makeMeasureSpec(unScaledSize[1], MeasureSpec.EXACTLY);
3790          Bitmap b = Bitmap.createBitmap(unScaledSize[0], unScaledSize[1],
3791                  Bitmap.Config.ARGB_8888);
3792          Canvas c = new Canvas(b);
3793  
3794          layout.measure(width, height);
3795          layout.layout(0, 0, unScaledSize[0], unScaledSize[1]);
3796          layout.draw(c);
3797          c.setBitmap(null);
3798          layout.setVisibility(visibility);
3799          return b;
3800      }
3801  
3802      private void getFinalPositionForDropAnimation(int[] loc, float[] scaleXY,
3803              DragView dragView, CellLayout layout, ItemInfo info, int[] targetCell,
3804              boolean external, boolean scale) {
3805          // Now we animate the dragView, (ie. the widget or shortcut preview) into its final
3806          // location and size on the home screen.
3807          int spanX = info.spanX;
3808          int spanY = info.spanY;
3809  
3810          Rect r = estimateItemPosition(layout, info, targetCell[0], targetCell[1], spanX, spanY);
3811          loc[0] = r.left;
3812          loc[1] = r.top;
3813  
3814          setFinalTransitionTransform(layout);
3815          float cellLayoutScale =
3816                  mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(layout, loc, true);
3817          resetTransitionTransform(layout);
3818  
3819          float dragViewScaleX;
3820          float dragViewScaleY;
3821          if (scale) {
3822              dragViewScaleX = (1.0f * r.width()) / dragView.getMeasuredWidth();
3823              dragViewScaleY = (1.0f * r.height()) / dragView.getMeasuredHeight();
3824          } else {
3825              dragViewScaleX = 1f;
3826              dragViewScaleY = 1f;
3827          }
3828  
3829          // The animation will scale the dragView about its center, so we need to center about
3830          // the final location.
3831          loc[0] -= (dragView.getMeasuredWidth() - cellLayoutScale * r.width()) / 2;
3832          loc[1] -= (dragView.getMeasuredHeight() - cellLayoutScale * r.height()) / 2;
3833  
3834          scaleXY[0] = dragViewScaleX * cellLayoutScale;
3835          scaleXY[1] = dragViewScaleY * cellLayoutScale;
3836      }
3837  
3838      public void animateWidgetDrop(ItemInfo info, CellLayout cellLayout, DragView dragView,
3839              final Runnable onCompleteRunnable, int animationType, final View finalView,
3840              boolean external) {
3841          Rect from = new Rect();
3842          mLauncher.getDragLayer().getViewRectRelativeToSelf(dragView, from);
3843  
3844          int[] finalPos = new int[2];
3845          float scaleXY[] = new float[2];
3846          boolean scalePreview = !(info instanceof PendingAddShortcutInfo);
3847          getFinalPositionForDropAnimation(finalPos, scaleXY, dragView, cellLayout, info, mTargetCell,
3848                  external, scalePreview);
3849  
3850          Resources res = mLauncher.getResources();
3851          final int duration = res.getInteger(R.integer.config_dropAnimMaxDuration) - 200;
3852  
3853          // In the case where we&#x27;ve prebound the widget, we remove it from the DragLayer
3854          if (finalView instanceof AppWidgetHostView &amp;&amp; external) {
3855              Log.d(TAG, &quot;6557954 Animate widget drop, final view is appWidgetHostView&quot;);
3856              mLauncher.getDragLayer().removeView(finalView);
3857          }
3858          if ((animationType == ANIMATE_INTO_POSITION_AND_RESIZE || external) &amp;&amp; finalView != null) {
3859              Bitmap crossFadeBitmap = createWidgetBitmap(info, finalView);
3860              dragView.setCrossFadeBitmap(crossFadeBitmap);
3861              dragView.crossFade((int) (duration * 0.8f));
3862          } else if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp; external) {
3863              scaleXY[0] = scaleXY[1] = Math.min(scaleXY[0],  scaleXY[1]);
3864          }
3865  
3866          DragLayer dragLayer = mLauncher.getDragLayer();
3867          if (animationType == CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION) {
3868              mLauncher.getDragLayer().animateViewIntoPosition(dragView, finalPos, 0f, 0.1f, 0.1f,
3869                      DragLayer.ANIMATION_END_DISAPPEAR, onCompleteRunnable, duration);
3870          } else {
3871              int endStyle;
3872              if (animationType == ANIMATE_INTO_POSITION_AND_REMAIN) {
3873                  endStyle = DragLayer.ANIMATION_END_REMAIN_VISIBLE;
3874              } else {
3875                  endStyle = DragLayer.ANIMATION_END_DISAPPEAR;;
3876              }
3877  
3878              Runnable onComplete = new Runnable() {
3879                  @Override
3880                  public void run() {
3881                      if (finalView != null) {
3882                          finalView.setVisibility(VISIBLE);
3883                      }
3884                      if (onCompleteRunnable != null) {
3885                          onCompleteRunnable.run();
3886                      }
3887                  }
3888              };
3889              dragLayer.animateViewIntoPosition(dragView, from.left, from.top, finalPos[0],
3890                      finalPos[1], 1, 1, 1, scaleXY[0], scaleXY[1], onComplete, endStyle,
3891                      duration, this);
3892          }
3893      }
3894  
3895      public void setFinalTransitionTransform(CellLayout layout) {
3896          if (isSwitchingState()) {
3897              mCurrentScale = getScaleX();
3898              setScaleX(mNewScale);
3899              setScaleY(mNewScale);
3900          }
3901      }
3902      public void resetTransitionTransform(CellLayout layout) {
3903          if (isSwitchingState()) {
3904              setScaleX(mCurrentScale);
3905              setScaleY(mCurrentScale);
3906          }
3907      }
3908  
3909      /**
3910       * Return the current {@link CellLayout}, correctly picking the destination
3911       * screen while a scroll is in progress.
3912       */
3913      public CellLayout getCurrentDropLayout() {
3914          return (CellLayout) getChildAt(getNextPage());
3915      }
3916  
3917      /**
3918       * Return the current CellInfo describing our current drag; this method exists
3919       * so that Launcher can sync this object with the correct info when the activity is created/
3920       * destroyed
3921       *
3922       */
3923      public CellLayout.CellInfo getDragInfo() {
3924          return mDragInfo;
3925      }
3926  
3927      public int getRestorePage() {
3928          return getNextPage() - numCustomPages();
3929      }
3930  
3931      /**
3932       * Calculate the nearest cell where the given object would be dropped.
3933       *
3934       * pixelX and pixelY should be in the coordinate system of layout
3935       */
3936      private int[] findNearestArea(int pixelX, int pixelY,
3937              int spanX, int spanY, CellLayout layout, int[] recycle) {
3938          return layout.findNearestArea(
3939                  pixelX, pixelY, spanX, spanY, recycle);
3940      }
3941  
3942      void setup(DragController dragController) {
3943          mSpringLoadedDragController = new SpringLoadedDragController(mLauncher);
3944          mDragController = dragController;
3945  
3946          // hardware layers on children are enabled on startup, but should be disabled until
3947          // needed
3948          updateChildrenLayersEnabled(false);
3949          setWallpaperDimension();
3950      }
3951  
3952      /**
3953       * Called at the end of a drag which originated on the workspace.
3954       */
3955      public void onDropCompleted(final View target, final DragObject d,
3956              final boolean isFlingToDelete, final boolean success) {
3957          if (mDeferDropAfterUninstall) {
3958              mDeferredAction = new Runnable() {
3959                  public void run() {
3960                      onDropCompleted(target, d, isFlingToDelete, success);
3961                      mDeferredAction = null;
3962                  }
3963              };
3964              return;
3965          }
3966  
3967          boolean beingCalledAfterUninstall = mDeferredAction != null;
3968  
3969          if (success &amp;&amp; !(beingCalledAfterUninstall &amp;&amp; !mUninstallSuccessful)) {
3970              if (target != this &amp;&amp; mDragInfo != null) {
3971                  CellLayout parentCell = getParentCellLayoutForView(mDragInfo.cell);
3972                  if (parentCell != null) {
3973                      parentCell.removeView(mDragInfo.cell);
3974                  }
3975                  if (mDragInfo.cell instanceof DropTarget) {
3976                      mDragController.removeDropTarget((DropTarget) mDragInfo.cell);
3977                  }
3978                  // If we move the item to anything not on the Workspace, check if any empty
3979                  // screens need to be removed. If we dropped back on the workspace, this will
3980                  // be done post drop animation.
3981                  removeExtraEmptyScreen(true, null, 0, true);
3982              }
3983          } else if (mDragInfo != null) {
3984              CellLayout cellLayout;
3985              if (mLauncher.isHotseatLayout(target)) {
3986                  cellLayout = mLauncher.getHotseat().getLayout();
3987              } else {
3988                  cellLayout = getScreenWithId(mDragInfo.screenId);
3989              }
3990              cellLayout.onDropChild(mDragInfo.cell);
3991          }
3992          if ((d.cancelled || (beingCalledAfterUninstall &amp;&amp; !mUninstallSuccessful))
3993                  &amp;&amp; mDragInfo.cell != null) {
3994              mDragInfo.cell.setVisibility(VISIBLE);
3995          }
3996          mDragOutline = null;
3997          mDragInfo = null;
3998      }
3999  
4000      public void deferCompleteDropAfterUninstallActivity() {
4001          mDeferDropAfterUninstall = true;
4002      }
4003  
4004      /// maybe move this into a smaller part
4005      public void onUninstallActivityReturned(boolean success) {
4006          mDeferDropAfterUninstall = false;
4007          mUninstallSuccessful = success;
4008          if (mDeferredAction != null) {
4009              mDeferredAction.run();
4010          }
4011      }
4012  
4013      void updateItemLocationsInDatabase(CellLayout cl) {
4014          int count = cl.getShortcutsAndWidgets().getChildCount();
4015  
4016          long screenId = getIdForScreen(cl);
4017          int container = Favorites.CONTAINER_DESKTOP;
4018  
4019          if (mLauncher.isHotseatLayout(cl)) {
4020              screenId = -1;
4021              container = Favorites.CONTAINER_HOTSEAT;
4022          }
4023  
4024          for (int i = 0; i &lt; count; i++) {
4025              View v = cl.getShortcutsAndWidgets().getChildAt(i);
4026              ItemInfo info = (ItemInfo) v.getTag();
4027              // Null check required as the AllApps button doesn&#x27;t have an item info
4028              if (info != null &amp;&amp; info.requiresDbUpdate) {
4029                  info.requiresDbUpdate = false;
4030                  LauncherModel.modifyItemInDatabase(mLauncher, info, container, screenId, info.cellX,
4031                          info.cellY, info.spanX, info.spanY);
4032              }
4033          }
4034      }
4035  
4036      ArrayList&lt;ComponentName&gt; getUniqueComponents(boolean stripDuplicates, ArrayList&lt;ComponentName&gt; duplicates) {
4037          ArrayList&lt;ComponentName&gt; uniqueIntents = new ArrayList&lt;ComponentName&gt;();
4038          getUniqueIntents((CellLayout) mLauncher.getHotseat().getLayout(), uniqueIntents, duplicates, false);
4039          int count = getChildCount();
4040          for (int i = 0; i &lt; count; i++) {
4041              CellLayout cl = (CellLayout) getChildAt(i);
4042              getUniqueIntents(cl, uniqueIntents, duplicates, false);
4043          }
4044          return uniqueIntents;
4045      }
4046  
4047      void getUniqueIntents(CellLayout cl, ArrayList&lt;ComponentName&gt; uniqueIntents,
4048              ArrayList&lt;ComponentName&gt; duplicates, boolean stripDuplicates) {
4049          int count = cl.getShortcutsAndWidgets().getChildCount();
4050  
4051          ArrayList&lt;View&gt; children = new ArrayList&lt;View&gt;();
4052          for (int i = 0; i &lt; count; i++) {
4053              View v = cl.getShortcutsAndWidgets().getChildAt(i);
4054              children.add(v);
4055          }
4056  
4057          for (int i = 0; i &lt; count; i++) {
4058              View v = children.get(i);
4059              ItemInfo info = (ItemInfo) v.getTag();
4060              // Null check required as the AllApps button doesn&#x27;t have an item info
4061              if (info instanceof ShortcutInfo) {
4062                  ShortcutInfo si = (ShortcutInfo) info;
4063                  ComponentName cn = si.intent.getComponent();
4064  
4065                  Uri dataUri = si.intent.getData();
4066                  // If dataUri is not null / empty or if this component isn&#x27;t one that would
4067                  // have previously showed up in the AllApps list, then this is a widget-type
4068                  // shortcut, so ignore it.
4069                  if (dataUri != null &amp;&amp; !dataUri.equals(Uri.EMPTY)) {
4070                      continue;
4071                  }
4072  
4073                  if (!uniqueIntents.contains(cn)) {
4074                      uniqueIntents.add(cn);
4075                  } else {
4076                      if (stripDuplicates) {
4077                          cl.removeViewInLayout(v);
4078                          LauncherModel.deleteItemFromDatabase(mLauncher, si);
4079                      }
4080                      if (duplicates != null) {
4081                          duplicates.add(cn);
4082                      }
4083                  }
4084              }
4085              if (v instanceof FolderIcon) {
4086                  FolderIcon fi = (FolderIcon) v;
4087                  ArrayList&lt;View&gt; items = fi.getFolder().getItemsInReadingOrder();
4088                  for (int j = 0; j &lt; items.size(); j++) {
4089                      if (items.get(j).getTag() instanceof ShortcutInfo) {
4090                          ShortcutInfo si = (ShortcutInfo) items.get(j).getTag();
4091                          ComponentName cn = si.intent.getComponent();
4092  
4093                          Uri dataUri = si.intent.getData();
4094                          // If dataUri is not null / empty or if this component isn&#x27;t one that would
4095                          // have previously showed up in the AllApps list, then this is a widget-type
4096                          // shortcut, so ignore it.
4097                          if (dataUri != null &amp;&amp; !dataUri.equals(Uri.EMPTY)) {
4098                              continue;
4099                          }
4100  
4101                          if (!uniqueIntents.contains(cn)) {
4102                              uniqueIntents.add(cn);
4103                          }  else {
4104                              if (stripDuplicates) {
4105                                  fi.getFolderInfo().remove(si);
4106                                  LauncherModel.deleteItemFromDatabase(mLauncher, si);
4107                              }
4108                              if (duplicates != null) {
4109                                  duplicates.add(cn);
4110                              }
4111                          }
4112                      }
4113                  }
4114              }
4115          }
4116      }
4117  
4118      void saveWorkspaceToDb() {
4119          saveWorkspaceScreenToDb((CellLayout) mLauncher.getHotseat().getLayout());
4120          int count = getChildCount();
4121          for (int i = 0; i &lt; count; i++) {
4122              CellLayout cl = (CellLayout) getChildAt(i);
4123              saveWorkspaceScreenToDb(cl);
4124          }
4125      }
4126  
4127      void saveWorkspaceScreenToDb(CellLayout cl) {
4128          int count = cl.getShortcutsAndWidgets().getChildCount();
4129  
4130          long screenId = getIdForScreen(cl);
4131          int container = Favorites.CONTAINER_DESKTOP;
4132  
4133          Hotseat hotseat = mLauncher.getHotseat();
4134          if (mLauncher.isHotseatLayout(cl)) {
4135              screenId = -1;
4136              container = Favorites.CONTAINER_HOTSEAT;
4137          }
4138  
4139          for (int i = 0; i &lt; count; i++) {
4140              View v = cl.getShortcutsAndWidgets().getChildAt(i);
4141              ItemInfo info = (ItemInfo) v.getTag();
4142              // Null check required as the AllApps button doesn&#x27;t have an item info
4143              if (info != null) {
4144                  int cellX = info.cellX;
4145                  int cellY = info.cellY;
4146                  if (container == Favorites.CONTAINER_HOTSEAT) {
4147                      cellX = hotseat.getCellXFromOrder((int) info.screenId);
4148                      cellY = hotseat.getCellYFromOrder((int) info.screenId);
4149                  }
4150                  LauncherModel.addItemToDatabase(mLauncher, info, container, screenId, cellX,
4151                          cellY, false);
4152              }
4153              if (v instanceof FolderIcon) {
4154                  FolderIcon fi = (FolderIcon) v;
4155                  fi.getFolder().addItemLocationsInDatabase();
4156              }
4157          }





4158      }
4159  
4160      @Override
4161      public boolean supportsFlingToDelete() {
4162          return true;
4163      }
4164  
4165      @Override
4166      public void onFlingToDelete(DragObject d, int x, int y, PointF vec) {
4167          // Do nothing
4168      }
4169  
4170      @Override
4171      public void onFlingToDeleteCompleted() {
4172          // Do nothing
4173      }
4174  
4175      public boolean isDropEnabled() {
4176          return true;
4177      }
4178  
4179      @Override
4180      protected void onRestoreInstanceState(Parcelable state) {
4181          super.onRestoreInstanceState(state);
4182          Launcher.setScreen(mCurrentPage);
4183      }
4184  
4185      @Override
4186      protected void dispatchRestoreInstanceState(SparseArray&lt;Parcelable&gt; container) {
4187          // We don&#x27;t dispatch restoreInstanceState to our children using this code path.
4188          // Some pages will be restored immediately as their items are bound immediately, and
4189          // others we will need to wait until after their items are bound.
4190          mSavedStates = container;
4191      }
4192  
4193      public void restoreInstanceStateForChild(int child) {
4194          if (mSavedStates != null) {
4195              mRestoredPages.add(child);
4196              CellLayout cl = (CellLayout) getChildAt(child);
4197              cl.restoreInstanceState(mSavedStates);
4198          }
4199      }
4200  
4201      public void restoreInstanceStateForRemainingPages() {
4202          int count = getChildCount();
4203          for (int i = 0; i &lt; count; i++) {
4204              if (!mRestoredPages.contains(i)) {
4205                  restoreInstanceStateForChild(i);
4206              }
4207          }
4208          mRestoredPages.clear();
4209          mSavedStates = null;
4210      }
4211  
4212      @Override
4213      public void scrollLeft() {
4214          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
4215              super.scrollLeft();
4216          }
4217          Folder openFolder = getOpenFolder();
4218          if (openFolder != null) {
4219              openFolder.completeDragExit();
4220          }
4221      }
4222  
4223      @Override
4224      public void scrollRight() {
4225          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
4226              super.scrollRight();
4227          }
4228          Folder openFolder = getOpenFolder();
4229          if (openFolder != null) {
4230              openFolder.completeDragExit();
4231          }
4232      }
4233  
4234      @Override
4235      public boolean onEnterScrollArea(int x, int y, int direction) {
4236          // Ignore the scroll area if we are dragging over the hot seat
4237          boolean isPortrait = !LauncherAppState.isScreenLandscape(getContext());
4238          if (mLauncher.getHotseat() != null &amp;&amp; isPortrait) {
4239              Rect r = new Rect();
4240              mLauncher.getHotseat().getHitRect(r);
4241              if (r.contains(x, y)) {
4242                  return false;
4243              }
4244          }
4245  
4246          boolean result = false;
4247          if (!isSmall() &amp;&amp; !mIsSwitchingState &amp;&amp; getOpenFolder() == null) {
4248              mInScrollArea = true;
4249  
4250              final int page = getNextPage() +
4251                         (direction == DragController.SCROLL_LEFT ? -1 : 1);
4252              // We always want to exit the current layout to ensure parity of enter / exit
4253              setCurrentDropLayout(null);
4254  
4255              if (0 &lt;= page &amp;&amp; page &lt; getChildCount()) {
4256                  // Ensure that we are not dragging over to the custom content screen
4257                  if (getScreenIdForPageIndex(page) == CUSTOM_CONTENT_SCREEN_ID) {
4258                      return false;
4259                  }
4260  
4261                  CellLayout layout = (CellLayout) getChildAt(page);
4262                  setCurrentDragOverlappingLayout(layout);
4263  
4264                  // Workspace is responsible for drawing the edge glow on adjacent pages,
4265                  // so we need to redraw the workspace when this may have changed.
4266                  invalidate();
4267                  result = true;
4268              }
4269          }
4270          return result;
4271      }
4272  
4273      @Override
4274      public boolean onExitScrollArea() {
4275          boolean result = false;
4276          if (mInScrollArea) {
4277              invalidate();
4278              CellLayout layout = getCurrentDropLayout();
4279              setCurrentDropLayout(layout);
4280              setCurrentDragOverlappingLayout(layout);
4281  
4282              result = true;
4283              mInScrollArea = false;
4284          }
4285          return result;
4286      }
4287  
4288      private void onResetScrollArea() {
4289          setCurrentDragOverlappingLayout(null);
4290          mInScrollArea = false;
4291      }
4292  
4293      /**
4294       * Returns a specific CellLayout
4295       */
4296      CellLayout getParentCellLayoutForView(View v) {
4297          ArrayList&lt;CellLayout&gt; layouts = getWorkspaceAndHotseatCellLayouts();
4298          for (CellLayout layout : layouts) {
4299              if (layout.getShortcutsAndWidgets().indexOfChild(v) &gt; -1) {
4300                  return layout;
4301              }
4302          }
4303          return null;
4304      }
4305  
4306      /**
4307       * Returns a list of all the CellLayouts in the workspace.
4308       */
4309      ArrayList&lt;CellLayout&gt; getWorkspaceAndHotseatCellLayouts() {
4310          ArrayList&lt;CellLayout&gt; layouts = new ArrayList&lt;CellLayout&gt;();
4311          int screenCount = getChildCount();
4312          for (int screen = 0; screen &lt; screenCount; screen++) {
4313              layouts.add(((CellLayout) getChildAt(screen)));
4314          }
4315          if (mLauncher.getHotseat() != null) {
4316              layouts.add(mLauncher.getHotseat().getLayout());
4317          }
4318          return layouts;
4319      }
4320  
4321      /**
4322       * We should only use this to search for specific children.  Do not use this method to modify
4323       * ShortcutsAndWidgetsContainer directly. Includes ShortcutAndWidgetContainers from
4324       * the hotseat and workspace pages
4325       */
4326      ArrayList&lt;ShortcutAndWidgetContainer&gt; getAllShortcutAndWidgetContainers() {
4327          ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4328                  new ArrayList&lt;ShortcutAndWidgetContainer&gt;();
4329          int screenCount = getChildCount();
4330          for (int screen = 0; screen &lt; screenCount; screen++) {
4331              childrenLayouts.add(((CellLayout) getChildAt(screen)).getShortcutsAndWidgets());
4332          }
4333          if (mLauncher.getHotseat() != null) {
4334              childrenLayouts.add(mLauncher.getHotseat().getLayout().getShortcutsAndWidgets());
4335          }
4336          return childrenLayouts;
4337      }
4338  
4339      public Folder getFolderForTag(Object tag) {
4340          ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4341                  getAllShortcutAndWidgetContainers();
4342          for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4343              int count = layout.getChildCount();
4344              for (int i = 0; i &lt; count; i++) {
4345                  View child = layout.getChildAt(i);
4346                  if (child instanceof Folder) {
4347                      Folder f = (Folder) child;
4348                      if (f.getInfo() == tag &amp;&amp; f.getInfo().opened) {
4349                          return f;
4350                      }
4351                  }
4352              }
4353          }
4354          return null;
4355      }
4356  
4357      public View getViewForTag(Object tag) {
4358          ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4359                  getAllShortcutAndWidgetContainers();
4360          for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4361              int count = layout.getChildCount();
4362              for (int i = 0; i &lt; count; i++) {
4363                  View child = layout.getChildAt(i);
4364                  if (child.getTag() == tag) {
4365                      return child;
4366                  }
4367              }
4368          }
4369          return null;
4370      }
4371  
4372      void clearDropTargets() {
4373          ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4374                  getAllShortcutAndWidgetContainers();
4375          for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4376              int childCount = layout.getChildCount();
4377              for (int j = 0; j &lt; childCount; j++) {
4378                  View v = layout.getChildAt(j);
4379                  if (v instanceof DropTarget) {
4380                      mDragController.removeDropTarget((DropTarget) v);
4381                  }
4382              }
4383          }
4384      }
4385  
4386      // Removes ALL items that match a given package name, this is usually called when a package
4387      // has been removed and we want to remove all components (widgets, shortcuts, apps) that
4388      // belong to that package.
4389      void removeItemsByPackageName(final ArrayList&lt;String&gt; packages) {
4390          final HashSet&lt;String&gt; packageNames = new HashSet&lt;String&gt;();
4391          packageNames.addAll(packages);
4392  
4393          // Filter out all the ItemInfos that this is going to affect
4394          final HashSet&lt;ItemInfo&gt; infos = new HashSet&lt;ItemInfo&gt;();
4395          final HashSet&lt;ComponentName&gt; cns = new HashSet&lt;ComponentName&gt;();
4396          ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
4397          for (CellLayout layoutParent : cellLayouts) {
4398              ViewGroup layout = layoutParent.getShortcutsAndWidgets();
4399              int childCount = layout.getChildCount();
4400              for (int i = 0; i &lt; childCount; ++i) {
4401                  View view = layout.getChildAt(i);
4402                  infos.add((ItemInfo) view.getTag());
4403              }
4404          }
4405          LauncherModel.ItemInfoFilter filter = new LauncherModel.ItemInfoFilter() {
4406              @Override
4407              public boolean filterItem(ItemInfo parent, ItemInfo info,
4408                                        ComponentName cn) {
4409                  if (packageNames.contains(cn.getPackageName())) {
4410                      cns.add(cn);
4411                      return true;
4412                  }
4413                  return false;
4414              }
4415          };
4416          LauncherModel.filterItemInfos(infos, filter);
4417  
4418          // Remove the affected components
4419          removeItemsByComponentName(cns);
4420      }
4421  
4422      // Removes items that match the application info specified, when applications are removed
4423      // as a part of an update, this is called to ensure that other widgets and application
4424      // shortcuts are not removed.
4425      void removeItemsByApplicationInfo(final ArrayList&lt;AppInfo&gt; appInfos) {
4426          // Just create a hash table of all the specific components that this will affect
4427          HashSet&lt;ComponentName&gt; cns = new HashSet&lt;ComponentName&gt;();
4428          for (AppInfo info : appInfos) {
4429              cns.add(info.componentName);
4430          }
4431  
4432          // Remove all the things
4433          removeItemsByComponentName(cns);
4434      }
4435  
4436      void removeItemsByComponentName(final HashSet&lt;ComponentName&gt; componentNames) {
4437          ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
4438          for (final CellLayout layoutParent: cellLayouts) {
4439              final ViewGroup layout = layoutParent.getShortcutsAndWidgets();
4440  
4441              final HashMap&lt;ItemInfo, View&gt; children = new HashMap&lt;ItemInfo, View&gt;();
4442              for (int j = 0; j &lt; layout.getChildCount(); j++) {
4443                  final View view = layout.getChildAt(j);
4444                  children.put((ItemInfo) view.getTag(), view);
4445              }
4446  
4447              final ArrayList&lt;View&gt; childrenToRemove = new ArrayList&lt;View&gt;();
4448              final HashMap&lt;FolderInfo, ArrayList&lt;ShortcutInfo&gt;&gt; folderAppsToRemove =
4449                      new HashMap&lt;FolderInfo, ArrayList&lt;ShortcutInfo&gt;&gt;();
4450              LauncherModel.ItemInfoFilter filter = new LauncherModel.ItemInfoFilter() {
4451                  @Override
4452                  public boolean filterItem(ItemInfo parent, ItemInfo info,
4453                                            ComponentName cn) {
4454                      if (parent instanceof FolderInfo) {
4455                          if (componentNames.contains(cn)) {
4456                              FolderInfo folder = (FolderInfo) parent;
4457                              ArrayList&lt;ShortcutInfo&gt; appsToRemove;
4458                              if (folderAppsToRemove.containsKey(folder)) {
4459                                  appsToRemove = folderAppsToRemove.get(folder);
4460                              } else {
4461                                  appsToRemove = new ArrayList&lt;ShortcutInfo&gt;();
4462                                  folderAppsToRemove.put(folder, appsToRemove);
4463                              }
4464                              appsToRemove.add((ShortcutInfo) info);
4465                              return true;
4466                          }
4467                      } else {
4468                          if (componentNames.contains(cn)) {
4469                              childrenToRemove.add(children.get(info));
4470                              return true;
4471                          }
4472                      }
4473                      return false;
4474                  }
4475              };
4476              LauncherModel.filterItemInfos(children.keySet(), filter);
4477  
4478              // Remove all the apps from their folders
4479              for (FolderInfo folder : folderAppsToRemove.keySet()) {
4480                  ArrayList&lt;ShortcutInfo&gt; appsToRemove = folderAppsToRemove.get(folder);
4481                  for (ShortcutInfo info : appsToRemove) {
4482                      folder.remove(info);
4483                  }
4484              }
4485  
4486              // Remove all the other children
4487              for (View child : childrenToRemove) {
4488                  // Note: We can not remove the view directly from CellLayoutChildren as this
4489                  // does not re-mark the spaces as unoccupied.
4490                  layoutParent.removeViewInLayout(child);
4491                  if (child instanceof DropTarget) {
4492                      mDragController.removeDropTarget((DropTarget) child);
4493                  }
4494              }
4495  
4496              if (childrenToRemove.size() &gt; 0) {
4497                  layout.requestLayout();
4498                  layout.invalidate();
4499              }
4500          }
4501  
4502          // Strip all the empty screens
4503          stripEmptyScreens();
4504      }
4505  
4506      private void updateShortcut(HashMap&lt;ComponentName, AppInfo&gt; appsMap, ItemInfo info,
4507                                  View child) {
4508          ComponentName cn = info.getIntent().getComponent();
4509          if (cn != null) {
4510              AppInfo appInfo = appsMap.get(info.getIntent().getComponent());
4511              if ((appInfo != null) &amp;&amp; LauncherModel.isShortcutInfoUpdateable(info)) {
4512                  ShortcutInfo shortcutInfo = (ShortcutInfo) info;
4513                  BubbleTextView shortcut = (BubbleTextView) child;
4514                  shortcutInfo.updateIcon(mIconCache);
4515                  shortcutInfo.title = appInfo.title.toString();
4516                  shortcut.applyFromShortcutInfo(shortcutInfo, mIconCache);
4517              }
4518          }
4519      }
4520  
4521      void updateShortcuts(ArrayList&lt;AppInfo&gt; apps) {
4522          // Create a map of the apps to test against
4523          final HashMap&lt;ComponentName, AppInfo&gt; appsMap = new HashMap&lt;ComponentName, AppInfo&gt;();
4524          for (AppInfo ai : apps) {
4525              appsMap.put(ai.componentName, ai);
4526          }
4527  
4528          ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts = getAllShortcutAndWidgetContainers();
4529          for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4530              // Update all the children shortcuts
4531              final HashMap&lt;ItemInfo, View&gt; children = new HashMap&lt;ItemInfo, View&gt;();
4532              for (int j = 0; j &lt; layout.getChildCount(); j++) {
4533                  View v = layout.getChildAt(j);
4534                  ItemInfo info = (ItemInfo) v.getTag();
4535                  if (info instanceof FolderInfo &amp;&amp; v instanceof FolderIcon) {
4536                      FolderIcon folder = (FolderIcon) v;
4537                      ArrayList&lt;View&gt; folderChildren = folder.getFolder().getItemsInReadingOrder();
4538                      for (View fv : folderChildren) {
4539                          info = (ItemInfo) fv.getTag();
4540                          updateShortcut(appsMap, info, fv);
4541                      }
4542                      folder.invalidate();
4543                  } else if (info instanceof ShortcutInfo) {
4544                      updateShortcut(appsMap, info, v);
4545                  }
4546              }
4547          }
4548      }
4549  
4550      private void moveToScreen(int page, boolean animate) {
4551          if (!isSmall()) {
4552              if (animate) {
4553                  snapToPage(page);
4554              } else {
4555                  setCurrentPage(page);
4556              }
4557          }
4558          View child = getChildAt(page);
4559          if (child != null) {
4560              child.requestFocus();
4561          }
4562      }
4563  
4564      void moveToDefaultScreen(boolean animate) {
4565          moveToScreen(mDefaultPage, animate);
4566      }
4567  
4568      void moveToCustomContentScreen(boolean animate) {
4569          if (hasCustomContent()) {
4570              int ccIndex = getPageIndexForScreenId(CUSTOM_CONTENT_SCREEN_ID);
4571              if (animate) {
4572                  snapToPage(ccIndex);
4573              } else {
4574                  setCurrentPage(ccIndex);
4575              }
4576              View child = getChildAt(ccIndex);
4577              if (child != null) {
4578                  child.requestFocus();
4579              }
4580           }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4581 +        exitWidgetResizeMode();</span>
4582      }
4583  
4584      @Override
4585      protected PageIndicator.PageMarkerResources getPageIndicatorMarker(int pageIndex) {
4586          long screenId = getScreenIdForPageIndex(pageIndex);
4587          if (screenId == EXTRA_EMPTY_SCREEN_ID) {
4588              int count = mScreenOrder.size() - numCustomPages();
4589              if (count &gt; 1) {
4590                  return new PageIndicator.PageMarkerResources(R.drawable.ic_pageindicator_current,
4591                          R.drawable.ic_pageindicator_add);
4592              }
4593          }
4594  
4595          return super.getPageIndicatorMarker(pageIndex);
4596      }
4597  
4598      @Override
4599      public void syncPages() {
4600      }
4601  
4602      @Override
4603      public void syncPageItems(int page, boolean immediate) {
4604      }
4605  
4606      protected String getPageIndicatorDescription() {
4607          String settings = getResources().getString(R.string.settings_button_text);
4608          return getCurrentPageDescription() + &quot;, &quot; + settings;
4609      }
4610  
4611      protected String getCurrentPageDescription() {
4612          int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
4613          int delta = numCustomPages();
4614          if (hasCustomContent() &amp;&amp; getNextPage() == 0) {
4615              return mCustomContentDescription;
4616          }
4617          return String.format(getContext().getString(R.string.workspace_scroll_format),
4618                  page + 1 - delta, getChildCount() - delta);
4619      }
4620  
4621      public void getLocationInDragLayer(int[] loc) {
4622          mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
4623      }
4624  }</pre></td>
                            <td><pre>   1  /*
   2   * Copyright (C) 2008 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  
  17  package com.android.launcher3;
  18  
  19  import android.animation.Animator;
  20  import android.animation.Animator.AnimatorListener;
  21  import android.animation.AnimatorListenerAdapter;
  22  import android.animation.AnimatorSet;
  23  import android.animation.LayoutTransition;
  24  import android.animation.ObjectAnimator;
  25  import android.animation.PropertyValuesHolder;
  26  import android.animation.TimeInterpolator;
  27  import android.animation.ValueAnimator;
  28  import android.animation.ValueAnimator.AnimatorUpdateListener;
  29  import android.app.WallpaperManager;
  30  import android.appwidget.AppWidgetHostView;
  31  import android.appwidget.AppWidgetProviderInfo;
  32  import android.content.ComponentName;
  33  import android.content.Context;
  34  import android.content.Intent;
  35  import android.content.SharedPreferences;
  36  import android.content.res.Resources;
  37  import android.content.res.TypedArray;
  38  import android.graphics.Bitmap;
  39  import android.graphics.Canvas;
  40  import android.graphics.Matrix;
  41  import android.graphics.Point;
  42  import android.graphics.PointF;
  43  import android.graphics.Rect;
  44  import android.graphics.Region.Op;
  45  import android.graphics.drawable.Drawable;
  46  import android.net.Uri;
  47  import android.os.IBinder;
  48  import android.os.Parcelable;
  49  import android.support.v4.view.ViewCompat;
  50  import android.util.AttributeSet;
  51  import android.util.Log;
  52  import android.util.SparseArray;
  53  import android.view.Choreographer;
  54  import android.view.Display;
  55  import android.view.MotionEvent;
  56  import android.view.View;
  57  import android.view.ViewGroup;
  58  import android.view.View.OnClickListener;
  59  import android.view.accessibility.AccessibilityEvent;
  60  import android.view.accessibility.AccessibilityManager;
  61  import android.view.accessibility.AccessibilityNodeInfo;
  62  import android.view.animation.DecelerateInterpolator;
  63  import android.view.animation.Interpolator;
  64  import android.widget.TextView;
  65  
  66  import com.android.launcher3.FolderIcon.FolderRingAnimator;
  67  import com.android.launcher3.Launcher.CustomContentCallbacks;
  68  import com.android.launcher3.LauncherSettings.Favorites;
  69  
  70  import java.util.ArrayList;
  71  import java.util.HashMap;
  72  import java.util.HashSet;
  73  import java.util.Iterator;
  74  
  75  /**
  76   * The workspace is a wide area with a wallpaper and a finite number of pages.
  77   * Each page contains a number of icons, folders or widgets the user can
  78   * interact with. A workspace is meant to be used with a fixed width only.
  79   */
  80  public class Workspace extends SmoothPagedView
  81          implements DropTarget, DragSource, DragScroller, View.OnTouchListener,
  82          DragController.DragListener, LauncherTransitionable, ViewGroup.OnHierarchyChangeListener,
  83          Insettable {
  84      private static final String TAG = &quot;Launcher.Workspace&quot;;
  85  
  86      // Y rotation to apply to the workspace screens
  87      private static final float WORKSPACE_OVERSCROLL_ROTATION = 24f;
  88  
  89      private static final int CHILDREN_OUTLINE_FADE_OUT_DELAY = 0;
  90      private static final int CHILDREN_OUTLINE_FADE_OUT_DURATION = 375;
  91      private static final int CHILDREN_OUTLINE_FADE_IN_DURATION = 100;
  92  
  93      protected static final int SNAP_OFF_EMPTY_SCREEN_DURATION = 400;
  94      protected static final int FADE_EMPTY_SCREEN_DURATION = 150;
  95  
  96      private static final int BACKGROUND_FADE_OUT_DURATION = 350;
  97      private static final int ADJACENT_SCREEN_DROP_DURATION = 300;
  98      private static final int FLING_THRESHOLD_VELOCITY = 500;
  99  
 100      private static final float ALPHA_CUTOFF_THRESHOLD = 0.01f;
 101  
 102      // These animators are used to fade the children&#x27;s outlines
 103      private ObjectAnimator mChildrenOutlineFadeInAnimation;
 104      private ObjectAnimator mChildrenOutlineFadeOutAnimation;
 105      private float mChildrenOutlineAlpha = 0;
 106  
 107      // These properties refer to the background protection gradient used for AllApps and Customize
 108      private ValueAnimator mBackgroundFadeInAnimation;
 109      private ValueAnimator mBackgroundFadeOutAnimation;
 110      private Drawable mBackground;
 111      boolean mDrawBackground = true;
 112      private float mBackgroundAlpha = 0;
 113  
 114      private static final long CUSTOM_CONTENT_GESTURE_DELAY = 200;
 115      private long mTouchDownTime = -1;
 116      private long mCustomContentShowTime = -1;
 117  
 118      private LayoutTransition mLayoutTransition;
 119      private final WallpaperManager mWallpaperManager;
 120      private IBinder mWindowToken;
 121  
 122      private int mOriginalDefaultPage;
 123      private int mDefaultPage;
 124  
 125      private ShortcutAndWidgetContainer mDragSourceInternal;
 126      private static boolean sAccessibilityEnabled;
 127  
 128      // The screen id used for the empty screen always present to the right.
 129      private final static long EXTRA_EMPTY_SCREEN_ID = -201;
 130      private final static long CUSTOM_CONTENT_SCREEN_ID = -301;
 131  
 132      private HashMap&lt;Long, CellLayout&gt; mWorkspaceScreens = new HashMap&lt;Long, CellLayout&gt;();
 133      private ArrayList&lt;Long&gt; mScreenOrder = new ArrayList&lt;Long&gt;();
 134  
 135      private Runnable mRemoveEmptyScreenRunnable;
 136  
 137      /**
 138       * CellInfo for the cell that is currently being dragged
 139       */
 140      private CellLayout.CellInfo mDragInfo;
 141  
 142      /**
 143       * Target drop area calculated during last acceptDrop call.
 144       */
 145      private int[] mTargetCell = new int[2];
 146      private int mDragOverX = -1;
 147      private int mDragOverY = -1;
 148  
 149      static Rect mLandscapeCellLayoutMetrics = null;
 150      static Rect mPortraitCellLayoutMetrics = null;
 151  
 152      CustomContentCallbacks mCustomContentCallbacks;
 153      boolean mCustomContentShowing;
 154      private float mLastCustomContentScrollProgress = -1f;
 155      private String mCustomContentDescription = &quot;&quot;;
 156  
 157      /**
 158       * The CellLayout that is currently being dragged over
 159       */
 160      private CellLayout mDragTargetLayout = null;
 161      /**
 162       * The CellLayout that we will show as glowing
 163       */
 164      private CellLayout mDragOverlappingLayout = null;
 165  
 166      /**
 167       * The CellLayout which will be dropped to
 168       */
 169      private CellLayout mDropToLayout = null;
 170  
 171      private Launcher mLauncher;
 172      private IconCache mIconCache;
 173      private DragController mDragController;
 174  
 175      // These are temporary variables to prevent having to allocate a new object just to
 176      // return an (x, y) value from helper functions. Do NOT use them to maintain other state.
 177      private int[] mTempCell = new int[2];
 178      private int[] mTempPt = new int[2];
 179      private int[] mTempEstimate = new int[2];
 180      private float[] mDragViewVisualCenter = new float[2];
 181      private float[] mTempCellLayoutCenterCoordinates = new float[2];
 182      private Matrix mTempInverseMatrix = new Matrix();
 183  
 184      private SpringLoadedDragController mSpringLoadedDragController;
 185      private float mSpringLoadedShrinkFactor;
 186      private float mOverviewModeShrinkFactor;
 187  
 188      // State variable that indicates whether the pages are small (ie when you&#x27;re
 189      // in all apps or customize mode)
 190  
 191      enum State { NORMAL, SPRING_LOADED, SMALL, OVERVIEW};
 192      private State mState = State.NORMAL;
 193      private boolean mIsSwitchingState = false;
 194  
 195      boolean mAnimatingViewIntoPlace = false;
 196      boolean mIsDragOccuring = false;
 197      boolean mChildrenLayersEnabled = true;
 198  
 199      private boolean mStripScreensOnPageStopMoving = false;
 200  
 201      /** Is the user is dragging an item near the edge of a page? */
 202      private boolean mInScrollArea = false;
 203  
 204      private HolographicOutlineHelper mOutlineHelper;
 205      private Bitmap mDragOutline = null;
 206      private final Rect mTempRect = new Rect();
 207      private final int[] mTempXY = new int[2];
 208      private int[] mTempVisiblePagesRange = new int[2];
 209      private boolean mOverscrollTransformsSet;
 210      private float mLastOverscrollPivotX;
 211      public static final int DRAG_BITMAP_PADDING = 2;
 212      private boolean mWorkspaceFadeInAdjacentScreens;
 213  
 214      WallpaperOffsetInterpolator mWallpaperOffset;
 215      private Runnable mDelayedResizeRunnable;
 216      private Runnable mDelayedSnapToPageRunnable;
 217      private Point mDisplaySize = new Point();
 218      private int mCameraDistance;
 219  
 220      // Variables relating to the creation of user folders by hovering shortcuts over shortcuts
 221      private static final int FOLDER_CREATION_TIMEOUT = 0;
 222      private static final int REORDER_TIMEOUT = 250;
 223      private final Alarm mFolderCreationAlarm = new Alarm();
 224      private final Alarm mReorderAlarm = new Alarm();
 225      private FolderRingAnimator mDragFolderRingAnimator = null;
 226      private FolderIcon mDragOverFolderIcon = null;
 227      private boolean mCreateUserFolderOnDrop = false;
 228      private boolean mAddToExistingFolderOnDrop = false;
 229      private DropTarget.DragEnforcer mDragEnforcer;
 230      private float mMaxDistanceForFolderCreation;
 231  
 232      // Variables relating to touch disambiguation (scrolling workspace vs. scrolling a widget)
 233      private float mXDown;
 234      private float mYDown;
 235      final static float START_DAMPING_TOUCH_SLOP_ANGLE = (float) Math.PI / 6;
 236      final static float MAX_SWIPE_ANGLE = (float) Math.PI / 3;
 237      final static float TOUCH_SLOP_DAMPING_FACTOR = 4;
 238  
 239      // Relating to the animation of items being dropped externally
 240      public static final int ANIMATE_INTO_POSITION_AND_DISAPPEAR = 0;
 241      public static final int ANIMATE_INTO_POSITION_AND_REMAIN = 1;
 242      public static final int ANIMATE_INTO_POSITION_AND_RESIZE = 2;
 243      public static final int COMPLETE_TWO_STAGE_WIDGET_DROP_ANIMATION = 3;
 244      public static final int CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION = 4;
 245  
 246      // Related to dragging, folder creation and reordering
 247      private static final int DRAG_MODE_NONE = 0;
 248      private static final int DRAG_MODE_CREATE_FOLDER = 1;
 249      private static final int DRAG_MODE_ADD_TO_FOLDER = 2;
 250      private static final int DRAG_MODE_REORDER = 3;
 251      private int mDragMode = DRAG_MODE_NONE;
 252      private int mLastReorderX = -1;
 253      private int mLastReorderY = -1;
 254  
 255      private SparseArray&lt;Parcelable&gt; mSavedStates;
 256      private final ArrayList&lt;Integer&gt; mRestoredPages = new ArrayList&lt;Integer&gt;();
 257  
 258      // These variables are used for storing the initial and final values during workspace animations
 259      private int mSavedScrollX;
 260      private float mSavedRotationY;
 261      private float mSavedTranslationX;
 262  
 263      private float mCurrentScale;
 264      private float mNewScale;
 265      private float[] mOldBackgroundAlphas;
 266      private float[] mOldAlphas;
 267      private float[] mNewBackgroundAlphas;
 268      private float[] mNewAlphas;
 269      private int mLastChildCount = -1;
 270      private float mTransitionProgress;
 271  
 272      private Runnable mDeferredAction;
 273      private boolean mDeferDropAfterUninstall;
 274      private boolean mUninstallSuccessful;
 275  
 276      private final Runnable mBindPages = new Runnable() {
 277          @Override
 278          public void run() {
 279              mLauncher.getModel().bindRemainingSynchronousPages();
 280          }
 281      };
 282  
 283      /**
 284       * Used to inflate the Workspace from XML.
 285       *
 286       * @param context The application&#x27;s context.
 287       * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 288       */
 289      public Workspace(Context context, AttributeSet attrs) {
 290          this(context, attrs, 0);
 291      }
 292  
 293      /**
 294       * Used to inflate the Workspace from XML.
 295       *
 296       * @param context The application&#x27;s context.
 297       * @param attrs The attributes set containing the Workspace&#x27;s customization values.
 298       * @param defStyle Unused.
 299       */
 300      public Workspace(Context context, AttributeSet attrs, int defStyle) {
 301          super(context, attrs, defStyle);
 302          mContentIsRefreshable = false;
 303  
 304          mOutlineHelper = HolographicOutlineHelper.obtain(context);
 305  
 306          mDragEnforcer = new DropTarget.DragEnforcer(context);
 307          // With workspace, data is available straight from the get-go
 308          setDataIsReady();
 309  
 310          mLauncher = (Launcher) context;
 311          final Resources res = getResources();
 312          mWorkspaceFadeInAdjacentScreens = LauncherAppState.getInstance().getDynamicGrid().
 313                  getDeviceProfile().shouldFadeAdjacentWorkspaceScreens();
 314          mFadeInAdjacentScreens = false;
 315          mWallpaperManager = WallpaperManager.getInstance(context);
 316  
 317          LauncherAppState app = LauncherAppState.getInstance();
 318          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 319          TypedArray a = context.obtainStyledAttributes(attrs,
 320                  R.styleable.Workspace, defStyle, 0);
 321          mSpringLoadedShrinkFactor =
 322              res.getInteger(R.integer.config_workspaceSpringLoadShrinkPercentage) / 100.0f;
 323          mOverviewModeShrinkFactor = grid.getOverviewModeScale();
 324          mCameraDistance = res.getInteger(R.integer.config_cameraDistance);
 325          mOriginalDefaultPage = mDefaultPage = a.getInt(R.styleable.Workspace_defaultScreen, 1);
 326          a.recycle();
 327  
 328          setOnHierarchyChangeListener(this);
 329          setHapticFeedbackEnabled(false);
 330  
 331          initWorkspace();
 332  
 333          // Disable multitouch across the workspace/all apps/customize tray
 334          setMotionEventSplittingEnabled(true);
 335          setImportantForAccessibility(View.IMPORTANT_FOR_ACCESSIBILITY_YES);
 336      }
 337  
 338      @Override
 339      public void setInsets(Rect insets) {
 340          mInsets.set(insets);
 341      }
 342  
 343      // estimate the size of a widget with spans hSpan, vSpan. return MAX_VALUE for each
 344      // dimension if unsuccessful
 345      public int[] estimateItemSize(int hSpan, int vSpan,
 346              ItemInfo itemInfo, boolean springLoaded) {
 347          int[] size = new int[2];
 348          if (getChildCount() &gt; 0) {
 349              // Use the first non-custom page to estimate the child position
 350              CellLayout cl = (CellLayout) getChildAt(numCustomPages());
 351              Rect r = estimateItemPosition(cl, itemInfo, 0, 0, hSpan, vSpan);
 352              size[0] = r.width();
 353              size[1] = r.height();
 354              if (springLoaded) {
 355                  size[0] *= mSpringLoadedShrinkFactor;
 356                  size[1] *= mSpringLoadedShrinkFactor;
 357              }
 358              return size;
 359          } else {
 360              size[0] = Integer.MAX_VALUE;
 361              size[1] = Integer.MAX_VALUE;
 362              return size;
 363          }
 364      }
 365  
 366      public Rect estimateItemPosition(CellLayout cl, ItemInfo pendingInfo,
 367              int hCell, int vCell, int hSpan, int vSpan) {
 368          Rect r = new Rect();
 369          cl.cellToRect(hCell, vCell, hSpan, vSpan, r);
 370          return r;
 371      }
 372  
 373      public void onDragStart(final DragSource source, Object info, int dragAction) {
 374          mIsDragOccuring = true;
 375          updateChildrenLayersEnabled(false);
 376          mLauncher.lockScreenOrientation();
 377          mLauncher.onInteractionBegin();
 378          setChildrenBackgroundAlphaMultipliers(1f);
 379          // Prevent any Un/InstallShortcutReceivers from updating the db while we are dragging
 380          InstallShortcutReceiver.enableInstallQueue();
 381          UninstallShortcutReceiver.enableUninstallQueue();
 382          post(new Runnable() {
 383              @Override
 384              public void run() {
 385                  if (mIsDragOccuring) {
 386                      addExtraEmptyScreenOnDrag();
 387                  }
 388              }
 389          });
 390      }
 391  
 392      public void onDragEnd() {
 393          mIsDragOccuring = false;
 394          updateChildrenLayersEnabled(false);
 395          mLauncher.unlockScreenOrientation(false);
 396  
 397          // Re-enable any Un/InstallShortcutReceiver and now process any queued items
 398          InstallShortcutReceiver.disableAndFlushInstallQueue(getContext());
 399          UninstallShortcutReceiver.disableAndFlushUninstallQueue(getContext());
 400  
 401          mDragSourceInternal = null;
 402          mLauncher.onInteractionEnd();
 403      }
 404  
 405      /**
 406       * Initializes various states for this workspace.
 407       */
 408      protected void initWorkspace() {
 409          Context context = getContext();
 410          mCurrentPage = mDefaultPage;
 411          Launcher.setScreen(mCurrentPage);
 412          LauncherAppState app = LauncherAppState.getInstance();
 413          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
 414          mIconCache = app.getIconCache();
 415          setWillNotDraw(false);
 416          setClipChildren(false);
 417          setClipToPadding(false);
 418          setChildrenDrawnWithCacheEnabled(true);
 419  
 420          setMinScale(mOverviewModeShrinkFactor);
 421          setupLayoutTransition();
 422  
 423          final Resources res = getResources();
 424          try {
 425              mBackground = res.getDrawable(R.drawable.apps_customize_bg);
 426          } catch (Resources.NotFoundException e) {
 427              // In this case, we will skip drawing background protection
 428          }
 429  
 430          mWallpaperOffset = new WallpaperOffsetInterpolator();
 431          Display display = mLauncher.getWindowManager().getDefaultDisplay();
 432          display.getSize(mDisplaySize);
 433  
 434          mMaxDistanceForFolderCreation = (0.55f * grid.iconSizePx);
 435          mFlingThresholdVelocity = (int) (FLING_THRESHOLD_VELOCITY * mDensity);
 436      }
 437  
 438      private void setupLayoutTransition() {
 439          // We want to show layout transitions when pages are deleted, to close the gap.
 440          mLayoutTransition = new LayoutTransition();
 441          mLayoutTransition.enableTransitionType(LayoutTransition.DISAPPEARING);
 442          mLayoutTransition.enableTransitionType(LayoutTransition.CHANGE_DISAPPEARING);
 443          mLayoutTransition.disableTransitionType(LayoutTransition.APPEARING);
 444          mLayoutTransition.disableTransitionType(LayoutTransition.CHANGE_APPEARING);
 445          setLayoutTransition(mLayoutTransition);
 446      }
 447  
 448      void enableLayoutTransitions() {
 449          setLayoutTransition(mLayoutTransition);
 450      }
 451      void disableLayoutTransitions() {
 452          setLayoutTransition(null);
 453      }
 454  
 455      @Override
 456      protected int getScrollMode() {
 457          return SmoothPagedView.X_LARGE_MODE;
 458      }
 459  
 460      @Override
 461      public void onChildViewAdded(View parent, View child) {
 462          if (!(child instanceof CellLayout)) {
 463              throw new IllegalArgumentException(&quot;A Workspace can only have CellLayout children.&quot;);
 464          }
 465          CellLayout cl = ((CellLayout) child);
 466          cl.setOnInterceptTouchListener(this);
 467          cl.setClickable(true);
 468          cl.setImportantForAccessibility(ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_NO);
 469          super.onChildViewAdded(parent, child);
 470      }
 471  
 472      protected boolean shouldDrawChild(View child) {
 473          final CellLayout cl = (CellLayout) child;
 474          return super.shouldDrawChild(child) &amp;&amp;
 475              (mIsSwitchingState ||
 476               cl.getShortcutsAndWidgets().getAlpha() &gt; 0 ||
 477               cl.getBackgroundAlpha() &gt; 0);
 478      }
 479  
 480      /**
 481       * @return The open folder on the current screen, or null if there is none
 482       */
 483      Folder getOpenFolder() {
 484          DragLayer dragLayer = mLauncher.getDragLayer();
 485          int count = dragLayer.getChildCount();
 486          for (int i = 0; i &lt; count; i++) {
 487              View child = dragLayer.getChildAt(i);
 488              if (child instanceof Folder) {
 489                  Folder folder = (Folder) child;
 490                  if (folder.getInfo().opened)
 491                      return folder;
 492              }
 493          }
 494          return null;
 495      }
 496  
 497      boolean isTouchActive() {
 498          return mTouchState != TOUCH_STATE_REST;
 499      }
 500  
 501      public void removeAllWorkspaceScreens() {
 502          // Disable all layout transitions before removing all pages to ensure that we don&#x27;t get the
 503          // transition animations competing with us changing the scroll when we add pages or the
 504          // custom content screen
 505          disableLayoutTransitions();
 506  
 507          // Since we increment the current page when we call addCustomContentPage via bindScreens
 508          // (and other places), we need to adjust the current page back when we clear the pages
 509          if (hasCustomContent()) {
 510              removeCustomContentPage();
 511          }
 512  
 513          // Remove the pages and clear the screen models
 514          removeAllViews();
 515          mScreenOrder.clear();
 516          mWorkspaceScreens.clear();
 517  
 518          // Re-enable the layout transitions
 519          enableLayoutTransitions();
 520      }
 521  
 522      public long insertNewWorkspaceScreenBeforeEmptyScreen(long screenId) {
 523          // Find the index to insert this view into.  If the empty screen exists, then
 524          // insert it before that.
 525          int insertIndex = mScreenOrder.indexOf(EXTRA_EMPTY_SCREEN_ID);
 526          if (insertIndex &lt; 0) {
 527              insertIndex = mScreenOrder.size();
 528          }
 529          return insertNewWorkspaceScreen(screenId, insertIndex);
 530      }
 531  
 532      public long insertNewWorkspaceScreen(long screenId) {
 533          return insertNewWorkspaceScreen(screenId, getChildCount());
 534      }
 535  
 536      public long insertNewWorkspaceScreen(long screenId, int insertIndex) {
 537          if (mWorkspaceScreens.containsKey(screenId)) {
 538              throw new RuntimeException(&quot;Screen id &quot; + screenId + &quot; already exists!&quot;);
 539          }
 540  
 541          CellLayout newScreen = (CellLayout)
 542                  mLauncher.getLayoutInflater().inflate(R.layout.workspace_screen, null);
 543  
 544          newScreen.setOnLongClickListener(mLongClickListener);
 545          newScreen.setOnClickListener(mLauncher);
 546          newScreen.setSoundEffectsEnabled(false);
 547          mWorkspaceScreens.put(screenId, newScreen);
 548          mScreenOrder.add(insertIndex, screenId);
 549          addView(newScreen, insertIndex);
 550          return screenId;
 551      }
 552  
 553      public void createCustomContentPage() {
 554          CellLayout customScreen = (CellLayout)
 555                  mLauncher.getLayoutInflater().inflate(R.layout.workspace_screen, null);
 556  
 557          mWorkspaceScreens.put(CUSTOM_CONTENT_SCREEN_ID, customScreen);
 558          mScreenOrder.add(0, CUSTOM_CONTENT_SCREEN_ID);
 559  
 560          // We want no padding on the custom content
 561          customScreen.setPadding(0, 0, 0, 0);
 562  
 563          addFullScreenPage(customScreen);
 564  
 565          // Ensure that the current page and default page are maintained.
 566          mDefaultPage = mOriginalDefaultPage + 1;
 567  
 568          // Update the custom content hint
 569          mLauncher.updateCustomContentHintVisibility();
 570          if (mRestorePage != INVALID_RESTORE_PAGE) {
 571              mRestorePage = mRestorePage + 1;
 572          } else {
 573              setCurrentPage(getCurrentPage() + 1);
 574          }
 575      }
 576  
 577      public void removeCustomContentPage() {
 578          CellLayout customScreen = getScreenWithId(CUSTOM_CONTENT_SCREEN_ID);
 579          if (customScreen == null) {
 580              throw new RuntimeException(&quot;Expected custom content screen to exist&quot;);
 581          }
 582  
 583          mWorkspaceScreens.remove(CUSTOM_CONTENT_SCREEN_ID);
 584          mScreenOrder.remove(CUSTOM_CONTENT_SCREEN_ID);
 585          removeView(customScreen);
 586  
 587          if (mCustomContentCallbacks != null) {
 588              mCustomContentCallbacks.onScrollProgressChanged(0);
 589              mCustomContentCallbacks.onHide();
 590          }
 591  
 592          mCustomContentCallbacks = null;
 593  
 594          // Ensure that the current page and default page are maintained.
 595          mDefaultPage = mOriginalDefaultPage - 1;
 596  
 597          // Update the custom content hint
 598          mLauncher.updateCustomContentHintVisibility();
 599          if (mRestorePage != INVALID_RESTORE_PAGE) {
 600              mRestorePage = mRestorePage - 1;
 601          } else {
 602              setCurrentPage(getCurrentPage() - 1);
 603          }
 604      }
 605  
 606      public void addToCustomContentPage(View customContent, CustomContentCallbacks callbacks,
 607              String description) {
 608          if (getPageIndexForScreenId(CUSTOM_CONTENT_SCREEN_ID) &lt; 0) {
 609              throw new RuntimeException(&quot;Expected custom content screen to exist&quot;);
 610          }
 611  
 612          // Add the custom content to the full screen custom page
 613          CellLayout customScreen = getScreenWithId(CUSTOM_CONTENT_SCREEN_ID);
 614          int spanX = customScreen.getCountX();
 615          int spanY = customScreen.getCountY();
 616          CellLayout.LayoutParams lp = new CellLayout.LayoutParams(0, 0, spanX, spanY);
 617          lp.canReorder  = false;
 618          lp.isFullscreen = true;
 619          if (customContent instanceof Insettable) {
 620              ((Insettable)customContent).setInsets(mInsets);
 621          }
 622          customScreen.removeAllViews();
 623          customScreen.addViewToCellLayout(customContent, 0, 0, lp, true);
 624          mCustomContentDescription = description;
 625  
 626          mCustomContentCallbacks = callbacks;
 627      }
 628  
 629      public void addExtraEmptyScreenOnDrag() {
 630          boolean lastChildOnScreen = false;
 631          boolean childOnFinalScreen = false;
 632  
 633          // Cancel any pending removal of empty screen
 634          mRemoveEmptyScreenRunnable = null;
 635  
 636          if (mDragSourceInternal != null) {
 637              if (mDragSourceInternal.getChildCount() == 1) {
 638                  lastChildOnScreen = true;
 639              }
 640              CellLayout cl = (CellLayout) mDragSourceInternal.getParent();
 641              if (indexOfChild(cl) == getChildCount() - 1) {
 642                  childOnFinalScreen = true;
 643              }
 644          }
 645  
 646          // If this is the last item on the final screen
 647          if (lastChildOnScreen &amp;&amp; childOnFinalScreen) {
 648              return;
 649          }
 650          if (!mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID)) {
 651              insertNewWorkspaceScreen(EXTRA_EMPTY_SCREEN_ID);
 652          }
 653      }
 654  
 655      public boolean addExtraEmptyScreen() {
 656          if (!mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID)) {
 657              insertNewWorkspaceScreen(EXTRA_EMPTY_SCREEN_ID);
 658              return true;
 659          }
 660          return false;
 661      }
 662  
 663      private void convertFinalScreenToEmptyScreenIfNecessary() {
 664          if (hasExtraEmptyScreen() || mScreenOrder.size() == 0) return;
 665          long finalScreenId = mScreenOrder.get(mScreenOrder.size() - 1);
 666  
 667          if (finalScreenId == CUSTOM_CONTENT_SCREEN_ID) return;
 668          CellLayout finalScreen = mWorkspaceScreens.get(finalScreenId);
 669  
 670          // If the final screen is empty, convert it to the extra empty screen
 671          if (finalScreen.getShortcutsAndWidgets().getChildCount() == 0 &amp;&amp;
 672                  !finalScreen.isDropPending()) {
 673              mWorkspaceScreens.remove(finalScreenId);
 674              mScreenOrder.remove(finalScreenId);
 675  
 676              // if this is the last non-custom content screen, convert it to the empty screen
 677              mWorkspaceScreens.put(EXTRA_EMPTY_SCREEN_ID, finalScreen);
 678              mScreenOrder.add(EXTRA_EMPTY_SCREEN_ID);
 679          }
 680      }
 681  
 682      public void removeExtraEmptyScreen(final boolean animate, final Runnable onComplete) {
 683          removeExtraEmptyScreen(animate, onComplete, 0, false);
 684      }
 685  
 686      public void removeExtraEmptyScreen(final boolean animate, final Runnable onComplete,
 687              final int delay, final boolean stripEmptyScreens) {
 688          if (delay &gt; 0) {
 689              postDelayed(new Runnable() {
 690                  @Override
 691                  public void run() {
 692                      removeExtraEmptyScreen(animate, onComplete, 0, stripEmptyScreens);
 693                  }
 694  
 695              }, delay);
 696              return;
 697          }
 698  
 699          convertFinalScreenToEmptyScreenIfNecessary();
 700          if (hasExtraEmptyScreen()) {
 701              int emptyIndex = mScreenOrder.indexOf(EXTRA_EMPTY_SCREEN_ID);
 702              if (getNextPage() == emptyIndex) {
 703                  snapToPage(getNextPage() - 1, SNAP_OFF_EMPTY_SCREEN_DURATION);
 704                  fadeAndRemoveEmptyScreen(SNAP_OFF_EMPTY_SCREEN_DURATION, FADE_EMPTY_SCREEN_DURATION,
 705                          onComplete, stripEmptyScreens);
 706              } else {
 707                  fadeAndRemoveEmptyScreen(0, FADE_EMPTY_SCREEN_DURATION,
 708                          onComplete, stripEmptyScreens);
 709              }
 710              return;
 711          }
 712          if (onComplete != null) {
 713              onComplete.run();
 714          }
 715      }
 716  
 717      private void fadeAndRemoveEmptyScreen(int delay, int duration, final Runnable onComplete,
 718              final boolean stripEmptyScreens) {
 719          PropertyValuesHolder alpha = PropertyValuesHolder.ofFloat(&quot;alpha&quot;, 0f);
 720          PropertyValuesHolder bgAlpha = PropertyValuesHolder.ofFloat(&quot;backgroundAlpha&quot;, 0f);
 721  
 722          final CellLayout cl = mWorkspaceScreens.get(EXTRA_EMPTY_SCREEN_ID);
 723  
 724          mRemoveEmptyScreenRunnable = new Runnable() {
 725              @Override
 726              public void run() {
 727                  if (hasExtraEmptyScreen()) {
 728                      mWorkspaceScreens.remove(EXTRA_EMPTY_SCREEN_ID);
 729                      mScreenOrder.remove(EXTRA_EMPTY_SCREEN_ID);
 730                      removeView(cl);
 731                      if (stripEmptyScreens) {
 732                          stripEmptyScreens();
 733                      }
 734                  }
 735              }
 736          };
 737  
 738          ObjectAnimator oa = ObjectAnimator.ofPropertyValuesHolder(cl, alpha, bgAlpha);
 739          oa.setDuration(duration);
 740          oa.setStartDelay(delay);
 741          oa.addListener(new AnimatorListenerAdapter() {
 742              @Override
 743              public void onAnimationEnd(Animator animation) {
 744                  if (mRemoveEmptyScreenRunnable != null) {
 745                      mRemoveEmptyScreenRunnable.run();
 746                  }
 747                  if (onComplete != null) {
 748                      onComplete.run();
 749                  }
 750              }
 751          });
 752          oa.start();
 753      }
 754  
 755      public boolean hasExtraEmptyScreen() {
 756          int nScreens = getChildCount();
 757          nScreens = nScreens - numCustomPages();
 758          return mWorkspaceScreens.containsKey(EXTRA_EMPTY_SCREEN_ID) &amp;&amp; nScreens &gt; 1;
 759      }
 760  
 761      public long commitExtraEmptyScreen() {
 762          int index = getPageIndexForScreenId(EXTRA_EMPTY_SCREEN_ID);
 763          CellLayout cl = mWorkspaceScreens.get(EXTRA_EMPTY_SCREEN_ID);
 764          mWorkspaceScreens.remove(EXTRA_EMPTY_SCREEN_ID);
 765          mScreenOrder.remove(EXTRA_EMPTY_SCREEN_ID);
 766  
 767          long newId = LauncherAppState.getLauncherProvider().generateNewScreenId();
 768          mWorkspaceScreens.put(newId, cl);
 769          mScreenOrder.add(newId);
 770  
 771          // Update the page indicator marker
 772          if (getPageIndicator() != null) {
 773              getPageIndicator().updateMarker(index, getPageIndicatorMarker(index));
 774          }
 775  
 776          // Update the model for the new screen
 777          mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
 778  
 779          return newId;
 780      }
 781  
 782      public CellLayout getScreenWithId(long screenId) {
 783          CellLayout layout = mWorkspaceScreens.get(screenId);
 784          return layout;
 785      }
 786  
 787      public long getIdForScreen(CellLayout layout) {
 788          Iterator&lt;Long&gt; iter = mWorkspaceScreens.keySet().iterator();
 789          while (iter.hasNext()) {
 790              long id = iter.next();
 791              if (mWorkspaceScreens.get(id) == layout) {
 792                  return id;
 793              }
 794          }
 795          return -1;
 796      }
 797  
 798      public int getPageIndexForScreenId(long screenId) {
 799          return indexOfChild(mWorkspaceScreens.get(screenId));
 800      }
 801  
 802      public long getScreenIdForPageIndex(int index) {
 803          if (0 &lt;= index &amp;&amp; index &lt; mScreenOrder.size()) {
 804              return mScreenOrder.get(index);
 805          }
 806          return -1;
 807      }
 808  
 809      ArrayList&lt;Long&gt; getScreenOrder() {
 810          return mScreenOrder;
 811      }
 812  
 813      public void stripEmptyScreens() {
 814          if (isPageMoving()) {
 815              mStripScreensOnPageStopMoving = true;
 816              return;
 817          }
 818  
 819          int currentPage = getNextPage();
 820          ArrayList&lt;Long&gt; removeScreens = new ArrayList&lt;Long&gt;();
 821          for (Long id: mWorkspaceScreens.keySet()) {
 822              CellLayout cl = mWorkspaceScreens.get(id);
 823              if (id &gt;= 0 &amp;&amp; cl.getShortcutsAndWidgets().getChildCount() == 0) {
 824                  removeScreens.add(id);
 825              }
 826          }
 827  
 828          // We enforce at least one page to add new items to. In the case that we remove the last
 829          // such screen, we convert the last screen to the empty screen
 830          int minScreens = 1 + numCustomPages();
 831  
 832          int pageShift = 0;
 833          for (Long id: removeScreens) {
 834              CellLayout cl = mWorkspaceScreens.get(id);
 835              mWorkspaceScreens.remove(id);
 836              mScreenOrder.remove(id);
 837  
 838              if (getChildCount() &gt; minScreens) {
 839                  if (indexOfChild(cl) &lt; currentPage) {
 840                      pageShift++;
 841                  }
 842                  removeView(cl);
 843              } else {
 844                  // if this is the last non-custom content screen, convert it to the empty screen
 845                  mRemoveEmptyScreenRunnable = null;
 846                  mWorkspaceScreens.put(EXTRA_EMPTY_SCREEN_ID, cl);
 847                  mScreenOrder.add(EXTRA_EMPTY_SCREEN_ID);
 848              }
 849          }
 850  
 851          if (!removeScreens.isEmpty()) {
 852              // Update the model if we have changed any screens
 853              mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
 854          }
 855  
 856          if (pageShift &gt;= 0) {
 857              setCurrentPage(currentPage - pageShift);
 858          }
 859      }
 860  
 861      // See implementation for parameter definition.
 862      void addInScreen(View child, long container, long screenId,
 863              int x, int y, int spanX, int spanY) {
 864          addInScreen(child, container, screenId, x, y, spanX, spanY, false, false);
 865      }
 866  
 867      // At bind time, we use the rank (screenId) to compute x and y for hotseat items.
 868      // See implementation for parameter definition.
 869      void addInScreenFromBind(View child, long container, long screenId, int x, int y,
 870              int spanX, int spanY) {
 871          addInScreen(child, container, screenId, x, y, spanX, spanY, false, true);
 872      }
 873  
 874      // See implementation for parameter definition.
 875      void addInScreen(View child, long container, long screenId, int x, int y, int spanX, int spanY,
 876              boolean insert) {
 877          addInScreen(child, container, screenId, x, y, spanX, spanY, insert, false);
 878      }
 879  
 880      /**
 881       * Adds the specified child in the specified screen. The position and dimension of
 882       * the child are defined by x, y, spanX and spanY.
 883       *
 884       * @param child The child to add in one of the workspace&#x27;s screens.
 885       * @param screenId The screen in which to add the child.
 886       * @param x The X position of the child in the screen&#x27;s grid.
 887       * @param y The Y position of the child in the screen&#x27;s grid.
 888       * @param spanX The number of cells spanned horizontally by the child.
 889       * @param spanY The number of cells spanned vertically by the child.
 890       * @param insert When true, the child is inserted at the beginning of the children list.
 891       * @param computeXYFromRank When true, we use the rank (stored in screenId) to compute
 892       *                          the x and y position in which to place hotseat items. Otherwise
 893       *                          we use the x and y position to compute the rank.
 894       */
 895      void addInScreen(View child, long container, long screenId, int x, int y, int spanX, int spanY,
 896              boolean insert, boolean computeXYFromRank) {
 897          if (container == LauncherSettings.Favorites.CONTAINER_DESKTOP) {
 898              if (getScreenWithId(screenId) == null) {
 899                  Log.e(TAG, &quot;Skipping child, screenId &quot; + screenId + &quot; not found&quot;);
 900                  // DEBUGGING - Print out the stack trace to see where we are adding from
 901                  new Throwable().printStackTrace();
 902                  return;
 903              }
 904          }
 905          if (screenId == EXTRA_EMPTY_SCREEN_ID) {
 906              // This should never happen
 907              throw new RuntimeException(&quot;Screen id should not be EXTRA_EMPTY_SCREEN_ID&quot;);
 908          }
 909  
 910          final CellLayout layout;
 911          if (container == LauncherSettings.Favorites.CONTAINER_HOTSEAT) {
 912              layout = mLauncher.getHotseat().getLayout();
 913              child.setOnKeyListener(null);
 914  
 915              // Hide folder title in the hotseat
 916              if (child instanceof FolderIcon) {
 917                  ((FolderIcon) child).setTextVisible(false);
 918              }
 919  
 920              if (computeXYFromRank) {
 921                  x = mLauncher.getHotseat().getCellXFromOrder((int) screenId);
 922                  y = mLauncher.getHotseat().getCellYFromOrder((int) screenId);
 923              } else {
 924                  screenId = mLauncher.getHotseat().getOrderInHotseat(x, y);
 925              }
 926          } else {
 927              // Show folder title if not in the hotseat
 928              if (child instanceof FolderIcon) {
 929                  ((FolderIcon) child).setTextVisible(true);
 930              }
 931              layout = getScreenWithId(screenId);
 932              child.setOnKeyListener(new IconKeyEventListener());
 933          }
 934  
 935          ViewGroup.LayoutParams genericLp = child.getLayoutParams();
 936          CellLayout.LayoutParams lp;
 937          if (genericLp == null || !(genericLp instanceof CellLayout.LayoutParams)) {
 938              lp = new CellLayout.LayoutParams(x, y, spanX, spanY);
 939          } else {
 940              lp = (CellLayout.LayoutParams) genericLp;
 941              lp.cellX = x;
 942              lp.cellY = y;
 943              lp.cellHSpan = spanX;
 944              lp.cellVSpan = spanY;
 945          }
 946  
 947          if (spanX &lt; 0 &amp;&amp; spanY &lt; 0) {
 948              lp.isLockedToGrid = false;
 949          }
 950  
 951          // Get the canonical child id to uniquely represent this view in this screen
 952          int childId = LauncherModel.getCellLayoutChildId(container, screenId, x, y, spanX, spanY);



 953          boolean markCellsAsOccupied = !(child instanceof Folder);
 954          if (!layout.addViewToCellLayout(child, insert ? 0 : -1, childId, lp, markCellsAsOccupied)) {
 955              // TODO: This branch occurs when the workspace is adding views
 956              // outside of the defined grid
 957              // maybe we should be deleting these items from the LauncherModel?
<abbr title=" 958              Launcher.addDumpLog(TAG, &quot;Failed to add to item at (&quot; + lp.cellX + &quot;,&quot; + lp.cellY + &quot;) to CellLayout&quot;, true);"> 958              Launcher.addDumpLog(TAG, &quot;Failed to add to item at (&quot; + lp.cellX + &quot;,&quot; + lp.cellY + &quot;) to CellLayout&quot;,🔵</abbr>
 959          }
 960  
 961          if (!(child instanceof Folder)) {
 962              child.setHapticFeedbackEnabled(false);
 963              child.setOnLongClickListener(mLongClickListener);
 964          }
 965          if (child instanceof DropTarget) {
 966              mDragController.addDropTarget((DropTarget) child);
 967          }
 968      }
 969  
 970      /**
 971       * Called directly from a CellLayout (not by the framework), after we&#x27;ve been added as a
 972       * listener via setOnInterceptTouchEventListener(). This allows us to tell the CellLayout
 973       * that it should intercept touch events, which is not something that is normally supported.
 974       */
 975      @Override
 976      public boolean onTouch(View v, MotionEvent event) {
 977          return (isSmall() || !isFinishedSwitchingState())
 978                  || (!isSmall() &amp;&amp; indexOfChild(v) != mCurrentPage);
 979      }
 980  
 981      public boolean isSwitchingState() {
 982          return mIsSwitchingState;
 983      }
 984  
 985      /** This differs from isSwitchingState in that we take into account how far the transition
 986       *  has completed. */
 987      public boolean isFinishedSwitchingState() {
 988          return !mIsSwitchingState || (mTransitionProgress &gt; 0.5f);
 989      }
 990  
 991      protected void onWindowVisibilityChanged (int visibility) {
 992          mLauncher.onWindowVisibilityChanged(visibility);
 993      }
 994  
 995      @Override
 996      public boolean dispatchUnhandledMove(View focused, int direction) {
 997          if (isSmall() || !isFinishedSwitchingState()) {
 998              // when the home screens are shrunken, shouldn&#x27;t allow side-scrolling
 999              return false;
1000          }
1001          return super.dispatchUnhandledMove(focused, direction);
1002      }
1003  
1004      @Override
1005      public boolean onInterceptTouchEvent(MotionEvent ev) {
1006          switch (ev.getAction() &amp; MotionEvent.ACTION_MASK) {
1007          case MotionEvent.ACTION_DOWN:
1008              mXDown = ev.getX();
1009              mYDown = ev.getY();
1010              mTouchDownTime = System.currentTimeMillis();
1011              break;
1012          case MotionEvent.ACTION_POINTER_UP:
1013          case MotionEvent.ACTION_UP:
1014              if (mTouchState == TOUCH_STATE_REST) {
1015                  final CellLayout currentPage = (CellLayout) getChildAt(mCurrentPage);
1016                  if (!currentPage.lastDownOnOccupiedCell()) {
1017                      onWallpaperTap(ev);
1018                  }
1019              }
1020          }
1021          return super.onInterceptTouchEvent(ev);
1022      }
1023  
1024      protected void reinflateWidgetsIfNecessary() {
1025          final int clCount = getChildCount();
1026          for (int i = 0; i &lt; clCount; i++) {
1027              CellLayout cl = (CellLayout) getChildAt(i);
1028              ShortcutAndWidgetContainer swc = cl.getShortcutsAndWidgets();
1029              final int itemCount = swc.getChildCount();
1030              for (int j = 0; j &lt; itemCount; j++) {
1031                  View v = swc.getChildAt(j);
1032  
1033                  if (v.getTag() instanceof LauncherAppWidgetInfo) {
1034                      LauncherAppWidgetInfo info = (LauncherAppWidgetInfo) v.getTag();
1035                      LauncherAppWidgetHostView lahv = (LauncherAppWidgetHostView) info.hostView;
1036                      if (lahv != null &amp;&amp; lahv.orientationChangedSincedInflation()) {
1037                          mLauncher.removeAppWidget(info);
1038                          // Remove the current widget which is inflated with the wrong orientation
1039                          cl.removeView(lahv);
1040                          mLauncher.bindAppWidget(info);
1041                      }
1042                  }
1043              }
1044          }
1045      }
1046  
1047      @Override
1048      protected void determineScrollingStart(MotionEvent ev) {
1049          if (!isFinishedSwitchingState()) return;
1050  
1051          float deltaX = ev.getX() - mXDown;
1052          float absDeltaX = Math.abs(deltaX);
1053          float absDeltaY = Math.abs(ev.getY() - mYDown);
1054  
1055          if (Float.compare(absDeltaX, 0f) == 0) return;
1056  
1057          float slope = absDeltaY / absDeltaX;
1058          float theta = (float) Math.atan(slope);
1059  
1060          if (absDeltaX &gt; mTouchSlop || absDeltaY &gt; mTouchSlop) {
1061              cancelCurrentPageLongPress();
1062          }
1063  
1064          boolean passRightSwipesToCustomContent =
1065                  (mTouchDownTime - mCustomContentShowTime) &gt; CUSTOM_CONTENT_GESTURE_DELAY;
1066  
1067          boolean swipeInIgnoreDirection = isLayoutRtl() ? deltaX &lt; 0 : deltaX &gt; 0;
1068          if (swipeInIgnoreDirection &amp;&amp; getScreenIdForPageIndex(getCurrentPage()) ==
1069                  CUSTOM_CONTENT_SCREEN_ID &amp;&amp; passRightSwipesToCustomContent) {
1070              // Pass swipes to the right to the custom content page.
1071              return;
1072          }
1073  
1074          if (theta &gt; MAX_SWIPE_ANGLE) {
1075              // Above MAX_SWIPE_ANGLE, we don&#x27;t want to ever start scrolling the workspace
1076              return;
1077          } else if (theta &gt; START_DAMPING_TOUCH_SLOP_ANGLE) {
1078              // Above START_DAMPING_TOUCH_SLOP_ANGLE and below MAX_SWIPE_ANGLE, we want to
1079              // increase the touch slop to make it harder to begin scrolling the workspace. This
1080              // results in vertically scrolling widgets to more easily. The higher the angle, the
1081              // more we increase touch slop.
1082              theta -= START_DAMPING_TOUCH_SLOP_ANGLE;
1083              float extraRatio = (float)
1084                      Math.sqrt((theta / (MAX_SWIPE_ANGLE - START_DAMPING_TOUCH_SLOP_ANGLE)));
1085              super.determineScrollingStart(ev, 1 + TOUCH_SLOP_DAMPING_FACTOR * extraRatio);
1086          } else {
1087              // Below START_DAMPING_TOUCH_SLOP_ANGLE, we don&#x27;t do anything special
1088              super.determineScrollingStart(ev);
1089          }
1090      }
1091  
1092      protected void onPageBeginMoving() {
1093          super.onPageBeginMoving();
1094  
1095          if (isHardwareAccelerated()) {
1096              updateChildrenLayersEnabled(false);
1097          } else {
1098              if (mNextPage != INVALID_PAGE) {
1099                  // we&#x27;re snapping to a particular screen
1100                  enableChildrenCache(mCurrentPage, mNextPage);
1101              } else {
1102                  // this is when user is actively dragging a particular screen, they might
1103                  // swipe it either left or right (but we won&#x27;t advance by more than one screen)
1104                  enableChildrenCache(mCurrentPage - 1, mCurrentPage + 1);
1105              }
1106          }
1107  
1108          // Only show page outlines as we pan if we are on large screen
1109          if (LauncherAppState.getInstance().isScreenLarge()) {
1110              showOutlines();
1111          }
1112  
1113          // If we are not fading in adjacent screens, we still need to restore the alpha in case the
1114          // user scrolls while we are transitioning (should not affect dispatchDraw optimizations)
1115          if (!mWorkspaceFadeInAdjacentScreens) {
1116              for (int i = 0; i &lt; getChildCount(); ++i) {
1117                  ((CellLayout) getPageAt(i)).setShortcutAndWidgetAlpha(1f);
1118              }
1119          }
1120      }
1121  
1122      protected void onPageEndMoving() {
1123          super.onPageEndMoving();
1124  
1125          if (isHardwareAccelerated()) {
1126              updateChildrenLayersEnabled(false);
1127          } else {
1128              clearChildrenCache();
1129          }
1130  
1131          if (mDragController.isDragging()) {
1132              if (isSmall()) {
1133                  // If we are in springloaded mode, then force an event to check if the current touch
1134                  // is under a new page (to scroll to)
1135                  mDragController.forceTouchMove();
1136              }
1137          } else {
1138              // If we are not mid-dragging, hide the page outlines if we are on a large screen
1139              if (LauncherAppState.getInstance().isScreenLarge()) {
1140                  hideOutlines();
1141              }
1142          }
1143  
1144          if (mDelayedResizeRunnable != null) {
1145              mDelayedResizeRunnable.run();
1146              mDelayedResizeRunnable = null;
1147          }
1148  
1149          if (mDelayedSnapToPageRunnable != null) {
1150              mDelayedSnapToPageRunnable.run();
1151              mDelayedSnapToPageRunnable = null;
1152          }
1153          if (mStripScreensOnPageStopMoving) {
1154              stripEmptyScreens();
1155              mStripScreensOnPageStopMoving = false;
1156          }
1157      }
1158  
1159      @Override
1160      protected void notifyPageSwitchListener() {
1161          super.notifyPageSwitchListener();
1162          Launcher.setScreen(mCurrentPage);
1163  
1164          if (hasCustomContent() &amp;&amp; getNextPage() == 0 &amp;&amp; !mCustomContentShowing) {
1165              mCustomContentShowing = true;
1166              if (mCustomContentCallbacks != null) {
1167                  mCustomContentCallbacks.onShow();
1168                  mCustomContentShowTime = System.currentTimeMillis();
1169                  mLauncher.updateVoiceButtonProxyVisible(false);
1170              }
1171          } else if (hasCustomContent() &amp;&amp; getNextPage() != 0 &amp;&amp; mCustomContentShowing) {
1172              mCustomContentShowing = false;
1173              if (mCustomContentCallbacks != null) {
1174                  mCustomContentCallbacks.onHide();
1175                  mLauncher.resetQSBScroll();
1176                  mLauncher.updateVoiceButtonProxyVisible(false);
1177              }
1178          }
1179          if (getPageIndicator() != null) {
1180              getPageIndicator().setContentDescription(getPageIndicatorDescription());
1181          }
1182      }
1183  
1184      protected CustomContentCallbacks getCustomContentCallbacks() {
1185          return mCustomContentCallbacks;
1186      }
1187  
1188      protected void setWallpaperDimension() {
1189          String spKey = WallpaperCropActivity.getSharedPreferencesKey();
1190          SharedPreferences sp = mLauncher.getSharedPreferences(spKey, Context.MODE_MULTI_PROCESS);
1191          WallpaperPickerActivity.suggestWallpaperDimension(mLauncher.getResources(),
1192                  sp, mLauncher.getWindowManager(), mWallpaperManager);
1193      }
1194  
1195      protected void snapToPage(int whichPage, Runnable r) {
1196          snapToPage(whichPage, SLOW_PAGE_SNAP_ANIMATION_DURATION, r);
1197      }
1198  
1199      protected void snapToPage(int whichPage, int duration, Runnable r) {
1200          if (mDelayedSnapToPageRunnable != null) {
1201              mDelayedSnapToPageRunnable.run();
1202          }
1203          mDelayedSnapToPageRunnable = r;
1204          snapToPage(whichPage, duration);
1205      }
1206  
1207      protected void snapToScreenId(long screenId, Runnable r) {
1208          snapToPage(getPageIndexForScreenId(screenId), r);
1209      }
1210  
1211      class WallpaperOffsetInterpolator implements Choreographer.FrameCallback {
1212          float mFinalOffset = 0.0f;
1213          float mCurrentOffset = 0.5f; // to force an initial update
1214          boolean mWaitingForUpdate;
1215          Choreographer mChoreographer;
1216          Interpolator mInterpolator;
1217          boolean mAnimating;
1218          long mAnimationStartTime;
1219          float mAnimationStartOffset;
1220          private final int ANIMATION_DURATION = 250;
1221          // Don&#x27;t use all the wallpaper for parallax until you have at least this many pages
1222          private final int MIN_PARALLAX_PAGE_SPAN = 3;
1223          int mNumScreens;
1224  
1225          public WallpaperOffsetInterpolator() {
1226              mChoreographer = Choreographer.getInstance();
1227              mInterpolator = new DecelerateInterpolator(1.5f);
1228          }
1229  
1230          @Override
1231          public void doFrame(long frameTimeNanos) {
1232              updateOffset(false);
1233          }
1234  
1235          private void updateOffset(boolean force) {
1236              if (mWaitingForUpdate || force) {
1237                  mWaitingForUpdate = false;
1238                  if (computeScrollOffset() &amp;&amp; mWindowToken != null) {
1239                      try {
1240                          mWallpaperManager.setWallpaperOffsets(mWindowToken,
1241                                  mWallpaperOffset.getCurrX(), 0.5f);
1242                          setWallpaperOffsetSteps();
1243                      } catch (IllegalArgumentException e) {
1244                          Log.e(TAG, &quot;Error updating wallpaper offset: &quot; + e);
1245                      }
1246                  }
1247              }
1248          }
1249  
1250          public boolean computeScrollOffset() {
1251              final float oldOffset = mCurrentOffset;
1252              if (mAnimating) {
1253                  long durationSinceAnimation = System.currentTimeMillis() - mAnimationStartTime;
1254                  float t0 = durationSinceAnimation / (float) ANIMATION_DURATION;
1255                  float t1 = mInterpolator.getInterpolation(t0);
1256                  mCurrentOffset = mAnimationStartOffset +
1257                          (mFinalOffset - mAnimationStartOffset) * t1;
1258                  mAnimating = durationSinceAnimation &lt; ANIMATION_DURATION;
1259              } else {
1260                  mCurrentOffset = mFinalOffset;
1261              }
1262  
1263              if (Math.abs(mCurrentOffset - mFinalOffset) &gt; 0.0000001f) {
1264                  scheduleUpdate();
1265              }
1266              if (Math.abs(oldOffset - mCurrentOffset) &gt; 0.0000001f) {
1267                  return true;
1268              }
1269              return false;
1270          }
1271  
1272          private float wallpaperOffsetForCurrentScroll() {
1273              if (getChildCount() &lt;= 1) {
1274                  return 0;
1275              }
1276  
1277              // Exclude the leftmost page
1278              int emptyExtraPages = numEmptyScreensToIgnore();
1279              int firstIndex = numCustomPages();
1280              // Exclude the last extra empty screen (if we have &gt; MIN_PARALLAX_PAGE_SPAN pages)
1281              int lastIndex = getChildCount() - 1 - emptyExtraPages;
1282              if (isLayoutRtl()) {
1283                  int temp = firstIndex;
1284                  firstIndex = lastIndex;
1285                  lastIndex = temp;
1286              }
1287  
1288              int firstPageScrollX = getScrollForPage(firstIndex);
1289              int scrollRange = getScrollForPage(lastIndex) - firstPageScrollX;
1290              if (scrollRange == 0) {
1291                  return 0;
1292              } else {
1293                  // TODO: do different behavior if it&#x27;s  a live wallpaper?
1294                  // Sometimes the left parameter of the pages is animated during a layout transition;
1295                  // this parameter offsets it to keep the wallpaper from animating as well
1296                  int adjustedScroll =
1297                          getScrollX() - firstPageScrollX - getLayoutTransitionOffsetForPage(0);
1298                  float offset = Math.min(1, adjustedScroll / (float) scrollRange);
1299                  offset = Math.max(0, offset);
1300                  // Don&#x27;t use up all the wallpaper parallax until you have at least
1301                  // MIN_PARALLAX_PAGE_SPAN pages
1302                  int numScrollingPages = getNumScreensExcludingEmptyAndCustom();
1303                  int parallaxPageSpan = Math.max(MIN_PARALLAX_PAGE_SPAN, numScrollingPages - 1);
1304                  // On RTL devices, push the wallpaper offset to the right if we don&#x27;t have enough
1305                  // pages (ie if numScrollingPages &lt; MIN_PARALLAX_PAGE_SPAN)
1306                  int padding = isLayoutRtl() ? parallaxPageSpan - numScrollingPages + 1 : 0;
1307                  return offset * (padding + numScrollingPages - 1) / parallaxPageSpan;
1308              }
1309          }
1310  
1311          private int numEmptyScreensToIgnore() {
1312              int numScrollingPages = getChildCount() - numCustomPages();
1313              if (numScrollingPages &gt;= MIN_PARALLAX_PAGE_SPAN &amp;&amp; hasExtraEmptyScreen()) {
1314                  return 1;
1315              } else {
1316                  return 0;
1317              }
1318          }
1319  
1320          private int getNumScreensExcludingEmptyAndCustom() {
1321              int numScrollingPages = getChildCount() - numEmptyScreensToIgnore() - numCustomPages();
1322              return numScrollingPages;
1323          }
1324  
1325          public void syncWithScroll() {
1326              float offset = wallpaperOffsetForCurrentScroll();
1327              mWallpaperOffset.setFinalX(offset);
1328              updateOffset(true);
1329          }
1330  
1331          public float getCurrX() {
1332              return mCurrentOffset;
1333          }
1334  
1335          public float getFinalX() {
1336              return mFinalOffset;
1337          }
1338  
1339          private void animateToFinal() {
1340              mAnimating = true;
1341              mAnimationStartOffset = mCurrentOffset;
1342              mAnimationStartTime = System.currentTimeMillis();
1343          }
1344  
1345          private void setWallpaperOffsetSteps() {
1346              // Set wallpaper offset steps (1 / (number of screens - 1))
1347              mWallpaperManager.setWallpaperOffsetSteps(1.0f / (getChildCount() - 1), 1.0f);
1348          }
1349  
1350          public void setFinalX(float x) {
1351              scheduleUpdate();
1352              mFinalOffset = Math.max(0f, Math.min(x, 1.0f));
1353              if (getNumScreensExcludingEmptyAndCustom() != mNumScreens) {
1354                  if (mNumScreens &gt; 0) {
1355                      // Don&#x27;t animate if we&#x27;re going from 0 screens
1356                      animateToFinal();
1357                  }
1358                  mNumScreens = getNumScreensExcludingEmptyAndCustom();
1359              }
1360          }
1361  
1362          private void scheduleUpdate() {
1363              if (!mWaitingForUpdate) {
1364                  mChoreographer.postFrameCallback(this);
1365                  mWaitingForUpdate = true;
1366              }
1367          }
1368  
1369          public void jumpToFinal() {
1370              mCurrentOffset = mFinalOffset;
1371          }
1372      }
1373  
1374      @Override
1375      public void computeScroll() {
1376          super.computeScroll();
1377          mWallpaperOffset.syncWithScroll();
1378      }
1379  
1380      void showOutlines() {
1381          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1382              if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
1383              if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1384              mChildrenOutlineFadeInAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 1.0f);
1385              mChildrenOutlineFadeInAnimation.setDuration(CHILDREN_OUTLINE_FADE_IN_DURATION);
1386              mChildrenOutlineFadeInAnimation.start();
1387          }
1388      }
1389  
1390      void hideOutlines() {
1391          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
1392              if (mChildrenOutlineFadeInAnimation != null) mChildrenOutlineFadeInAnimation.cancel();
1393              if (mChildrenOutlineFadeOutAnimation != null) mChildrenOutlineFadeOutAnimation.cancel();
1394              mChildrenOutlineFadeOutAnimation = LauncherAnimUtils.ofFloat(this, &quot;childrenOutlineAlpha&quot;, 0.0f);
1395              mChildrenOutlineFadeOutAnimation.setDuration(CHILDREN_OUTLINE_FADE_OUT_DURATION);
1396              mChildrenOutlineFadeOutAnimation.setStartDelay(CHILDREN_OUTLINE_FADE_OUT_DELAY);
1397              mChildrenOutlineFadeOutAnimation.start();
1398          }
1399      }
1400  
1401      public void showOutlinesTemporarily() {
1402          if (!mIsPageMoving &amp;&amp; !isTouchActive()) {
1403              snapToPage(mCurrentPage);
1404          }
1405      }
1406  
1407      public void setChildrenOutlineAlpha(float alpha) {
1408          mChildrenOutlineAlpha = alpha;
1409          for (int i = 0; i &lt; getChildCount(); i++) {
1410              CellLayout cl = (CellLayout) getChildAt(i);
1411              cl.setBackgroundAlpha(alpha);
1412          }
1413      }
1414  
1415      public float getChildrenOutlineAlpha() {
1416          return mChildrenOutlineAlpha;
1417      }
1418  
1419      void disableBackground() {
1420          mDrawBackground = false;
1421      }
1422      void enableBackground() {
1423          mDrawBackground = true;
1424      }
1425  
1426      private void animateBackgroundGradient(float finalAlpha, boolean animated) {
1427          if (mBackground == null) return;
1428          if (mBackgroundFadeInAnimation != null) {
1429              mBackgroundFadeInAnimation.cancel();
1430              mBackgroundFadeInAnimation = null;
1431          }
1432          if (mBackgroundFadeOutAnimation != null) {
1433              mBackgroundFadeOutAnimation.cancel();
1434              mBackgroundFadeOutAnimation = null;
1435          }
1436          float startAlpha = getBackgroundAlpha();
1437          if (finalAlpha != startAlpha) {
1438              if (animated) {
1439                  mBackgroundFadeOutAnimation =
1440                          LauncherAnimUtils.ofFloat(this, startAlpha, finalAlpha);
1441                  mBackgroundFadeOutAnimation.addUpdateListener(new AnimatorUpdateListener() {
1442                      public void onAnimationUpdate(ValueAnimator animation) {
1443                          setBackgroundAlpha(((Float) animation.getAnimatedValue()).floatValue());
1444                      }
1445                  });
1446                  mBackgroundFadeOutAnimation.setInterpolator(new DecelerateInterpolator(1.5f));
1447                  mBackgroundFadeOutAnimation.setDuration(BACKGROUND_FADE_OUT_DURATION);
1448                  mBackgroundFadeOutAnimation.start();
1449              } else {
1450                  setBackgroundAlpha(finalAlpha);
1451              }
1452          }
1453      }
1454  
1455      public void setBackgroundAlpha(float alpha) {
1456          if (alpha != mBackgroundAlpha) {
1457              mBackgroundAlpha = alpha;
1458              invalidate();
1459          }
1460      }
1461  
1462      public float getBackgroundAlpha() {
1463          return mBackgroundAlpha;
1464      }
1465  
1466      float backgroundAlphaInterpolator(float r) {
1467          float pivotA = 0.1f;
1468          float pivotB = 0.4f;
1469          if (r &lt; pivotA) {
1470              return 0;
1471          } else if (r &gt; pivotB) {
1472              return 1.0f;
1473          } else {
1474              return (r - pivotA)/(pivotB - pivotA);
1475          }
1476      }
1477  
1478      private void updatePageAlphaValues(int screenCenter) {
1479          boolean isInOverscroll = mOverScrollX &lt; 0 || mOverScrollX &gt; mMaxScrollX;
1480          if (mWorkspaceFadeInAdjacentScreens &amp;&amp;
1481                  mState == State.NORMAL &amp;&amp;
1482                  !mIsSwitchingState &amp;&amp;
1483                  !isInOverscroll) {
1484              for (int i = numCustomPages(); i &lt; getChildCount(); i++) {
1485                  CellLayout child = (CellLayout) getChildAt(i);
1486                  if (child != null) {
1487                      float scrollProgress = getScrollProgress(screenCenter, child, i);
1488                      float alpha = 1 - Math.abs(scrollProgress);
1489                      child.getShortcutsAndWidgets().setAlpha(alpha);
1490                  }
1491              }
1492          }
1493      }
1494  
1495      private void setChildrenBackgroundAlphaMultipliers(float a) {
1496          for (int i = 0; i &lt; getChildCount(); i++) {
1497              CellLayout child = (CellLayout) getChildAt(i);
1498              child.setBackgroundAlphaMultiplier(a);
1499          }
1500      }
1501  
1502      public boolean hasCustomContent() {
1503          return (mScreenOrder.size() &gt; 0 &amp;&amp; mScreenOrder.get(0) == CUSTOM_CONTENT_SCREEN_ID);
1504      }
1505  
1506      public int numCustomPages() {
1507          return hasCustomContent() ? 1 : 0;
1508      }
1509  
1510      public boolean isOnOrMovingToCustomContent() {
1511          return hasCustomContent() &amp;&amp; getNextPage() == 0;
1512      }
1513  
1514      private void updateStateForCustomContent(int screenCenter) {
1515          float translationX = 0;
1516          float progress = 0;
1517          if (hasCustomContent()) {
1518              int index = mScreenOrder.indexOf(CUSTOM_CONTENT_SCREEN_ID);
1519  
1520              int scrollDelta = getScrollX() - getScrollForPage(index) -
1521                      getLayoutTransitionOffsetForPage(index);
1522              float scrollRange = getScrollForPage(index + 1) - getScrollForPage(index);
1523              translationX = scrollRange - scrollDelta;
1524              progress = (scrollRange - scrollDelta) / scrollRange;
1525  
1526              if (isLayoutRtl()) {
1527                  translationX = Math.min(0, translationX);
1528              } else {
1529                  translationX = Math.max(0, translationX);
1530              }
1531              progress = Math.max(0, progress);
1532          }
1533  
1534          if (Float.compare(progress, mLastCustomContentScrollProgress) == 0) return;
1535  
1536          CellLayout cc = mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID);
1537          if (progress &gt; 0 &amp;&amp; cc.getVisibility() != VISIBLE &amp;&amp; !isSmall()) {
1538              cc.setVisibility(VISIBLE);
1539          }
1540  
1541          mLastCustomContentScrollProgress = progress;
1542  
1543          setBackgroundAlpha(progress * 0.8f);
1544  
1545          if (mLauncher.getHotseat() != null) {
1546              mLauncher.getHotseat().setTranslationX(translationX);
1547          }
1548  
1549          if (getPageIndicator() != null) {
1550              getPageIndicator().setTranslationX(translationX);
1551          }
1552  
1553          if (mCustomContentCallbacks != null) {
1554              mCustomContentCallbacks.onScrollProgressChanged(progress);
1555          }
1556      }
1557  
1558      @Override
1559      protected OnClickListener getPageIndicatorClickListener() {
1560          AccessibilityManager am = (AccessibilityManager)
1561                  getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
1562          if (!am.isTouchExplorationEnabled()) {
1563              return null;
1564          }
1565          OnClickListener listener = new OnClickListener() {
1566              @Override
1567              public void onClick(View arg0) {
1568                  enterOverviewMode();
1569              }
1570          };
1571          return listener;
1572      }
1573  
1574      @Override
1575      protected void screenScrolled(int screenCenter) {
1576          final boolean isRtl = isLayoutRtl();
1577          super.screenScrolled(screenCenter);
1578  
1579          updatePageAlphaValues(screenCenter);
1580          updateStateForCustomContent(screenCenter);
1581          enableHwLayersOnVisiblePages();
1582  
1583          boolean shouldOverScroll = (mOverScrollX &lt; 0 &amp;&amp; (!hasCustomContent() || isLayoutRtl())) ||
1584                  (mOverScrollX &gt; mMaxScrollX &amp;&amp; (!hasCustomContent() || !isLayoutRtl()));
1585  
1586          if (shouldOverScroll) {
1587              int index = 0;
1588              float pivotX = 0f;
1589              final float leftBiasedPivot = 0.25f;
1590              final float rightBiasedPivot = 0.75f;
1591              final int lowerIndex = 0;
1592              final int upperIndex = getChildCount() - 1;
1593  
1594              final boolean isLeftPage = mOverScrollX &lt; 0;
1595              index = (!isRtl &amp;&amp; isLeftPage) || (isRtl &amp;&amp; !isLeftPage) ? lowerIndex : upperIndex;
1596              pivotX = isLeftPage ? rightBiasedPivot : leftBiasedPivot;
1597  
1598              CellLayout cl = (CellLayout) getChildAt(index);
1599              float scrollProgress = getScrollProgress(screenCenter, cl, index);
1600              cl.setOverScrollAmount(Math.abs(scrollProgress), isLeftPage);
1601              float rotation = -WORKSPACE_OVERSCROLL_ROTATION * scrollProgress;
1602              cl.setRotationY(rotation);
1603  
1604              if (!mOverscrollTransformsSet || Float.compare(mLastOverscrollPivotX, pivotX) != 0) {
1605                  mOverscrollTransformsSet = true;
1606                  mLastOverscrollPivotX = pivotX;
1607                  cl.setCameraDistance(mDensity * mCameraDistance);
1608                  cl.setPivotX(cl.getMeasuredWidth() * pivotX);
1609                  cl.setPivotY(cl.getMeasuredHeight() * 0.5f);
1610                  cl.setOverscrollTransformsDirty(true);
1611              }
1612          } else {
1613              if (mOverscrollTransformsSet) {
1614                  mOverscrollTransformsSet = false;
1615                  ((CellLayout) getChildAt(0)).resetOverscrollTransforms();
1616                  ((CellLayout) getChildAt(getChildCount() - 1)).resetOverscrollTransforms();
1617              }
1618          }
1619      }
1620  
1621      @Override
1622      protected void overScroll(float amount) {
1623          acceleratedOverScroll(amount);
1624      }
1625  
1626      protected void onAttachedToWindow() {
1627          super.onAttachedToWindow();
1628          mWindowToken = getWindowToken();
1629          computeScroll();
1630          mDragController.setWindowToken(mWindowToken);
1631      }
1632  
1633      protected void onDetachedFromWindow() {
1634          super.onDetachedFromWindow();
1635          mWindowToken = null;
1636      }
1637  
1638      protected void onResume() {
1639          if (getPageIndicator() != null) {
1640              // In case accessibility state has changed, we need to perform this on every
1641              // attach to window
1642              OnClickListener listener = getPageIndicatorClickListener();
1643              if (listener != null) {
1644                  getPageIndicator().setOnClickListener(listener);
1645              }
1646          }
1647          AccessibilityManager am = (AccessibilityManager)
1648                  getContext().getSystemService(Context.ACCESSIBILITY_SERVICE);
1649          sAccessibilityEnabled = am.isEnabled();
1650      }
1651  
1652      @Override
1653      protected void onLayout(boolean changed, int left, int top, int right, int bottom) {
1654          if (mFirstLayout &amp;&amp; mCurrentPage &gt;= 0 &amp;&amp; mCurrentPage &lt; getChildCount()) {
1655              mWallpaperOffset.syncWithScroll();
1656              mWallpaperOffset.jumpToFinal();
1657          }
1658          super.onLayout(changed, left, top, right, bottom);
1659      }
1660  
1661      @Override
1662      protected void onDraw(Canvas canvas) {
1663          // Draw the background gradient if necessary
1664          if (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground) {
1665              int alpha = (int) (mBackgroundAlpha * 255);
1666              mBackground.setAlpha(alpha);
1667              mBackground.setBounds(getScrollX(), 0, getScrollX() + getMeasuredWidth(),
1668                      getMeasuredHeight());
1669              mBackground.draw(canvas);
1670          }
1671  
1672          super.onDraw(canvas);
1673  
1674          // Call back to LauncherModel to finish binding after the first draw
1675          post(mBindPages);
1676      }
1677  
1678      boolean isDrawingBackgroundGradient() {
1679          return (mBackground != null &amp;&amp; mBackgroundAlpha &gt; 0.0f &amp;&amp; mDrawBackground);
1680      }
1681  
1682      @Override
1683      protected boolean onRequestFocusInDescendants(int direction, Rect previouslyFocusedRect) {
1684          if (!mLauncher.isAllAppsVisible()) {
1685              final Folder openFolder = getOpenFolder();
1686              if (openFolder != null) {
1687                  return openFolder.requestFocus(direction, previouslyFocusedRect);
1688              } else {
1689                  return super.onRequestFocusInDescendants(direction, previouslyFocusedRect);
1690              }
1691          }
1692          return false;
1693      }
1694  
1695      @Override
1696      public int getDescendantFocusability() {
1697          if (isSmall()) {
1698              return ViewGroup.FOCUS_BLOCK_DESCENDANTS;
1699          }
1700          return super.getDescendantFocusability();
1701      }
1702  
1703      @Override
1704      public void addFocusables(ArrayList&lt;View&gt; views, int direction, int focusableMode) {
1705          if (!mLauncher.isAllAppsVisible()) {
1706              final Folder openFolder = getOpenFolder();
1707              if (openFolder != null) {
1708                  openFolder.addFocusables(views, direction);
1709              } else {
1710                  super.addFocusables(views, direction, focusableMode);
1711              }
1712          }
1713      }
1714  
1715      public boolean isSmall() {
1716          return mState == State.SMALL || mState == State.SPRING_LOADED || mState == State.OVERVIEW;
1717      }
1718  
1719      void enableChildrenCache(int fromPage, int toPage) {
1720          if (fromPage &gt; toPage) {
1721              final int temp = fromPage;
1722              fromPage = toPage;
1723              toPage = temp;
1724          }
1725  
1726          final int screenCount = getChildCount();
1727  
1728          fromPage = Math.max(fromPage, 0);
1729          toPage = Math.min(toPage, screenCount - 1);
1730  
1731          for (int i = fromPage; i &lt;= toPage; i++) {
1732              final CellLayout layout = (CellLayout) getChildAt(i);
1733              layout.setChildrenDrawnWithCacheEnabled(true);
1734              layout.setChildrenDrawingCacheEnabled(true);
1735          }
1736      }
1737  
1738      void clearChildrenCache() {
1739          final int screenCount = getChildCount();
1740          for (int i = 0; i &lt; screenCount; i++) {
1741              final CellLayout layout = (CellLayout) getChildAt(i);
1742              layout.setChildrenDrawnWithCacheEnabled(false);
1743              // In software mode, we don&#x27;t want the items to continue to be drawn into bitmaps
1744              if (!isHardwareAccelerated()) {
1745                  layout.setChildrenDrawingCacheEnabled(false);
1746              }
1747          }
1748      }
1749  
1750      private void updateChildrenLayersEnabled(boolean force) {
1751          boolean small = mState == State.SMALL || mState == State.OVERVIEW || mIsSwitchingState;
1752          boolean enableChildrenLayers = force || small || mAnimatingViewIntoPlace || isPageMoving();
1753  
1754          if (enableChildrenLayers != mChildrenLayersEnabled) {
1755              mChildrenLayersEnabled = enableChildrenLayers;
1756              if (mChildrenLayersEnabled) {
1757                  enableHwLayersOnVisiblePages();
1758              } else {
1759                  for (int i = 0; i &lt; getPageCount(); i++) {
1760                      final CellLayout cl = (CellLayout) getChildAt(i);
1761                      cl.enableHardwareLayer(false);
1762                  }
1763              }
1764          }
1765      }
1766  
1767      private void enableHwLayersOnVisiblePages() {
1768          if (mChildrenLayersEnabled) {
1769              final int screenCount = getChildCount();
1770              getVisiblePages(mTempVisiblePagesRange);
1771              int leftScreen = mTempVisiblePagesRange[0];
1772              int rightScreen = mTempVisiblePagesRange[1];
1773              if (leftScreen == rightScreen) {
1774                  // make sure we&#x27;re caching at least two pages always
1775                  if (rightScreen &lt; screenCount - 1) {
1776                      rightScreen++;
1777                  } else if (leftScreen &gt; 0) {
1778                      leftScreen--;
1779                  }
1780              }
1781  
1782              final CellLayout customScreen = mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID);
1783              for (int i = 0; i &lt; screenCount; i++) {
1784                  final CellLayout layout = (CellLayout) getPageAt(i);
1785  
1786                  // enable layers between left and right screen inclusive, except for the
1787                  // customScreen, which may animate its content during transitions.
1788                  boolean enableLayer = layout != customScreen &amp;&amp;
1789                          leftScreen &lt;= i &amp;&amp; i &lt;= rightScreen &amp;&amp; shouldDrawChild(layout);
1790                  layout.enableHardwareLayer(enableLayer);
1791              }
1792          }
1793      }
1794  
1795      public void buildPageHardwareLayers() {
1796          // force layers to be enabled just for the call to buildLayer
1797          updateChildrenLayersEnabled(true);
1798          if (getWindowToken() != null) {
1799              final int childCount = getChildCount();
1800              for (int i = 0; i &lt; childCount; i++) {
1801                  CellLayout cl = (CellLayout) getChildAt(i);
1802                  cl.buildHardwareLayer();
1803              }
1804          }
1805          updateChildrenLayersEnabled(false);
1806      }
1807  
1808      protected void onWallpaperTap(MotionEvent ev) {
1809          final int[] position = mTempCell;
1810          getLocationOnScreen(position);
1811  
1812          int pointerIndex = ev.getActionIndex();
1813          position[0] += (int) ev.getX(pointerIndex);
1814          position[1] += (int) ev.getY(pointerIndex);
1815  
1816          mWallpaperManager.sendWallpaperCommand(getWindowToken(),
1817                  ev.getAction() == MotionEvent.ACTION_UP
1818                          ? WallpaperManager.COMMAND_TAP : WallpaperManager.COMMAND_SECONDARY_TAP,
1819                  position[0], position[1], 0, null);
1820      }
1821  
1822      /*
1823       * This interpolator emulates the rate at which the perceived scale of an object changes
1824       * as its distance from a camera increases. When this interpolator is applied to a scale
1825       * animation on a view, it evokes the sense that the object is shrinking due to moving away
1826       * from the camera.
1827       */
1828      static class ZInterpolator implements TimeInterpolator {
1829          private float focalLength;
1830  
1831          public ZInterpolator(float foc) {
1832              focalLength = foc;
1833          }
1834  
1835          public float getInterpolation(float input) {
1836              return (1.0f - focalLength / (focalLength + input)) /
1837                  (1.0f - focalLength / (focalLength + 1.0f));
1838          }
1839      }
1840  
1841      /*
1842       * The exact reverse of ZInterpolator.
1843       */
1844      static class InverseZInterpolator implements TimeInterpolator {
1845          private ZInterpolator zInterpolator;
1846          public InverseZInterpolator(float foc) {
1847              zInterpolator = new ZInterpolator(foc);
1848          }
1849          public float getInterpolation(float input) {
1850              return 1 - zInterpolator.getInterpolation(1 - input);
1851          }
1852      }
1853  
1854      /*
1855       * ZInterpolator compounded with an ease-out.
1856       */
1857      static class ZoomOutInterpolator implements TimeInterpolator {
1858          private final DecelerateInterpolator decelerate = new DecelerateInterpolator(0.75f);
1859          private final ZInterpolator zInterpolator = new ZInterpolator(0.13f);
1860  
1861          public float getInterpolation(float input) {
1862              return decelerate.getInterpolation(zInterpolator.getInterpolation(input));
1863          }
1864      }
1865  
1866      /*
1867       * InvereZInterpolator compounded with an ease-out.
1868       */
1869      static class ZoomInInterpolator implements TimeInterpolator {
1870          private final InverseZInterpolator inverseZInterpolator = new InverseZInterpolator(0.35f);
1871          private final DecelerateInterpolator decelerate = new DecelerateInterpolator(3.0f);
1872  
1873          public float getInterpolation(float input) {
1874              return decelerate.getInterpolation(inverseZInterpolator.getInterpolation(input));
1875          }
1876      }
1877  
1878      private final ZoomInInterpolator mZoomInInterpolator = new ZoomInInterpolator();
1879  
1880      /*
1881      *
1882      * We call these methods (onDragStartedWithItemSpans/onDragStartedWithSize) whenever we
1883      * start a drag in Launcher, regardless of whether the drag has ever entered the Workspace
1884      *
1885      * These methods mark the appropriate pages as accepting drops (which alters their visual
1886      * appearance).
1887      *
1888      */
1889      public void onDragStartedWithItem(View v) {
1890          final Canvas canvas = new Canvas();
1891  
1892          // The outline is used to visualize where the item will land if dropped
1893          mDragOutline = createDragOutline(v, canvas, DRAG_BITMAP_PADDING);
1894      }
1895  
1896      public void onDragStartedWithItem(PendingAddItemInfo info, Bitmap b, boolean clipAlpha) {
1897          final Canvas canvas = new Canvas();
1898  
1899          int[] size = estimateItemSize(info.spanX, info.spanY, info, false);
1900  
1901          // The outline is used to visualize where the item will land if dropped
1902          mDragOutline = createDragOutline(b, canvas, DRAG_BITMAP_PADDING, size[0],
1903                  size[1], clipAlpha);
1904      }
1905  
1906      public void exitWidgetResizeMode() {
1907          DragLayer dragLayer = mLauncher.getDragLayer();
1908          dragLayer.clearAllResizeFrames();
1909      }
1910  
1911      private void initAnimationArrays() {
1912          final int childCount = getChildCount();
1913          if (mLastChildCount == childCount) return;
1914  
1915          mOldBackgroundAlphas = new float[childCount];
1916          mOldAlphas = new float[childCount];
1917          mNewBackgroundAlphas = new float[childCount];
1918          mNewAlphas = new float[childCount];
1919      }
1920  
1921      Animator getChangeStateAnimation(final State state, boolean animated) {
1922          return getChangeStateAnimation(state, animated, 0, -1);
1923      }
1924  
1925      @Override
1926      protected void getOverviewModePages(int[] range) {
1927          int start = numCustomPages();
1928          int end = getChildCount() - 1;
1929  
1930          range[0] = Math.max(0, Math.min(start, getChildCount() - 1));
1931          range[1] = Math.max(0,  end);
1932       }
1933  
1934      protected void onStartReordering() {
1935          super.onStartReordering();
1936          showOutlines();
1937          // Reordering handles its own animations, disable the automatic ones.
1938          disableLayoutTransitions();
1939      }
1940  
1941      protected void onEndReordering() {
1942          super.onEndReordering();
1943  
1944          hideOutlines();
1945          mScreenOrder.clear();
1946          int count = getChildCount();
1947          for (int i = 0; i &lt; count; i++) {
1948              CellLayout cl = ((CellLayout) getChildAt(i));
1949              mScreenOrder.add(getIdForScreen(cl));
1950          }
1951  
1952          mLauncher.getModel().updateWorkspaceScreenOrder(mLauncher, mScreenOrder);
1953  
1954          // Re-enable auto layout transitions for page deletion.
1955          enableLayoutTransitions();
1956      }
1957  
1958      public boolean isInOverviewMode() {
1959          return mState == State.OVERVIEW;
1960      }
1961  
1962      public boolean enterOverviewMode() {
1963          if (mTouchState != TOUCH_STATE_REST) {
1964              return false;
1965          }
1966          enableOverviewMode(true, -1, true);
1967          return true;
1968      }
1969  
1970      public void exitOverviewMode(boolean animated) {
1971          exitOverviewMode(-1, animated);
1972      }
1973  
1974      public void exitOverviewMode(int snapPage, boolean animated) {
1975          enableOverviewMode(false, snapPage, animated);
1976      }
1977  
1978      private void enableOverviewMode(boolean enable, int snapPage, boolean animated) {
1979          State finalState = Workspace.State.OVERVIEW;
1980          if (!enable) {
1981              finalState = Workspace.State.NORMAL;
1982          }
1983  
1984          Animator workspaceAnim = getChangeStateAnimation(finalState, animated, 0, snapPage);
1985          if (workspaceAnim != null) {
1986              onTransitionPrepare();
1987              workspaceAnim.addListener(new AnimatorListenerAdapter() {
1988                  @Override
1989                  public void onAnimationEnd(Animator arg0) {
1990                      onTransitionEnd();
1991                  }
1992              });
1993              workspaceAnim.start();
1994          }
1995      }
1996  
1997      int getOverviewModeTranslationY() {
1998          LauncherAppState app = LauncherAppState.getInstance();
1999          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2000          Rect overviewBar = grid.getOverviewModeButtonBarRect();
2001  
2002          int availableHeight = getViewportHeight();
2003          int scaledHeight = (int) (mOverviewModeShrinkFactor * getNormalChildHeight());
2004          int offsetFromTopEdge = (availableHeight - scaledHeight) / 2;
2005          int offsetToCenterInOverview = (availableHeight - mInsets.top - overviewBar.height()
2006                  - scaledHeight) / 2;
2007  
2008          return -offsetFromTopEdge + mInsets.top + offsetToCenterInOverview;
2009      }
2010  
2011      boolean shouldVoiceButtonProxyBeVisible() {
2012          if (isOnOrMovingToCustomContent()) {
2013              return false;
2014          }
2015          if (mState != State.NORMAL) {
2016              return false;
2017          }
2018          return true;
2019      }
2020  
2021      public void updateInteractionForState() {
2022          if (mState != State.NORMAL) {
2023              mLauncher.onInteractionBegin();
2024          } else {
2025              mLauncher.onInteractionEnd();
2026          }
2027      }
2028  
2029      private void setState(State state) {
2030          mState = state;
2031          updateInteractionForState();
2032          updateAccessibilityFlags();
2033      }
2034  
2035      private void updateAccessibilityFlags() {
2036          int accessible = mState == State.NORMAL ?
2037                  ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_YES :
2038                  ViewCompat.IMPORTANT_FOR_ACCESSIBILITY_NO_HIDE_DESCENDANTS;
2039          setImportantForAccessibility(accessible);
2040      }
2041  
2042      Animator getChangeStateAnimation(final State state, boolean animated, int delay, int snapPage) {
2043          if (mState == state) {
2044              return null;
2045          }
2046  
2047          // Initialize animation arrays for the first time if necessary
2048          initAnimationArrays();
2049  
2050          AnimatorSet anim = animated ? LauncherAnimUtils.createAnimatorSet() : null;
2051  
2052          final State oldState = mState;
2053          final boolean oldStateIsNormal = (oldState == State.NORMAL);
2054          final boolean oldStateIsSpringLoaded = (oldState == State.SPRING_LOADED);
2055          final boolean oldStateIsSmall = (oldState == State.SMALL);
2056          final boolean oldStateIsOverview = (oldState == State.OVERVIEW);
2057          setState(state);
2058          final boolean stateIsNormal = (state == State.NORMAL);
2059          final boolean stateIsSpringLoaded = (state == State.SPRING_LOADED);
2060          final boolean stateIsSmall = (state == State.SMALL);
2061          final boolean stateIsOverview = (state == State.OVERVIEW);
2062          float finalBackgroundAlpha = (stateIsSpringLoaded || stateIsOverview) ? 1.0f : 0f;
2063          float finalHotseatAndPageIndicatorAlpha = (stateIsOverview || stateIsSmall) ? 0f : 1f;
2064          float finalOverviewPanelAlpha = stateIsOverview ? 1f : 0f;
2065          float finalSearchBarAlpha = !stateIsNormal ? 0f : 1f;
2066          float finalWorkspaceTranslationY = stateIsOverview ? getOverviewModeTranslationY() : 0;
2067  
2068          boolean workspaceToAllApps = (oldStateIsNormal &amp;&amp; stateIsSmall);
2069          boolean allAppsToWorkspace = (oldStateIsSmall &amp;&amp; stateIsNormal);
2070          boolean workspaceToOverview = (oldStateIsNormal &amp;&amp; stateIsOverview);
2071          boolean overviewToWorkspace = (oldStateIsOverview &amp;&amp; stateIsNormal);
2072  
2073          mNewScale = 1.0f;
2074  
2075          if (oldStateIsOverview) {
2076              disableFreeScroll(snapPage);
2077          } else if (stateIsOverview) {
2078              enableFreeScroll();
2079          }
2080  
2081          if (state != State.NORMAL) {
2082              if (stateIsSpringLoaded) {
2083                  mNewScale = mSpringLoadedShrinkFactor;
2084              } else if (stateIsOverview) {
2085                  mNewScale = mOverviewModeShrinkFactor;
2086              } else if (stateIsSmall){
2087                  mNewScale = mOverviewModeShrinkFactor - 0.3f;
2088              }
2089              if (workspaceToAllApps) {
2090                  updateChildrenLayersEnabled(false);
2091              }
2092          }
2093  
2094          final int duration;
2095          if (workspaceToAllApps) {
2096              duration = getResources().getInteger(R.integer.config_workspaceUnshrinkTime);
2097          } else if (workspaceToOverview || overviewToWorkspace) {
2098              duration = getResources().getInteger(R.integer.config_overviewTransitionTime);
2099          } else {
2100              duration = getResources().getInteger(R.integer.config_appsCustomizeWorkspaceShrinkTime);
2101          }
2102  
2103          for (int i = 0; i &lt; getChildCount(); i++) {
2104              final CellLayout cl = (CellLayout) getChildAt(i);
2105              boolean isCurrentPage = (i == getNextPage());
2106              float initialAlpha = cl.getShortcutsAndWidgets().getAlpha();
2107              float finalAlpha;
2108              if (stateIsSmall) {
2109                  finalAlpha = 0f;
2110              } else if (stateIsNormal &amp;&amp; mWorkspaceFadeInAdjacentScreens) {
2111                  finalAlpha = i == getNextPage() ? 1f : 0f;


2112              } else {
2113                  finalAlpha = 1f;
2114              }
2115  
2116              // If we are animating to/from the small state, then hide the side pages and fade the
2117              // current page in
2118              if (!mIsSwitchingState) {
2119                  if (workspaceToAllApps || allAppsToWorkspace) {
2120                      if (allAppsToWorkspace &amp;&amp; isCurrentPage) {
2121                          initialAlpha = 0f;
2122                      } else if (!isCurrentPage) {
2123                          initialAlpha = finalAlpha = 0f;
2124                      }
2125                      cl.setShortcutAndWidgetAlpha(initialAlpha);
2126                  }
2127              }
2128  
2129              mOldAlphas[i] = initialAlpha;
2130              mNewAlphas[i] = finalAlpha;
2131              if (animated) {
2132                  mOldBackgroundAlphas[i] = cl.getBackgroundAlpha();
2133                  mNewBackgroundAlphas[i] = finalBackgroundAlpha;
2134              } else {
2135                  cl.setBackgroundAlpha(finalBackgroundAlpha);
2136                  cl.setShortcutAndWidgetAlpha(finalAlpha);
2137              }
2138          }
2139  
2140          final View searchBar = mLauncher.getQsbBar();
2141          final View overviewPanel = mLauncher.getOverviewPanel();
2142          final View hotseat = mLauncher.getHotseat();
2143          if (animated) {
2144              anim.setDuration(duration);
2145              LauncherViewPropertyAnimator scale = new LauncherViewPropertyAnimator(this);
2146              scale.scaleX(mNewScale)
2147                  .scaleY(mNewScale)
2148                  .translationY(finalWorkspaceTranslationY)
2149                  .setInterpolator(mZoomInInterpolator);
2150              anim.play(scale);
2151              for (int index = 0; index &lt; getChildCount(); index++) {
2152                  final int i = index;
2153                  final CellLayout cl = (CellLayout) getChildAt(i);
2154                  float currentAlpha = cl.getShortcutsAndWidgets().getAlpha();
2155                  if (mOldAlphas[i] == 0 &amp;&amp; mNewAlphas[i] == 0) {
2156                      cl.setBackgroundAlpha(mNewBackgroundAlphas[i]);
2157                      cl.setShortcutAndWidgetAlpha(mNewAlphas[i]);
2158                  } else {
2159                      if (mOldAlphas[i] != mNewAlphas[i] || currentAlpha != mNewAlphas[i]) {
2160                          LauncherViewPropertyAnimator alphaAnim =
2161                              new LauncherViewPropertyAnimator(cl.getShortcutsAndWidgets());
2162                          alphaAnim.alpha(mNewAlphas[i])
2163                              .setInterpolator(mZoomInInterpolator);
2164                          anim.play(alphaAnim);
2165                      }
2166                      if (mOldBackgroundAlphas[i] != 0 ||
2167                          mNewBackgroundAlphas[i] != 0) {
2168                          ValueAnimator bgAnim =
2169                                  LauncherAnimUtils.ofFloat(cl, 0f, 1f);
2170                          bgAnim.setInterpolator(mZoomInInterpolator);
2171                          bgAnim.addUpdateListener(new LauncherAnimatorUpdateListener() {
2172                                  public void onAnimationUpdate(float a, float b) {
2173                                      cl.setBackgroundAlpha(
2174                                              a * mOldBackgroundAlphas[i] +
2175                                              b * mNewBackgroundAlphas[i]);
2176                                  }
2177                              });
2178                          anim.play(bgAnim);
2179                      }
2180                  }
2181              }
2182              ObjectAnimator pageIndicatorAlpha = null;
2183              if (getPageIndicator() != null) {
2184                  pageIndicatorAlpha = ObjectAnimator.ofFloat(getPageIndicator(), &quot;alpha&quot;,
2185                          finalHotseatAndPageIndicatorAlpha);
2186              }
2187              ObjectAnimator hotseatAlpha = ObjectAnimator.ofFloat(hotseat, &quot;alpha&quot;,
2188                      finalHotseatAndPageIndicatorAlpha);
2189              ObjectAnimator searchBarAlpha = ObjectAnimator.ofFloat(searchBar,
2190                      &quot;alpha&quot;, finalSearchBarAlpha);
2191              ObjectAnimator overviewPanelAlpha = ObjectAnimator.ofFloat(overviewPanel,
2192                      &quot;alpha&quot;, finalOverviewPanelAlpha);
2193  
2194              overviewPanelAlpha.addListener(new AlphaUpdateListener(overviewPanel));
2195              hotseatAlpha.addListener(new AlphaUpdateListener(hotseat));
2196              searchBarAlpha.addListener(new AlphaUpdateListener(searchBar));
2197  
2198              if (workspaceToOverview) {
2199                  hotseatAlpha.setInterpolator(new DecelerateInterpolator(2));
2200              } else if (overviewToWorkspace) {
2201                  overviewPanelAlpha.setInterpolator(new DecelerateInterpolator(2));
2202              }
2203  
2204              if (getPageIndicator() != null) {
2205                  pageIndicatorAlpha.addListener(new AlphaUpdateListener(getPageIndicator()));
2206              }
2207  
2208              anim.play(overviewPanelAlpha);
2209              anim.play(hotseatAlpha);
2210              anim.play(searchBarAlpha);
2211              anim.play(pageIndicatorAlpha);
2212              anim.setStartDelay(delay);
2213          } else {
2214              overviewPanel.setAlpha(finalOverviewPanelAlpha);
2215              AlphaUpdateListener.updateVisibility(overviewPanel);
2216              hotseat.setAlpha(finalHotseatAndPageIndicatorAlpha);
2217              AlphaUpdateListener.updateVisibility(hotseat);
2218              if (getPageIndicator() != null) {
2219                  getPageIndicator().setAlpha(finalHotseatAndPageIndicatorAlpha);
2220                  AlphaUpdateListener.updateVisibility(getPageIndicator());
2221              }
2222              searchBar.setAlpha(finalSearchBarAlpha);
2223              AlphaUpdateListener.updateVisibility(searchBar);
2224              updateCustomContentVisibility();
2225              setScaleX(mNewScale);
2226              setScaleY(mNewScale);
2227              setTranslationY(finalWorkspaceTranslationY);
2228          }
2229          mLauncher.updateVoiceButtonProxyVisible(false);
2230  
2231          if (stateIsSpringLoaded) {
2232              // Right now we&#x27;re covered by Apps Customize
2233              // Show the background gradient immediately, so the gradient will
2234              // be showing once AppsCustomize disappears
2235              animateBackgroundGradient(getResources().getInteger(
2236                      R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100f, false);
2237          } else if (stateIsOverview) {
2238              animateBackgroundGradient(getResources().getInteger(
2239                      R.integer.config_appsCustomizeSpringLoadedBgAlpha) / 100f, true);
2240          } else {
2241              // Fade the background gradient away
2242              animateBackgroundGradient(0f, animated);
2243          }
2244          return anim;
2245      }
2246  
2247      static class AlphaUpdateListener implements AnimatorUpdateListener, AnimatorListener {
2248          View view;
2249          public AlphaUpdateListener(View v) {
2250              view = v;
2251          }
2252  
2253          @Override
2254          public void onAnimationUpdate(ValueAnimator arg0) {
2255              updateVisibility(view);
2256          }
2257  
2258          public static void updateVisibility(View view) {
2259              // We want to avoid the extra layout pass by setting the views to GONE unless
2260              // accessibility is on, in which case not setting them to GONE causes a glitch.
2261              int invisibleState = sAccessibilityEnabled ? GONE : INVISIBLE;
2262              if (view.getAlpha() &lt; ALPHA_CUTOFF_THRESHOLD &amp;&amp; view.getVisibility() != invisibleState) {
2263                  view.setVisibility(invisibleState);
2264              } else if (view.getAlpha() &gt; ALPHA_CUTOFF_THRESHOLD
2265                      &amp;&amp; view.getVisibility() != VISIBLE) {
2266                  view.setVisibility(VISIBLE);
2267              }
2268          }
2269  
2270          @Override
2271          public void onAnimationCancel(Animator arg0) {
2272          }
2273  
2274          @Override
2275          public void onAnimationEnd(Animator arg0) {
2276              updateVisibility(view);
2277          }
2278  
2279          @Override
2280          public void onAnimationRepeat(Animator arg0) {
2281          }
2282  
2283          @Override
2284          public void onAnimationStart(Animator arg0) {
2285              // We want the views to be visible for animation, so fade-in/out is visible
2286              view.setVisibility(VISIBLE);
2287          }
2288      }
2289  
2290      @Override
2291      public void onLauncherTransitionPrepare(Launcher l, boolean animated, boolean toWorkspace) {
2292          onTransitionPrepare();
2293      }
2294  
2295      @Override
2296      public void onLauncherTransitionStart(Launcher l, boolean animated, boolean toWorkspace) {
2297      }
2298  
2299      @Override
2300      public void onLauncherTransitionStep(Launcher l, float t) {
2301          mTransitionProgress = t;
2302      }
2303  
2304      @Override
2305      public void onLauncherTransitionEnd(Launcher l, boolean animated, boolean toWorkspace) {
2306          onTransitionEnd();
2307      }
2308  
2309      private void onTransitionPrepare() {
2310          mIsSwitchingState = true;
2311  
2312          // Invalidate here to ensure that the pages are rendered during the state change transition.
2313          invalidate();
2314  
2315          updateChildrenLayersEnabled(false);
2316          hideCustomContentIfNecessary();
2317      }
2318  
2319      void updateCustomContentVisibility() {
2320          int visibility = mState == Workspace.State.NORMAL ? VISIBLE : INVISIBLE;
2321          if (hasCustomContent()) {
2322              mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(visibility);
2323          }
2324      }
2325  
2326      void showCustomContentIfNecessary() {
2327          boolean show  = mState == Workspace.State.NORMAL;
2328          if (show &amp;&amp; hasCustomContent()) {
2329              mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(VISIBLE);
2330          }
2331      }
2332  
2333      void hideCustomContentIfNecessary() {
2334          boolean hide  = mState != Workspace.State.NORMAL;
2335          if (hide &amp;&amp; hasCustomContent()) {
2336              mWorkspaceScreens.get(CUSTOM_CONTENT_SCREEN_ID).setVisibility(INVISIBLE);
2337          }
2338      }
2339  
2340      private void onTransitionEnd() {
2341          mIsSwitchingState = false;
2342          updateChildrenLayersEnabled(false);
2343          // The code in getChangeStateAnimation to determine initialAlpha and finalAlpha will ensure
2344          // ensure that only the current page is visible during (and subsequently, after) the
2345          // transition animation.  If fade adjacent pages is disabled, then re-enable the page
2346          // visibility after the transition animation.
2347          if (!mWorkspaceFadeInAdjacentScreens) {
2348              for (int i = 0; i &lt; getChildCount(); i++) {
2349                  final CellLayout cl = (CellLayout) getChildAt(i);
2350                  cl.setShortcutAndWidgetAlpha(1f);
2351              }





2352          }
2353          showCustomContentIfNecessary();
2354      }
2355  
2356      @Override
2357      public View getContent() {
2358          return this;
2359      }
2360  
2361      /**
2362       * Draw the View v into the given Canvas.
2363       *
2364       * @param v the view to draw
2365       * @param destCanvas the canvas to draw on
2366       * @param padding the horizontal and vertical padding to use when drawing
2367       */
2368      private void drawDragView(View v, Canvas destCanvas, int padding, boolean pruneToDrawable) {
2369          final Rect clipRect = mTempRect;
2370          v.getDrawingRect(clipRect);
2371  
2372          boolean textVisible = false;
2373  
2374          destCanvas.save();
2375          if (v instanceof TextView &amp;&amp; pruneToDrawable) {
2376              Drawable d = ((TextView) v).getCompoundDrawables()[1];
2377              clipRect.set(0, 0, d.getIntrinsicWidth() + padding, d.getIntrinsicHeight() + padding);
2378              destCanvas.translate(padding / 2, padding / 2);
2379              d.draw(destCanvas);
2380          } else {
2381              if (v instanceof FolderIcon) {
2382                  // For FolderIcons the text can bleed into the icon area, and so we need to
2383                  // hide the text completely (which can&#x27;t be achieved by clipping).
2384                  if (((FolderIcon) v).getTextVisible()) {
2385                      ((FolderIcon) v).setTextVisible(false);
2386                      textVisible = true;
2387                  }
2388              } else if (v instanceof BubbleTextView) {
2389                  final BubbleTextView tv = (BubbleTextView) v;
2390                  clipRect.bottom = tv.getExtendedPaddingTop() - (int) BubbleTextView.PADDING_V +
2391                          tv.getLayout().getLineTop(0);
2392              } else if (v instanceof TextView) {
2393                  final TextView tv = (TextView) v;
2394                  clipRect.bottom = tv.getExtendedPaddingTop() - tv.getCompoundDrawablePadding() +
2395                          tv.getLayout().getLineTop(0);
2396              }
2397              destCanvas.translate(-v.getScrollX() + padding / 2, -v.getScrollY() + padding / 2);
2398              destCanvas.clipRect(clipRect, Op.REPLACE);
2399              v.draw(destCanvas);
2400  
2401              // Restore text visibility of FolderIcon if necessary
2402              if (textVisible) {
2403                  ((FolderIcon) v).setTextVisible(true);
2404              }
2405          }
2406          destCanvas.restore();
2407      }
2408  
2409      /**
2410       * Returns a new bitmap to show when the given View is being dragged around.
2411       * Responsibility for the bitmap is transferred to the caller.
2412       */
2413      public Bitmap createDragBitmap(View v, Canvas canvas, int padding) {
2414          Bitmap b;
2415  
2416          if (v instanceof TextView) {
2417              Drawable d = ((TextView) v).getCompoundDrawables()[1];
2418              b = Bitmap.createBitmap(d.getIntrinsicWidth() + padding,
2419                      d.getIntrinsicHeight() + padding, Bitmap.Config.ARGB_8888);
2420          } else {
2421              b = Bitmap.createBitmap(
2422                      v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
2423          }
2424  
2425          canvas.setBitmap(b);
2426          drawDragView(v, canvas, padding, true);
2427          canvas.setBitmap(null);
2428  
2429          return b;
2430      }
2431  
2432      /**
2433       * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
2434       * Responsibility for the bitmap is transferred to the caller.
2435       */
2436      private Bitmap createDragOutline(View v, Canvas canvas, int padding) {
2437          final int outlineColor = getResources().getColor(R.color.outline_color);
2438          final Bitmap b = Bitmap.createBitmap(
2439                  v.getWidth() + padding, v.getHeight() + padding, Bitmap.Config.ARGB_8888);
2440  
2441          canvas.setBitmap(b);
2442          drawDragView(v, canvas, padding, true);
2443          mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor);
2444          canvas.setBitmap(null);
2445          return b;
2446      }
2447  
2448      /**
2449       * Returns a new bitmap to be used as the object outline, e.g. to visualize the drop location.
2450       * Responsibility for the bitmap is transferred to the caller.
2451       */
2452      private Bitmap createDragOutline(Bitmap orig, Canvas canvas, int padding, int w, int h,
2453              boolean clipAlpha) {
2454          final int outlineColor = getResources().getColor(R.color.outline_color);
2455          final Bitmap b = Bitmap.createBitmap(w, h, Bitmap.Config.ARGB_8888);
2456          canvas.setBitmap(b);
2457  
2458          Rect src = new Rect(0, 0, orig.getWidth(), orig.getHeight());
2459          float scaleFactor = Math.min((w - padding) / (float) orig.getWidth(),
2460                  (h - padding) / (float) orig.getHeight());
2461          int scaledWidth = (int) (scaleFactor * orig.getWidth());
2462          int scaledHeight = (int) (scaleFactor * orig.getHeight());
2463          Rect dst = new Rect(0, 0, scaledWidth, scaledHeight);
2464  
2465          // center the image
2466          dst.offset((w - scaledWidth) / 2, (h - scaledHeight) / 2);
2467  
2468          canvas.drawBitmap(orig, src, dst, null);
2469          mOutlineHelper.applyMediumExpensiveOutlineWithBlur(b, canvas, outlineColor, outlineColor,
2470                  clipAlpha);
2471          canvas.setBitmap(null);
2472  
2473          return b;
2474      }
2475  
2476      void startDrag(CellLayout.CellInfo cellInfo) {
2477          View child = cellInfo.cell;
2478  
2479          // Make sure the drag was started by a long press as opposed to a long click.
2480          if (!child.isInTouchMode()) {
2481              return;
2482          }
2483  
2484          mDragInfo = cellInfo;
2485          child.setVisibility(INVISIBLE);
2486          CellLayout layout = (CellLayout) child.getParent().getParent();
2487          layout.prepareChildForDrag(child);
2488  
2489          child.clearFocus();
2490          child.setPressed(false);
2491  
2492          final Canvas canvas = new Canvas();
2493  
2494          // The outline is used to visualize where the item will land if dropped
2495          mDragOutline = createDragOutline(child, canvas, DRAG_BITMAP_PADDING);
2496          beginDragShared(child, this);
2497      }
2498  
2499      public void beginDragShared(View child, DragSource source) {
2500          // The drag bitmap follows the touch point around on the screen
2501          final Bitmap b = createDragBitmap(child, new Canvas(), DRAG_BITMAP_PADDING);
2502  
2503          final int bmpWidth = b.getWidth();
2504          final int bmpHeight = b.getHeight();
2505  
2506          float scale = mLauncher.getDragLayer().getLocationInDragLayer(child, mTempXY);
2507          int dragLayerX =
2508                  Math.round(mTempXY[0] - (bmpWidth - scale * child.getWidth()) / 2);
2509          int dragLayerY =
2510                  Math.round(mTempXY[1] - (bmpHeight - scale * bmpHeight) / 2
2511                          - DRAG_BITMAP_PADDING / 2);
2512  
2513          LauncherAppState app = LauncherAppState.getInstance();
2514          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
2515          Point dragVisualizeOffset = null;
2516          Rect dragRect = null;
2517          if (child instanceof BubbleTextView || child instanceof PagedViewIcon) {
2518              int iconSize = grid.iconSizePx;
2519              int top = child.getPaddingTop();
2520              int left = (bmpWidth - iconSize) / 2;
2521              int right = left + iconSize;
2522              int bottom = top + iconSize;
2523              dragLayerY += top;
2524              // Note: The drag region is used to calculate drag layer offsets, but the
2525              // dragVisualizeOffset in addition to the dragRect (the size) to position the outline.
2526              dragVisualizeOffset = new Point(-DRAG_BITMAP_PADDING / 2, DRAG_BITMAP_PADDING / 2);
2527              dragRect = new Rect(left, top, right, bottom);
2528          } else if (child instanceof FolderIcon) {
2529              int previewSize = grid.folderIconSizePx;
2530              dragRect = new Rect(0, child.getPaddingTop(), child.getWidth(), previewSize);
2531          }
2532  
2533          // Clear the pressed state if necessary
2534          if (child instanceof BubbleTextView) {
2535              BubbleTextView icon = (BubbleTextView) child;
2536              icon.clearPressedOrFocusedBackground();
2537          }
2538  







<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">2539 -        mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2540 +        DragView dv = mDragController.startDrag(b, dragLayerX, dragLayerY, source, child.getTag(),</span>
2541                  DragController.DRAG_ACTION_MOVE, dragVisualizeOffset, dragRect, scale);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">2542 +        dv.setIntrinsicIconScaleFactor(source.getIntrinsicIconScaleFactor());</span>
2543  
2544          if (child.getParent() instanceof ShortcutAndWidgetContainer) {
2545              mDragSourceInternal = (ShortcutAndWidgetContainer) child.getParent();
2546          }
2547  
2548          b.recycle();
2549      }
2550  
2551      void addApplicationShortcut(ShortcutInfo info, CellLayout target, long container, long screenId,
2552              int cellX, int cellY, boolean insertAtFirst, int intersectX, int intersectY) {
2553          View view = mLauncher.createShortcut(R.layout.application, target, (ShortcutInfo) info);
2554  
2555          final int[] cellXY = new int[2];
2556          target.findCellForSpanThatIntersects(cellXY, 1, 1, intersectX, intersectY);
2557          addInScreen(view, container, screenId, cellXY[0], cellXY[1], 1, 1, insertAtFirst);
2558  
2559          LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screenId, cellXY[0],
2560                  cellXY[1]);
2561      }
2562  
2563      public boolean transitionStateShouldAllowDrop() {
2564          return ((!isSwitchingState() || mTransitionProgress &gt; 0.5f) &amp;&amp; mState != State.SMALL);
2565      }
2566  
2567      /**
2568       * {@inheritDoc}
2569       */
2570      public boolean acceptDrop(DragObject d) {
2571          // If it&#x27;s an external drop (e.g. from All Apps), check if it should be accepted
2572          CellLayout dropTargetLayout = mDropToLayout;
2573          if (d.dragSource != this) {
2574              // Don&#x27;t accept the drop if we&#x27;re not over a screen at time of drop
2575              if (dropTargetLayout == null) {
2576                  return false;
2577              }
2578              if (!transitionStateShouldAllowDrop()) return false;
2579  
2580              mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
2581                      d.dragView, mDragViewVisualCenter);
2582  
2583              // We want the point to be mapped to the dragTarget.
2584              if (mLauncher.isHotseatLayout(dropTargetLayout)) {
2585                  mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
2586              } else {
2587                  mapPointFromSelfToChild(dropTargetLayout, mDragViewVisualCenter, null);
2588              }
2589  
2590              int spanX = 1;
2591              int spanY = 1;
2592              if (mDragInfo != null) {
2593                  final CellLayout.CellInfo dragCellInfo = mDragInfo;
2594                  spanX = dragCellInfo.spanX;
2595                  spanY = dragCellInfo.spanY;
2596              } else {
2597                  final ItemInfo dragInfo = (ItemInfo) d.dragInfo;
2598                  spanX = dragInfo.spanX;
2599                  spanY = dragInfo.spanY;
2600              }
2601  
2602              int minSpanX = spanX;
2603              int minSpanY = spanY;
2604              if (d.dragInfo instanceof PendingAddWidgetInfo) {
2605                  minSpanX = ((PendingAddWidgetInfo) d.dragInfo).minSpanX;
2606                  minSpanY = ((PendingAddWidgetInfo) d.dragInfo).minSpanY;
2607              }
2608  
2609              mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
2610                      (int) mDragViewVisualCenter[1], minSpanX, minSpanY, dropTargetLayout,
2611                      mTargetCell);
2612              float distance = dropTargetLayout.getDistanceFromCell(mDragViewVisualCenter[0],
2613                      mDragViewVisualCenter[1], mTargetCell);
2614              if (willCreateUserFolder((ItemInfo) d.dragInfo, dropTargetLayout,
2615                      mTargetCell, distance, true)) {
2616                  return true;
2617              }
2618              if (willAddToExistingUserFolder((ItemInfo) d.dragInfo, dropTargetLayout,
2619                      mTargetCell, distance)) {
2620                  return true;
2621              }
2622  
2623              int[] resultSpan = new int[2];
2624              mTargetCell = dropTargetLayout.createArea((int) mDragViewVisualCenter[0],
2625                      (int) mDragViewVisualCenter[1], minSpanX, minSpanY, spanX, spanY,
2626                      null, mTargetCell, resultSpan, CellLayout.MODE_ACCEPT_DROP);
2627              boolean foundCell = mTargetCell[0] &gt;= 0 &amp;&amp; mTargetCell[1] &gt;= 0;
2628  
2629              // Don&#x27;t accept the drop if there&#x27;s no room for the item
2630              if (!foundCell) {
2631                  // Don&#x27;t show the message if we are dropping on the AllApps button and the hotseat
2632                  // is full
2633                  boolean isHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
2634                  if (mTargetCell != null &amp;&amp; isHotseat) {
2635                      Hotseat hotseat = mLauncher.getHotseat();
2636                      if (hotseat.isAllAppsButtonRank(
2637                              hotseat.getOrderInHotseat(mTargetCell[0], mTargetCell[1]))) {
2638                          return false;
2639                      }
2640                  }
2641  
2642                  mLauncher.showOutOfSpaceMessage(isHotseat);
2643                  return false;
2644              }
2645          }
2646  
2647          long screenId = getIdForScreen(dropTargetLayout);
2648          if (screenId == EXTRA_EMPTY_SCREEN_ID) {
2649              commitExtraEmptyScreen();
2650          }
2651  
2652          return true;
2653      }
2654  
2655      boolean willCreateUserFolder(ItemInfo info, CellLayout target, int[] targetCell, float
2656              distance, boolean considerTimeout) {
2657          if (distance &gt; mMaxDistanceForFolderCreation) return false;
2658          View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2659  
2660          if (dropOverView != null) {
2661              CellLayout.LayoutParams lp = (CellLayout.LayoutParams) dropOverView.getLayoutParams();
2662              if (lp.useTmpCoords &amp;&amp; (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.tmpCellY)) {
2663                  return false;
2664              }
2665          }
2666  
2667          boolean hasntMoved = false;
2668          if (mDragInfo != null) {
2669              hasntMoved = dropOverView == mDragInfo.cell;
2670          }
2671  
2672          if (dropOverView == null || hasntMoved || (considerTimeout &amp;&amp; !mCreateUserFolderOnDrop)) {
2673              return false;
2674          }
2675  
2676          boolean aboveShortcut = (dropOverView.getTag() instanceof ShortcutInfo);
2677          boolean willBecomeShortcut =
2678                  (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPLICATION ||
2679                  info.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT);
2680  
2681          return (aboveShortcut &amp;&amp; willBecomeShortcut);
2682      }
2683  
2684      boolean willAddToExistingUserFolder(Object dragInfo, CellLayout target, int[] targetCell,
2685              float distance) {
2686          if (distance &gt; mMaxDistanceForFolderCreation) return false;
2687          View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2688  
2689          if (dropOverView != null) {
2690              CellLayout.LayoutParams lp = (CellLayout.LayoutParams) dropOverView.getLayoutParams();
2691              if (lp.useTmpCoords &amp;&amp; (lp.tmpCellX != lp.cellX || lp.tmpCellY != lp.tmpCellY)) {
2692                  return false;
2693              }
2694          }
2695  
2696          if (dropOverView instanceof FolderIcon) {
2697              FolderIcon fi = (FolderIcon) dropOverView;
2698              if (fi.acceptDrop(dragInfo)) {
2699                  return true;
2700              }
2701          }
2702          return false;
2703      }
2704  
2705      boolean createUserFolderIfNecessary(View newView, long container, CellLayout target,
2706              int[] targetCell, float distance, boolean external, DragView dragView,
2707              Runnable postAnimationRunnable) {
2708          if (distance &gt; mMaxDistanceForFolderCreation) return false;
2709          View v = target.getChildAt(targetCell[0], targetCell[1]);
2710  
2711          boolean hasntMoved = false;
2712          if (mDragInfo != null) {
2713              CellLayout cellParent = getParentCellLayoutForView(mDragInfo.cell);
2714              hasntMoved = (mDragInfo.cellX == targetCell[0] &amp;&amp;
2715                      mDragInfo.cellY == targetCell[1]) &amp;&amp; (cellParent == target);
2716          }
2717  
2718          if (v == null || hasntMoved || !mCreateUserFolderOnDrop) return false;
2719          mCreateUserFolderOnDrop = false;
2720          final long screenId = (targetCell == null) ? mDragInfo.screenId : getIdForScreen(target);
2721  
2722          boolean aboveShortcut = (v.getTag() instanceof ShortcutInfo);
2723          boolean willBecomeShortcut = (newView.getTag() instanceof ShortcutInfo);
2724  
2725          if (aboveShortcut &amp;&amp; willBecomeShortcut) {
2726              ShortcutInfo sourceInfo = (ShortcutInfo) newView.getTag();
2727              ShortcutInfo destInfo = (ShortcutInfo) v.getTag();
2728              // if the drag started here, we need to remove it from the workspace
2729              if (!external) {
2730                  getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2731              }
2732  
2733              Rect folderLocation = new Rect();
2734              float scale = mLauncher.getDragLayer().getDescendantRectRelativeToSelf(v, folderLocation);
2735              target.removeView(v);
2736  
2737              FolderIcon fi =
2738                  mLauncher.addFolder(target, container, screenId, targetCell[0], targetCell[1]);
2739              destInfo.cellX = -1;
2740              destInfo.cellY = -1;
2741              sourceInfo.cellX = -1;
2742              sourceInfo.cellY = -1;
2743  
2744              // If the dragView is null, we can&#x27;t animate
2745              boolean animate = dragView != null;
2746              if (animate) {
2747                  fi.performCreateAnimation(destInfo, v, sourceInfo, dragView, folderLocation, scale,
2748                          postAnimationRunnable);
2749              } else {
2750                  fi.addItem(destInfo);
2751                  fi.addItem(sourceInfo);
2752              }
2753              return true;
2754          }
2755          return false;
2756      }
2757  
2758      boolean addToExistingFolderIfNecessary(View newView, CellLayout target, int[] targetCell,
2759              float distance, DragObject d, boolean external) {
2760          if (distance &gt; mMaxDistanceForFolderCreation) return false;
2761  
2762          View dropOverView = target.getChildAt(targetCell[0], targetCell[1]);
2763          if (!mAddToExistingFolderOnDrop) return false;
2764          mAddToExistingFolderOnDrop = false;
2765  
2766          if (dropOverView instanceof FolderIcon) {
2767              FolderIcon fi = (FolderIcon) dropOverView;
2768              if (fi.acceptDrop(d.dragInfo)) {
2769                  fi.onDrop(d);
2770  
2771                  // if the drag started here, we need to remove it from the workspace
2772                  if (!external) {
2773                      getParentCellLayoutForView(mDragInfo.cell).removeView(mDragInfo.cell);
2774                  }
2775                  return true;
2776              }
2777          }
2778          return false;
2779      }
2780  
2781      public void onDrop(final DragObject d) {
2782          mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset, d.dragView,
2783                  mDragViewVisualCenter);
2784  
2785          CellLayout dropTargetLayout = mDropToLayout;
2786  
2787          // We want the point to be mapped to the dragTarget.
2788          if (dropTargetLayout != null) {
2789              if (mLauncher.isHotseatLayout(dropTargetLayout)) {
2790                  mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
2791              } else {
2792                  mapPointFromSelfToChild(dropTargetLayout, mDragViewVisualCenter, null);
2793              }
2794          }
2795  
2796          int snapScreen = -1;
2797          boolean resizeOnDrop = false;
2798          if (d.dragSource != this) {
2799              final int[] touchXY = new int[] { (int) mDragViewVisualCenter[0],
2800                      (int) mDragViewVisualCenter[1] };
2801              onDropExternal(touchXY, d.dragInfo, dropTargetLayout, false, d);
2802          } else if (mDragInfo != null) {
2803              final View cell = mDragInfo.cell;
2804  
2805              Runnable resizeRunnable = null;
2806              if (dropTargetLayout != null &amp;&amp; !d.cancelled) {
2807                  // Move internally
2808                  boolean hasMovedLayouts = (getParentCellLayoutForView(cell) != dropTargetLayout);
2809                  boolean hasMovedIntoHotseat = mLauncher.isHotseatLayout(dropTargetLayout);
2810                  long container = hasMovedIntoHotseat ?
2811                          LauncherSettings.Favorites.CONTAINER_HOTSEAT :
2812                          LauncherSettings.Favorites.CONTAINER_DESKTOP;
2813                  long screenId = (mTargetCell[0] &lt; 0) ?
2814                          mDragInfo.screenId : getIdForScreen(dropTargetLayout);
2815                  int spanX = mDragInfo != null ? mDragInfo.spanX : 1;
2816                  int spanY = mDragInfo != null ? mDragInfo.spanY : 1;
2817                  // First we find the cell nearest to point at which the item is
2818                  // dropped, without any consideration to whether there is an item there.
2819  
2820                  mTargetCell = findNearestArea((int) mDragViewVisualCenter[0], (int)
2821                          mDragViewVisualCenter[1], spanX, spanY, dropTargetLayout, mTargetCell);
2822                  float distance = dropTargetLayout.getDistanceFromCell(mDragViewVisualCenter[0],
2823                          mDragViewVisualCenter[1], mTargetCell);
2824  
2825                  // If the item being dropped is a shortcut and the nearest drop
2826                  // cell also contains a shortcut, then create a folder with the two shortcuts.
2827                  if (!mInScrollArea &amp;&amp; createUserFolderIfNecessary(cell, container,
2828                          dropTargetLayout, mTargetCell, distance, false, d.dragView, null)) {
2829                      removeExtraEmptyScreen(true, null, 0, true);
2830                      return;
2831                  }
2832  
2833                  if (addToExistingFolderIfNecessary(cell, dropTargetLayout, mTargetCell,
2834                          distance, d, false)) {
2835                      removeExtraEmptyScreen(true, null, 0, true);
2836                      return;
2837                  }
2838  
2839                  // Aside from the special case where we&#x27;re dropping a shortcut onto a shortcut,
2840                  // we need to find the nearest cell location that is vacant
2841                  ItemInfo item = (ItemInfo) d.dragInfo;
2842                  int minSpanX = item.spanX;
2843                  int minSpanY = item.spanY;
2844                  if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
2845                      minSpanX = item.minSpanX;
2846                      minSpanY = item.minSpanY;
2847                  }
2848  
2849                  int[] resultSpan = new int[2];
2850                  mTargetCell = dropTargetLayout.createArea((int) mDragViewVisualCenter[0],
2851                          (int) mDragViewVisualCenter[1], minSpanX, minSpanY, spanX, spanY, cell,
2852                          mTargetCell, resultSpan, CellLayout.MODE_ON_DROP);
2853  
2854                  boolean foundCell = mTargetCell[0] &gt;= 0 &amp;&amp; mTargetCell[1] &gt;= 0;
2855  
2856                  // if the widget resizes on drop
2857                  if (foundCell &amp;&amp; (cell instanceof AppWidgetHostView) &amp;&amp;
2858                          (resultSpan[0] != item.spanX || resultSpan[1] != item.spanY)) {
2859                      resizeOnDrop = true;
2860                      item.spanX = resultSpan[0];
2861                      item.spanY = resultSpan[1];
2862                      AppWidgetHostView awhv = (AppWidgetHostView) cell;
2863                      AppWidgetResizeFrame.updateWidgetSizeRanges(awhv, mLauncher, resultSpan[0],
2864                              resultSpan[1]);
2865                  }
2866  
2867                  if (getScreenIdForPageIndex(mCurrentPage) != screenId &amp;&amp; !hasMovedIntoHotseat) {
2868                      snapScreen = getPageIndexForScreenId(screenId);
2869                      snapToPage(snapScreen);
2870                  }
2871  
2872                  if (foundCell) {
2873                      final ItemInfo info = (ItemInfo) cell.getTag();
2874                      if (hasMovedLayouts) {
2875                          // Reparent the view
2876                          getParentCellLayoutForView(cell).removeView(cell);
2877                          addInScreen(cell, container, screenId, mTargetCell[0], mTargetCell[1],
2878                                  info.spanX, info.spanY);
2879                      }
2880  
2881                      // update the item&#x27;s position after drop
2882                      CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();
2883                      lp.cellX = lp.tmpCellX = mTargetCell[0];
2884                      lp.cellY = lp.tmpCellY = mTargetCell[1];
2885                      lp.cellHSpan = item.spanX;
2886                      lp.cellVSpan = item.spanY;
2887                      lp.isLockedToGrid = true;
2888                      cell.setId(LauncherModel.getCellLayoutChildId(container, mDragInfo.screenId,
2889                              mTargetCell[0], mTargetCell[1], mDragInfo.spanX, mDragInfo.spanY));
2890  
2891                      if (container != LauncherSettings.Favorites.CONTAINER_HOTSEAT &amp;&amp;
2892                              cell instanceof LauncherAppWidgetHostView) {
2893                          final CellLayout cellLayout = dropTargetLayout;
2894                          // We post this call so that the widget has a chance to be placed
2895                          // in its final location
2896  
2897                          final LauncherAppWidgetHostView hostView = (LauncherAppWidgetHostView) cell;
2898                          AppWidgetProviderInfo pinfo = hostView.getAppWidgetInfo();
2899                          if (pinfo != null &amp;&amp;
2900                                  pinfo.resizeMode != AppWidgetProviderInfo.RESIZE_NONE) {
2901                              final Runnable addResizeFrame = new Runnable() {
2902                                  public void run() {
2903                                      DragLayer dragLayer = mLauncher.getDragLayer();
2904                                      dragLayer.addResizeFrame(info, hostView, cellLayout);
2905                                  }
2906                              };
2907                              resizeRunnable = (new Runnable() {
2908                                  public void run() {
2909                                      if (!isPageMoving()) {
2910                                          addResizeFrame.run();
2911                                      } else {
2912                                          mDelayedResizeRunnable = addResizeFrame;
2913                                      }
2914                                  }
2915                              });
2916                          }
2917                      }
2918  
2919                      LauncherModel.modifyItemInDatabase(mLauncher, info, container, screenId, lp.cellX,
2920                              lp.cellY, item.spanX, item.spanY);
2921                  } else {
2922                      // If we can&#x27;t find a drop location, we return the item to its original position
2923                      CellLayout.LayoutParams lp = (CellLayout.LayoutParams) cell.getLayoutParams();
2924                      mTargetCell[0] = lp.cellX;
2925                      mTargetCell[1] = lp.cellY;
2926                      CellLayout layout = (CellLayout) cell.getParent().getParent();
2927                      layout.markCellsAsOccupiedForView(cell);
2928                  }
2929              }
2930  
2931              final CellLayout parent = (CellLayout) cell.getParent().getParent();
2932              final Runnable finalResizeRunnable = resizeRunnable;
2933              // Prepare it to be animated into its new position
2934              // This must be called after the view has been re-parented
2935              final Runnable onCompleteRunnable = new Runnable() {
2936                  @Override
2937                  public void run() {
2938                      mAnimatingViewIntoPlace = false;
2939                      updateChildrenLayersEnabled(false);
2940                      if (finalResizeRunnable != null) {
2941                          finalResizeRunnable.run();
2942                      }
2943                      removeExtraEmptyScreen(true, null, 0, true);
2944                  }
2945              };
2946              mAnimatingViewIntoPlace = true;
2947              if (d.dragView.hasDrawn()) {
2948                  final ItemInfo info = (ItemInfo) cell.getTag();
2949                  if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET) {
2950                      int animationType = resizeOnDrop ? ANIMATE_INTO_POSITION_AND_RESIZE :
2951                              ANIMATE_INTO_POSITION_AND_DISAPPEAR;
2952                      animateWidgetDrop(info, parent, d.dragView,
2953                              onCompleteRunnable, animationType, cell, false);
2954                  } else {
2955                      int duration = snapScreen &lt; 0 ? -1 : ADJACENT_SCREEN_DROP_DURATION;
2956                      mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, cell, duration,
2957                              onCompleteRunnable, this);
2958                  }
2959              } else {
2960                  d.deferDragViewCleanupPostAnimation = false;
2961                  cell.setVisibility(VISIBLE);
2962              }
2963              parent.onDropChild(cell);
2964          }
2965      }
2966  
2967      public void setFinalScrollForPageChange(int pageIndex) {
2968          CellLayout cl = (CellLayout) getChildAt(pageIndex);
2969          if (cl != null) {
2970              mSavedScrollX = getScrollX();
2971              mSavedTranslationX = cl.getTranslationX();
2972              mSavedRotationY = cl.getRotationY();
2973              final int newX = getScrollForPage(pageIndex);
2974              setScrollX(newX);
2975              cl.setTranslationX(0f);
2976              cl.setRotationY(0f);
2977          }
2978      }
2979  
2980      public void resetFinalScrollForPageChange(int pageIndex) {
2981          if (pageIndex &gt;= 0) {
2982              CellLayout cl = (CellLayout) getChildAt(pageIndex);
2983              setScrollX(mSavedScrollX);
2984              cl.setTranslationX(mSavedTranslationX);
2985              cl.setRotationY(mSavedRotationY);
2986          }
2987      }
2988  
2989      public void getViewLocationRelativeToSelf(View v, int[] location) {
2990          getLocationInWindow(location);
2991          int x = location[0];
2992          int y = location[1];
2993  
2994          v.getLocationInWindow(location);
2995          int vX = location[0];
2996          int vY = location[1];
2997  
2998          location[0] = vX - x;
2999          location[1] = vY - y;
3000      }
3001  
3002      public void onDragEnter(DragObject d) {
3003          mDragEnforcer.onDragEnter();
3004          mCreateUserFolderOnDrop = false;
3005          mAddToExistingFolderOnDrop = false;
3006  
3007          mDropToLayout = null;
3008          CellLayout layout = getCurrentDropLayout();
3009          setCurrentDropLayout(layout);
3010          setCurrentDragOverlappingLayout(layout);
3011  
3012          // Because we don&#x27;t have space in the Phone UI (the CellLayouts run to the edge) we
3013          // don&#x27;t need to show the outlines
3014          if (LauncherAppState.getInstance().isScreenLarge()) {
3015              showOutlines();
3016          }
3017      }
3018  
3019      /** Return a rect that has the cellWidth/cellHeight (left, top), and
3020       * widthGap/heightGap (right, bottom) */
3021      static Rect getCellLayoutMetrics(Launcher launcher, int orientation) {
3022          LauncherAppState app = LauncherAppState.getInstance();
3023          DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
3024  
3025          Resources res = launcher.getResources();
3026          Display display = launcher.getWindowManager().getDefaultDisplay();
3027          Point smallestSize = new Point();
3028          Point largestSize = new Point();
3029          display.getCurrentSizeRange(smallestSize, largestSize);
3030          int countX = (int) grid.numColumns;
3031          int countY = (int) grid.numRows;
3032          int constrainedLongEdge = largestSize.y;
3033          int constrainedShortEdge = smallestSize.y;
3034          if (orientation == CellLayout.LANDSCAPE) {
3035              if (mLandscapeCellLayoutMetrics == null) {
3036                  Rect padding = grid.getWorkspacePadding(CellLayout.LANDSCAPE);
3037                  int width = constrainedLongEdge - padding.left - padding.right;
3038                  int height = constrainedShortEdge - padding.top - padding.bottom;
3039                  mLandscapeCellLayoutMetrics = new Rect();
3040                  mLandscapeCellLayoutMetrics.set(
3041                          grid.calculateCellWidth(width, countX),
3042                          grid.calculateCellHeight(height, countY), 0, 0);
3043              }
3044              return mLandscapeCellLayoutMetrics;
3045          } else if (orientation == CellLayout.PORTRAIT) {
3046              if (mPortraitCellLayoutMetrics == null) {
3047                  Rect padding = grid.getWorkspacePadding(CellLayout.PORTRAIT);
3048                  int width = constrainedShortEdge - padding.left - padding.right;
3049                  int height = constrainedLongEdge - padding.top - padding.bottom;
3050                  mPortraitCellLayoutMetrics = new Rect();
3051                  mPortraitCellLayoutMetrics.set(
3052                          grid.calculateCellWidth(width, countX),
3053                          grid.calculateCellHeight(height, countY), 0, 0);
3054              }
3055              return mPortraitCellLayoutMetrics;
3056          }
3057          return null;
3058      }
3059  
3060      public void onDragExit(DragObject d) {
3061          mDragEnforcer.onDragExit();
3062  
3063          // Here we store the final page that will be dropped to, if the workspace in fact
3064          // receives the drop
3065          if (mInScrollArea) {
3066              if (isPageMoving()) {
3067                  // If the user drops while the page is scrolling, we should use that page as the
3068                  // destination instead of the page that is being hovered over.
3069                  mDropToLayout = (CellLayout) getPageAt(getNextPage());
3070              } else {
3071                  mDropToLayout = mDragOverlappingLayout;
3072              }
3073          } else {
3074              mDropToLayout = mDragTargetLayout;
3075          }
3076  
3077          if (mDragMode == DRAG_MODE_CREATE_FOLDER) {
3078              mCreateUserFolderOnDrop = true;
3079          } else if (mDragMode == DRAG_MODE_ADD_TO_FOLDER) {
3080              mAddToExistingFolderOnDrop = true;
3081          }
3082  
3083          // Reset the scroll area and previous drag target
3084          onResetScrollArea();
3085          setCurrentDropLayout(null);
3086          setCurrentDragOverlappingLayout(null);
3087  
3088          mSpringLoadedDragController.cancel();
3089  
3090          if (!mIsPageMoving) {
3091              hideOutlines();
3092          }
3093      }
3094  
3095      void setCurrentDropLayout(CellLayout layout) {
3096          if (mDragTargetLayout != null) {
3097              mDragTargetLayout.revertTempState();
3098              mDragTargetLayout.onDragExit();
3099          }
3100          mDragTargetLayout = layout;
3101          if (mDragTargetLayout != null) {
3102              mDragTargetLayout.onDragEnter();
3103          }
3104          cleanupReorder(true);
3105          cleanupFolderCreation();
3106          setCurrentDropOverCell(-1, -1);
3107      }
3108  
3109      void setCurrentDragOverlappingLayout(CellLayout layout) {
3110          if (mDragOverlappingLayout != null) {
3111              mDragOverlappingLayout.setIsDragOverlapping(false);
3112          }
3113          mDragOverlappingLayout = layout;
3114          if (mDragOverlappingLayout != null) {
3115              mDragOverlappingLayout.setIsDragOverlapping(true);
3116          }
3117          invalidate();
3118      }
3119  
3120      void setCurrentDropOverCell(int x, int y) {
3121          if (x != mDragOverX || y != mDragOverY) {
3122              mDragOverX = x;
3123              mDragOverY = y;
3124              setDragMode(DRAG_MODE_NONE);
3125          }
3126      }
3127  
3128      void setDragMode(int dragMode) {
3129          if (dragMode != mDragMode) {
3130              if (dragMode == DRAG_MODE_NONE) {
3131                  cleanupAddToFolder();
3132                  // We don&#x27;t want to cancel the re-order alarm every time the target cell changes
3133                  // as this feels to slow / unresponsive.
3134                  cleanupReorder(false);
3135                  cleanupFolderCreation();
3136              } else if (dragMode == DRAG_MODE_ADD_TO_FOLDER) {
3137                  cleanupReorder(true);
3138                  cleanupFolderCreation();
3139              } else if (dragMode == DRAG_MODE_CREATE_FOLDER) {
3140                  cleanupAddToFolder();
3141                  cleanupReorder(true);
3142              } else if (dragMode == DRAG_MODE_REORDER) {
3143                  cleanupAddToFolder();
3144                  cleanupFolderCreation();
3145              }
3146              mDragMode = dragMode;
3147          }
3148      }
3149  
3150      private void cleanupFolderCreation() {
3151          if (mDragFolderRingAnimator != null) {
3152              mDragFolderRingAnimator.animateToNaturalState();
3153              mDragFolderRingAnimator = null;
3154          }
3155          mFolderCreationAlarm.setOnAlarmListener(null);
3156          mFolderCreationAlarm.cancelAlarm();
3157      }
3158  
3159      private void cleanupAddToFolder() {
3160          if (mDragOverFolderIcon != null) {
3161              mDragOverFolderIcon.onDragExit(null);
3162              mDragOverFolderIcon = null;
3163          }
3164      }
3165  
3166      private void cleanupReorder(boolean cancelAlarm) {
3167          // Any pending reorders are canceled
3168          if (cancelAlarm) {
3169              mReorderAlarm.cancelAlarm();
3170          }
3171          mLastReorderX = -1;
3172          mLastReorderY = -1;
3173      }
3174  
3175     /*
3176      *
3177      * Convert the 2D coordinate xy from the parent View&#x27;s coordinate space to this CellLayout&#x27;s
3178      * coordinate space. The argument xy is modified with the return result.
3179      *
3180      * if cachedInverseMatrix is not null, this method will just use that matrix instead of
3181      * computing it itself; we use this to avoid redundant matrix inversions in
3182      * findMatchingPageForDragOver
3183      *
3184      */
3185     void mapPointFromSelfToChild(View v, float[] xy, Matrix cachedInverseMatrix) {
3186         xy[0] = xy[0] - v.getLeft();
3187         xy[1] = xy[1] - v.getTop();
3188     }
3189  
3190     boolean isPointInSelfOverHotseat(int x, int y, Rect r) {
3191         if (r == null) {
3192             r = new Rect();
3193         }
3194         mTempPt[0] = x;
3195         mTempPt[1] = y;
3196         mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(this, mTempPt, true);
3197  
3198         LauncherAppState app = LauncherAppState.getInstance();
3199         DeviceProfile grid = app.getDynamicGrid().getDeviceProfile();
3200         r = grid.getHotseatRect();
3201         if (r.contains(mTempPt[0], mTempPt[1])) {
3202             return true;
3203         }
3204         return false;
3205     }
3206  
3207     void mapPointFromSelfToHotseatLayout(Hotseat hotseat, float[] xy) {
3208         mTempPt[0] = (int) xy[0];
3209         mTempPt[1] = (int) xy[1];
3210         mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(this, mTempPt, true);
3211         mLauncher.getDragLayer().mapCoordInSelfToDescendent(hotseat.getLayout(), mTempPt);
3212  
3213         xy[0] = mTempPt[0];
3214         xy[1] = mTempPt[1];
3215     }
3216  
3217     /*
3218      *
3219      * Convert the 2D coordinate xy from this CellLayout&#x27;s coordinate space to
3220      * the parent View&#x27;s coordinate space. The argument xy is modified with the return result.
3221      *
3222      */
3223     void mapPointFromChildToSelf(View v, float[] xy) {
3224         xy[0] += v.getLeft();
3225         xy[1] += v.getTop();
3226     }
3227  
3228     static private float squaredDistance(float[] point1, float[] point2) {
3229          float distanceX = point1[0] - point2[0];
3230          float distanceY = point2[1] - point2[1];
3231          return distanceX * distanceX + distanceY * distanceY;
3232     }
3233  
3234      /*
3235       *
3236       * This method returns the CellLayout that is currently being dragged to. In order to drag
3237       * to a CellLayout, either the touch point must be directly over the CellLayout, or as a second
3238       * strategy, we see if the dragView is overlapping any CellLayout and choose the closest one
3239       *
3240       * Return null if no CellLayout is currently being dragged over
3241       *
3242       */
3243      private CellLayout findMatchingPageForDragOver(
3244              DragView dragView, float originX, float originY, boolean exact) {
3245          // We loop through all the screens (ie CellLayouts) and see which ones overlap
3246          // with the item being dragged and then choose the one that&#x27;s closest to the touch point
3247          final int screenCount = getChildCount();
3248          CellLayout bestMatchingScreen = null;
3249          float smallestDistSoFar = Float.MAX_VALUE;
3250  
3251          for (int i = 0; i &lt; screenCount; i++) {
3252              // The custom content screen is not a valid drag over option
3253              if (mScreenOrder.get(i) == CUSTOM_CONTENT_SCREEN_ID) {
3254                  continue;
3255              }
3256  
3257              CellLayout cl = (CellLayout) getChildAt(i);
3258  
3259              final float[] touchXy = {originX, originY};
3260              // Transform the touch coordinates to the CellLayout&#x27;s local coordinates
3261              // If the touch point is within the bounds of the cell layout, we can return immediately
3262              cl.getMatrix().invert(mTempInverseMatrix);
3263              mapPointFromSelfToChild(cl, touchXy, mTempInverseMatrix);
3264  
3265              if (touchXy[0] &gt;= 0 &amp;&amp; touchXy[0] &lt;= cl.getWidth() &amp;&amp;
3266                      touchXy[1] &gt;= 0 &amp;&amp; touchXy[1] &lt;= cl.getHeight()) {
3267                  return cl;
3268              }
3269  
3270              if (!exact) {
3271                  // Get the center of the cell layout in screen coordinates
3272                  final float[] cellLayoutCenter = mTempCellLayoutCenterCoordinates;
3273                  cellLayoutCenter[0] = cl.getWidth()/2;
3274                  cellLayoutCenter[1] = cl.getHeight()/2;
3275                  mapPointFromChildToSelf(cl, cellLayoutCenter);
3276  
3277                  touchXy[0] = originX;
3278                  touchXy[1] = originY;
3279  
3280                  // Calculate the distance between the center of the CellLayout
3281                  // and the touch point
3282                  float dist = squaredDistance(touchXy, cellLayoutCenter);
3283  
3284                  if (dist &lt; smallestDistSoFar) {
3285                      smallestDistSoFar = dist;
3286                      bestMatchingScreen = cl;
3287                  }
3288              }
3289          }
3290          return bestMatchingScreen;
3291      }
3292  
3293      // This is used to compute the visual center of the dragView. This point is then
3294      // used to visualize drop locations and determine where to drop an item. The idea is that
3295      // the visual center represents the user&#x27;s interpretation of where the item is, and hence
3296      // is the appropriate point to use when determining drop location.
3297      private float[] getDragViewVisualCenter(int x, int y, int xOffset, int yOffset,
3298              DragView dragView, float[] recycle) {
3299          float res[];
3300          if (recycle == null) {
3301              res = new float[2];
3302          } else {
3303              res = recycle;
3304          }
3305  
3306          // First off, the drag view has been shifted in a way that is not represented in the
3307          // x and y values or the x/yOffsets. Here we account for that shift.
3308          x += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetX);
3309          y += getResources().getDimensionPixelSize(R.dimen.dragViewOffsetY);
3310  
3311          // These represent the visual top and left of drag view if a dragRect was provided.
3312          // If a dragRect was not provided, then they correspond to the actual view left and
3313          // top, as the dragRect is in that case taken to be the entire dragView.
3314          // R.dimen.dragViewOffsetY.
3315          int left = x - xOffset;
3316          int top = y - yOffset;
3317  
3318          // In order to find the visual center, we shift by half the dragRect
3319          res[0] = left + dragView.getDragRegion().width() / 2;
3320          res[1] = top + dragView.getDragRegion().height() / 2;
3321  
3322          return res;
3323      }
3324  
3325      private boolean isDragWidget(DragObject d) {
3326          return (d.dragInfo instanceof LauncherAppWidgetInfo ||
3327                  d.dragInfo instanceof PendingAddWidgetInfo);
3328      }
3329      private boolean isExternalDragWidget(DragObject d) {
3330          return d.dragSource != this &amp;&amp; isDragWidget(d);
3331      }
3332  
3333      public void onDragOver(DragObject d) {
3334          // Skip drag over events while we are dragging over side pages
3335          if (mInScrollArea || mIsSwitchingState || mState == State.SMALL) return;
3336  
3337          Rect r = new Rect();
3338          CellLayout layout = null;
3339          ItemInfo item = (ItemInfo) d.dragInfo;
3340  
3341          // Ensure that we have proper spans for the item that we are dropping
3342          if (item.spanX &lt; 0 || item.spanY &lt; 0) throw new RuntimeException(&quot;Improper spans found&quot;);
3343          mDragViewVisualCenter = getDragViewVisualCenter(d.x, d.y, d.xOffset, d.yOffset,
3344              d.dragView, mDragViewVisualCenter);
3345  
3346          final View child = (mDragInfo == null) ? null : mDragInfo.cell;
3347          // Identify whether we have dragged over a side page
3348          if (isSmall()) {
3349              if (mLauncher.getHotseat() != null &amp;&amp; !isExternalDragWidget(d)) {
3350                  if (isPointInSelfOverHotseat(d.x, d.y, r)) {
3351                      layout = mLauncher.getHotseat().getLayout();
3352                  }
3353              }
3354              if (layout == null) {
3355                  layout = findMatchingPageForDragOver(d.dragView, d.x, d.y, false);
3356              }
3357              if (layout != mDragTargetLayout) {
3358                  setCurrentDropLayout(layout);
3359                  setCurrentDragOverlappingLayout(layout);
3360  
3361                  boolean isInSpringLoadedMode = (mState == State.SPRING_LOADED);
3362                  if (isInSpringLoadedMode) {
3363                      if (mLauncher.isHotseatLayout(layout)) {
3364                          mSpringLoadedDragController.cancel();
3365                      } else {
3366                          mSpringLoadedDragController.setAlarm(mDragTargetLayout);
3367                      }
3368                  }
3369              }
3370          } else {
3371              // Test to see if we are over the hotseat otherwise just use the current page
3372              if (mLauncher.getHotseat() != null &amp;&amp; !isDragWidget(d)) {
3373                  if (isPointInSelfOverHotseat(d.x, d.y, r)) {
3374                      layout = mLauncher.getHotseat().getLayout();
3375                  }
3376              }
3377              if (layout == null) {
3378                  layout = getCurrentDropLayout();
3379              }
3380              if (layout != mDragTargetLayout) {
3381                  setCurrentDropLayout(layout);
3382                  setCurrentDragOverlappingLayout(layout);
3383              }
3384          }
3385  
3386          // Handle the drag over
3387          if (mDragTargetLayout != null) {
3388              // We want the point to be mapped to the dragTarget.
3389              if (mLauncher.isHotseatLayout(mDragTargetLayout)) {
3390                  mapPointFromSelfToHotseatLayout(mLauncher.getHotseat(), mDragViewVisualCenter);
3391              } else {
3392                  mapPointFromSelfToChild(mDragTargetLayout, mDragViewVisualCenter, null);
3393              }
3394  
3395              ItemInfo info = (ItemInfo) d.dragInfo;
3396  
3397              int minSpanX = item.spanX;
3398              int minSpanY = item.spanY;
3399              if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
3400                  minSpanX = item.minSpanX;
3401                  minSpanY = item.minSpanY;
3402              }
3403  
3404              mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
3405                      (int) mDragViewVisualCenter[1], minSpanX, minSpanY,
3406                      mDragTargetLayout, mTargetCell);
3407              int reorderX = mTargetCell[0];
3408              int reorderY = mTargetCell[1];
3409  
3410              setCurrentDropOverCell(mTargetCell[0], mTargetCell[1]);
3411  
3412              float targetCellDistance = mDragTargetLayout.getDistanceFromCell(
3413                      mDragViewVisualCenter[0], mDragViewVisualCenter[1], mTargetCell);
3414  
3415              final View dragOverView = mDragTargetLayout.getChildAt(mTargetCell[0],
3416                      mTargetCell[1]);
3417  
3418              manageFolderFeedback(info, mDragTargetLayout, mTargetCell,
3419                      targetCellDistance, dragOverView);
3420  
3421              boolean nearestDropOccupied = mDragTargetLayout.isNearestDropLocationOccupied((int)
3422                      mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1], item.spanX,
3423                      item.spanY, child, mTargetCell);
3424  
3425              if (!nearestDropOccupied) {
3426                  mDragTargetLayout.visualizeDropLocation(child, mDragOutline,
3427                          (int) mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1],
3428                          mTargetCell[0], mTargetCell[1], item.spanX, item.spanY, false,
3429                          d.dragView.getDragVisualizeOffset(), d.dragView.getDragRegion());
3430              } else if ((mDragMode == DRAG_MODE_NONE || mDragMode == DRAG_MODE_REORDER)
3431                      &amp;&amp; !mReorderAlarm.alarmPending() &amp;&amp; (mLastReorderX != reorderX ||
3432                      mLastReorderY != reorderY)) {
3433  
3434                  // Otherwise, if we aren&#x27;t adding to or creating a folder and there&#x27;s no pending
3435                  // reorder, then we schedule a reorder
3436                  ReorderAlarmListener listener = new ReorderAlarmListener(mDragViewVisualCenter,
3437                          minSpanX, minSpanY, item.spanX, item.spanY, d.dragView, child);
3438                  mReorderAlarm.setOnAlarmListener(listener);
3439                  mReorderAlarm.setAlarm(REORDER_TIMEOUT);
3440              }
3441  
3442              if (mDragMode == DRAG_MODE_CREATE_FOLDER || mDragMode == DRAG_MODE_ADD_TO_FOLDER ||
3443                      !nearestDropOccupied) {
3444                  if (mDragTargetLayout != null) {
3445                      mDragTargetLayout.revertTempState();
3446                  }
3447              }
3448          }
3449      }
3450  
3451      private void manageFolderFeedback(ItemInfo info, CellLayout targetLayout,
3452              int[] targetCell, float distance, View dragOverView) {
3453          boolean userFolderPending = willCreateUserFolder(info, targetLayout, targetCell, distance,
3454                  false);
3455  
3456          if (mDragMode == DRAG_MODE_NONE &amp;&amp; userFolderPending &amp;&amp;
3457                  !mFolderCreationAlarm.alarmPending()) {
3458              mFolderCreationAlarm.setOnAlarmListener(new
3459                      FolderCreationAlarmListener(targetLayout, targetCell[0], targetCell[1]));
3460              mFolderCreationAlarm.setAlarm(FOLDER_CREATION_TIMEOUT);
3461              return;
3462          }
3463  
3464          boolean willAddToFolder =
3465                  willAddToExistingUserFolder(info, targetLayout, targetCell, distance);
3466  
3467          if (willAddToFolder &amp;&amp; mDragMode == DRAG_MODE_NONE) {
3468              mDragOverFolderIcon = ((FolderIcon) dragOverView);
3469              mDragOverFolderIcon.onDragEnter(info);
3470              if (targetLayout != null) {
3471                  targetLayout.clearDragOutlines();
3472              }
3473              setDragMode(DRAG_MODE_ADD_TO_FOLDER);
3474              return;
3475          }
3476  
3477          if (mDragMode == DRAG_MODE_ADD_TO_FOLDER &amp;&amp; !willAddToFolder) {
3478              setDragMode(DRAG_MODE_NONE);
3479          }
3480          if (mDragMode == DRAG_MODE_CREATE_FOLDER &amp;&amp; !userFolderPending) {
3481              setDragMode(DRAG_MODE_NONE);
3482          }
3483  
3484          return;
3485      }
3486  
3487      class FolderCreationAlarmListener implements OnAlarmListener {
3488          CellLayout layout;
3489          int cellX;
3490          int cellY;
3491  
3492          public FolderCreationAlarmListener(CellLayout layout, int cellX, int cellY) {
3493              this.layout = layout;
3494              this.cellX = cellX;
3495              this.cellY = cellY;
3496          }
3497  
3498          public void onAlarm(Alarm alarm) {
3499              if (mDragFolderRingAnimator != null) {
3500                  // This shouldn&#x27;t happen ever, but just in case, make sure we clean up the mess.
3501                  mDragFolderRingAnimator.animateToNaturalState();
3502              }
3503              mDragFolderRingAnimator = new FolderRingAnimator(mLauncher, null);
3504              mDragFolderRingAnimator.setCell(cellX, cellY);
3505              mDragFolderRingAnimator.setCellLayout(layout);
3506              mDragFolderRingAnimator.animateToAcceptState();
3507              layout.showFolderAccept(mDragFolderRingAnimator);
3508              layout.clearDragOutlines();
3509              setDragMode(DRAG_MODE_CREATE_FOLDER);
3510          }
3511      }
3512  
3513      class ReorderAlarmListener implements OnAlarmListener {
3514          float[] dragViewCenter;
3515          int minSpanX, minSpanY, spanX, spanY;
3516          DragView dragView;
3517          View child;
3518  
3519          public ReorderAlarmListener(float[] dragViewCenter, int minSpanX, int minSpanY, int spanX,
3520                  int spanY, DragView dragView, View child) {
3521              this.dragViewCenter = dragViewCenter;
3522              this.minSpanX = minSpanX;
3523              this.minSpanY = minSpanY;
3524              this.spanX = spanX;
3525              this.spanY = spanY;
3526              this.child = child;
3527              this.dragView = dragView;
3528          }
3529  
3530          public void onAlarm(Alarm alarm) {
3531              int[] resultSpan = new int[2];
3532              mTargetCell = findNearestArea((int) mDragViewVisualCenter[0],
3533                      (int) mDragViewVisualCenter[1], minSpanX, minSpanY, mDragTargetLayout,
3534                      mTargetCell);
3535              mLastReorderX = mTargetCell[0];
3536              mLastReorderY = mTargetCell[1];
3537  
3538              mTargetCell = mDragTargetLayout.createArea((int) mDragViewVisualCenter[0],
3539                  (int) mDragViewVisualCenter[1], minSpanX, minSpanY, spanX, spanY,
3540                  child, mTargetCell, resultSpan, CellLayout.MODE_DRAG_OVER);
3541  
3542              if (mTargetCell[0] &lt; 0 || mTargetCell[1] &lt; 0) {
3543                  mDragTargetLayout.revertTempState();
3544              } else {
3545                  setDragMode(DRAG_MODE_REORDER);
3546              }
3547  
3548              boolean resize = resultSpan[0] != spanX || resultSpan[1] != spanY;
3549              mDragTargetLayout.visualizeDropLocation(child, mDragOutline,
3550                  (int) mDragViewVisualCenter[0], (int) mDragViewVisualCenter[1],
3551                  mTargetCell[0], mTargetCell[1], resultSpan[0], resultSpan[1], resize,
3552                  dragView.getDragVisualizeOffset(), dragView.getDragRegion());
3553          }
3554      }
3555  
3556      @Override
3557      public void getHitRectRelativeToDragLayer(Rect outRect) {
3558          // We want the workspace to have the whole area of the display (it will find the correct
3559          // cell layout to drop to in the existing drag/drop logic.
3560          mLauncher.getDragLayer().getDescendantRectRelativeToSelf(this, outRect);
3561      }
3562  
3563      /**
3564       * Add the item specified by dragInfo to the given layout.
3565       * @return true if successful
3566       */
3567      public boolean addExternalItemToScreen(ItemInfo dragInfo, CellLayout layout) {
3568          if (layout.findCellForSpan(mTempEstimate, dragInfo.spanX, dragInfo.spanY)) {
3569              onDropExternal(dragInfo.dropPos, (ItemInfo) dragInfo, (CellLayout) layout, false);
3570              return true;
3571          }
3572          mLauncher.showOutOfSpaceMessage(mLauncher.isHotseatLayout(layout));
3573          return false;
3574      }
3575  
3576      private void onDropExternal(int[] touchXY, Object dragInfo,
3577              CellLayout cellLayout, boolean insertAtFirst) {
3578          onDropExternal(touchXY, dragInfo, cellLayout, insertAtFirst, null);
3579      }
3580  
3581      /**
3582       * Drop an item that didn&#x27;t originate on one of the workspace screens.
3583       * It may have come from Launcher (e.g. from all apps or customize), or it may have
3584       * come from another app altogether.
3585       *
3586       * NOTE: This can also be called when we are outside of a drag event, when we want
3587       * to add an item to one of the workspace screens.
3588       */
3589      private void onDropExternal(final int[] touchXY, final Object dragInfo,
3590              final CellLayout cellLayout, boolean insertAtFirst, DragObject d) {
3591          final Runnable exitSpringLoadedRunnable = new Runnable() {
3592              @Override
3593              public void run() {
3594                  removeExtraEmptyScreen(false, new Runnable() {
3595                      @Override
3596                      public void run() {
3597                          mLauncher.exitSpringLoadedDragModeDelayed(true,
3598                                  Launcher.EXIT_SPRINGLOADED_MODE_SHORT_TIMEOUT, null);
3599                      }
3600                  });
3601              }
3602          };
3603  
3604          ItemInfo info = (ItemInfo) dragInfo;
3605          int spanX = info.spanX;
3606          int spanY = info.spanY;
3607          if (mDragInfo != null) {
3608              spanX = mDragInfo.spanX;
3609              spanY = mDragInfo.spanY;
3610          }
3611  
3612          final long container = mLauncher.isHotseatLayout(cellLayout) ?
3613                  LauncherSettings.Favorites.CONTAINER_HOTSEAT :
3614                      LauncherSettings.Favorites.CONTAINER_DESKTOP;
3615          final long screenId = getIdForScreen(cellLayout);
3616          if (!mLauncher.isHotseatLayout(cellLayout)
3617                  &amp;&amp; screenId != getScreenIdForPageIndex(mCurrentPage)
3618                  &amp;&amp; mState != State.SPRING_LOADED) {
3619              snapToScreenId(screenId, null);
3620          }
3621  
3622          if (info instanceof PendingAddItemInfo) {
3623              final PendingAddItemInfo pendingInfo = (PendingAddItemInfo) dragInfo;
3624  
3625              boolean findNearestVacantCell = true;
3626              if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT) {
3627                  mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3628                          cellLayout, mTargetCell);
3629                  float distance = cellLayout.getDistanceFromCell(mDragViewVisualCenter[0],
3630                          mDragViewVisualCenter[1], mTargetCell);
3631                  if (willCreateUserFolder((ItemInfo) d.dragInfo, cellLayout, mTargetCell,
3632                          distance, true) || willAddToExistingUserFolder((ItemInfo) d.dragInfo,
3633                                  cellLayout, mTargetCell, distance)) {
3634                      findNearestVacantCell = false;
3635                  }
3636              }
3637  
3638              final ItemInfo item = (ItemInfo) d.dragInfo;
3639              boolean updateWidgetSize = false;
3640              if (findNearestVacantCell) {
3641                  int minSpanX = item.spanX;
3642                  int minSpanY = item.spanY;
3643                  if (item.minSpanX &gt; 0 &amp;&amp; item.minSpanY &gt; 0) {
3644                      minSpanX = item.minSpanX;
3645                      minSpanY = item.minSpanY;
3646                  }
3647                  int[] resultSpan = new int[2];
3648                  mTargetCell = cellLayout.createArea((int) mDragViewVisualCenter[0],
3649                          (int) mDragViewVisualCenter[1], minSpanX, minSpanY, info.spanX, info.spanY,
3650                          null, mTargetCell, resultSpan, CellLayout.MODE_ON_DROP_EXTERNAL);
3651  
3652                  if (resultSpan[0] != item.spanX || resultSpan[1] != item.spanY) {
3653                      updateWidgetSize = true;
3654                  }
3655                  item.spanX = resultSpan[0];
3656                  item.spanY = resultSpan[1];
3657              }
3658  
3659              Runnable onAnimationCompleteRunnable = new Runnable() {
3660                  @Override
3661                  public void run() {
3662                      // When dragging and dropping from customization tray, we deal with creating
3663                      // widgets/shortcuts/folders in a slightly different way
3664                      switch (pendingInfo.itemType) {
3665                      case LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET:
3666                          int span[] = new int[2];
3667                          span[0] = item.spanX;
3668                          span[1] = item.spanY;
3669                          mLauncher.addAppWidgetFromDrop((PendingAddWidgetInfo) pendingInfo,
3670                                  container, screenId, mTargetCell, span, null);
3671                          break;
3672                      case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3673                          mLauncher.processShortcutFromDrop(pendingInfo.componentName,
3674                                  container, screenId, mTargetCell, null);
3675                          break;
3676                      default:
3677                          throw new IllegalStateException(&quot;Unknown item type: &quot; +
3678                                  pendingInfo.itemType);
3679                      }
3680                  }
3681              };
3682              View finalView = pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET
3683                      ? ((PendingAddWidgetInfo) pendingInfo).boundWidget : null;
3684  
3685              if (finalView instanceof AppWidgetHostView &amp;&amp; updateWidgetSize) {
3686                  AppWidgetHostView awhv = (AppWidgetHostView) finalView;
3687                  AppWidgetResizeFrame.updateWidgetSizeRanges(awhv, mLauncher, item.spanX,
3688                          item.spanY);
3689              }
3690  
3691              int animationStyle = ANIMATE_INTO_POSITION_AND_DISAPPEAR;
3692              if (pendingInfo.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp;
3693                      ((PendingAddWidgetInfo) pendingInfo).info.configure != null) {
3694                  animationStyle = ANIMATE_INTO_POSITION_AND_REMAIN;
3695              }
3696              animateWidgetDrop(info, cellLayout, d.dragView, onAnimationCompleteRunnable,
3697                      animationStyle, finalView, true);
3698          } else {
3699              // This is for other drag/drop cases, like dragging from All Apps
3700              View view = null;
3701  
3702              switch (info.itemType) {
3703              case LauncherSettings.Favorites.ITEM_TYPE_APPLICATION:
3704              case LauncherSettings.Favorites.ITEM_TYPE_SHORTCUT:
3705                  if (info.container == NO_ID &amp;&amp; info instanceof AppInfo) {
3706                      // Came from all apps -- make a copy
3707                      info = new ShortcutInfo((AppInfo) info);
3708                  }
3709                  view = mLauncher.createShortcut(R.layout.application, cellLayout,
3710                          (ShortcutInfo) info);
3711                  break;
3712              case LauncherSettings.Favorites.ITEM_TYPE_FOLDER:
3713                  view = FolderIcon.fromXml(R.layout.folder_icon, mLauncher, cellLayout,
3714                          (FolderInfo) info, mIconCache);
3715                  break;
3716              default:
3717                  throw new IllegalStateException(&quot;Unknown item type: &quot; + info.itemType);
3718              }
3719  
3720              // First we find the cell nearest to point at which the item is
3721              // dropped, without any consideration to whether there is an item there.
3722              if (touchXY != null) {
3723                  mTargetCell = findNearestArea((int) touchXY[0], (int) touchXY[1], spanX, spanY,
3724                          cellLayout, mTargetCell);
3725                  float distance = cellLayout.getDistanceFromCell(mDragViewVisualCenter[0],
3726                          mDragViewVisualCenter[1], mTargetCell);
3727                  d.postAnimationRunnable = exitSpringLoadedRunnable;
3728                  if (createUserFolderIfNecessary(view, container, cellLayout, mTargetCell, distance,
3729                          true, d.dragView, d.postAnimationRunnable)) {
3730                      return;
3731                  }
3732                  if (addToExistingFolderIfNecessary(view, cellLayout, mTargetCell, distance, d,
3733                          true)) {
3734                      return;
3735                  }
3736              }
3737  
3738              if (touchXY != null) {
3739                  // when dragging and dropping, just find the closest free spot
3740                  mTargetCell = cellLayout.createArea((int) mDragViewVisualCenter[0],
3741                          (int) mDragViewVisualCenter[1], 1, 1, 1, 1,
3742                          null, mTargetCell, null, CellLayout.MODE_ON_DROP_EXTERNAL);
3743              } else {
3744                  cellLayout.findCellForSpan(mTargetCell, 1, 1);
3745              }
3746              addInScreen(view, container, screenId, mTargetCell[0], mTargetCell[1], info.spanX,
3747                      info.spanY, insertAtFirst);
3748              cellLayout.onDropChild(view);
3749              CellLayout.LayoutParams lp = (CellLayout.LayoutParams) view.getLayoutParams();
3750              cellLayout.getShortcutsAndWidgets().measureChild(view);
3751  
3752              LauncherModel.addOrMoveItemInDatabase(mLauncher, info, container, screenId,
3753                      lp.cellX, lp.cellY);
3754  
3755              if (d.dragView != null) {
3756                  // We wrap the animation call in the temporary set and reset of the current
3757                  // cellLayout to its final transform -- this means we animate the drag view to
3758                  // the correct final location.
3759                  setFinalTransitionTransform(cellLayout);
3760                  mLauncher.getDragLayer().animateViewIntoPosition(d.dragView, view,
3761                          exitSpringLoadedRunnable, this);
3762                  resetTransitionTransform(cellLayout);
3763              }
3764          }
3765      }
3766  
3767      public Bitmap createWidgetBitmap(ItemInfo widgetInfo, View layout) {
3768          int[] unScaledSize = mLauncher.getWorkspace().estimateItemSize(widgetInfo.spanX,
3769                  widgetInfo.spanY, widgetInfo, false);
3770          int visibility = layout.getVisibility();
3771          layout.setVisibility(VISIBLE);
3772  
3773          int width = MeasureSpec.makeMeasureSpec(unScaledSize[0], MeasureSpec.EXACTLY);
3774          int height = MeasureSpec.makeMeasureSpec(unScaledSize[1], MeasureSpec.EXACTLY);
3775          Bitmap b = Bitmap.createBitmap(unScaledSize[0], unScaledSize[1],
3776                  Bitmap.Config.ARGB_8888);
3777          Canvas c = new Canvas(b);
3778  
3779          layout.measure(width, height);
3780          layout.layout(0, 0, unScaledSize[0], unScaledSize[1]);
3781          layout.draw(c);
3782          c.setBitmap(null);
3783          layout.setVisibility(visibility);
3784          return b;
3785      }
3786  
3787      private void getFinalPositionForDropAnimation(int[] loc, float[] scaleXY,
3788              DragView dragView, CellLayout layout, ItemInfo info, int[] targetCell,
3789              boolean external, boolean scale) {
3790          // Now we animate the dragView, (ie. the widget or shortcut preview) into its final
3791          // location and size on the home screen.
3792          int spanX = info.spanX;
3793          int spanY = info.spanY;
3794  
3795          Rect r = estimateItemPosition(layout, info, targetCell[0], targetCell[1], spanX, spanY);
3796          loc[0] = r.left;
3797          loc[1] = r.top;
3798  
3799          setFinalTransitionTransform(layout);
3800          float cellLayoutScale =
3801                  mLauncher.getDragLayer().getDescendantCoordRelativeToSelf(layout, loc, true);
3802          resetTransitionTransform(layout);
3803  
3804          float dragViewScaleX;
3805          float dragViewScaleY;
3806          if (scale) {
3807              dragViewScaleX = (1.0f * r.width()) / dragView.getMeasuredWidth();
3808              dragViewScaleY = (1.0f * r.height()) / dragView.getMeasuredHeight();
3809          } else {
3810              dragViewScaleX = 1f;
3811              dragViewScaleY = 1f;
3812          }
3813  
3814          // The animation will scale the dragView about its center, so we need to center about
3815          // the final location.
3816          loc[0] -= (dragView.getMeasuredWidth() - cellLayoutScale * r.width()) / 2;
3817          loc[1] -= (dragView.getMeasuredHeight() - cellLayoutScale * r.height()) / 2;
3818  
3819          scaleXY[0] = dragViewScaleX * cellLayoutScale;
3820          scaleXY[1] = dragViewScaleY * cellLayoutScale;
3821      }
3822  
3823      public void animateWidgetDrop(ItemInfo info, CellLayout cellLayout, DragView dragView,
3824              final Runnable onCompleteRunnable, int animationType, final View finalView,
3825              boolean external) {
3826          Rect from = new Rect();
3827          mLauncher.getDragLayer().getViewRectRelativeToSelf(dragView, from);
3828  
3829          int[] finalPos = new int[2];
3830          float scaleXY[] = new float[2];
3831          boolean scalePreview = !(info instanceof PendingAddShortcutInfo);
3832          getFinalPositionForDropAnimation(finalPos, scaleXY, dragView, cellLayout, info, mTargetCell,
3833                  external, scalePreview);
3834  
3835          Resources res = mLauncher.getResources();
3836          final int duration = res.getInteger(R.integer.config_dropAnimMaxDuration) - 200;
3837  
3838          // In the case where we&#x27;ve prebound the widget, we remove it from the DragLayer
3839          if (finalView instanceof AppWidgetHostView &amp;&amp; external) {
3840              Log.d(TAG, &quot;6557954 Animate widget drop, final view is appWidgetHostView&quot;);
3841              mLauncher.getDragLayer().removeView(finalView);
3842          }
3843          if ((animationType == ANIMATE_INTO_POSITION_AND_RESIZE || external) &amp;&amp; finalView != null) {
3844              Bitmap crossFadeBitmap = createWidgetBitmap(info, finalView);
3845              dragView.setCrossFadeBitmap(crossFadeBitmap);
3846              dragView.crossFade((int) (duration * 0.8f));
3847          } else if (info.itemType == LauncherSettings.Favorites.ITEM_TYPE_APPWIDGET &amp;&amp; external) {
3848              scaleXY[0] = scaleXY[1] = Math.min(scaleXY[0],  scaleXY[1]);
3849          }
3850  
3851          DragLayer dragLayer = mLauncher.getDragLayer();
3852          if (animationType == CANCEL_TWO_STAGE_WIDGET_DROP_ANIMATION) {
3853              mLauncher.getDragLayer().animateViewIntoPosition(dragView, finalPos, 0f, 0.1f, 0.1f,
3854                      DragLayer.ANIMATION_END_DISAPPEAR, onCompleteRunnable, duration);
3855          } else {
3856              int endStyle;
3857              if (animationType == ANIMATE_INTO_POSITION_AND_REMAIN) {
3858                  endStyle = DragLayer.ANIMATION_END_REMAIN_VISIBLE;
3859              } else {
3860                  endStyle = DragLayer.ANIMATION_END_DISAPPEAR;;
3861              }
3862  
3863              Runnable onComplete = new Runnable() {
3864                  @Override
3865                  public void run() {
3866                      if (finalView != null) {
3867                          finalView.setVisibility(VISIBLE);
3868                      }
3869                      if (onCompleteRunnable != null) {
3870                          onCompleteRunnable.run();
3871                      }
3872                  }
3873              };
3874              dragLayer.animateViewIntoPosition(dragView, from.left, from.top, finalPos[0],
3875                      finalPos[1], 1, 1, 1, scaleXY[0], scaleXY[1], onComplete, endStyle,
3876                      duration, this);
3877          }
3878      }
3879  
3880      public void setFinalTransitionTransform(CellLayout layout) {
3881          if (isSwitchingState()) {
3882              mCurrentScale = getScaleX();
3883              setScaleX(mNewScale);
3884              setScaleY(mNewScale);
3885          }
3886      }
3887      public void resetTransitionTransform(CellLayout layout) {
3888          if (isSwitchingState()) {
3889              setScaleX(mCurrentScale);
3890              setScaleY(mCurrentScale);
3891          }
3892      }
3893  
3894      /**
3895       * Return the current {@link CellLayout}, correctly picking the destination
3896       * screen while a scroll is in progress.
3897       */
3898      public CellLayout getCurrentDropLayout() {
3899          return (CellLayout) getChildAt(getNextPage());
3900      }
3901  
3902      /**
3903       * Return the current CellInfo describing our current drag; this method exists
3904       * so that Launcher can sync this object with the correct info when the activity is created/
3905       * destroyed
3906       *
3907       */
3908      public CellLayout.CellInfo getDragInfo() {
3909          return mDragInfo;
3910      }
3911  
3912      public int getRestorePage() {
3913          return getNextPage() - numCustomPages();
3914      }
3915  
3916      /**
3917       * Calculate the nearest cell where the given object would be dropped.
3918       *
3919       * pixelX and pixelY should be in the coordinate system of layout
3920       */
3921      private int[] findNearestArea(int pixelX, int pixelY,
3922              int spanX, int spanY, CellLayout layout, int[] recycle) {
3923          return layout.findNearestArea(
3924                  pixelX, pixelY, spanX, spanY, recycle);
3925      }
3926  
3927      void setup(DragController dragController) {
3928          mSpringLoadedDragController = new SpringLoadedDragController(mLauncher);
3929          mDragController = dragController;
3930  
3931          // hardware layers on children are enabled on startup, but should be disabled until
3932          // needed
3933          updateChildrenLayersEnabled(false);
3934          setWallpaperDimension();
3935      }
3936  
3937      /**
3938       * Called at the end of a drag which originated on the workspace.
3939       */
3940      public void onDropCompleted(final View target, final DragObject d,
3941              final boolean isFlingToDelete, final boolean success) {
3942          if (mDeferDropAfterUninstall) {
3943              mDeferredAction = new Runnable() {
3944                  public void run() {
3945                      onDropCompleted(target, d, isFlingToDelete, success);
3946                      mDeferredAction = null;
3947                  }
3948              };
3949              return;
3950          }
3951  
3952          boolean beingCalledAfterUninstall = mDeferredAction != null;
3953  
3954          if (success &amp;&amp; !(beingCalledAfterUninstall &amp;&amp; !mUninstallSuccessful)) {
3955              if (target != this &amp;&amp; mDragInfo != null) {
3956                  CellLayout parentCell = getParentCellLayoutForView(mDragInfo.cell);
3957                  if (parentCell != null) {
3958                      parentCell.removeView(mDragInfo.cell);
3959                  }
3960                  if (mDragInfo.cell instanceof DropTarget) {
3961                      mDragController.removeDropTarget((DropTarget) mDragInfo.cell);
3962                  }
3963                  // If we move the item to anything not on the Workspace, check if any empty
3964                  // screens need to be removed. If we dropped back on the workspace, this will
3965                  // be done post drop animation.
3966                  removeExtraEmptyScreen(true, null, 0, true);
3967              }
3968          } else if (mDragInfo != null) {
3969              CellLayout cellLayout;
3970              if (mLauncher.isHotseatLayout(target)) {
3971                  cellLayout = mLauncher.getHotseat().getLayout();
3972              } else {
3973                  cellLayout = getScreenWithId(mDragInfo.screenId);
3974              }
3975              cellLayout.onDropChild(mDragInfo.cell);
3976          }
3977          if ((d.cancelled || (beingCalledAfterUninstall &amp;&amp; !mUninstallSuccessful))
3978                  &amp;&amp; mDragInfo.cell != null) {
3979              mDragInfo.cell.setVisibility(VISIBLE);
3980          }
3981          mDragOutline = null;
3982          mDragInfo = null;
3983      }
3984  
3985      public void deferCompleteDropAfterUninstallActivity() {
3986          mDeferDropAfterUninstall = true;
3987      }
3988  
3989      /// maybe move this into a smaller part
3990      public void onUninstallActivityReturned(boolean success) {
3991          mDeferDropAfterUninstall = false;
3992          mUninstallSuccessful = success;
3993          if (mDeferredAction != null) {
3994              mDeferredAction.run();
3995          }
3996      }
3997  
3998      void updateItemLocationsInDatabase(CellLayout cl) {
3999          int count = cl.getShortcutsAndWidgets().getChildCount();
4000  
4001          long screenId = getIdForScreen(cl);
4002          int container = Favorites.CONTAINER_DESKTOP;
4003  
4004          if (mLauncher.isHotseatLayout(cl)) {
4005              screenId = -1;
4006              container = Favorites.CONTAINER_HOTSEAT;
4007          }
4008  
4009          for (int i = 0; i &lt; count; i++) {
4010              View v = cl.getShortcutsAndWidgets().getChildAt(i);
4011              ItemInfo info = (ItemInfo) v.getTag();
4012              // Null check required as the AllApps button doesn&#x27;t have an item info
4013              if (info != null &amp;&amp; info.requiresDbUpdate) {
4014                  info.requiresDbUpdate = false;
4015                  LauncherModel.modifyItemInDatabase(mLauncher, info, container, screenId, info.cellX,
4016                          info.cellY, info.spanX, info.spanY);
4017              }
4018          }
4019      }
4020  
4021      ArrayList&lt;ComponentName&gt; getUniqueComponents(boolean stripDuplicates, ArrayList&lt;ComponentName&gt; duplicates) {
4022          ArrayList&lt;ComponentName&gt; uniqueIntents = new ArrayList&lt;ComponentName&gt;();
4023          getUniqueIntents((CellLayout) mLauncher.getHotseat().getLayout(), uniqueIntents, duplicates, false);
4024          int count = getChildCount();
4025          for (int i = 0; i &lt; count; i++) {
4026              CellLayout cl = (CellLayout) getChildAt(i);
4027              getUniqueIntents(cl, uniqueIntents, duplicates, false);
4028          }
4029          return uniqueIntents;
4030      }
4031  
4032      void getUniqueIntents(CellLayout cl, ArrayList&lt;ComponentName&gt; uniqueIntents,
4033              ArrayList&lt;ComponentName&gt; duplicates, boolean stripDuplicates) {
4034          int count = cl.getShortcutsAndWidgets().getChildCount();
4035  
4036          ArrayList&lt;View&gt; children = new ArrayList&lt;View&gt;();
4037          for (int i = 0; i &lt; count; i++) {
4038              View v = cl.getShortcutsAndWidgets().getChildAt(i);
4039              children.add(v);
4040          }
4041  
4042          for (int i = 0; i &lt; count; i++) {
4043              View v = children.get(i);
4044              ItemInfo info = (ItemInfo) v.getTag();
4045              // Null check required as the AllApps button doesn&#x27;t have an item info
4046              if (info instanceof ShortcutInfo) {
4047                  ShortcutInfo si = (ShortcutInfo) info;
4048                  ComponentName cn = si.intent.getComponent();
4049  
4050                  Uri dataUri = si.intent.getData();
4051                  // If dataUri is not null / empty or if this component isn&#x27;t one that would
4052                  // have previously showed up in the AllApps list, then this is a widget-type
4053                  // shortcut, so ignore it.
4054                  if (dataUri != null &amp;&amp; !dataUri.equals(Uri.EMPTY)) {
4055                      continue;
4056                  }
4057  
4058                  if (!uniqueIntents.contains(cn)) {
4059                      uniqueIntents.add(cn);
4060                  } else {
4061                      if (stripDuplicates) {
4062                          cl.removeViewInLayout(v);
4063                          LauncherModel.deleteItemFromDatabase(mLauncher, si);
4064                      }
4065                      if (duplicates != null) {
4066                          duplicates.add(cn);
4067                      }
4068                  }
4069              }
4070              if (v instanceof FolderIcon) {
4071                  FolderIcon fi = (FolderIcon) v;
4072                  ArrayList&lt;View&gt; items = fi.getFolder().getItemsInReadingOrder();
4073                  for (int j = 0; j &lt; items.size(); j++) {
4074                      if (items.get(j).getTag() instanceof ShortcutInfo) {
4075                          ShortcutInfo si = (ShortcutInfo) items.get(j).getTag();
4076                          ComponentName cn = si.intent.getComponent();
4077  
4078                          Uri dataUri = si.intent.getData();
4079                          // If dataUri is not null / empty or if this component isn&#x27;t one that would
4080                          // have previously showed up in the AllApps list, then this is a widget-type
4081                          // shortcut, so ignore it.
4082                          if (dataUri != null &amp;&amp; !dataUri.equals(Uri.EMPTY)) {
4083                              continue;
4084                          }
4085  
4086                          if (!uniqueIntents.contains(cn)) {
4087                              uniqueIntents.add(cn);
4088                          }  else {
4089                              if (stripDuplicates) {
4090                                  fi.getFolderInfo().remove(si);
4091                                  LauncherModel.deleteItemFromDatabase(mLauncher, si);
4092                              }
4093                              if (duplicates != null) {
4094                                  duplicates.add(cn);
4095                              }
4096                          }
4097                      }
4098                  }
4099              }
4100          }
4101      }
4102  
4103      void saveWorkspaceToDb() {
4104          saveWorkspaceScreenToDb((CellLayout) mLauncher.getHotseat().getLayout());
4105          int count = getChildCount();
4106          for (int i = 0; i &lt; count; i++) {
4107              CellLayout cl = (CellLayout) getChildAt(i);
4108              saveWorkspaceScreenToDb(cl);
4109          }
4110      }
4111  
4112      void saveWorkspaceScreenToDb(CellLayout cl) {
4113          int count = cl.getShortcutsAndWidgets().getChildCount();
4114  
4115          long screenId = getIdForScreen(cl);
4116          int container = Favorites.CONTAINER_DESKTOP;
4117  
4118          Hotseat hotseat = mLauncher.getHotseat();
4119          if (mLauncher.isHotseatLayout(cl)) {
4120              screenId = -1;
4121              container = Favorites.CONTAINER_HOTSEAT;
4122          }
4123  
4124          for (int i = 0; i &lt; count; i++) {
4125              View v = cl.getShortcutsAndWidgets().getChildAt(i);
4126              ItemInfo info = (ItemInfo) v.getTag();
4127              // Null check required as the AllApps button doesn&#x27;t have an item info
4128              if (info != null) {
4129                  int cellX = info.cellX;
4130                  int cellY = info.cellY;
4131                  if (container == Favorites.CONTAINER_HOTSEAT) {
4132                      cellX = hotseat.getCellXFromOrder((int) info.screenId);
4133                      cellY = hotseat.getCellYFromOrder((int) info.screenId);
4134                  }
4135                  LauncherModel.addItemToDatabase(mLauncher, info, container, screenId, cellX,
4136                          cellY, false);
4137              }
4138              if (v instanceof FolderIcon) {
4139                  FolderIcon fi = (FolderIcon) v;
4140                  fi.getFolder().addItemLocationsInDatabase();
4141              }
4142          }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4143 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4144 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4145 +    @Override</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4146 +    public float getIntrinsicIconScaleFactor() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">4147 +        return 1f;</span>
4148      }
4149  
4150      @Override
4151      public boolean supportsFlingToDelete() {
4152          return true;
4153      }
4154  
4155      @Override
4156      public void onFlingToDelete(DragObject d, int x, int y, PointF vec) {
4157          // Do nothing
4158      }
4159  
4160      @Override
4161      public void onFlingToDeleteCompleted() {
4162          // Do nothing
4163      }
4164  
4165      public boolean isDropEnabled() {
4166          return true;
4167      }
4168  
4169      @Override
4170      protected void onRestoreInstanceState(Parcelable state) {
4171          super.onRestoreInstanceState(state);
4172          Launcher.setScreen(mCurrentPage);
4173      }
4174  
4175      @Override
4176      protected void dispatchRestoreInstanceState(SparseArray&lt;Parcelable&gt; container) {
4177          // We don&#x27;t dispatch restoreInstanceState to our children using this code path.
4178          // Some pages will be restored immediately as their items are bound immediately, and
4179          // others we will need to wait until after their items are bound.
4180          mSavedStates = container;
4181      }
4182  
4183      public void restoreInstanceStateForChild(int child) {
4184          if (mSavedStates != null) {
4185              mRestoredPages.add(child);
4186              CellLayout cl = (CellLayout) getChildAt(child);
4187              cl.restoreInstanceState(mSavedStates);
4188          }
4189      }
4190  
4191      public void restoreInstanceStateForRemainingPages() {
4192          int count = getChildCount();
4193          for (int i = 0; i &lt; count; i++) {
4194              if (!mRestoredPages.contains(i)) {
4195                  restoreInstanceStateForChild(i);
4196              }
4197          }
4198          mRestoredPages.clear();
4199          mSavedStates = null;
4200      }
4201  
4202      @Override
4203      public void scrollLeft() {
4204          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
4205              super.scrollLeft();
4206          }
4207          Folder openFolder = getOpenFolder();
4208          if (openFolder != null) {
4209              openFolder.completeDragExit();
4210          }
4211      }
4212  
4213      @Override
4214      public void scrollRight() {
4215          if (!isSmall() &amp;&amp; !mIsSwitchingState) {
4216              super.scrollRight();
4217          }
4218          Folder openFolder = getOpenFolder();
4219          if (openFolder != null) {
4220              openFolder.completeDragExit();
4221          }
4222      }
4223  
4224      @Override
4225      public boolean onEnterScrollArea(int x, int y, int direction) {
4226          // Ignore the scroll area if we are dragging over the hot seat
4227          boolean isPortrait = !LauncherAppState.isScreenLandscape(getContext());
4228          if (mLauncher.getHotseat() != null &amp;&amp; isPortrait) {
4229              Rect r = new Rect();
4230              mLauncher.getHotseat().getHitRect(r);
4231              if (r.contains(x, y)) {
4232                  return false;
4233              }
4234          }
4235  
4236          boolean result = false;
4237          if (!isSmall() &amp;&amp; !mIsSwitchingState &amp;&amp; getOpenFolder() == null) {
4238              mInScrollArea = true;
4239  
4240              final int page = getNextPage() +
4241                         (direction == DragController.SCROLL_LEFT ? -1 : 1);
4242              // We always want to exit the current layout to ensure parity of enter / exit
4243              setCurrentDropLayout(null);
4244  
4245              if (0 &lt;= page &amp;&amp; page &lt; getChildCount()) {
4246                  // Ensure that we are not dragging over to the custom content screen
4247                  if (getScreenIdForPageIndex(page) == CUSTOM_CONTENT_SCREEN_ID) {
4248                      return false;
4249                  }
4250  
4251                  CellLayout layout = (CellLayout) getChildAt(page);
4252                  setCurrentDragOverlappingLayout(layout);
4253  
4254                  // Workspace is responsible for drawing the edge glow on adjacent pages,
4255                  // so we need to redraw the workspace when this may have changed.
4256                  invalidate();
4257                  result = true;
4258              }
4259          }
4260          return result;
4261      }
4262  
4263      @Override
4264      public boolean onExitScrollArea() {
4265          boolean result = false;
4266          if (mInScrollArea) {
4267              invalidate();
4268              CellLayout layout = getCurrentDropLayout();
4269              setCurrentDropLayout(layout);
4270              setCurrentDragOverlappingLayout(layout);
4271  
4272              result = true;
4273              mInScrollArea = false;
4274          }
4275          return result;
4276      }
4277  
4278      private void onResetScrollArea() {
4279          setCurrentDragOverlappingLayout(null);
4280          mInScrollArea = false;
4281      }
4282  
4283      /**
4284       * Returns a specific CellLayout
4285       */
4286      CellLayout getParentCellLayoutForView(View v) {
4287          ArrayList&lt;CellLayout&gt; layouts = getWorkspaceAndHotseatCellLayouts();
4288          for (CellLayout layout : layouts) {
4289              if (layout.getShortcutsAndWidgets().indexOfChild(v) &gt; -1) {
4290                  return layout;
4291              }
4292          }
4293          return null;
4294      }
4295  
4296      /**
4297       * Returns a list of all the CellLayouts in the workspace.
4298       */
4299      ArrayList&lt;CellLayout&gt; getWorkspaceAndHotseatCellLayouts() {
4300          ArrayList&lt;CellLayout&gt; layouts = new ArrayList&lt;CellLayout&gt;();
4301          int screenCount = getChildCount();
4302          for (int screen = 0; screen &lt; screenCount; screen++) {
4303              layouts.add(((CellLayout) getChildAt(screen)));
4304          }
4305          if (mLauncher.getHotseat() != null) {
4306              layouts.add(mLauncher.getHotseat().getLayout());
4307          }
4308          return layouts;
4309      }
4310  
4311      /**
4312       * We should only use this to search for specific children.  Do not use this method to modify
4313       * ShortcutsAndWidgetsContainer directly. Includes ShortcutAndWidgetContainers from
4314       * the hotseat and workspace pages
4315       */
4316      ArrayList&lt;ShortcutAndWidgetContainer&gt; getAllShortcutAndWidgetContainers() {
4317          ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4318                  new ArrayList&lt;ShortcutAndWidgetContainer&gt;();
4319          int screenCount = getChildCount();
4320          for (int screen = 0; screen &lt; screenCount; screen++) {
4321              childrenLayouts.add(((CellLayout) getChildAt(screen)).getShortcutsAndWidgets());
4322          }
4323          if (mLauncher.getHotseat() != null) {
4324              childrenLayouts.add(mLauncher.getHotseat().getLayout().getShortcutsAndWidgets());
4325          }
4326          return childrenLayouts;
4327      }
4328  
4329      public Folder getFolderForTag(Object tag) {
4330          ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4331                  getAllShortcutAndWidgetContainers();
4332          for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4333              int count = layout.getChildCount();
4334              for (int i = 0; i &lt; count; i++) {
4335                  View child = layout.getChildAt(i);
4336                  if (child instanceof Folder) {
4337                      Folder f = (Folder) child;
4338                      if (f.getInfo() == tag &amp;&amp; f.getInfo().opened) {
4339                          return f;
4340                      }
4341                  }
4342              }
4343          }
4344          return null;
4345      }
4346  
4347      public View getViewForTag(Object tag) {
4348          ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4349                  getAllShortcutAndWidgetContainers();
4350          for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4351              int count = layout.getChildCount();
4352              for (int i = 0; i &lt; count; i++) {
4353                  View child = layout.getChildAt(i);
4354                  if (child.getTag() == tag) {
4355                      return child;
4356                  }
4357              }
4358          }
4359          return null;
4360      }
4361  
4362      void clearDropTargets() {
4363          ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts =
4364                  getAllShortcutAndWidgetContainers();
4365          for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4366              int childCount = layout.getChildCount();
4367              for (int j = 0; j &lt; childCount; j++) {
4368                  View v = layout.getChildAt(j);
4369                  if (v instanceof DropTarget) {
4370                      mDragController.removeDropTarget((DropTarget) v);
4371                  }
4372              }
4373          }
4374      }
4375  
4376      // Removes ALL items that match a given package name, this is usually called when a package
4377      // has been removed and we want to remove all components (widgets, shortcuts, apps) that
4378      // belong to that package.
4379      void removeItemsByPackageName(final ArrayList&lt;String&gt; packages) {
4380          final HashSet&lt;String&gt; packageNames = new HashSet&lt;String&gt;();
4381          packageNames.addAll(packages);
4382  
4383          // Filter out all the ItemInfos that this is going to affect
4384          final HashSet&lt;ItemInfo&gt; infos = new HashSet&lt;ItemInfo&gt;();
4385          final HashSet&lt;ComponentName&gt; cns = new HashSet&lt;ComponentName&gt;();
4386          ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
4387          for (CellLayout layoutParent : cellLayouts) {
4388              ViewGroup layout = layoutParent.getShortcutsAndWidgets();
4389              int childCount = layout.getChildCount();
4390              for (int i = 0; i &lt; childCount; ++i) {
4391                  View view = layout.getChildAt(i);
4392                  infos.add((ItemInfo) view.getTag());
4393              }
4394          }
4395          LauncherModel.ItemInfoFilter filter = new LauncherModel.ItemInfoFilter() {
4396              @Override
4397              public boolean filterItem(ItemInfo parent, ItemInfo info,
4398                                        ComponentName cn) {
4399                  if (packageNames.contains(cn.getPackageName())) {
4400                      cns.add(cn);
4401                      return true;
4402                  }
4403                  return false;
4404              }
4405          };
4406          LauncherModel.filterItemInfos(infos, filter);
4407  
4408          // Remove the affected components
4409          removeItemsByComponentName(cns);
4410      }
4411  
4412      // Removes items that match the application info specified, when applications are removed
4413      // as a part of an update, this is called to ensure that other widgets and application
4414      // shortcuts are not removed.
4415      void removeItemsByApplicationInfo(final ArrayList&lt;AppInfo&gt; appInfos) {
4416          // Just create a hash table of all the specific components that this will affect
4417          HashSet&lt;ComponentName&gt; cns = new HashSet&lt;ComponentName&gt;();
4418          for (AppInfo info : appInfos) {
4419              cns.add(info.componentName);
4420          }
4421  
4422          // Remove all the things
4423          removeItemsByComponentName(cns);
4424      }
4425  
4426      void removeItemsByComponentName(final HashSet&lt;ComponentName&gt; componentNames) {
4427          ArrayList&lt;CellLayout&gt; cellLayouts = getWorkspaceAndHotseatCellLayouts();
4428          for (final CellLayout layoutParent: cellLayouts) {
4429              final ViewGroup layout = layoutParent.getShortcutsAndWidgets();
4430  
4431              final HashMap&lt;ItemInfo, View&gt; children = new HashMap&lt;ItemInfo, View&gt;();
4432              for (int j = 0; j &lt; layout.getChildCount(); j++) {
4433                  final View view = layout.getChildAt(j);
4434                  children.put((ItemInfo) view.getTag(), view);
4435              }
4436  
4437              final ArrayList&lt;View&gt; childrenToRemove = new ArrayList&lt;View&gt;();
4438              final HashMap&lt;FolderInfo, ArrayList&lt;ShortcutInfo&gt;&gt; folderAppsToRemove =
4439                      new HashMap&lt;FolderInfo, ArrayList&lt;ShortcutInfo&gt;&gt;();
4440              LauncherModel.ItemInfoFilter filter = new LauncherModel.ItemInfoFilter() {
4441                  @Override
4442                  public boolean filterItem(ItemInfo parent, ItemInfo info,
4443                                            ComponentName cn) {
4444                      if (parent instanceof FolderInfo) {
4445                          if (componentNames.contains(cn)) {
4446                              FolderInfo folder = (FolderInfo) parent;
4447                              ArrayList&lt;ShortcutInfo&gt; appsToRemove;
4448                              if (folderAppsToRemove.containsKey(folder)) {
4449                                  appsToRemove = folderAppsToRemove.get(folder);
4450                              } else {
4451                                  appsToRemove = new ArrayList&lt;ShortcutInfo&gt;();
4452                                  folderAppsToRemove.put(folder, appsToRemove);
4453                              }
4454                              appsToRemove.add((ShortcutInfo) info);
4455                              return true;
4456                          }
4457                      } else {
4458                          if (componentNames.contains(cn)) {
4459                              childrenToRemove.add(children.get(info));
4460                              return true;
4461                          }
4462                      }
4463                      return false;
4464                  }
4465              };
4466              LauncherModel.filterItemInfos(children.keySet(), filter);
4467  
4468              // Remove all the apps from their folders
4469              for (FolderInfo folder : folderAppsToRemove.keySet()) {
4470                  ArrayList&lt;ShortcutInfo&gt; appsToRemove = folderAppsToRemove.get(folder);
4471                  for (ShortcutInfo info : appsToRemove) {
4472                      folder.remove(info);
4473                  }
4474              }
4475  
4476              // Remove all the other children
4477              for (View child : childrenToRemove) {
4478                  // Note: We can not remove the view directly from CellLayoutChildren as this
4479                  // does not re-mark the spaces as unoccupied.
4480                  layoutParent.removeViewInLayout(child);
4481                  if (child instanceof DropTarget) {
4482                      mDragController.removeDropTarget((DropTarget) child);
4483                  }
4484              }
4485  
4486              if (childrenToRemove.size() &gt; 0) {
4487                  layout.requestLayout();
4488                  layout.invalidate();
4489              }
4490          }
4491  
4492          // Strip all the empty screens
4493          stripEmptyScreens();
4494      }
4495  
4496      private void updateShortcut(HashMap&lt;ComponentName, AppInfo&gt; appsMap, ItemInfo info,
4497                                  View child) {
4498          ComponentName cn = info.getIntent().getComponent();
4499          if (cn != null) {
4500              AppInfo appInfo = appsMap.get(info.getIntent().getComponent());
4501              if ((appInfo != null) &amp;&amp; LauncherModel.isShortcutInfoUpdateable(info)) {
4502                  ShortcutInfo shortcutInfo = (ShortcutInfo) info;
4503                  BubbleTextView shortcut = (BubbleTextView) child;
4504                  shortcutInfo.updateIcon(mIconCache);
4505                  shortcutInfo.title = appInfo.title.toString();
4506                  shortcut.applyFromShortcutInfo(shortcutInfo, mIconCache);
4507              }
4508          }
4509      }
4510  
4511      void updateShortcuts(ArrayList&lt;AppInfo&gt; apps) {
4512          // Create a map of the apps to test against
4513          final HashMap&lt;ComponentName, AppInfo&gt; appsMap = new HashMap&lt;ComponentName, AppInfo&gt;();
4514          for (AppInfo ai : apps) {
4515              appsMap.put(ai.componentName, ai);
4516          }
4517  
4518          ArrayList&lt;ShortcutAndWidgetContainer&gt; childrenLayouts = getAllShortcutAndWidgetContainers();
4519          for (ShortcutAndWidgetContainer layout: childrenLayouts) {
4520              // Update all the children shortcuts
4521              final HashMap&lt;ItemInfo, View&gt; children = new HashMap&lt;ItemInfo, View&gt;();
4522              for (int j = 0; j &lt; layout.getChildCount(); j++) {
4523                  View v = layout.getChildAt(j);
4524                  ItemInfo info = (ItemInfo) v.getTag();
4525                  if (info instanceof FolderInfo &amp;&amp; v instanceof FolderIcon) {
4526                      FolderIcon folder = (FolderIcon) v;
4527                      ArrayList&lt;View&gt; folderChildren = folder.getFolder().getItemsInReadingOrder();
4528                      for (View fv : folderChildren) {
4529                          info = (ItemInfo) fv.getTag();
4530                          updateShortcut(appsMap, info, fv);
4531                      }
4532                      folder.invalidate();
4533                  } else if (info instanceof ShortcutInfo) {
4534                      updateShortcut(appsMap, info, v);
4535                  }
4536              }
4537          }
4538      }
4539  
4540      private void moveToScreen(int page, boolean animate) {
4541          if (!isSmall()) {
4542              if (animate) {
4543                  snapToPage(page);
4544              } else {
4545                  setCurrentPage(page);
4546              }
4547          }
4548          View child = getChildAt(page);
4549          if (child != null) {
4550              child.requestFocus();
4551          }
4552      }
4553  
4554      void moveToDefaultScreen(boolean animate) {
4555          moveToScreen(mDefaultPage, animate);
4556      }
4557  
4558      void moveToCustomContentScreen(boolean animate) {
4559          if (hasCustomContent()) {
4560              int ccIndex = getPageIndexForScreenId(CUSTOM_CONTENT_SCREEN_ID);
4561              if (animate) {
4562                  snapToPage(ccIndex);
4563              } else {
4564                  setCurrentPage(ccIndex);
4565              }
4566              View child = getChildAt(ccIndex);
4567              if (child != null) {
4568                  child.requestFocus();
4569              }
4570           }

4571      }
4572  
4573      @Override
4574      protected PageIndicator.PageMarkerResources getPageIndicatorMarker(int pageIndex) {
4575          long screenId = getScreenIdForPageIndex(pageIndex);
4576          if (screenId == EXTRA_EMPTY_SCREEN_ID) {
4577              int count = mScreenOrder.size() - numCustomPages();
4578              if (count &gt; 1) {
4579                  return new PageIndicator.PageMarkerResources(R.drawable.ic_pageindicator_current,
4580                          R.drawable.ic_pageindicator_add);
4581              }
4582          }
4583  
4584          return super.getPageIndicatorMarker(pageIndex);
4585      }
4586  
4587      @Override
4588      public void syncPages() {
4589      }
4590  
4591      @Override
4592      public void syncPageItems(int page, boolean immediate) {
4593      }
4594  
4595      protected String getPageIndicatorDescription() {
4596          String settings = getResources().getString(R.string.settings_button_text);
4597          return getCurrentPageDescription() + &quot;, &quot; + settings;
4598      }
4599  
4600      protected String getCurrentPageDescription() {
4601          int page = (mNextPage != INVALID_PAGE) ? mNextPage : mCurrentPage;
4602          int delta = numCustomPages();
4603          if (hasCustomContent() &amp;&amp; getNextPage() == 0) {
4604              return mCustomContentDescription;
4605          }
4606          return String.format(getContext().getString(R.string.workspace_scroll_format),
4607                  page + 1 - delta, getChildCount() - delta);
4608      }
4609  
4610      public void getLocationInDragLayer(int[] loc) {
4611          mLauncher.getDragLayer().getLocationInDragLayer(this, loc);
4612      }
4613  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            