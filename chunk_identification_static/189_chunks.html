<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>189 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Autowired;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Qualifier;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import org.hibernate.Session;\n&#x27;
                           &#x27;import org.hibernate.jdbc.Work;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.springframework.beans.factory.annotation.Autowired;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.springframework.core.env.Environment;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    @Autowired\n&#x27;
                         &#x27;    @Qualifier(&quot;blNotificationDispatcher&quot;)\n&#x27;
                         &#x27;    protected NotificationDispatcher &#x27;
                         &#x27;notificationDispatcher;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    @Resource(name = &#x27;
                           &#x27;&quot;blDeleteStatementGenerator&quot;)\n&#x27;
                           &#x27;    protected DeleteStatementGenerator &#x27;
                           &#x27;deleteStatementGenerator;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Autowired\n&#x27;
                           &#x27;    protected Environment env;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @PersistenceContext(unitName = &quot;blPU&quot;)\n&#x27;
                           &#x27;    protected EntityManager em;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Resource(name = &#x27;
                           &#x27;&quot;blResourcePurgeExtensionManager&quot;)\n&#x27;
                           &#x27;    protected ResourcePurgeExtensionManager &#x27;
                           &#x27;extensionManager;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void notifyCarts(final Map&lt;String, &#x27;
                         &#x27;String&gt; config) {\n&#x27;
                         &#x27;        if (LOG.isDebugEnabled()) {\n&#x27;
                         &#x27;            LOG.debug(&quot;Notifying carts of purge&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (MapUtils.isEmpty(config)) {\n&#x27;
                         &#x27;            throw new &#x27;
                         &#x27;IllegalArgumentException(&quot;Cannot notify carts of &#x27;
                         &#x27;purge since there was no configuration provided. &quot; &#x27;
                         &#x27;+\n&#x27;
                         &#x27;                    &quot;In the absence of config &#x27;
                         &#x27;params, all carts would be candidates for &#x27;
                         &#x27;deletion.&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        CartPurgeParams purgeParams = new &#x27;
                         &#x27;CartPurgeParams(config).invoke();\n&#x27;
                         &#x27;        int batchCount = 0;\n&#x27;
                         &#x27;        Set&lt;Long&gt; failedCartIds = &#x27;
                         &#x27;getCartsInErrorToIgnore(purgeParams);\n&#x27;
                         &#x27;        batchCount = &#x27;
                         &#x27;getCartsToPurgeLength(purgeParams, new &#x27;
                         &#x27;ArrayList&lt;&gt;(failedCartIds)).intValue();\n&#x27;
                         &#x27;        List&lt;Order&gt; carts = &#x27;
                         &#x27;getCartsToPurge(purgeParams, 0, batchCount, new &#x27;
                         &#x27;ArrayList&lt;&gt;(failedCartIds));\n&#x27;
                         &#x27;        for (Order cart : carts) {\n&#x27;
                         &#x27;            notifyCart(cart);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void purgeOrderHistory(Class&lt;?&gt; &#x27;
                           &#x27;rootType, String rootTypeIdValue, Map&lt;String, &#x27;
                           &#x27;List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; &#x27;
                           &#x27;depends, final Map&lt;String, Integer&gt; config) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;            LOG.debug(&quot;Purging historical &#x27;
                           &#x27;orders&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String enablePurge = &#x27;
                           &#x27;env.getProperty(&quot;enable.purge.order.history&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (!Boolean.parseBoolean(enablePurge)) {\n&#x27;
                           &#x27;            LOG.info(&quot;Save protection. Purging &#x27;
                           &#x27;history is off. Please set property &#x27;
                           &#x27;enable.purge.order.history to true.&quot;);\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Integer daysCount = &#x27;
                           &#x27;config.get(PurgeOrderHistoryVariableNames.OLDER_THAN_DAYS.toString());\n&#x27;
                           &#x27;        Integer batchSize = &#x27;
                           &#x27;config.get(PurgeOrderHistoryVariableNames.BATCH_SIZE.toString());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;Order&gt; oldOrders = &#x27;
                           &#x27;orderService.findOrdersByDaysCount(daysCount, &#x27;
                           &#x27;batchSize);\n&#x27;
                           &#x27;        Map&lt;String, &#x27;
                           &#x27;List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; &#x27;
                           &#x27;dependencies = new HashMap&lt;&gt;(depends);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;List&lt;DeleteStatementGeneratorImpl.PathElement&gt; &#x27;
                           &#x27;orderDependencies = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        orderDependencies.add(new &#x27;
                           &#x27;DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_LOCK&quot;, &#x27;
                           &#x27;&quot;ORDER_ID&quot;, &quot;ORDER_ID&quot;));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        dependencies.put(&quot;BLC_ORDER&quot;, &#x27;
                           &#x27;orderDependencies);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;ArrayList&lt;DeleteStatementGeneratorImpl.PathElement&gt; &#x27;
                           &#x27;orderItemDependencies = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;        orderDependencies.add(new &#x27;
                           &#x27;DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_MULTISHIP_OPTION&quot;, &#x27;
                           &#x27;&quot;ORDER_MULTISHIP_OPTION_ID&quot;, &quot;ORDER_ITEM_ID&quot;));\n&#x27;
                           &#x27;        orderDependencies.add(new &#x27;
                           &#x27;DeleteStatementGeneratorImpl.PathElement(&quot;BLC_GIFTWRAP_ORDER_ITEM&quot;, &#x27;
                           &#x27;&quot;ORDER_ITEM_ID&quot;, &quot;ORDER_ITEM_ID&quot;));\n&#x27;
                           &#x27;        dependencies.put(&quot;BLC_ORDER_ITEM&quot;, &#x27;
                           &#x27;orderItemDependencies);\n&#x27;
                           &#x27;        dependencies.put(&quot;BLC_ORDER_PAYMENT&quot;, &#x27;
                           &#x27;Collections.singletonList(new &#x27;
                           &#x27;DeleteStatementGeneratorImpl.PathElement(&quot;BLC_PAYMENT_LOG&quot;, &#x27;
                           &#x27;&quot;ORDER_PAYMENT_ID&quot;, &quot;ORDER_PAYMENT_ID&quot;)));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;extensionManager.getProxy().addPurgeDependencies(dependencies);\n&#x27;
                           &#x27;        Set&lt;String&gt; exclusions = new HashSet&lt;&gt;();\n&#x27;
                           &#x27;        exclusions.add(&quot;BLC_ADMIN_USER&quot;);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;extensionManager.getProxy().addPurgeExclusions(exclusions);\n&#x27;
                           &#x27;        Map&lt;String, String&gt; deleteStatement = &#x27;
                           &#x27;deleteStatementGenerator.generateDeleteStatementsForType(OrderImpl.class, &#x27;
                           &#x27;&quot;?&quot;, dependencies, exclusions);\n&#x27;
                           &#x27;        for (Order order : oldOrders) {\n&#x27;
                           &#x27;            TransactionStatus status = &#x27;
                           &#x27;TransactionUtils.createTransaction(&quot;Cart Purge&quot;,\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;TransactionDefinition.PROPAGATION_REQUIRED, &#x27;
                           &#x27;transactionManager, false);\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;em.unwrap(Session.class).doWork(new Work() {\n&#x27;
                           &#x27;                    @Override\n&#x27;
                           &#x27;                    public void execute(Connection &#x27;
                           &#x27;connection) throws SQLException {\n&#x27;
                           &#x27;                        Statement statement = &#x27;
                           &#x27;connection.createStatement();\n&#x27;
                           &#x27;                        for (String value : &#x27;
                           &#x27;deleteStatement.values()) {\n&#x27;
                           &#x27;                            String sql = &#x27;
                           &#x27;value.replace(&quot;?&quot;, &#x27;
                           &#x27;String.valueOf(order.getId()));\n&#x27;
                           &#x27;                            LOG.debug(sql);\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;statement.addBatch(sql);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;extensionManager.getProxy().addPurgeStatements(statement, &#x27;
                           &#x27;rootTypeIdValue);\n&#x27;
                           &#x27;                        statement.executeBatch();\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                });\n&#x27;
                           &#x27;                &#x27;
                           &#x27;TransactionUtils.finalizeTransaction(status, &#x27;
                           &#x27;transactionManager, false);\n&#x27;
                           &#x27;            } catch (Exception e) {\n&#x27;
                           &#x27;                if (!status.isCompleted()) {\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;TransactionUtils.finalizeTransaction(status, &#x27;
                           &#x27;transactionManager, true);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                LOG.error(String.format(&quot;Not able &#x27;
                           &#x27;to purge Order ID: %d&quot;, order.getId()), e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        LOG.info(&quot;Finished purging historical &#x27;
                           &#x27;orders.&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Autowired;\n&#x27;
                         &#x27;import &#x27;
                         &#x27;org.springframework.beans.factory.annotation.Qualifier;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;import org.hibernate.Session;\n&#x27;
                           &#x27;import org.hibernate.jdbc.Work;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.springframework.beans.factory.annotation.Autowired;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;org.springframework.core.env.Environment;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    @Autowired\n&#x27;
                         &#x27;    @Qualifier(&quot;blNotificationDispatcher&quot;)\n&#x27;
                         &#x27;    protected NotificationDispatcher &#x27;
                         &#x27;notificationDispatcher;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    @Resource(name = &#x27;
                           &#x27;&quot;blDeleteStatementGenerator&quot;)\n&#x27;
                           &#x27;    protected DeleteStatementGenerator &#x27;
                           &#x27;deleteStatementGenerator;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Autowired\n&#x27;
                           &#x27;    protected Environment env;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @PersistenceContext(unitName = &quot;blPU&quot;)\n&#x27;
                           &#x27;    protected EntityManager em;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    @Resource(name = &#x27;
                           &#x27;&quot;blResourcePurgeExtensionManager&quot;)\n&#x27;
                           &#x27;    protected ResourcePurgeExtensionManager &#x27;
                           &#x27;extensionManager;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    public void notifyCarts(final Map&lt;String, &#x27;
                         &#x27;String&gt; config) {\n&#x27;
                         &#x27;        if (LOG.isDebugEnabled()) {\n&#x27;
                         &#x27;            LOG.debug(&quot;Notifying carts of purge&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        if (MapUtils.isEmpty(config)) {\n&#x27;
                         &#x27;            throw new &#x27;
                         &#x27;IllegalArgumentException(&quot;Cannot notify carts of &#x27;
                         &#x27;purge since there was no configuration provided. &quot; &#x27;
                         &#x27;+\n&#x27;
                         &#x27;                    &quot;In the absence of config &#x27;
                         &#x27;params, all carts would be candidates for &#x27;
                         &#x27;deletion.&quot;);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        CartPurgeParams purgeParams = new &#x27;
                         &#x27;CartPurgeParams(config).invoke();\n&#x27;
                         &#x27;        int batchCount = 0;\n&#x27;
                         &#x27;        Set&lt;Long&gt; failedCartIds = &#x27;
                         &#x27;getCartsInErrorToIgnore(purgeParams);\n&#x27;
                         &#x27;        batchCount = &#x27;
                         &#x27;getCartsToPurgeLength(purgeParams, new &#x27;
                         &#x27;ArrayList&lt;&gt;(failedCartIds)).intValue();\n&#x27;
                         &#x27;        List&lt;Order&gt; carts = &#x27;
                         &#x27;getCartsToPurge(purgeParams, 0, batchCount, new &#x27;
                         &#x27;ArrayList&lt;&gt;(failedCartIds));\n&#x27;
                         &#x27;        for (Order cart : carts) {\n&#x27;
                         &#x27;            notifyCart(cart);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;    public void purgeOrderHistory(Class&lt;?&gt; &#x27;
                           &#x27;rootType, String rootTypeIdValue, Map&lt;String, &#x27;
                           &#x27;List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; &#x27;
                           &#x27;depends, final Map&lt;String, Integer&gt; config) {\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (LOG.isDebugEnabled()) {\n&#x27;
                           &#x27;            LOG.debug(&quot;Purging historical &#x27;
                           &#x27;orders&quot;);\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        String enablePurge = &#x27;
                           &#x27;env.getProperty(&quot;enable.purge.order.history&quot;);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        if (!Boolean.parseBoolean(enablePurge)) {\n&#x27;
                           &#x27;            LOG.info(&quot;Save protection. Purging &#x27;
                           &#x27;history is off. Please set property &#x27;
                           &#x27;enable.purge.order.history to true.&quot;);\n&#x27;
                           &#x27;            return;\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        Integer daysCount = &#x27;
                           &#x27;config.get(PurgeOrderHistoryVariableNames.OLDER_THAN_DAYS.toString());\n&#x27;
                           &#x27;        Integer batchSize = &#x27;
                           &#x27;config.get(PurgeOrderHistoryVariableNames.BATCH_SIZE.toString());\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        List&lt;Order&gt; oldOrders = &#x27;
                           &#x27;orderService.findOrdersByDaysCount(daysCount, &#x27;
                           &#x27;batchSize);\n&#x27;
                           &#x27;        Map&lt;String, &#x27;
                           &#x27;List&lt;DeleteStatementGeneratorImpl.PathElement&gt;&gt; &#x27;
                           &#x27;dependencies = new HashMap&lt;&gt;(depends);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;List&lt;DeleteStatementGeneratorImpl.PathElement&gt; &#x27;
                           &#x27;orderDependencies = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        orderDependencies.add(new &#x27;
                           &#x27;DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_LOCK&quot;, &#x27;
                           &#x27;&quot;ORDER_ID&quot;, &quot;ORDER_ID&quot;));\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        dependencies.put(&quot;BLC_ORDER&quot;, &#x27;
                           &#x27;orderDependencies);\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;ArrayList&lt;DeleteStatementGeneratorImpl.PathElement&gt; &#x27;
                           &#x27;orderItemDependencies = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;        orderDependencies.add(new &#x27;
                           &#x27;DeleteStatementGeneratorImpl.PathElement(&quot;BLC_ORDER_MULTISHIP_OPTION&quot;, &#x27;
                           &#x27;&quot;ORDER_MULTISHIP_OPTION_ID&quot;, &quot;ORDER_ITEM_ID&quot;));\n&#x27;
                           &#x27;        orderDependencies.add(new &#x27;
                           &#x27;DeleteStatementGeneratorImpl.PathElement(&quot;BLC_GIFTWRAP_ORDER_ITEM&quot;, &#x27;
                           &#x27;&quot;ORDER_ITEM_ID&quot;, &quot;ORDER_ITEM_ID&quot;));\n&#x27;
                           &#x27;        dependencies.put(&quot;BLC_ORDER_ITEM&quot;, &#x27;
                           &#x27;orderItemDependencies);\n&#x27;
                           &#x27;        dependencies.put(&quot;BLC_ORDER_PAYMENT&quot;, &#x27;
                           &#x27;Collections.singletonList(new &#x27;
                           &#x27;DeleteStatementGeneratorImpl.PathElement(&quot;BLC_PAYMENT_LOG&quot;, &#x27;
                           &#x27;&quot;ORDER_PAYMENT_ID&quot;, &quot;ORDER_PAYMENT_ID&quot;)));\n&#x27;
                           &#x27;        &#x27;
                           &#x27;extensionManager.getProxy().addPurgeDependencies(dependencies);\n&#x27;
                           &#x27;        Set&lt;String&gt; exclusions = new HashSet&lt;&gt;();\n&#x27;
                           &#x27;        exclusions.add(&quot;BLC_ADMIN_USER&quot;);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;extensionManager.getProxy().addPurgeExclusions(exclusions);\n&#x27;
                           &#x27;        Map&lt;String, String&gt; deleteStatement = &#x27;
                           &#x27;deleteStatementGenerator.generateDeleteStatementsForType(OrderImpl.class, &#x27;
                           &#x27;&quot;?&quot;, dependencies, exclusions);\n&#x27;
                           &#x27;        for (Order order : oldOrders) {\n&#x27;
                           &#x27;            TransactionStatus status = &#x27;
                           &#x27;TransactionUtils.createTransaction(&quot;Cart Purge&quot;,\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;TransactionDefinition.PROPAGATION_REQUIRED, &#x27;
                           &#x27;transactionManager, false);\n&#x27;
                           &#x27;            try {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;em.unwrap(Session.class).doWork(new Work() {\n&#x27;
                           &#x27;                    @Override\n&#x27;
                           &#x27;                    public void execute(Connection &#x27;
                           &#x27;connection) throws SQLException {\n&#x27;
                           &#x27;                        Statement statement = &#x27;
                           &#x27;connection.createStatement();\n&#x27;
                           &#x27;                        for (String value : &#x27;
                           &#x27;deleteStatement.values()) {\n&#x27;
                           &#x27;                            String sql = &#x27;
                           &#x27;value.replace(&quot;?&quot;, &#x27;
                           &#x27;String.valueOf(order.getId()));\n&#x27;
                           &#x27;                            LOG.debug(sql);\n&#x27;
                           &#x27;                            &#x27;
                           &#x27;statement.addBatch(sql);\n&#x27;
                           &#x27;                        }\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;extensionManager.getProxy().addPurgeStatements(statement, &#x27;
                           &#x27;rootTypeIdValue);\n&#x27;
                           &#x27;                        statement.executeBatch();\n&#x27;
                           &#x27;                    }\n&#x27;
                           &#x27;                });\n&#x27;
                           &#x27;                &#x27;
                           &#x27;TransactionUtils.finalizeTransaction(status, &#x27;
                           &#x27;transactionManager, false);\n&#x27;
                           &#x27;            } catch (Exception e) {\n&#x27;
                           &#x27;                if (!status.isCompleted()) {\n&#x27;
                           &#x27;                    &#x27;
                           &#x27;TransactionUtils.finalizeTransaction(status, &#x27;
                           &#x27;transactionManager, true);\n&#x27;
                           &#x27;                }\n&#x27;
                           &#x27;                LOG.error(String.format(&quot;Not able &#x27;
                           &#x27;to purge Order ID: %d&quot;, order.getId()), e);\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;        LOG.info(&quot;Finished purging historical &#x27;
                           &#x27;orders.&quot;);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}}]]</pre>
          </body>
        </html>
        