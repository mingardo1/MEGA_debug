<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>352</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    352
                    <a href="351.html">prev</a>
                    <a href="353.html">next</a>
                    <a href="352_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_5d4ba5ed2f858c649144837dbbb37c70e0ed7f6b_core/src/main/java/com/dtstack/flink/sql/table/AbstractTableParser.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;5d4ba5ed2f858c649144837dbbb37c70e0ed7f6b:core/src/main/java/com/dtstack/flink/sql/table/AbstractTableParser.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;5d4ba5ed2f858c649144837dbbb37c70e0ed7f6b^1:core/src/main/java/com/dtstack/flink/sql/table/AbstractTableParser.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;5d4ba5ed2f858c649144837dbbb37c70e0ed7f6b^2:core/src/main/java/com/dtstack/flink/sql/table/AbstractTableParser.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;b929fcc7726accedaf499c8774e68cee1731c9a0:core/src/main/java/com/dtstack/flink/sql/table/AbstractTableParser.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 
  21 package com.dtstack.flink.sql.table;
  22 
  23 import com.dtstack.flink.sql.util.ClassUtil;
  24 import com.dtstack.flink.sql.util.DtStringUtil;
  25 import com.google.common.base.Preconditions;
  26 import com.google.common.collect.Lists;
  27 import com.google.common.collect.Maps;
  28 import org.apache.commons.lang3.StringUtils;
  29 
  30 import java.util.List;
  31 import java.util.Map;
  32 import java.util.regex.Matcher;
  33 import java.util.regex.Pattern;
  34 
  35 /**
  36  * Reason:
  37  * Date: 2018/7/4
  38  * Company: www.dtstack.com
  39  * @author xuchao
  40  */
  41 
  42 public abstract class AbstractTableParser {
  43 
  44     private static final String PRIMARY_KEY = &quot;primaryKey&quot;;
  45     private static final String NEST_JSON_FIELD_KEY = &quot;nestFieldKey&quot;;
  46     private static final String CHAR_TYPE_NO_LENGTH = &quot;CHAR&quot;;
  47 
  48     private static Pattern primaryKeyPattern = Pattern.compile(&quot;(?i)PRIMARY\\s+KEY\\s*\\((.*)\\)&quot;);
<abbr title="  49     private static Pattern nestJsonFieldKeyPattern = Pattern.compile(&quot;(?i)((@*\\S+\\.)*\\S+)\\s+(.+?)\\s+AS\\s+(\\w+)(\\s+NOT\\s+NULL)?$&quot;);">  49     private static Pattern nestJsonFieldKeyPattern = Pattern.compile(&quot;(?i)((@*\\S+\\.)*\\S+)\\s+(.+?)\\s+ðŸ”µ</abbr>
  50     private static Pattern physicalFieldFunPattern = Pattern.compile(&quot;\\w+\\((\\w+)\\)$&quot;);
  51     private static Pattern charTypePattern = Pattern.compile(&quot;(?i)CHAR\\((\\d*)\\)$&quot;);
  52 
  53     private Map&lt;String, Pattern&gt; patternMap = Maps.newHashMap();
  54 
  55     private Map&lt;String, ITableFieldDealHandler&gt; handlerMap = Maps.newHashMap();
  56 
  57     public AbstractTableParser() {
  58         addParserHandler(PRIMARY_KEY, primaryKeyPattern, this::dealPrimaryKey);
  59         addParserHandler(NEST_JSON_FIELD_KEY, nestJsonFieldKeyPattern, this::dealNestField);
  60     }
  61 
  62     protected boolean fieldNameNeedsUpperCase() {
  63         return true;
  64     }
  65 
<abbr title="  66     public abstract AbstractTableInfo getTableInfo(String tableName, String fieldsInfo, Map&lt;String, Object&gt; props) throws Exception;">  66     public abstract AbstractTableInfo getTableInfo(String tableName, String fieldsInfo, Map&lt;String, ObjecðŸ”µ</abbr>
  67 
  68     public boolean dealKeyPattern(String fieldRow, AbstractTableInfo tableInfo){
  69         for(Map.Entry&lt;String, Pattern&gt; keyPattern : patternMap.entrySet()){
  70             Pattern pattern = keyPattern.getValue();
  71             String key = keyPattern.getKey();
  72             Matcher matcher = pattern.matcher(fieldRow);
  73             if(matcher.find()){
  74                 ITableFieldDealHandler handler = handlerMap.get(key);
  75                 if(handler == null){
  76                     throw new RuntimeException(&quot;parse field [&quot; + fieldRow + &quot;] error.&quot;);
  77                 }
  78 
  79                 handler.dealPrimaryKey(matcher, tableInfo);
  80                 return true;
  81             }
  82         }
  83 
  84         return false;
  85     }
  86 
  87     public void parseFieldsInfo(String fieldsInfo, AbstractTableInfo tableInfo){
  88 
  89 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  90         List&lt;String&gt; fieldRows = DtStringUtil.splitIgnoreQuota(fieldsInfo, &#x27;,&#x27;);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  91         for(String fieldRow : fieldRows){</span>
  92 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  93         List&lt;String&gt; fieldRows = DtStringUtil.splitIgnoreQuota(fieldsInfo, &#x27;,&#x27;);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  94 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  95         for (String fieldRow : fieldRows) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  96             fieldRow = fieldRow.trim();</span>
  97 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  98         List&lt;String&gt; fieldRows = DtStringUtil.splitField(fieldsInfo);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  99 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 100         for (String fieldRow : fieldRows) {</span>
 101 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 102             fieldRow = fieldRow.trim();
 103 
 104             if(StringUtils.isBlank(fieldRow)){
<abbr title=" 105                 throw new RuntimeException(String.format(&quot;table [%s],exists field empty.&quot;, tableInfo.getName()));"> 105                 throw new RuntimeException(String.format(&quot;table [%s],exists field empty.&quot;, tableInfo.getNðŸ”µ</abbr>
 106             }
 107 
 108             String[] fieldInfoArr = fieldRow.split(&quot;\\s+&quot;);
 109 
<abbr title=" 110             String errorMsg = String.format(&quot;table [%s] field [%s] format error.&quot;, tableInfo.getName(), fieldRow);"> 110             String errorMsg = String.format(&quot;table [%s] field [%s] format error.&quot;, tableInfo.getName(), fðŸ”µ</abbr>
 111             Preconditions.checkState(fieldInfoArr.length &gt;= 2, errorMsg);
 112 
 113             boolean isMatcherKey = dealKeyPattern(fieldRow, tableInfo);
 114             if (isMatcherKey) {
 115                 continue;
 116             }
 117 
 118             //Compatible situation may arise in space in the fieldName
 119             String[] filedNameArr = new String[fieldInfoArr.length - 1];
 120             System.arraycopy(fieldInfoArr, 0, filedNameArr, 0, fieldInfoArr.length - 1);
 121             String fieldName = String.join(&quot; &quot;, filedNameArr);
 122             String fieldType = fieldInfoArr[fieldInfoArr.length - 1 ].trim();
 123 
 124             Class fieldClass = null;
 125             AbstractTableInfo.FieldExtraInfo fieldExtraInfo = null;
 126 
 127             Matcher matcher = charTypePattern.matcher(fieldType);
 128             if (matcher.find()) {
 129                 fieldClass = dbTypeConvertToJavaType(CHAR_TYPE_NO_LENGTH);
 130                 fieldExtraInfo = new AbstractTableInfo.FieldExtraInfo();
 131                 fieldExtraInfo.setLength(Integer.valueOf(matcher.group(1)));
 132             } else {
 133                 fieldClass = dbTypeConvertToJavaType(fieldType);
 134             }
 135 
 136             tableInfo.addPhysicalMappings(fieldInfoArr[0], fieldInfoArr[0]);
 137             tableInfo.addField(fieldName);
 138             tableInfo.addFieldClass(fieldClass);
 139             tableInfo.addFieldType(fieldType);
 140             tableInfo.addFieldExtraInfo(fieldExtraInfo);
 141         }
 142 
 143         tableInfo.finish();
 144     }
 145 
 146     public void dealPrimaryKey(Matcher matcher, AbstractTableInfo tableInfo){
 147         String primaryFields = matcher.group(1).trim();
 148         String[] splitArry = primaryFields.split(&quot;,&quot;);
 149         List&lt;String&gt; primaryKes = Lists.newArrayList(splitArry);
 150         tableInfo.setPrimaryKeys(primaryKes);
 151     }
 152 
 153     /**
 154      * add parser for alias field
 155      * @param matcher
 156      * @param tableInfo
 157      */
 158     protected void dealNestField(Matcher matcher, AbstractTableInfo tableInfo) {
 159         String physicalField = matcher.group(1);
 160         Preconditions.checkArgument(!physicalFieldFunPattern.matcher(physicalField).find(),
<abbr title=" 161                 &quot;No need to add data types when using functions, The correct way is : strLen(name) as nameSize, &quot;);"> 161                 &quot;No need to add data types when using functions, The correct way is : strLen(name) as namðŸ”µ</abbr>
 162 
 163         String fieldType = matcher.group(3);
 164         String mappingField = matcher.group(4);
 165         Class fieldClass = dbTypeConvertToJavaType(fieldType);
 166         boolean notNull = matcher.group(5) != null;
 167         AbstractTableInfo.FieldExtraInfo fieldExtraInfo = new AbstractTableInfo.FieldExtraInfo();
 168         fieldExtraInfo.setNotNull(notNull);
 169 
 170         tableInfo.addPhysicalMappings(mappingField, physicalField);
 171         tableInfo.addField(mappingField);
 172         tableInfo.addFieldClass(fieldClass);
 173         tableInfo.addFieldType(fieldType);
 174         tableInfo.addFieldExtraInfo(fieldExtraInfo);
 175     }
 176 
 177     public Class dbTypeConvertToJavaType(String fieldType) {
 178         return ClassUtil.stringConvertClass(fieldType);
 179     }
 180 
 181     protected void addParserHandler(String parserName, Pattern pattern, ITableFieldDealHandler handler) {
 182         patternMap.put(parserName, pattern);
 183         handlerMap.put(parserName, handler);
 184     }
 185 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.dtstack.flink.sql.table;
  20 
  21 import com.dtstack.flink.sql.util.ClassUtil;
  22 import com.dtstack.flink.sql.util.DtStringUtil;
  23 import com.google.common.base.Preconditions;
  24 import com.google.common.collect.Lists;
  25 import com.google.common.collect.Maps;
  26 import org.apache.commons.lang3.StringUtils;
  27 
  28 import java.util.List;
  29 import java.util.Map;
  30 import java.util.regex.Matcher;
  31 import java.util.regex.Pattern;
  32 
  33 /**
  34  * Reason:
  35  * Date: 2018/7/4
  36  * Company: www.dtstack.com
  37  * @author xuchao
  38  */
  39 
  40 public abstract class AbstractTableParser {
  41 
  42     private static final String PRIMARY_KEY = &quot;primaryKey&quot;;
  43     private static final String NEST_JSON_FIELD_KEY = &quot;nestFieldKey&quot;;
  44     private static final String CHAR_TYPE_NO_LENGTH = &quot;CHAR&quot;;
  45 
  46     private static Pattern primaryKeyPattern = Pattern.compile(&quot;(?i)PRIMARY\\s+KEY\\s*\\((.*)\\)&quot;);
<abbr title="  47     private static Pattern nestJsonFieldKeyPattern = Pattern.compile(&quot;(?i)((@*\\S+\\.)*\\S+)\\s+(.+?)\\s+AS\\s+(\\w+)(\\s+NOT\\s+NULL)?$&quot;);">  47     private static Pattern nestJsonFieldKeyPattern = Pattern.compile(&quot;(?i)((@*\\S+\\.)*\\S+)\\s+(.+?)\\s+ðŸ”µ</abbr>
  48     private static Pattern physicalFieldFunPattern = Pattern.compile(&quot;\\w+\\((\\w+)\\)$&quot;);
  49     private static Pattern charTypePattern = Pattern.compile(&quot;(?i)CHAR\\((\\d*)\\)$&quot;);
  50 
  51     private Map&lt;String, Pattern&gt; patternMap = Maps.newHashMap();
  52 
  53     private Map&lt;String, ITableFieldDealHandler&gt; handlerMap = Maps.newHashMap();
  54 
  55     public AbstractTableParser() {
  56         addParserHandler(PRIMARY_KEY, primaryKeyPattern, this::dealPrimaryKey);
  57         addParserHandler(NEST_JSON_FIELD_KEY, nestJsonFieldKeyPattern, this::dealNestField);
  58     }
  59 
  60     protected boolean fieldNameNeedsUpperCase() {
  61         return true;
  62     }
  63 
<abbr title="  64     public abstract AbstractTableInfo getTableInfo(String tableName, String fieldsInfo, Map&lt;String, Object&gt; props) throws Exception;">  64     public abstract AbstractTableInfo getTableInfo(String tableName, String fieldsInfo, Map&lt;String, ObjecðŸ”µ</abbr>
  65 
  66     public boolean dealKeyPattern(String fieldRow, AbstractTableInfo tableInfo){
  67         for(Map.Entry&lt;String, Pattern&gt; keyPattern : patternMap.entrySet()){
  68             Pattern pattern = keyPattern.getValue();
  69             String key = keyPattern.getKey();
  70             Matcher matcher = pattern.matcher(fieldRow);
  71             if(matcher.find()){
  72                 ITableFieldDealHandler handler = handlerMap.get(key);
  73                 if(handler == null){
  74                     throw new RuntimeException(&quot;parse field [&quot; + fieldRow + &quot;] error.&quot;);
  75                 }
  76 
  77                 handler.dealPrimaryKey(matcher, tableInfo);
  78                 return true;
  79             }
  80         }
  81 
  82         return false;
  83     }
  84 
  85     public void parseFieldsInfo(String fieldsInfo, AbstractTableInfo tableInfo) {
  86 
  87         List&lt;String&gt; fieldRows = DtStringUtil.splitField(fieldsInfo);
  88 
  89         for (String fieldRow : fieldRows) {
  90             fieldRow = fieldRow.trim();
  91 
  92             if (StringUtils.isBlank(fieldRow)) {
<abbr title="  93                 throw new RuntimeException(String.format(&quot;table [%s],exists field empty.&quot;, tableInfo.getName()));">  93                 throw new RuntimeException(String.format(&quot;table [%s],exists field empty.&quot;, tableInfo.getNðŸ”µ</abbr>
  94             }
  95 
  96             String[] fieldInfoArr = fieldRow.split(&quot;\\s+&quot;);
  97 
<abbr title="  98             String errorMsg = String.format(&quot;table [%s] field [%s] format error.&quot;, tableInfo.getName(), fieldRow);">  98             String errorMsg = String.format(&quot;table [%s] field [%s] format error.&quot;, tableInfo.getName(), fðŸ”µ</abbr>
  99             Preconditions.checkState(fieldInfoArr.length &gt;= 2, errorMsg);
 100 
 101             boolean isMatcherKey = dealKeyPattern(fieldRow, tableInfo);
 102             if (isMatcherKey) {
 103                 continue;
 104             }
 105 
 106             //Compatible situation may arise in space in the fieldName
 107             String[] filedNameArr = new String[fieldInfoArr.length - 1];
 108             System.arraycopy(fieldInfoArr, 0, filedNameArr, 0, fieldInfoArr.length - 1);
 109             String fieldName = String.join(&quot; &quot;, filedNameArr);
 110             String fieldType = fieldInfoArr[fieldInfoArr.length - 1 ].trim();
 111 
 112             Class fieldClass = null;
 113             AbstractTableInfo.FieldExtraInfo fieldExtraInfo = null;
 114 
 115             Matcher matcher = charTypePattern.matcher(fieldType);
 116             if (matcher.find()) {
 117                 fieldClass = dbTypeConvertToJavaType(CHAR_TYPE_NO_LENGTH);
 118                 fieldExtraInfo = new AbstractTableInfo.FieldExtraInfo();
 119                 fieldExtraInfo.setLength(Integer.valueOf(matcher.group(1)));
 120             } else {
 121                 fieldClass = dbTypeConvertToJavaType(fieldType);
 122             }
 123 
 124             tableInfo.addPhysicalMappings(fieldInfoArr[0], fieldInfoArr[0]);
 125             tableInfo.addField(fieldName);
 126             tableInfo.addFieldClass(fieldClass);
 127             tableInfo.addFieldType(fieldType);
 128             tableInfo.addFieldExtraInfo(fieldExtraInfo);
 129         }
 130 
 131         tableInfo.finish();
 132     }
 133 
 134     public void dealPrimaryKey(Matcher matcher, AbstractTableInfo tableInfo) {
 135         String primaryFields = matcher.group(1).trim();
 136         String[] splitArry = primaryFields.split(&quot;,&quot;);
 137         List&lt;String&gt; primaryKes = Lists.newArrayList(splitArry);
 138         tableInfo.setPrimaryKeys(primaryKes);
 139     }
 140 
 141     /**
 142      * add parser for alias field
 143      * @param matcher
 144      * @param tableInfo
 145      */
 146     protected void dealNestField(Matcher matcher, AbstractTableInfo tableInfo) {
 147         String physicalField = matcher.group(1);
 148         Preconditions.checkArgument(!physicalFieldFunPattern.matcher(physicalField).find(),
<abbr title=" 149                 &quot;No need to add data types when using functions, The correct way is : strLen(name) as nameSize, &quot;);"> 149                 &quot;No need to add data types when using functions, The correct way is : strLen(name) as namðŸ”µ</abbr>
 150 
 151         String fieldType = matcher.group(3);
 152         String mappingField = matcher.group(4);
 153         Class fieldClass = dbTypeConvertToJavaType(fieldType);
 154         boolean notNull = matcher.group(5) != null;
 155         AbstractTableInfo.FieldExtraInfo fieldExtraInfo = new AbstractTableInfo.FieldExtraInfo();
 156         fieldExtraInfo.setNotNull(notNull);
 157 
 158         tableInfo.addPhysicalMappings(mappingField, physicalField);
 159         tableInfo.addField(mappingField);
 160         tableInfo.addFieldClass(fieldClass);
 161         tableInfo.addFieldType(fieldType);
 162         tableInfo.addFieldExtraInfo(fieldExtraInfo);
 163     }
 164 
 165     public Class dbTypeConvertToJavaType(String fieldType) {
 166         return ClassUtil.stringConvertClass(fieldType);
 167     }
 168 
 169     protected void addParserHandler(String parserName, Pattern pattern, ITableFieldDealHandler handler) {
 170         patternMap.put(parserName, pattern);
 171         handlerMap.put(parserName, handler);
 172     }
 173 
 174 }
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.table;
  19 
  20 import com.dtstack.flink.sql.util.ClassUtil;
  21 import com.dtstack.flink.sql.util.DtStringUtil;
  22 import com.google.common.base.Preconditions;
  23 import com.google.common.collect.Lists;
  24 import com.google.common.collect.Maps;
  25 import java.util.List;
  26 import java.util.Map;
  27 import java.util.regex.Matcher;
  28 import java.util.regex.Pattern;
  29 import org.apache.commons.lang3.StringUtils;
  30 
  31 
  32 /**
  33  * Reason:
  34  * Date: 2018/7/4
  35  * Company: www.dtstack.com
  36  * @author xuchao
  37  */
  38 public abstract class AbstractTableParser {
  39     private static final String PRIMARY_KEY = &quot;primaryKey&quot;;
  40 
  41     private static final String NEST_JSON_FIELD_KEY = &quot;nestFieldKey&quot;;
  42 
  43     private static final String CHAR_TYPE_NO_LENGTH = &quot;CHAR&quot;;
  44 
  45     private static Pattern primaryKeyPattern = Pattern.compile(&quot;(?i)PRIMARY\\s+KEY\\s*\\((.*)\\)&quot;);
  46 
<abbr title="  47     private static Pattern nestJsonFieldKeyPattern = Pattern.compile(&quot;(?i)((@*\\S+\\.)*\\S+)\\s+(.+?)\\s+AS\\s+(\\w+)(\\s+NOT\\s+NULL)?$&quot;);">  47     private static Pattern nestJsonFieldKeyPattern = Pattern.compile(&quot;(?i)((@*\\S+\\.)*\\S+)\\s+(.+?)\\s+ðŸ”µ</abbr>
  48 
  49     private static Pattern physicalFieldFunPattern = Pattern.compile(&quot;\\w+\\((\\w+)\\)$&quot;);
  50 
  51     private static Pattern charTypePattern = Pattern.compile(&quot;(?i)CHAR\\((\\d*)\\)$&quot;);
  52 
  53     private Map&lt;String, Pattern&gt; patternMap = Maps.newHashMap();
  54 
  55     private Map&lt;String, ITableFieldDealHandler&gt; handlerMap = Maps.newHashMap();
  56 
  57     public AbstractTableParser() {
  58         addParserHandler(PRIMARY_KEY, primaryKeyPattern, this::dealPrimaryKey);
  59         addParserHandler(NEST_JSON_FIELD_KEY, nestJsonFieldKeyPattern, this::dealNestField);
  60     }
  61 
  62     protected boolean fieldNameNeedsUpperCase() {
  63         return true;
  64     }
  65 
<abbr title="  66     public abstract AbstractTableInfo getTableInfo(String tableName, String fieldsInfo, Map&lt;String, Object&gt; props) throws Exception;">  66     public abstract AbstractTableInfo getTableInfo(String tableName, String fieldsInfo, Map&lt;String, ObjecðŸ”µ</abbr>
  67 
  68     public boolean dealKeyPattern(String fieldRow, AbstractTableInfo tableInfo){
  69         for(Map.Entry&lt;String, Pattern&gt; keyPattern : patternMap.entrySet()){
  70             Pattern pattern = keyPattern.getValue();
  71             String key = keyPattern.getKey();
  72             Matcher matcher = pattern.matcher(fieldRow);
  73             if(matcher.find()){
  74                 ITableFieldDealHandler handler = handlerMap.get(key);
  75                 if(handler == null){
  76                     throw new RuntimeException(&quot;parse field [&quot; + fieldRow + &quot;] error.&quot;);
  77                 }
  78 
  79                 handler.dealPrimaryKey(matcher, tableInfo);
  80                 return true;
  81             }
  82         }
  83 
  84         return false;
  85     }
  86 
  87     public void parseFieldsInfo(String fieldsInfo, AbstractTableInfo tableInfo) {
  88         List&lt;String&gt; fieldRows = DtStringUtil.splitField(fieldsInfo);
  89         for (String fieldRow : fieldRows) {
  90             fieldRow = fieldRow.trim();
  91             if (StringUtils.isBlank(fieldRow)) {
<abbr title="  92                 throw new RuntimeException(String.format(&quot;table [%s],exists field empty.&quot;, tableInfo.getName()));">  92                 throw new RuntimeException(String.format(&quot;table [%s],exists field empty.&quot;, tableInfo.getNðŸ”µ</abbr>
  93             }
  94             String[] fieldInfoArr = fieldRow.split(&quot;\\s+&quot;);
<abbr title="  95             String errorMsg = String.format(&quot;table [%s] field [%s] format error.&quot;, tableInfo.getName(), fieldRow);">  95             String errorMsg = String.format(&quot;table [%s] field [%s] format error.&quot;, tableInfo.getName(), fðŸ”µ</abbr>
  96             Preconditions.checkState(fieldInfoArr.length &gt;= 2, errorMsg);
  97             boolean isMatcherKey = dealKeyPattern(fieldRow, tableInfo);
  98             if (isMatcherKey) {
  99                 continue;
 100             }
 101             // Compatible situation may arise in space in the fieldName
 102             String[] filedNameArr = new String[fieldInfoArr.length - 1];
 103             System.arraycopy(fieldInfoArr, 0, filedNameArr, 0, fieldInfoArr.length - 1);
 104             String fieldName = String.join(&quot; &quot;, filedNameArr);
 105             String fieldType = fieldInfoArr[fieldInfoArr.length - 1].trim();
 106             Class fieldClass = null;
 107             AbstractTableInfo.FieldExtraInfo fieldExtraInfo = null;
 108             Matcher matcher = charTypePattern.matcher(fieldType);
 109             if (matcher.find()) {
 110                 fieldClass = dbTypeConvertToJavaType(CHAR_TYPE_NO_LENGTH);
 111                 fieldExtraInfo = new AbstractTableInfo.FieldExtraInfo();
 112                 fieldExtraInfo.setLength(Integer.valueOf(matcher.group(1)));
 113             } else {
 114                 fieldClass = dbTypeConvertToJavaType(fieldType);
 115             }
 116             tableInfo.addPhysicalMappings(fieldInfoArr[0], fieldInfoArr[0]);
 117             tableInfo.addField(fieldName);
 118             tableInfo.addFieldClass(fieldClass);
 119             tableInfo.addFieldType(fieldType);
 120             tableInfo.addFieldExtraInfo(fieldExtraInfo);
 121         }
 122         tableInfo.finish();
 123     }
 124 
 125     public void dealPrimaryKey(Matcher matcher, AbstractTableInfo tableInfo) {
 126         String primaryFields = matcher.group(1).trim();
 127         String[] splitArry = primaryFields.split(&quot;,&quot;);
 128         List&lt;String&gt; primaryKes = Lists.newArrayList(splitArry);
 129         tableInfo.setPrimaryKeys(primaryKes);
 130     }
 131 
 132     /**
 133      * add parser for alias field
 134      * @param matcher
 135      * @param tableInfo
 136      */
 137     protected void dealNestField(Matcher matcher, AbstractTableInfo tableInfo) {
 138         String physicalField = matcher.group(1);
 139         Preconditions.checkArgument(!physicalFieldFunPattern.matcher(physicalField).find(),
<abbr title=" 140                 &quot;No need to add data types when using functions, The correct way is : strLen(name) as nameSize, &quot;);"> 140                 &quot;No need to add data types when using functions, The correct way is : strLen(name) as namðŸ”µ</abbr>
 141 
 142         String fieldType = matcher.group(3);
 143         String mappingField = matcher.group(4);
 144         Class fieldClass = dbTypeConvertToJavaType(fieldType);
 145         boolean notNull = matcher.group(5) != null;
 146         AbstractTableInfo.FieldExtraInfo fieldExtraInfo = new AbstractTableInfo.FieldExtraInfo();
 147         fieldExtraInfo.setNotNull(notNull);
 148 
 149         tableInfo.addPhysicalMappings(mappingField, physicalField);
 150         tableInfo.addField(mappingField);
 151         tableInfo.addFieldClass(fieldClass);
 152         tableInfo.addFieldType(fieldType);
 153         tableInfo.addFieldExtraInfo(fieldExtraInfo);
 154     }
 155 
 156     public Class dbTypeConvertToJavaType(String fieldType) {
 157         return ClassUtil.stringConvertClass(fieldType);
 158     }
 159 
 160     protected void addParserHandler(String parserName, Pattern pattern, ITableFieldDealHandler handler) {
 161         patternMap.put(parserName, pattern);
 162         handlerMap.put(parserName, handler);
 163     }
 164 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  18 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  19 +</span>
  20  
  21  package com.dtstack.flink.sql.table;
  22  
  23  import com.dtstack.flink.sql.util.ClassUtil;
  24  import com.dtstack.flink.sql.util.DtStringUtil;
  25  import com.google.common.base.Preconditions;
  26  import com.google.common.collect.Lists;
  27  import com.google.common.collect.Maps;
  28  import org.apache.commons.lang3.StringUtils;
  29  
  30  import java.util.List;
  31  import java.util.Map;
  32  import java.util.regex.Matcher;
  33  import java.util.regex.Pattern;
  34  
  35  /**
  36   * Reason:
  37   * Date: 2018/7/4
  38   * Company: www.dtstack.com
  39   * @author xuchao
  40   */
  41  
  42  public abstract class AbstractTableParser {
  43  
  44      private static final String PRIMARY_KEY = &quot;primaryKey&quot;;
  45      private static final String NEST_JSON_FIELD_KEY = &quot;nestFieldKey&quot;;
  46      private static final String CHAR_TYPE_NO_LENGTH = &quot;CHAR&quot;;
  47  
  48      private static Pattern primaryKeyPattern = Pattern.compile(&quot;(?i)PRIMARY\\s+KEY\\s*\\((.*)\\)&quot;);
<abbr title="  49      private static Pattern nestJsonFieldKeyPattern = Pattern.compile(&quot;(?i)((@*\\S+\\.)*\\S+)\\s+(.+)\\s+AS\\s+(\\w+)(\\s+NOT\\s+NULL)?$&quot;);">  49      private static Pattern nestJsonFieldKeyPattern = Pattern.compile(&quot;(?i)((@*\\S+\\.)*\\S+)\\s+(.+)\\s+AS\\s+(\\wðŸ”µ</abbr>

  50      private static Pattern physicalFieldFunPattern = Pattern.compile(&quot;\\w+\\((\\w+)\\)$&quot;);
  51      private static Pattern charTypePattern = Pattern.compile(&quot;(?i)CHAR\\((\\d*)\\)$&quot;);
  52  
  53      private Map&lt;String, Pattern&gt; patternMap = Maps.newHashMap();
  54  
  55      private Map&lt;String, ITableFieldDealHandler&gt; handlerMap = Maps.newHashMap();
  56  
  57      public AbstractTableParser() {
  58          addParserHandler(PRIMARY_KEY, primaryKeyPattern, this::dealPrimaryKey);
  59          addParserHandler(NEST_JSON_FIELD_KEY, nestJsonFieldKeyPattern, this::dealNestField);
  60      }
  61  
  62      protected boolean fieldNameNeedsUpperCase() {
  63          return true;
  64      }
  65  
<abbr title="  66      public abstract AbstractTableInfo getTableInfo(String tableName, String fieldsInfo, Map&lt;String, Object&gt; props) throws Exception;">  66      public abstract AbstractTableInfo getTableInfo(String tableName, String fieldsInfo, Map&lt;String, Object&gt; props)ðŸ”µ</abbr>
  67  
  68      public boolean dealKeyPattern(String fieldRow, AbstractTableInfo tableInfo){
  69          for(Map.Entry&lt;String, Pattern&gt; keyPattern : patternMap.entrySet()){
  70              Pattern pattern = keyPattern.getValue();
  71              String key = keyPattern.getKey();
  72              Matcher matcher = pattern.matcher(fieldRow);
  73              if(matcher.find()){
  74                  ITableFieldDealHandler handler = handlerMap.get(key);
  75                  if(handler == null){
  76                      throw new RuntimeException(&quot;parse field [&quot; + fieldRow + &quot;] error.&quot;);
  77                  }
  78  
  79                  handler.dealPrimaryKey(matcher, tableInfo);
  80                  return true;
  81              }
  82          }
  83  
  84          return false;
  85      }
  86  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  87 -    public void parseFieldsInfo(String fieldsInfo, AbstractTableInfo tableInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  88 +    public void parseFieldsInfo(String fieldsInfo, AbstractTableInfo tableInfo){</span>
  89  
  90          List&lt;String&gt; fieldRows = DtStringUtil.splitIgnoreQuota(fieldsInfo, &#x27;,&#x27;);

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  91 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  92 -        for (String fieldRow : fieldRows) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +        for(String fieldRow : fieldRows){</span>
  94              fieldRow = fieldRow.trim();
  95  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  96 -            if (StringUtils.isBlank(fieldRow)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  97 +            if(StringUtils.isBlank(fieldRow)){</span>
  98                  throw new RuntimeException(String.format(&quot;table [%s],exists field empty.&quot;, tableInfo.getName()));
  99              }
 100  
 101              String[] fieldInfoArr = fieldRow.split(&quot;\\s+&quot;);
 102  
 103              String errorMsg = String.format(&quot;table [%s] field [%s] format error.&quot;, tableInfo.getName(), fieldRow);
 104              Preconditions.checkState(fieldInfoArr.length &gt;= 2, errorMsg);
 105  
 106              boolean isMatcherKey = dealKeyPattern(fieldRow, tableInfo);
 107              if (isMatcherKey) {
 108                  continue;
 109              }
 110  
 111              //Compatible situation may arise in space in the fieldName
 112              String[] filedNameArr = new String[fieldInfoArr.length - 1];
 113              System.arraycopy(fieldInfoArr, 0, filedNameArr, 0, fieldInfoArr.length - 1);
 114              String fieldName = String.join(&quot; &quot;, filedNameArr);
 115              String fieldType = fieldInfoArr[fieldInfoArr.length - 1 ].trim();
 116  
 117              Class fieldClass = null;
 118              AbstractTableInfo.FieldExtraInfo fieldExtraInfo = null;
 119  
 120              Matcher matcher = charTypePattern.matcher(fieldType);
 121              if (matcher.find()) {
 122                  fieldClass = dbTypeConvertToJavaType(CHAR_TYPE_NO_LENGTH);
 123                  fieldExtraInfo = new AbstractTableInfo.FieldExtraInfo();
 124                  fieldExtraInfo.setLength(Integer.valueOf(matcher.group(1)));
 125              } else {
 126                  fieldClass = dbTypeConvertToJavaType(fieldType);
 127              }
 128  
 129              tableInfo.addPhysicalMappings(fieldInfoArr[0], fieldInfoArr[0]);
 130              tableInfo.addField(fieldName);
 131              tableInfo.addFieldClass(fieldClass);
 132              tableInfo.addFieldType(fieldType);
 133              tableInfo.addFieldExtraInfo(fieldExtraInfo);
 134          }
 135  
 136          tableInfo.finish();
 137      }
 138  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 139 -    public void dealPrimaryKey(Matcher matcher, AbstractTableInfo tableInfo) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 140 +    public void dealPrimaryKey(Matcher matcher, AbstractTableInfo tableInfo){</span>
 141          String primaryFields = matcher.group(1).trim();
 142          String[] splitArry = primaryFields.split(&quot;,&quot;);
 143          List&lt;String&gt; primaryKes = Lists.newArrayList(splitArry);
 144          tableInfo.setPrimaryKeys(primaryKes);
 145      }
 146  
 147      /**
 148       * add parser for alias field
 149       * @param matcher
 150       * @param tableInfo
 151       */
 152      protected void dealNestField(Matcher matcher, AbstractTableInfo tableInfo) {
 153          String physicalField = matcher.group(1);
 154          Preconditions.checkArgument(!physicalFieldFunPattern.matcher(physicalField).find(),
<abbr title=" 155                  &quot;No need to add data types when using functions, The correct way is : strLen(name) as nameSize, &quot;);"> 155                  &quot;No need to add data types when using functions, The correct way is : strLen(name) as nameSize, &quot;)ðŸ”µ</abbr>
 156  
 157          String fieldType = matcher.group(3);
 158          String mappingField = matcher.group(4);
 159          Class fieldClass = dbTypeConvertToJavaType(fieldType);
 160          boolean notNull = matcher.group(5) != null;
 161          AbstractTableInfo.FieldExtraInfo fieldExtraInfo = new AbstractTableInfo.FieldExtraInfo();
 162          fieldExtraInfo.setNotNull(notNull);
 163  
 164          tableInfo.addPhysicalMappings(mappingField, physicalField);
 165          tableInfo.addField(mappingField);
 166          tableInfo.addFieldClass(fieldClass);
 167          tableInfo.addFieldType(fieldType);
 168          tableInfo.addFieldExtraInfo(fieldExtraInfo);
 169      }
 170  
 171      public Class dbTypeConvertToJavaType(String fieldType) {
 172          return ClassUtil.stringConvertClass(fieldType);
 173      }
 174  
 175      protected void addParserHandler(String parserName, Pattern pattern, ITableFieldDealHandler handler) {
 176          patternMap.put(parserName, pattern);
 177          handlerMap.put(parserName, handler);
 178      }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 179 -</span>
 180  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */


  18  
  19  package com.dtstack.flink.sql.table;
  20  
  21  import com.dtstack.flink.sql.util.ClassUtil;
  22  import com.dtstack.flink.sql.util.DtStringUtil;
  23  import com.google.common.base.Preconditions;
  24  import com.google.common.collect.Lists;
  25  import com.google.common.collect.Maps;
  26  import org.apache.commons.lang3.StringUtils;
  27  
  28  import java.util.List;
  29  import java.util.Map;
  30  import java.util.regex.Matcher;
  31  import java.util.regex.Pattern;
  32  
  33  /**
  34   * Reason:
  35   * Date: 2018/7/4
  36   * Company: www.dtstack.com
  37   * @author xuchao
  38   */
  39  
  40  public abstract class AbstractTableParser {
  41  
  42      private static final String PRIMARY_KEY = &quot;primaryKey&quot;;
  43      private static final String NEST_JSON_FIELD_KEY = &quot;nestFieldKey&quot;;
  44      private static final String CHAR_TYPE_NO_LENGTH = &quot;CHAR&quot;;
  45  
  46      private static Pattern primaryKeyPattern = Pattern.compile(&quot;(?i)PRIMARY\\s+KEY\\s*\\((.*)\\)&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"><abbr title="  47 -    private static Pattern nestJsonFieldKeyPattern = Pattern.compile(&quot;(?i)((@*\\S+\\.)*\\S+)\\s+(.+)\\s+AS\\s+(\\w+)(\\s+NOT\\s+NULL)?$&quot;);">  47 -    private static Pattern nestJsonFieldKeyPattern = Pattern.compile(&quot;(?i)((@*\\S+\\.)*\\S+)\\s+(.+)\\s+AS\\s+(\\wðŸ”µ</abbr></span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"><abbr title="  48 +    private static Pattern nestJsonFieldKeyPattern = Pattern.compile(&quot;(?i)((@*\\S+\\.)*\\S+)\\s+(.+?)\\s+AS\\s+(\\w+)(\\s+NOT\\s+NULL)?$&quot;);">  48 +    private static Pattern nestJsonFieldKeyPattern = Pattern.compile(&quot;(?i)((@*\\S+\\.)*\\S+)\\s+(.+?)\\s+AS\\s+(\\ðŸ”µ</abbr></span>
  49      private static Pattern physicalFieldFunPattern = Pattern.compile(&quot;\\w+\\((\\w+)\\)$&quot;);
  50      private static Pattern charTypePattern = Pattern.compile(&quot;(?i)CHAR\\((\\d*)\\)$&quot;);
  51  
  52      private Map&lt;String, Pattern&gt; patternMap = Maps.newHashMap();
  53  
  54      private Map&lt;String, ITableFieldDealHandler&gt; handlerMap = Maps.newHashMap();
  55  
  56      public AbstractTableParser() {
  57          addParserHandler(PRIMARY_KEY, primaryKeyPattern, this::dealPrimaryKey);
  58          addParserHandler(NEST_JSON_FIELD_KEY, nestJsonFieldKeyPattern, this::dealNestField);
  59      }
  60  
  61      protected boolean fieldNameNeedsUpperCase() {
  62          return true;
  63      }
  64  
<abbr title="  65      public abstract AbstractTableInfo getTableInfo(String tableName, String fieldsInfo, Map&lt;String, Object&gt; props) throws Exception;">  65      public abstract AbstractTableInfo getTableInfo(String tableName, String fieldsInfo, Map&lt;String, Object&gt; props)ðŸ”µ</abbr>
  66  
  67      public boolean dealKeyPattern(String fieldRow, AbstractTableInfo tableInfo){
  68          for(Map.Entry&lt;String, Pattern&gt; keyPattern : patternMap.entrySet()){
  69              Pattern pattern = keyPattern.getValue();
  70              String key = keyPattern.getKey();
  71              Matcher matcher = pattern.matcher(fieldRow);
  72              if(matcher.find()){
  73                  ITableFieldDealHandler handler = handlerMap.get(key);
  74                  if(handler == null){
  75                      throw new RuntimeException(&quot;parse field [&quot; + fieldRow + &quot;] error.&quot;);
  76                  }
  77  
  78                  handler.dealPrimaryKey(matcher, tableInfo);
  79                  return true;
  80              }
  81          }
  82  
  83          return false;
  84      }
  85  
  86      public void parseFieldsInfo(String fieldsInfo, AbstractTableInfo tableInfo) {

  87  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  88 -        List&lt;String&gt; fieldRows = DtStringUtil.splitIgnoreQuota(fieldsInfo, &#x27;,&#x27;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  89 +        List&lt;String&gt; fieldRows = DtStringUtil.splitField(fieldsInfo);</span>
  90  
  91          for (String fieldRow : fieldRows) {

  92              fieldRow = fieldRow.trim();
  93  
  94              if (StringUtils.isBlank(fieldRow)) {

  95                  throw new RuntimeException(String.format(&quot;table [%s],exists field empty.&quot;, tableInfo.getName()));
  96              }
  97  
  98              String[] fieldInfoArr = fieldRow.split(&quot;\\s+&quot;);
  99  
 100              String errorMsg = String.format(&quot;table [%s] field [%s] format error.&quot;, tableInfo.getName(), fieldRow);
 101              Preconditions.checkState(fieldInfoArr.length &gt;= 2, errorMsg);
 102  
 103              boolean isMatcherKey = dealKeyPattern(fieldRow, tableInfo);
 104              if (isMatcherKey) {
 105                  continue;
 106              }
 107  
 108              //Compatible situation may arise in space in the fieldName
 109              String[] filedNameArr = new String[fieldInfoArr.length - 1];
 110              System.arraycopy(fieldInfoArr, 0, filedNameArr, 0, fieldInfoArr.length - 1);
 111              String fieldName = String.join(&quot; &quot;, filedNameArr);
 112              String fieldType = fieldInfoArr[fieldInfoArr.length - 1 ].trim();
 113  
 114              Class fieldClass = null;
 115              AbstractTableInfo.FieldExtraInfo fieldExtraInfo = null;
 116  
 117              Matcher matcher = charTypePattern.matcher(fieldType);
 118              if (matcher.find()) {
 119                  fieldClass = dbTypeConvertToJavaType(CHAR_TYPE_NO_LENGTH);
 120                  fieldExtraInfo = new AbstractTableInfo.FieldExtraInfo();
 121                  fieldExtraInfo.setLength(Integer.valueOf(matcher.group(1)));
 122              } else {
 123                  fieldClass = dbTypeConvertToJavaType(fieldType);
 124              }
 125  
 126              tableInfo.addPhysicalMappings(fieldInfoArr[0], fieldInfoArr[0]);
 127              tableInfo.addField(fieldName);
 128              tableInfo.addFieldClass(fieldClass);
 129              tableInfo.addFieldType(fieldType);
 130              tableInfo.addFieldExtraInfo(fieldExtraInfo);
 131          }
 132  
 133          tableInfo.finish();
 134      }
 135  
 136      public void dealPrimaryKey(Matcher matcher, AbstractTableInfo tableInfo) {

 137          String primaryFields = matcher.group(1).trim();
 138          String[] splitArry = primaryFields.split(&quot;,&quot;);
 139          List&lt;String&gt; primaryKes = Lists.newArrayList(splitArry);
 140          tableInfo.setPrimaryKeys(primaryKes);
 141      }
 142  
 143      /**
 144       * add parser for alias field
 145       * @param matcher
 146       * @param tableInfo
 147       */
 148      protected void dealNestField(Matcher matcher, AbstractTableInfo tableInfo) {
 149          String physicalField = matcher.group(1);
 150          Preconditions.checkArgument(!physicalFieldFunPattern.matcher(physicalField).find(),
<abbr title=" 151                  &quot;No need to add data types when using functions, The correct way is : strLen(name) as nameSize, &quot;);"> 151                  &quot;No need to add data types when using functions, The correct way is : strLen(name) as nameSize, &quot;)ðŸ”µ</abbr>
 152  
 153          String fieldType = matcher.group(3);
 154          String mappingField = matcher.group(4);
 155          Class fieldClass = dbTypeConvertToJavaType(fieldType);
 156          boolean notNull = matcher.group(5) != null;
 157          AbstractTableInfo.FieldExtraInfo fieldExtraInfo = new AbstractTableInfo.FieldExtraInfo();
 158          fieldExtraInfo.setNotNull(notNull);
 159  
 160          tableInfo.addPhysicalMappings(mappingField, physicalField);
 161          tableInfo.addField(mappingField);
 162          tableInfo.addFieldClass(fieldClass);
 163          tableInfo.addFieldType(fieldType);
 164          tableInfo.addFieldExtraInfo(fieldExtraInfo);
 165      }
 166  
 167      public Class dbTypeConvertToJavaType(String fieldType) {
 168          return ClassUtil.stringConvertClass(fieldType);
 169      }
 170  
 171      protected void addParserHandler(String parserName, Pattern pattern, ITableFieldDealHandler handler) {
 172          patternMap.put(parserName, pattern);
 173          handlerMap.put(parserName, handler);
 174      }
 175  
 176  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            