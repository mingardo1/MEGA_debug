<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>2 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Copyright (C) 2016 &#x27;
                           &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                           &#x27;(the &quot;License&quot;);\n&#x27;
                           &#x27; * you may not use this file except in compliance &#x27;
                           &#x27;with the License.\n&#x27;
                           &#x27; * You may obtain a copy of the License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *      &#x27;
                           &#x27;http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package com.arialyy.aria.http;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.arialyy.aria.core.TaskRecord;\n&#x27;
                           &#x27;import com.arialyy.aria.core.ThreadRecord;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.common.AbsRecordHandlerAdapter;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.RecordHelper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.config.Configuration;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.IRecordHandler;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.wrapper.AbsTaskWrapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.wrapper.ITaskWrapper;\n&#x27;
                           &#x27;import com.arialyy.aria.util.RecordUtil;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * @Author lyy\n&#x27;
                           &#x27; * @Date 2019-09-23\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class HttpRecordAdapter extends &#x27;
                           &#x27;AbsRecordHandlerAdapter {\n&#x27;
                           &#x27;  public HttpRecordAdapter(AbsTaskWrapper wrapper) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;    super(wrapper);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void onPre() {\n&#x27;
                           &#x27;    super.onPre();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void &#x27;
                           &#x27;handlerTaskRecord(TaskRecord record) {\n&#x27;
                           &#x27;    RecordHelper helper = new &#x27;
                           &#x27;RecordHelper(getWrapper(), record);\n&#x27;
                           &#x27;    if (getWrapper().isSupportBP() &amp;&amp; &#x27;
                           &#x27;record.threadNum &gt; 1) {\n&#x27;
                           &#x27;      if (record.isBlock) {\n&#x27;
                           &#x27;        helper.handleBlockRecord();\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        helper.handleMultiRecord();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    } else if (!getWrapper().isSupportBP()) {\n&#x27;
                           &#x27;      helper.handleNoSupportBPRecord();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      helper.handleSingleThreadRecord();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override\n&#x27;
                           &#x27;  public ThreadRecord &#x27;
                           &#x27;createThreadRecord(TaskRecord record, int &#x27;
                           &#x27;threadId, long startL, long endL) {\n&#x27;
                           &#x27;    ThreadRecord tr;\n&#x27;
                           &#x27;    tr = new ThreadRecord();\n&#x27;
                           &#x27;    tr.taskKey = record.filePath;\n&#x27;
                           &#x27;    tr.threadId = threadId;\n&#x27;
                           &#x27;    tr.startLocation = startL;\n&#x27;
                           &#x27;    tr.isComplete = false;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    tr.threadType = getEntity().getTaskType();\n&#x27;
                           &#x27;    //最后一个线程的结束位置即为文件的总长度\n&#x27;
                           &#x27;    if (threadId == (record.threadNum - 1)) {\n&#x27;
                           &#x27;      endL = getEntity().getFileSize();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    tr.endLocation = endL;\n&#x27;
                           &#x27;    tr.blockLen = &#x27;
                           &#x27;RecordUtil.getBlockLen(getEntity().getFileSize(), &#x27;
                           &#x27;threadId, record.threadNum);\n&#x27;
                           &#x27;    return tr;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public TaskRecord createTaskRecord(int &#x27;
                           &#x27;threadNum) {\n&#x27;
                           &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                           &#x27;    record.fileName = getEntity().getFileName();\n&#x27;
                           &#x27;    record.filePath = getEntity().getFilePath();\n&#x27;
                           &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;    record.threadNum = threadNum;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int requestType = &#x27;
                           &#x27;getWrapper().getRequestType();\n&#x27;
                           &#x27;    if (requestType == ITaskWrapper.D_FTP || &#x27;
                           &#x27;requestType == ITaskWrapper.D_FTP_DIR\n&#x27;
                           &#x27;        || requestType == ITaskWrapper.D_HTTP || &#x27;
                           &#x27;requestType == ITaskWrapper.DG_HTTP) {\n&#x27;
                           &#x27;      record.isBlock = &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      record.isBlock = false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    record.taskType = getEntity().getTaskType();\n&#x27;
                           &#x27;    record.isGroupRecord = &#x27;
                           &#x27;getEntity().isGroupChild();\n&#x27;
                           &#x27;    if (record.isGroupRecord) {\n&#x27;
                           &#x27;      if (getEntity() instanceof DownloadEntity) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                           &#x27;getEntity()).getGroupHash();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    return record;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public int initTaskThreadNum() {\n&#x27;
                           &#x27;    int requestTpe = &#x27;
                           &#x27;getWrapper().getRequestType();\n&#x27;
                           &#x27;    if (requestTpe == ITaskWrapper.U_HTTP\n&#x27;
                           &#x27;        || (requestTpe == ITaskWrapper.D_HTTP &amp;&amp; &#x27;
                           &#x27;(!getWrapper().isSupportBP())\n&#x27;
                           &#x27;        || ((HttpTaskOption) &#x27;
                           &#x27;getWrapper().getTaskOption()).isChunked())) {\n&#x27;
                           &#x27;      return 1;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    int threadNum = &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.getThreadNum();\n&#x27;
                           &#x27;    return getEntity().getFileSize() &lt;= &#x27;
                           &#x27;IRecordHandler.SUB_LEN\n&#x27;
                           &#x27;        || getEntity().isGroupChild()\n&#x27;
                           &#x27;        || threadNum == 1\n&#x27;
                           &#x27;        ? 1\n&#x27;
                           &#x27;        : threadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Copyright (C) 2016 &#x27;
                           &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                           &#x27;(the &quot;License&quot;);\n&#x27;
                           &#x27; * you may not use this file except in compliance &#x27;
                           &#x27;with the License.\n&#x27;
                           &#x27; * You may obtain a copy of the License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *      &#x27;
                           &#x27;http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package com.arialyy.aria.http;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.arialyy.aria.core.TaskRecord;\n&#x27;
                           &#x27;import com.arialyy.aria.core.ThreadRecord;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.common.AbsRecordHandlerAdapter;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.RecordHelper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.config.Configuration;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.IRecordHandler;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.wrapper.AbsTaskWrapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.wrapper.ITaskWrapper;\n&#x27;
                           &#x27;import com.arialyy.aria.util.RecordUtil;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * @Author lyy\n&#x27;
                           &#x27; * @Date 2019-09-23\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class HttpRecordAdapter extends &#x27;
                           &#x27;AbsRecordHandlerAdapter {\n&#x27;
                           &#x27;  public HttpRecordAdapter(AbsTaskWrapper wrapper) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;    super(wrapper);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void onPre() {\n&#x27;
                           &#x27;    super.onPre();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void &#x27;
                           &#x27;handlerTaskRecord(TaskRecord record) {\n&#x27;
                           &#x27;    RecordHelper helper = new &#x27;
                           &#x27;RecordHelper(getWrapper(), record);\n&#x27;
                           &#x27;    if (getWrapper().isSupportBP() &amp;&amp; &#x27;
                           &#x27;record.threadNum &gt; 1) {\n&#x27;
                           &#x27;      if (record.isBlock) {\n&#x27;
                           &#x27;        helper.handleBlockRecord();\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        helper.handleMultiRecord();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    } else if (!getWrapper().isSupportBP()) {\n&#x27;
                           &#x27;      helper.handleNoSupportBPRecord();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      helper.handleSingleThreadRecord();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override\n&#x27;
                           &#x27;  public ThreadRecord &#x27;
                           &#x27;createThreadRecord(TaskRecord record, int &#x27;
                           &#x27;threadId, long startL, long endL) {\n&#x27;
                           &#x27;    ThreadRecord tr;\n&#x27;
                           &#x27;    tr = new ThreadRecord();\n&#x27;
                           &#x27;    tr.taskKey = record.filePath;\n&#x27;
                           &#x27;    tr.threadId = threadId;\n&#x27;
                           &#x27;    tr.startLocation = startL;\n&#x27;
                           &#x27;    tr.isComplete = false;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    tr.threadType = getEntity().getTaskType();\n&#x27;
                           &#x27;    //最后一个线程的结束位置即为文件的总长度\n&#x27;
                           &#x27;    if (threadId == (record.threadNum - 1)) {\n&#x27;
                           &#x27;      endL = getEntity().getFileSize();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    tr.endLocation = endL;\n&#x27;
                           &#x27;    tr.blockLen = &#x27;
                           &#x27;RecordUtil.getBlockLen(getEntity().getFileSize(), &#x27;
                           &#x27;threadId, record.threadNum);\n&#x27;
                           &#x27;    return tr;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public TaskRecord createTaskRecord(int &#x27;
                           &#x27;threadNum) {\n&#x27;
                           &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                           &#x27;    record.fileName = getEntity().getFileName();\n&#x27;
                           &#x27;    record.filePath = getEntity().getFilePath();\n&#x27;
                           &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;    record.threadNum = threadNum;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int requestType = &#x27;
                           &#x27;getWrapper().getRequestType();\n&#x27;
                           &#x27;    if (requestType == ITaskWrapper.D_FTP || &#x27;
                           &#x27;requestType == ITaskWrapper.D_FTP_DIR\n&#x27;
                           &#x27;        || requestType == ITaskWrapper.D_HTTP || &#x27;
                           &#x27;requestType == ITaskWrapper.DG_HTTP) {\n&#x27;
                           &#x27;      record.isBlock = &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      record.isBlock = false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    record.taskType = getEntity().getTaskType();\n&#x27;
                           &#x27;    record.isGroupRecord = &#x27;
                           &#x27;getEntity().isGroupChild();\n&#x27;
                           &#x27;    if (record.isGroupRecord) {\n&#x27;
                           &#x27;      if (getEntity() instanceof DownloadEntity) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                           &#x27;getEntity()).getGroupHash();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    return record;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public int initTaskThreadNum() {\n&#x27;
                           &#x27;    int requestTpe = &#x27;
                           &#x27;getWrapper().getRequestType();\n&#x27;
                           &#x27;    if (requestTpe == ITaskWrapper.U_HTTP\n&#x27;
                           &#x27;        || (requestTpe == ITaskWrapper.D_HTTP &amp;&amp; &#x27;
                           &#x27;(!getWrapper().isSupportBP())\n&#x27;
                           &#x27;        || ((HttpTaskOption) &#x27;
                           &#x27;getWrapper().getTaskOption()).isChunked())) {\n&#x27;
                           &#x27;      return 1;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    int threadNum = &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.getThreadNum();\n&#x27;
                           &#x27;    return getEntity().getFileSize() &lt;= &#x27;
                           &#x27;IRecordHandler.SUB_LEN\n&#x27;
                           &#x27;        || getEntity().isGroupChild()\n&#x27;
                           &#x27;        || threadNum == 1\n&#x27;
                           &#x27;        ? 1\n&#x27;
                           &#x27;        : threadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;/*\n&#x27;
                           &#x27; * Copyright (C) 2016 &#x27;
                           &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                           &#x27;(the &quot;License&quot;);\n&#x27;
                           &#x27; * you may not use this file except in compliance &#x27;
                           &#x27;with the License.\n&#x27;
                           &#x27; * You may obtain a copy of the License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *      &#x27;
                           &#x27;http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package com.arialyy.aria.http;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.arialyy.aria.core.TaskRecord;\n&#x27;
                           &#x27;import com.arialyy.aria.core.ThreadRecord;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.common.AbsRecordHandlerAdapter;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.RecordHelper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.config.Configuration;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.IRecordHandler;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.wrapper.AbsTaskWrapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.wrapper.ITaskWrapper;\n&#x27;
                           &#x27;import com.arialyy.aria.util.RecordUtil;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * @Author lyy\n&#x27;
                           &#x27; * @Date 2019-09-23\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class HttpRecordAdapter extends &#x27;
                           &#x27;AbsRecordHandlerAdapter {\n&#x27;
                           &#x27;  public HttpRecordAdapter(AbsTaskWrapper wrapper) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;    super(wrapper);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void onPre() {\n&#x27;
                           &#x27;    super.onPre();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void &#x27;
                           &#x27;handlerTaskRecord(TaskRecord record) {\n&#x27;
                           &#x27;    RecordHelper helper = new &#x27;
                           &#x27;RecordHelper(getWrapper(), record);\n&#x27;
                           &#x27;    if (getWrapper().isSupportBP() &amp;&amp; &#x27;
                           &#x27;record.threadNum &gt; 1) {\n&#x27;
                           &#x27;      if (record.isBlock) {\n&#x27;
                           &#x27;        helper.handleBlockRecord();\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        helper.handleMultiRecord();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    } else if (!getWrapper().isSupportBP()) {\n&#x27;
                           &#x27;      helper.handleNoSupportBPRecord();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      helper.handleSingleThreadRecord();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override\n&#x27;
                           &#x27;  public ThreadRecord &#x27;
                           &#x27;createThreadRecord(TaskRecord record, int &#x27;
                           &#x27;threadId, long startL, long endL) {\n&#x27;
                           &#x27;    ThreadRecord tr;\n&#x27;
                           &#x27;    tr = new ThreadRecord();\n&#x27;
                           &#x27;    tr.taskKey = record.filePath;\n&#x27;
                           &#x27;    tr.threadId = threadId;\n&#x27;
                           &#x27;    tr.startLocation = startL;\n&#x27;
                           &#x27;    tr.isComplete = false;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    tr.threadType = getEntity().getTaskType();\n&#x27;
                           &#x27;    //最后一个线程的结束位置即为文件的总长度\n&#x27;
                           &#x27;    if (threadId == (record.threadNum - 1)) {\n&#x27;
                           &#x27;      endL = getEntity().getFileSize();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    tr.endLocation = endL;\n&#x27;
                           &#x27;    tr.blockLen = &#x27;
                           &#x27;RecordUtil.getBlockLen(getEntity().getFileSize(), &#x27;
                           &#x27;threadId, record.threadNum);\n&#x27;
                           &#x27;    return tr;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public TaskRecord createTaskRecord(int &#x27;
                           &#x27;threadNum) {\n&#x27;
                           &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                           &#x27;    record.fileName = getEntity().getFileName();\n&#x27;
                           &#x27;    record.filePath = getEntity().getFilePath();\n&#x27;
                           &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;    record.threadNum = threadNum;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int requestType = &#x27;
                           &#x27;getWrapper().getRequestType();\n&#x27;
                           &#x27;    if (requestType == ITaskWrapper.D_FTP || &#x27;
                           &#x27;requestType == ITaskWrapper.D_FTP_DIR\n&#x27;
                           &#x27;        || requestType == ITaskWrapper.D_HTTP || &#x27;
                           &#x27;requestType == ITaskWrapper.DG_HTTP) {\n&#x27;
                           &#x27;      record.isBlock = &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      record.isBlock = false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    record.taskType = getEntity().getTaskType();\n&#x27;
                           &#x27;    record.isGroupRecord = &#x27;
                           &#x27;getEntity().isGroupChild();\n&#x27;
                           &#x27;    if (record.isGroupRecord) {\n&#x27;
                           &#x27;      if (getEntity() instanceof DownloadEntity) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                           &#x27;getEntity()).getGroupHash();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    return record;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public int initTaskThreadNum() {\n&#x27;
                           &#x27;    int requestTpe = &#x27;
                           &#x27;getWrapper().getRequestType();\n&#x27;
                           &#x27;    if (requestTpe == ITaskWrapper.U_HTTP\n&#x27;
                           &#x27;        || (requestTpe == ITaskWrapper.D_HTTP &amp;&amp; &#x27;
                           &#x27;(!getWrapper().isSupportBP())\n&#x27;
                           &#x27;        || ((HttpTaskOption) &#x27;
                           &#x27;getWrapper().getTaskOption()).isChunked())) {\n&#x27;
                           &#x27;      return 1;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    int threadNum = &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.getThreadNum();\n&#x27;
                           &#x27;    return getEntity().getFileSize() &lt;= &#x27;
                           &#x27;IRecordHandler.SUB_LEN\n&#x27;
                           &#x27;        || getEntity().isGroupChild()\n&#x27;
                           &#x27;        || threadNum == 1\n&#x27;
                           &#x27;        ? 1\n&#x27;
                           &#x27;        : threadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Copyright (C) 2016 &#x27;
                           &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                           &#x27;(the &quot;License&quot;);\n&#x27;
                           &#x27; * you may not use this file except in compliance &#x27;
                           &#x27;with the License.\n&#x27;
                           &#x27; * You may obtain a copy of the License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *      &#x27;
                           &#x27;http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package com.arialyy.aria.http;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.arialyy.aria.core.TaskRecord;\n&#x27;
                           &#x27;import com.arialyy.aria.core.ThreadRecord;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.common.AbsRecordHandlerAdapter;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.RecordHelper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.config.Configuration;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.IRecordHandler;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.wrapper.AbsTaskWrapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.wrapper.ITaskWrapper;\n&#x27;
                           &#x27;import com.arialyy.aria.util.RecordUtil;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * @Author lyy\n&#x27;
                           &#x27; * @Date 2019-09-23\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class HttpRecordAdapter extends &#x27;
                           &#x27;AbsRecordHandlerAdapter {\n&#x27;
                           &#x27;  public HttpRecordAdapter(AbsTaskWrapper wrapper) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;    super(wrapper);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void onPre() {\n&#x27;
                           &#x27;    super.onPre();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void &#x27;
                           &#x27;handlerTaskRecord(TaskRecord record) {\n&#x27;
                           &#x27;    RecordHelper helper = new &#x27;
                           &#x27;RecordHelper(getWrapper(), record);\n&#x27;
                           &#x27;    if (getWrapper().isSupportBP() &amp;&amp; &#x27;
                           &#x27;record.threadNum &gt; 1) {\n&#x27;
                           &#x27;      if (record.isBlock) {\n&#x27;
                           &#x27;        helper.handleBlockRecord();\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        helper.handleMultiRecord();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    } else if (!getWrapper().isSupportBP()) {\n&#x27;
                           &#x27;      helper.handleNoSupportBPRecord();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      helper.handleSingleThreadRecord();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override\n&#x27;
                           &#x27;  public ThreadRecord &#x27;
                           &#x27;createThreadRecord(TaskRecord record, int &#x27;
                           &#x27;threadId, long startL, long endL) {\n&#x27;
                           &#x27;    ThreadRecord tr;\n&#x27;
                           &#x27;    tr = new ThreadRecord();\n&#x27;
                           &#x27;    tr.taskKey = record.filePath;\n&#x27;
                           &#x27;    tr.threadId = threadId;\n&#x27;
                           &#x27;    tr.startLocation = startL;\n&#x27;
                           &#x27;    tr.isComplete = false;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    tr.threadType = getEntity().getTaskType();\n&#x27;
                           &#x27;    //最后一个线程的结束位置即为文件的总长度\n&#x27;
                           &#x27;    if (threadId == (record.threadNum - 1)) {\n&#x27;
                           &#x27;      endL = getEntity().getFileSize();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    tr.endLocation = endL;\n&#x27;
                           &#x27;    tr.blockLen = &#x27;
                           &#x27;RecordUtil.getBlockLen(getEntity().getFileSize(), &#x27;
                           &#x27;threadId, record.threadNum);\n&#x27;
                           &#x27;    return tr;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public TaskRecord createTaskRecord(int &#x27;
                           &#x27;threadNum) {\n&#x27;
                           &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                           &#x27;    record.fileName = getEntity().getFileName();\n&#x27;
                           &#x27;    record.filePath = getEntity().getFilePath();\n&#x27;
                           &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;    record.threadNum = threadNum;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int requestType = &#x27;
                           &#x27;getWrapper().getRequestType();\n&#x27;
                           &#x27;    if (requestType == ITaskWrapper.D_FTP || &#x27;
                           &#x27;requestType == ITaskWrapper.D_FTP_DIR\n&#x27;
                           &#x27;        || requestType == ITaskWrapper.D_HTTP || &#x27;
                           &#x27;requestType == ITaskWrapper.DG_HTTP) {\n&#x27;
                           &#x27;      record.isBlock = &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      record.isBlock = false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    record.taskType = getEntity().getTaskType();\n&#x27;
                           &#x27;    record.isGroupRecord = &#x27;
                           &#x27;getEntity().isGroupChild();\n&#x27;
                           &#x27;    if (record.isGroupRecord) {\n&#x27;
                           &#x27;      if (getEntity() instanceof DownloadEntity) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                           &#x27;getEntity()).getGroupHash();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    return record;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public int initTaskThreadNum() {\n&#x27;
                           &#x27;    int requestTpe = &#x27;
                           &#x27;getWrapper().getRequestType();\n&#x27;
                           &#x27;    if (requestTpe == ITaskWrapper.U_HTTP\n&#x27;
                           &#x27;        || (requestTpe == ITaskWrapper.D_HTTP &amp;&amp; &#x27;
                           &#x27;(!getWrapper().isSupportBP())\n&#x27;
                           &#x27;        || ((HttpTaskOption) &#x27;
                           &#x27;getWrapper().getTaskOption()).isChunked())) {\n&#x27;
                           &#x27;      return 1;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    int threadNum = &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.getThreadNum();\n&#x27;
                           &#x27;    return getEntity().getFileSize() &lt;= &#x27;
                           &#x27;IRecordHandler.SUB_LEN\n&#x27;
                           &#x27;        || getEntity().isGroupChild()\n&#x27;
                           &#x27;        || threadNum == 1\n&#x27;
                           &#x27;        ? 1\n&#x27;
                           &#x27;        : threadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;/*\n&#x27;
                           &#x27; * Copyright (C) 2016 &#x27;
                           &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                           &#x27;(the &quot;License&quot;);\n&#x27;
                           &#x27; * you may not use this file except in compliance &#x27;
                           &#x27;with the License.\n&#x27;
                           &#x27; * You may obtain a copy of the License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *      &#x27;
                           &#x27;http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package com.arialyy.aria.http;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.arialyy.aria.core.TaskRecord;\n&#x27;
                           &#x27;import com.arialyy.aria.core.ThreadRecord;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.common.AbsRecordHandlerAdapter;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.RecordHelper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.config.Configuration;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.IRecordHandler;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.wrapper.AbsTaskWrapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.wrapper.ITaskWrapper;\n&#x27;
                           &#x27;import com.arialyy.aria.util.RecordUtil;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * @Author lyy\n&#x27;
                           &#x27; * @Date 2019-09-23\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class HttpRecordAdapter extends &#x27;
                           &#x27;AbsRecordHandlerAdapter {\n&#x27;
                           &#x27;  public HttpRecordAdapter(AbsTaskWrapper wrapper) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;    super(wrapper);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void onPre() {\n&#x27;
                           &#x27;    super.onPre();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void &#x27;
                           &#x27;handlerTaskRecord(TaskRecord record) {\n&#x27;
                           &#x27;    RecordHelper helper = new &#x27;
                           &#x27;RecordHelper(getWrapper(), record);\n&#x27;
                           &#x27;    if (getWrapper().isSupportBP() &amp;&amp; &#x27;
                           &#x27;record.threadNum &gt; 1) {\n&#x27;
                           &#x27;      if (record.isBlock) {\n&#x27;
                           &#x27;        helper.handleBlockRecord();\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        helper.handleMultiRecord();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    } else if (!getWrapper().isSupportBP()) {\n&#x27;
                           &#x27;      helper.handleNoSupportBPRecord();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      helper.handleSingleThreadRecord();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override\n&#x27;
                           &#x27;  public ThreadRecord &#x27;
                           &#x27;createThreadRecord(TaskRecord record, int &#x27;
                           &#x27;threadId, long startL, long endL) {\n&#x27;
                           &#x27;    ThreadRecord tr;\n&#x27;
                           &#x27;    tr = new ThreadRecord();\n&#x27;
                           &#x27;    tr.taskKey = record.filePath;\n&#x27;
                           &#x27;    tr.threadId = threadId;\n&#x27;
                           &#x27;    tr.startLocation = startL;\n&#x27;
                           &#x27;    tr.isComplete = false;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    tr.threadType = getEntity().getTaskType();\n&#x27;
                           &#x27;    //最后一个线程的结束位置即为文件的总长度\n&#x27;
                           &#x27;    if (threadId == (record.threadNum - 1)) {\n&#x27;
                           &#x27;      endL = getEntity().getFileSize();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    tr.endLocation = endL;\n&#x27;
                           &#x27;    tr.blockLen = &#x27;
                           &#x27;RecordUtil.getBlockLen(getEntity().getFileSize(), &#x27;
                           &#x27;threadId, record.threadNum);\n&#x27;
                           &#x27;    return tr;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public TaskRecord createTaskRecord(int &#x27;
                           &#x27;threadNum) {\n&#x27;
                           &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                           &#x27;    record.fileName = getEntity().getFileName();\n&#x27;
                           &#x27;    record.filePath = getEntity().getFilePath();\n&#x27;
                           &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;    record.threadNum = threadNum;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int requestType = &#x27;
                           &#x27;getWrapper().getRequestType();\n&#x27;
                           &#x27;    if (requestType == ITaskWrapper.D_FTP || &#x27;
                           &#x27;requestType == ITaskWrapper.D_FTP_DIR\n&#x27;
                           &#x27;        || requestType == ITaskWrapper.D_HTTP || &#x27;
                           &#x27;requestType == ITaskWrapper.DG_HTTP) {\n&#x27;
                           &#x27;      record.isBlock = &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      record.isBlock = false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    record.taskType = getEntity().getTaskType();\n&#x27;
                           &#x27;    record.isGroupRecord = &#x27;
                           &#x27;getEntity().isGroupChild();\n&#x27;
                           &#x27;    if (record.isGroupRecord) {\n&#x27;
                           &#x27;      if (getEntity() instanceof DownloadEntity) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                           &#x27;getEntity()).getGroupHash();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    return record;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public int initTaskThreadNum() {\n&#x27;
                           &#x27;    int requestTpe = &#x27;
                           &#x27;getWrapper().getRequestType();\n&#x27;
                           &#x27;    if (requestTpe == ITaskWrapper.U_HTTP\n&#x27;
                           &#x27;        || (requestTpe == ITaskWrapper.D_HTTP &amp;&amp; &#x27;
                           &#x27;(!getWrapper().isSupportBP())\n&#x27;
                           &#x27;        || ((HttpTaskOption) &#x27;
                           &#x27;getWrapper().getTaskOption()).isChunked())) {\n&#x27;
                           &#x27;      return 1;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    int threadNum = &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.getThreadNum();\n&#x27;
                           &#x27;    return getEntity().getFileSize() &lt;= &#x27;
                           &#x27;IRecordHandler.SUB_LEN\n&#x27;
                           &#x27;        || getEntity().isGroupChild()\n&#x27;
                           &#x27;        || threadNum == 1\n&#x27;
                           &#x27;        ? 1\n&#x27;
                           &#x27;        : threadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;}\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;/*\n&#x27;
                           &#x27; * Copyright (C) 2016 &#x27;
                           &#x27;AriaLyy(https://github.com/AriaLyy/Aria)\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Licensed under the Apache License, Version 2.0 &#x27;
                           &#x27;(the &quot;License&quot;);\n&#x27;
                           &#x27; * you may not use this file except in compliance &#x27;
                           &#x27;with the License.\n&#x27;
                           &#x27; * You may obtain a copy of the License at\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; *      &#x27;
                           &#x27;http://www.apache.org/licenses/LICENSE-2.0\n&#x27;
                           &#x27; *\n&#x27;
                           &#x27; * Unless required by applicable law or agreed to &#x27;
                           &#x27;in writing, software\n&#x27;
                           &#x27; * distributed under the License is distributed on &#x27;
                           &#x27;an &quot;AS IS&quot; BASIS,\n&#x27;
                           &#x27; * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, &#x27;
                           &#x27;either express or implied.\n&#x27;
                           &#x27; * See the License for the specific language &#x27;
                           &#x27;governing permissions and\n&#x27;
                           &#x27; * limitations under the License.\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;package com.arialyy.aria.http;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;import com.arialyy.aria.core.TaskRecord;\n&#x27;
                           &#x27;import com.arialyy.aria.core.ThreadRecord;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.common.AbsRecordHandlerAdapter;\n&#x27;
                           &#x27;import com.arialyy.aria.core.common.RecordHelper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.config.Configuration;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.download.DownloadEntity;\n&#x27;
                           &#x27;import com.arialyy.aria.core.inf.IRecordHandler;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.wrapper.AbsTaskWrapper;\n&#x27;
                           &#x27;import &#x27;
                           &#x27;com.arialyy.aria.core.wrapper.ITaskWrapper;\n&#x27;
                           &#x27;import com.arialyy.aria.util.RecordUtil;\n&#x27;
                           &#x27;import java.util.ArrayList;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;/**\n&#x27;
                           &#x27; * @Author lyy\n&#x27;
                           &#x27; * @Date 2019-09-23\n&#x27;
                           &#x27; */\n&#x27;
                           &#x27;public class HttpRecordAdapter extends &#x27;
                           &#x27;AbsRecordHandlerAdapter {\n&#x27;
                           &#x27;  public HttpRecordAdapter(AbsTaskWrapper wrapper) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;    super(wrapper);\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void onPre() {\n&#x27;
                           &#x27;    super.onPre();\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public void &#x27;
                           &#x27;handlerTaskRecord(TaskRecord record) {\n&#x27;
                           &#x27;    RecordHelper helper = new &#x27;
                           &#x27;RecordHelper(getWrapper(), record);\n&#x27;
                           &#x27;    if (getWrapper().isSupportBP() &amp;&amp; &#x27;
                           &#x27;record.threadNum &gt; 1) {\n&#x27;
                           &#x27;      if (record.isBlock) {\n&#x27;
                           &#x27;        helper.handleBlockRecord();\n&#x27;
                           &#x27;      } else {\n&#x27;
                           &#x27;        helper.handleMultiRecord();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    } else if (!getWrapper().isSupportBP()) {\n&#x27;
                           &#x27;      helper.handleNoSupportBPRecord();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      helper.handleSingleThreadRecord();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override\n&#x27;
                           &#x27;  public ThreadRecord &#x27;
                           &#x27;createThreadRecord(TaskRecord record, int &#x27;
                           &#x27;threadId, long startL, long endL) {\n&#x27;
                           &#x27;    ThreadRecord tr;\n&#x27;
                           &#x27;    tr = new ThreadRecord();\n&#x27;
                           &#x27;    tr.taskKey = record.filePath;\n&#x27;
                           &#x27;    tr.threadId = threadId;\n&#x27;
                           &#x27;    tr.startLocation = startL;\n&#x27;
                           &#x27;    tr.isComplete = false;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    tr.threadType = getEntity().getTaskType();\n&#x27;
                           &#x27;    //最后一个线程的结束位置即为文件的总长度\n&#x27;
                           &#x27;    if (threadId == (record.threadNum - 1)) {\n&#x27;
                           &#x27;      endL = getEntity().getFileSize();\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    tr.endLocation = endL;\n&#x27;
                           &#x27;    tr.blockLen = &#x27;
                           &#x27;RecordUtil.getBlockLen(getEntity().getFileSize(), &#x27;
                           &#x27;threadId, record.threadNum);\n&#x27;
                           &#x27;    return tr;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public TaskRecord createTaskRecord(int &#x27;
                           &#x27;threadNum) {\n&#x27;
                           &#x27;    TaskRecord record = new TaskRecord();\n&#x27;
                           &#x27;    record.fileName = getEntity().getFileName();\n&#x27;
                           &#x27;    record.filePath = getEntity().getFilePath();\n&#x27;
                           &#x27;    record.threadRecords = new ArrayList&lt;&gt;();\n&#x27;
                           &#x27;    record.threadNum = threadNum;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    int requestType = &#x27;
                           &#x27;getWrapper().getRequestType();\n&#x27;
                           &#x27;    if (requestType == ITaskWrapper.D_FTP || &#x27;
                           &#x27;requestType == ITaskWrapper.D_FTP_DIR\n&#x27;
                           &#x27;        || requestType == ITaskWrapper.D_HTTP || &#x27;
                           &#x27;requestType == ITaskWrapper.DG_HTTP) {\n&#x27;
                           &#x27;      record.isBlock = &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.isUseBlock();\n&#x27;
                           &#x27;    } else {\n&#x27;
                           &#x27;      record.isBlock = false;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    record.taskType = getEntity().getTaskType();\n&#x27;
                           &#x27;    record.isGroupRecord = &#x27;
                           &#x27;getEntity().isGroupChild();\n&#x27;
                           &#x27;    if (record.isGroupRecord) {\n&#x27;
                           &#x27;      if (getEntity() instanceof DownloadEntity) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;        record.dGroupHash = ((DownloadEntity) &#x27;
                           &#x27;getEntity()).getGroupHash();\n&#x27;
                           &#x27;      }\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;    return record;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;  @Override public int initTaskThreadNum() {\n&#x27;
                           &#x27;    int requestTpe = &#x27;
                           &#x27;getWrapper().getRequestType();\n&#x27;
                           &#x27;    if (requestTpe == ITaskWrapper.U_HTTP\n&#x27;
                           &#x27;        || (requestTpe == ITaskWrapper.D_HTTP &amp;&amp; &#x27;
                           &#x27;(!getWrapper().isSupportBP())\n&#x27;
                           &#x27;        || ((HttpTaskOption) &#x27;
                           &#x27;getWrapper().getTaskOption()).isChunked())) {\n&#x27;
                           &#x27;      return 1;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    int threadNum = &#x27;
                           &#x27;Configuration.getInstance().downloadCfg.getThreadNum();\n&#x27;
                           &#x27;    return getEntity().getFileSize() &lt;= &#x27;
                           &#x27;IRecordHandler.SUB_LEN\n&#x27;
                           &#x27;        || getEntity().isGroupChild()\n&#x27;
                           &#x27;        || threadNum == 1\n&#x27;
                           &#x27;        ? 1\n&#x27;
                           &#x27;        : threadNum;\n&#x27;
                           &#x27;  }\n&#x27;
                           &#x27;}\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;, &#x27;jfstmerge&#x27;}}]]</pre>
          </body>
        </html>
        