<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>581 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (shouldShowIntroScreen()) {\n&#x27;
                         &#x27;            showIntroScreen();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        // The two first run cling paths are &#x27;
                           &#x27;mutually exclusive, if the launcher is &#x27;
                           &#x27;preinstalled\n&#x27;
                           &#x27;        // on the device, then we always show the &#x27;
                           &#x27;first run cling experience (or if there is no\n&#x27;
                           &#x27;        // launcher2). Otherwise, we prompt the &#x27;
                           &#x27;user upon started for migration\n&#x27;
                           &#x27;        showFirstRunActivity();\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(mLauncherClings.shouldShowFirstRunOrMigrationClings()) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(mModel.canMigrateFromOldLauncherDb(this)) {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mLauncherClings.showMigrationCling();\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mLauncherClings.showFirstRunCling();\n&#x27;
                           &#x27;            }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            showFirstRunActivity();\n&#x27;
                         &#x27;            showFirstRunClings();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;            &#x27;
                           &#x27;mLauncherClings.removeFirstRunAndMigrationClings();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * This method indicates whether or not we &#x27;
                         &#x27;should suggest default wallpaper dimensions\n&#x27;
                         &#x27;     * when our wallpaper cropper was not yet used &#x27;
                         &#x27;to set a wallpaper.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected boolean overrideWallpaperDimensions() &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        return true;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean shouldClingFocusHotseatApp() &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        return false;\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (shouldShowIntroScreen()) {\n&#x27;
                         &#x27;            showIntroScreen();\n&#x27;
                         &#x27;        } else {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        // The two first run cling paths are &#x27;
                           &#x27;mutually exclusive, if the launcher is &#x27;
                           &#x27;preinstalled\n&#x27;
                           &#x27;        // on the device, then we always show the &#x27;
                           &#x27;first run cling experience (or if there is no\n&#x27;
                           &#x27;        // launcher2). Otherwise, we prompt the &#x27;
                           &#x27;user upon started for migration\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            showFirstRunClings();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        if &#x27;
                           &#x27;(mLauncherClings.shouldShowFirstRunOrMigrationClings()) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(mModel.canMigrateFromOldLauncherDb(this)) {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mLauncherClings.showMigrationCling();\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mLauncherClings.showFirstRunCling();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mLauncherClings.removeFirstRunAndMigrationClings();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        mWorkspace.setPageSwitchListener(this);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        mWorkspace.setPageSwitchListener(this);\n\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            } else if &#x27;
                         &#x27;(LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED.equals(action)\n&#x27;
                         &#x27;                    || &#x27;
                         &#x27;LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED.equals(action)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                getModel().forceReload();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;            } else if &#x27;
                         &#x27;(LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED.equals(action)\n&#x27;
                         &#x27;                    || &#x27;
                         &#x27;LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED.equals(action)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                getModel().forceReload();\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        // For handling managed profiles\n&#x27;
                         &#x27;        &#x27;
                         &#x27;filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        // For handling managed profiles\n&#x27;
                         &#x27;        &#x27;
                         &#x27;filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED);\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;public ViewGroup getOverviewPanel() {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public View getOverviewPanel() {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public ViewGroup getOverviewPanel() {\n\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n    public View getOverviewPanel() {\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;            // Dismiss the folder cling\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mLauncherClings.dismissFolderCling(null);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            // Dismiss the folder cling\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mLauncherClings.dismissFolderCling(null);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                &#x27;
                         &#x27;mWorkspace.getChangeStateAnimation(workspaceState, &#x27;
                         &#x27;animated, layerViews);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                &#x27;
                           &#x27;mWorkspace.getChangeStateAnimation(Workspace.State.SMALL, &#x27;
                           &#x27;animated);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;                &#x27;
                         &#x27;mWorkspace.getChangeStateAnimation(workspaceState, &#x27;
                         &#x27;animated, layerViews);\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mWorkspace.getChangeStateAnimation(Workspace.State.SMALL, &#x27;
                           &#x27;animated);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        &#x27;
                           &#x27;mLauncherClings.updateSearchBarHint(hint);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mLauncherClings.updateSearchBarHint(hint);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public void dismissFirstRunCling(View v) {\n&#x27;
                           &#x27;        mLauncherClings.dismissFirstRunCling(v);\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public void dismissWorkspaceCling(View v) {\n&#x27;
                           &#x27;        mLauncherClings.dismissWorkspaceCling(v);\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public void dismissFolderCling(View v) {\n&#x27;
                           &#x27;        mLauncherClings.dismissFolderCling(v);\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (mWorkspace != null) &#x27;
                         &#x27;mWorkspace.setAlpha(1f);\n&#x27;
                         &#x27;        if (mHotseat != null) &#x27;
                         &#x27;mHotseat.setAlpha(1f);\n&#x27;
                         &#x27;        if (mPageIndicators != null) &#x27;
                         &#x27;mPageIndicators.setAlpha(1f);\n&#x27;
                         &#x27;        if (mSearchDropTargetBar != null) &#x27;
                         &#x27;mSearchDropTargetBar.showSearchBar(false);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        mWorkspace.setAlpha(1f);\n&#x27;
                           &#x27;        mHotseat.setAlpha(1f);\n&#x27;
                           &#x27;        mPageIndicators.setAlpha(1f);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mSearchDropTargetBar.showSearchBar(false);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (mWorkspace != null) &#x27;
                         &#x27;mWorkspace.setAlpha(0f);\n&#x27;
                         &#x27;        if (mHotseat != null) &#x27;
                         &#x27;mHotseat.setAlpha(0f);\n&#x27;
                         &#x27;        if (mPageIndicators != null) &#x27;
                         &#x27;mPageIndicators.setAlpha(0f);\n&#x27;
                         &#x27;        if (mSearchDropTargetBar != null) &#x27;
                         &#x27;mSearchDropTargetBar.hideSearchBar(false);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        mWorkspace.setAlpha(0f);\n&#x27;
                           &#x27;        mHotseat.setAlpha(0f);\n&#x27;
                           &#x27;        mPageIndicators.setAlpha(0f);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mSearchDropTargetBar.hideSearchBar(false);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    private static final int ACTIVITY_START_DELAY = &#x27;
                         &#x27;1000;\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    FocusIndicatorView mFocusHandler;\n\n\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (shouldShowIntroScreen()) {\n&#x27;
                         &#x27;            showIntroScreen();\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;            showFirstRunActivity();\n&#x27;
                         &#x27;            showFirstRunClings();\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;        // The two first run cling paths are &#x27;
                           &#x27;mutually exclusive, if the launcher is &#x27;
                           &#x27;preinstalled\n&#x27;
                           &#x27;        // on the device, then we always show the &#x27;
                           &#x27;first run cling experience (or if there is no\n&#x27;
                           &#x27;        // launcher2). Otherwise, we prompt the &#x27;
                           &#x27;user upon started for migration\n&#x27;
                           &#x27;        showFirstRunActivity();\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(mLauncherClings.shouldShowFirstRunOrMigrationClings()) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(mModel.canMigrateFromOldLauncherDb(this)) {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mLauncherClings.showMigrationCling();\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mLauncherClings.showFirstRunCling();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mLauncherClings.removeFirstRunAndMigrationClings();\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    public LauncherClings getLauncherClings() {\n&#x27;
                           &#x27;        return mLauncherClings;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * To be overridden by subclasses to indicate &#x27;
                         &#x27;that there is an activity to launch\n&#x27;
                         &#x27;     * before showing the standard launcher &#x27;
                         &#x27;experience.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected boolean hasFirstRunActivity() {\n&#x27;
                         &#x27;        return false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * To be overridden by subclasses to launch any &#x27;
                         &#x27;first run activity\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected Intent getFirstRunActivity() {\n&#x27;
                         &#x27;        return null;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private boolean shouldRunFirstRunActivity() {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;!ActivityManager.isRunningInTestHarness() &amp;&amp;\n&#x27;
                         &#x27;                &#x27;
                         &#x27;!mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, &#x27;
                         &#x27;false);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean hasRunFirstRunActivity() {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, &#x27;
                         &#x27;false);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public boolean showFirstRunActivity() {\n&#x27;
                         &#x27;        if (shouldRunFirstRunActivity() &amp;&amp;\n&#x27;
                         &#x27;                hasFirstRunActivity()) {\n&#x27;
                         &#x27;            Intent firstRunIntent = &#x27;
                         &#x27;getFirstRunActivity();\n&#x27;
                         &#x27;            if (firstRunIntent != null) {\n&#x27;
                         &#x27;                startActivity(firstRunIntent);\n&#x27;
                         &#x27;                markFirstRunActivityShown();\n&#x27;
                         &#x27;                return true;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void markFirstRunActivityShown() {\n&#x27;
                         &#x27;        SharedPreferences.Editor editor = &#x27;
                         &#x27;mSharedPrefs.edit();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;editor.putBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, &#x27;
                         &#x27;true);\n&#x27;
                         &#x27;        editor.apply();\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    public void dismissFirstRunCling(View v) {\n&#x27;
                           &#x27;        mLauncherClings.dismissFirstRunCling(v);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    public void dismissMigrationClingCopyApps(View &#x27;
                           &#x27;v) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mLauncherClings.dismissMigrationClingCopyApps(v);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    public void &#x27;
                           &#x27;dismissMigrationClingUseDefault(View v) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mLauncherClings.dismissMigrationClingUseDefault(v);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    public void &#x27;
                           &#x27;dismissMigrationWorkspaceCling(View v) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mLauncherClings.dismissMigrationWorkspaceCling(v);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * To be overridden by subclasses to indicate &#x27;
                         &#x27;that there is an in-activity full-screen intro\n&#x27;
                         &#x27;     * screen that must be displayed and dismissed.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected boolean hasDismissableIntroScreen() {\n&#x27;
                         &#x27;        return false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Full screen intro screen to be shown and &#x27;
                         &#x27;dismissed before the launcher can be used.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected View getIntroScreen() {\n&#x27;
                         &#x27;        return null;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * To be overriden by subclasses to indicate &#x27;
                         &#x27;whether the in-activity intro screen has been\n&#x27;
                         &#x27;     * dismissed. This method is ignored if &#x27;
                         &#x27;#hasDismissableIntroScreen returns false.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    private boolean shouldShowIntroScreen() {\n&#x27;
                         &#x27;        return hasDismissableIntroScreen() &amp;&amp;\n&#x27;
                         &#x27;                &#x27;
                         &#x27;!mSharedPrefs.getBoolean(INTRO_SCREEN_DISMISSED, &#x27;
                         &#x27;false);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void showIntroScreen() {\n&#x27;
                         &#x27;        View introScreen = getIntroScreen();\n&#x27;
                         &#x27;        changeWallpaperVisiblity(false);\n&#x27;
                         &#x27;        if (introScreen != null) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;mDragLayer.showOverlayView(introScreen);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    public void dismissWorkspaceCling(View v) {\n&#x27;
                           &#x27;        mLauncherClings.dismissWorkspaceCling(v);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;
                         &#x27;    public void dismissIntroScreen() {\n&#x27;
                         &#x27;        markIntroScreenDismissed();\n&#x27;
                         &#x27;        if (showFirstRunActivity()) {\n&#x27;
                         &#x27;            // We delay hiding the intro view until &#x27;
                         &#x27;the first run activity is showing. This\n&#x27;
                         &#x27;            // avoids a blip.\n&#x27;
                         &#x27;            mWorkspace.postDelayed(new Runnable() {\n&#x27;
                         &#x27;                @Override\n&#x27;
                         &#x27;                public void run() {\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;mDragLayer.dismissOverlayView();\n&#x27;
                         &#x27;                    showFirstRunClings();\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }, ACTIVITY_START_DELAY);\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;            mDragLayer.dismissOverlayView();\n&#x27;
                         &#x27;            showFirstRunClings();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        changeWallpaperVisiblity(true);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void markIntroScreenDismissed() {\n&#x27;
                         &#x27;        SharedPreferences.Editor editor = &#x27;
                         &#x27;mSharedPrefs.edit();\n&#x27;
                         &#x27;        editor.putBoolean(INTRO_SCREEN_DISMISSED, &#x27;
                         &#x27;true);\n&#x27;
                         &#x27;        editor.apply();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void showFirstRunClings() {\n&#x27;
                         &#x27;        // The two first run cling paths are &#x27;
                         &#x27;mutually exclusive, if the launcher is preinstalled\n&#x27;
                         &#x27;        // on the device, then we always show the &#x27;
                         &#x27;first run cling experience (or if there is no\n&#x27;
                         &#x27;        // launcher2). Otherwise, we prompt the user &#x27;
                         &#x27;upon started for migration\n&#x27;
                         &#x27;        LauncherClings launcherClings = new &#x27;
                         &#x27;LauncherClings(this);\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(launcherClings.shouldShowFirstRunOrMigrationClings()) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(mModel.canMigrateFromOldLauncherDb(this)) {\n&#x27;
                         &#x27;                &#x27;
                         &#x27;launcherClings.showMigrationCling();\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                &#x27;
                         &#x27;launcherClings.showLongPressCling(true);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    void showWorkspaceSearchAndHotseat() {\n&#x27;
                         &#x27;        if (mWorkspace != null) &#x27;
                         &#x27;mWorkspace.setAlpha(1f);\n&#x27;
                         &#x27;        if (mHotseat != null) &#x27;
                         &#x27;mHotseat.setAlpha(1f);\n&#x27;
                         &#x27;        if (mPageIndicators != null) &#x27;
                         &#x27;mPageIndicators.setAlpha(1f);\n&#x27;
                         &#x27;        if (mSearchDropTargetBar != null) &#x27;
                         &#x27;mSearchDropTargetBar.showSearchBar(false);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    void hideWorkspaceSearchAndHotseat() {\n&#x27;
                         &#x27;        if (mWorkspace != null) &#x27;
                         &#x27;mWorkspace.setAlpha(0f);\n&#x27;
                         &#x27;        if (mHotseat != null) &#x27;
                         &#x27;mHotseat.setAlpha(0f);\n&#x27;
                         &#x27;        if (mPageIndicators != null) &#x27;
                         &#x27;mPageIndicators.setAlpha(0f);\n&#x27;
                         &#x27;        if (mSearchDropTargetBar != null) &#x27;
                         &#x27;mSearchDropTargetBar.hideSearchBar(false);\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    public void dismissFolderCling(View v) {\n&#x27;
                           &#x27;        mLauncherClings.dismissFolderCling(v);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (shouldShowIntroScreen()) {\n&#x27;
                         &#x27;            showIntroScreen();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        // The two first run cling paths are &#x27;
                           &#x27;mutually exclusive, if the launcher is &#x27;
                           &#x27;preinstalled\n&#x27;
                           &#x27;        // on the device, then we always show the &#x27;
                           &#x27;first run cling experience (or if there is no\n&#x27;
                           &#x27;        // launcher2). Otherwise, we prompt the &#x27;
                           &#x27;user upon started for migration\n&#x27;
                           &#x27;        showFirstRunActivity();\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(mLauncherClings.shouldShowFirstRunOrMigrationClings()) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(mModel.canMigrateFromOldLauncherDb(this)) {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mLauncherClings.showMigrationCling();\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mLauncherClings.showFirstRunCling();\n&#x27;
                           &#x27;            }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        if (shouldShowIntroScreen()) {\n&#x27;
                         &#x27;            showIntroScreen();\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;            showFirstRunActivity();\n&#x27;
                         &#x27;            showFirstRunClings();\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;        // The two first run cling paths are &#x27;
                           &#x27;mutually exclusive, if the launcher is &#x27;
                           &#x27;preinstalled\n&#x27;
                           &#x27;        // on the device, then we always show the &#x27;
                           &#x27;first run cling experience (or if there is no\n&#x27;
                           &#x27;        // launcher2). Otherwise, we prompt the &#x27;
                           &#x27;user upon started for migration\n&#x27;
                           &#x27;        showFirstRunActivity();\n&#x27;
                           &#x27;        if &#x27;
                           &#x27;(mLauncherClings.shouldShowFirstRunOrMigrationClings()) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(mModel.canMigrateFromOldLauncherDb(this)) {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mLauncherClings.showMigrationCling();\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mLauncherClings.showFirstRunCling();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mLauncherClings.removeFirstRunAndMigrationClings();\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;, &#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            showFirstRunActivity();\n&#x27;
                         &#x27;            showFirstRunClings();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;            &#x27;
                           &#x27;mLauncherClings.removeFirstRunAndMigrationClings();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * This method indicates whether or not we &#x27;
                         &#x27;should suggest default wallpaper dimensions\n&#x27;
                         &#x27;     * when our wallpaper cropper was not yet used &#x27;
                         &#x27;to set a wallpaper.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected boolean overrideWallpaperDimensions() &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        return true;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean shouldClingFocusHotseatApp() &#x27;
                         &#x27;{\n&#x27;
                         &#x27;        return false;\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (shouldShowIntroScreen()) {\n&#x27;
                         &#x27;            showIntroScreen();\n&#x27;
                         &#x27;        } else {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        // The two first run cling paths are &#x27;
                           &#x27;mutually exclusive, if the launcher is &#x27;
                           &#x27;preinstalled\n&#x27;
                           &#x27;        // on the device, then we always show the &#x27;
                           &#x27;first run cling experience (or if there is no\n&#x27;
                           &#x27;        // launcher2). Otherwise, we prompt the &#x27;
                           &#x27;user upon started for migration\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            showFirstRunClings();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        if &#x27;
                           &#x27;(mLauncherClings.shouldShowFirstRunOrMigrationClings()) &#x27;
                           &#x27;{\n&#x27;
                           &#x27;            if &#x27;
                           &#x27;(mModel.canMigrateFromOldLauncherDb(this)) {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mLauncherClings.showMigrationCling();\n&#x27;
                           &#x27;            } else {\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mLauncherClings.showFirstRunCling();\n&#x27;
                           &#x27;            }\n&#x27;
                           &#x27;        } else {\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mLauncherClings.removeFirstRunAndMigrationClings();\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        mWorkspace.setPageSwitchListener(this);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        mWorkspace.setPageSwitchListener(this);\n\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;            } else if &#x27;
                         &#x27;(LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED.equals(action)\n&#x27;
                         &#x27;                    || &#x27;
                         &#x27;LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED.equals(action)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                getModel().forceReload();\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;            } else if &#x27;
                         &#x27;(LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED.equals(action)\n&#x27;
                         &#x27;                    || &#x27;
                         &#x27;LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED.equals(action)) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;                getModel().forceReload();\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        // For handling managed profiles\n&#x27;
                         &#x27;        &#x27;
                         &#x27;filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;        // For handling managed profiles\n&#x27;
                         &#x27;        &#x27;
                         &#x27;filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_ADDED);\n&#x27;
                         &#x27;        &#x27;
                         &#x27;filter.addAction(LauncherAppsCompat.ACTION_MANAGED_PROFILE_REMOVED);\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;public ViewGroup getOverviewPanel() {\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public View getOverviewPanel() {\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    public ViewGroup getOverviewPanel() {\n\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n    public View getOverviewPanel() {\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;            // Dismiss the folder cling\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mLauncherClings.dismissFolderCling(null);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;            // Dismiss the folder cling\n&#x27;
                           &#x27;            &#x27;
                           &#x27;mLauncherClings.dismissFolderCling(null);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;                &#x27;
                         &#x27;mWorkspace.getChangeStateAnimation(workspaceState, &#x27;
                         &#x27;animated, layerViews);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;                &#x27;
                           &#x27;mWorkspace.getChangeStateAnimation(Workspace.State.SMALL, &#x27;
                           &#x27;animated);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;                &#x27;
                         &#x27;mWorkspace.getChangeStateAnimation(workspaceState, &#x27;
                         &#x27;animated, layerViews);\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;                &#x27;
                           &#x27;mWorkspace.getChangeStateAnimation(Workspace.State.SMALL, &#x27;
                           &#x27;animated);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        &#x27;
                           &#x27;mLauncherClings.updateSearchBarHint(hint);\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;\n\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mLauncherClings.updateSearchBarHint(hint);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public void dismissFirstRunCling(View v) {\n&#x27;
                           &#x27;        mLauncherClings.dismissFirstRunCling(v);\n&#x27;
                           &#x27;    }\n&#x27;},
          {&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * To be overridden by subclasses to indicate &#x27;
                         &#x27;that there is an activity to launch\n&#x27;
                         &#x27;     * before showing the standard launcher &#x27;
                         &#x27;experience.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected boolean hasFirstRunActivity() {\n&#x27;
                         &#x27;        return false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * To be overridden by subclasses to launch any &#x27;
                         &#x27;first run activity\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected Intent getFirstRunActivity() {\n&#x27;
                         &#x27;        return null;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private boolean shouldRunFirstRunActivity() {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;!ActivityManager.isRunningInTestHarness() &amp;&amp;\n&#x27;
                         &#x27;                &#x27;
                         &#x27;!mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, &#x27;
                         &#x27;false);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected boolean hasRunFirstRunActivity() {\n&#x27;
                         &#x27;        return &#x27;
                         &#x27;mSharedPrefs.getBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, &#x27;
                         &#x27;false);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    public boolean showFirstRunActivity() {\n&#x27;
                         &#x27;        if (shouldRunFirstRunActivity() &amp;&amp;\n&#x27;
                         &#x27;                hasFirstRunActivity()) {\n&#x27;
                         &#x27;            Intent firstRunIntent = &#x27;
                         &#x27;getFirstRunActivity();\n&#x27;
                         &#x27;            if (firstRunIntent != null) {\n&#x27;
                         &#x27;                startActivity(firstRunIntent);\n&#x27;
                         &#x27;                markFirstRunActivityShown();\n&#x27;
                         &#x27;                return true;\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        return false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void markFirstRunActivityShown() {\n&#x27;
                         &#x27;        SharedPreferences.Editor editor = &#x27;
                         &#x27;mSharedPrefs.edit();\n&#x27;
                         &#x27;        &#x27;
                         &#x27;editor.putBoolean(FIRST_RUN_ACTIVITY_DISPLAYED, &#x27;
                         &#x27;true);\n&#x27;
                         &#x27;        editor.apply();\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    public void dismissFirstRunCling(View v) {\n&#x27;
                           &#x27;        mLauncherClings.dismissFirstRunCling(v);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    public void dismissMigrationClingCopyApps(View &#x27;
                           &#x27;v) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mLauncherClings.dismissMigrationClingCopyApps(v);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    public void &#x27;
                           &#x27;dismissMigrationClingUseDefault(View v) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mLauncherClings.dismissMigrationClingUseDefault(v);\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;    public void &#x27;
                           &#x27;dismissMigrationWorkspaceCling(View v) {\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mLauncherClings.dismissMigrationWorkspaceCling(v);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;, &#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public void dismissWorkspaceCling(View v) {\n&#x27;
                           &#x27;        mLauncherClings.dismissWorkspaceCling(v);\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;public void dismissFolderCling(View v) {\n&#x27;
                           &#x27;        mLauncherClings.dismissFolderCling(v);\n&#x27;
                           &#x27;    }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (mWorkspace != null) &#x27;
                         &#x27;mWorkspace.setAlpha(1f);\n&#x27;
                         &#x27;        if (mHotseat != null) &#x27;
                         &#x27;mHotseat.setAlpha(1f);\n&#x27;
                         &#x27;        if (mPageIndicators != null) &#x27;
                         &#x27;mPageIndicators.setAlpha(1f);\n&#x27;
                         &#x27;        if (mSearchDropTargetBar != null) &#x27;
                         &#x27;mSearchDropTargetBar.showSearchBar(false);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        mWorkspace.setAlpha(1f);\n&#x27;
                           &#x27;        mHotseat.setAlpha(1f);\n&#x27;
                           &#x27;        mPageIndicators.setAlpha(1f);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mSearchDropTargetBar.showSearchBar(false);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;        if (mWorkspace != null) &#x27;
                         &#x27;mWorkspace.setAlpha(0f);\n&#x27;
                         &#x27;        if (mHotseat != null) &#x27;
                         &#x27;mHotseat.setAlpha(0f);\n&#x27;
                         &#x27;        if (mPageIndicators != null) &#x27;
                         &#x27;mPageIndicators.setAlpha(0f);\n&#x27;
                         &#x27;        if (mSearchDropTargetBar != null) &#x27;
                         &#x27;mSearchDropTargetBar.hideSearchBar(false);\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;        mWorkspace.setAlpha(0f);\n&#x27;
                           &#x27;        mHotseat.setAlpha(0f);\n&#x27;
                           &#x27;        mPageIndicators.setAlpha(0f);\n&#x27;
                           &#x27;        &#x27;
                           &#x27;mSearchDropTargetBar.hideSearchBar(false);\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;jfstmerge&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    private static final int ACTIVITY_START_DELAY = &#x27;
                         &#x27;1000;\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    FocusIndicatorView mFocusHandler;\n\n\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    public LauncherClings getLauncherClings() {\n&#x27;
                           &#x27;        return mLauncherClings;\n&#x27;
                           &#x27;    }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * To be overridden by subclasses to indicate &#x27;
                         &#x27;that there is an in-activity full-screen intro\n&#x27;
                         &#x27;     * screen that must be displayed and dismissed.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected boolean hasDismissableIntroScreen() {\n&#x27;
                         &#x27;        return false;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * Full screen intro screen to be shown and &#x27;
                         &#x27;dismissed before the launcher can be used.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    protected View getIntroScreen() {\n&#x27;
                         &#x27;        return null;\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    /**\n&#x27;
                         &#x27;     * To be overriden by subclasses to indicate &#x27;
                         &#x27;whether the in-activity intro screen has been\n&#x27;
                         &#x27;     * dismissed. This method is ignored if &#x27;
                         &#x27;#hasDismissableIntroScreen returns false.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    private boolean shouldShowIntroScreen() {\n&#x27;
                         &#x27;        return hasDismissableIntroScreen() &amp;&amp;\n&#x27;
                         &#x27;                &#x27;
                         &#x27;!mSharedPrefs.getBoolean(INTRO_SCREEN_DISMISSED, &#x27;
                         &#x27;false);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    protected void showIntroScreen() {\n&#x27;
                         &#x27;        View introScreen = getIntroScreen();\n&#x27;
                         &#x27;        changeWallpaperVisiblity(false);\n&#x27;
                         &#x27;        if (introScreen != null) {\n&#x27;
                         &#x27;            &#x27;
                         &#x27;mDragLayer.showOverlayView(introScreen);\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    public void dismissWorkspaceCling(View v) {\n&#x27;
                           &#x27;        mLauncherClings.dismissWorkspaceCling(v);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;\n&#x27;
                         &#x27;    public void dismissIntroScreen() {\n&#x27;
                         &#x27;        markIntroScreenDismissed();\n&#x27;
                         &#x27;        if (showFirstRunActivity()) {\n&#x27;
                         &#x27;            // We delay hiding the intro view until &#x27;
                         &#x27;the first run activity is showing. This\n&#x27;
                         &#x27;            // avoids a blip.\n&#x27;
                         &#x27;            mWorkspace.postDelayed(new Runnable() {\n&#x27;
                         &#x27;                @Override\n&#x27;
                         &#x27;                public void run() {\n&#x27;
                         &#x27;                    &#x27;
                         &#x27;mDragLayer.dismissOverlayView();\n&#x27;
                         &#x27;                    showFirstRunClings();\n&#x27;
                         &#x27;                }\n&#x27;
                         &#x27;            }, ACTIVITY_START_DELAY);\n&#x27;
                         &#x27;        } else {\n&#x27;
                         &#x27;            mDragLayer.dismissOverlayView();\n&#x27;
                         &#x27;            showFirstRunClings();\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;        changeWallpaperVisiblity(true);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void markIntroScreenDismissed() {\n&#x27;
                         &#x27;        SharedPreferences.Editor editor = &#x27;
                         &#x27;mSharedPrefs.edit();\n&#x27;
                         &#x27;        editor.putBoolean(INTRO_SCREEN_DISMISSED, &#x27;
                         &#x27;true);\n&#x27;
                         &#x27;        editor.apply();\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    private void showFirstRunClings() {\n&#x27;
                         &#x27;        // The two first run cling paths are &#x27;
                         &#x27;mutually exclusive, if the launcher is preinstalled\n&#x27;
                         &#x27;        // on the device, then we always show the &#x27;
                         &#x27;first run cling experience (or if there is no\n&#x27;
                         &#x27;        // launcher2). Otherwise, we prompt the user &#x27;
                         &#x27;upon started for migration\n&#x27;
                         &#x27;        LauncherClings launcherClings = new &#x27;
                         &#x27;LauncherClings(this);\n&#x27;
                         &#x27;        if &#x27;
                         &#x27;(launcherClings.shouldShowFirstRunOrMigrationClings()) &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            if &#x27;
                         &#x27;(mModel.canMigrateFromOldLauncherDb(this)) {\n&#x27;
                         &#x27;                &#x27;
                         &#x27;launcherClings.showMigrationCling();\n&#x27;
                         &#x27;            } else {\n&#x27;
                         &#x27;                &#x27;
                         &#x27;launcherClings.showLongPressCling(true);\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        }\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    void showWorkspaceSearchAndHotseat() {\n&#x27;
                         &#x27;        if (mWorkspace != null) &#x27;
                         &#x27;mWorkspace.setAlpha(1f);\n&#x27;
                         &#x27;        if (mHotseat != null) &#x27;
                         &#x27;mHotseat.setAlpha(1f);\n&#x27;
                         &#x27;        if (mPageIndicators != null) &#x27;
                         &#x27;mPageIndicators.setAlpha(1f);\n&#x27;
                         &#x27;        if (mSearchDropTargetBar != null) &#x27;
                         &#x27;mSearchDropTargetBar.showSearchBar(false);\n&#x27;
                         &#x27;    }\n&#x27;
                         &#x27;\n&#x27;
                         &#x27;    void hideWorkspaceSearchAndHotseat() {\n&#x27;
                         &#x27;        if (mWorkspace != null) &#x27;
                         &#x27;mWorkspace.setAlpha(0f);\n&#x27;
                         &#x27;        if (mHotseat != null) &#x27;
                         &#x27;mHotseat.setAlpha(0f);\n&#x27;
                         &#x27;        if (mPageIndicators != null) &#x27;
                         &#x27;mPageIndicators.setAlpha(0f);\n&#x27;
                         &#x27;        if (mSearchDropTargetBar != null) &#x27;
                         &#x27;mSearchDropTargetBar.hideSearchBar(false);\n&#x27;
                         &#x27;\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;\n&#x27;
                           &#x27;    public void dismissFolderCling(View v) {\n&#x27;
                           &#x27;        mLauncherClings.dismissFolderCling(v);\n&#x27;
                           &#x27;\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;spork&#x27;}}]]</pre>
          </body>
        </html>
        