<!DOCTYPE html>
<html lang="en">
          <head>
            <meta charset="utf-8">
            <title>496 chunks</title>
                <style>
                    #top {
                        height: 48vh;
                        overflow-y: auto;
                    }
                    #bottom {
                        height: 48vh;
                        overflow-y: auto;
                    }
                </style>
          </head>
          <body>
            <pre>[[{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously downloads the object from this &#x27;
                         &#x27;{@link StorageReference} a byte array will be &#x27;
                         &#x27;allocated large enough to hold the entire file in &#x27;
                         &#x27;memory.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef           represents a &#x27;
                         &#x27;reference to a Google Cloud Storage object.\n&#x27;
                         &#x27;     * @param maxDownloadSizeBytes the maximum &#x27;
                         &#x27;allowed size in bytes that will be allocated. Set &#x27;
                         &#x27;this parameter to prevent out of memory conditions &#x27;
                         &#x27;from occurring.\n&#x27;
                         &#x27;     *                             If the download &#x27;
                         &#x27;exceeds this limit, the task will fail and an &#x27;
                         &#x27;IndexOutOfBoundsException will be returned.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an byte[] &#x27;
                         &#x27;if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static Maybe&lt;byte[]&gt; getBytes(@NonNull &#x27;
                         &#x27;final StorageReference storageRef,\n&#x27;
                         &#x27;                                         final long &#x27;
                         &#x27;maxDownloadSizeBytes) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;byte[]&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;byte[]&gt; emitter) throws &#x27;
                         &#x27;Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.getBytes(maxDownloadSizeBytes));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously downloads the object from &#x27;
                           &#x27;this {@link StorageReference} a byte array will be &#x27;
                           &#x27;allocated large enough to hold the entire file in &#x27;
                           &#x27;memory.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef           represents a &#x27;
                           &#x27;reference to a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param maxDownloadSizeBytes the maximum &#x27;
                           &#x27;allowed size in bytes that will be allocated. Set &#x27;
                           &#x27;this parameter to prevent out of memory conditions &#x27;
                           &#x27;from occurring.\n&#x27;
                           &#x27;    *                             If the download &#x27;
                           &#x27;exceeds this limit, the task will fail and an &#x27;
                           &#x27;IndexOutOfBoundsException will be returned.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;byte[] if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Maybe&lt;byte[]&gt; getBytes(@NonNull &#x27;
                           &#x27;final StorageReference storageRef,\n&#x27;
                           &#x27;                                        final long &#x27;
                           &#x27;maxDownloadSizeBytes) {\n&#x27;
                           &#x27;      return Maybe.create(new &#x27;
                           &#x27;MaybeOnSubscribe&lt;byte[]&gt;() {\n&#x27;
                           &#x27;         @Override\n&#x27;
                           &#x27;         public void &#x27;
                           &#x27;subscribe(MaybeEmitter&lt;byte[]&gt; emitter) throws &#x27;
                           &#x27;Exception {\n&#x27;
                           &#x27;            RxHandler.assignOnTask(emitter, &#x27;
                           &#x27;storageRef.getBytes(maxDownloadSizeBytes));\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously retrieves a long lived &#x27;
                         &#x27;download URL with a revocable token.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef represents a reference to a &#x27;
                         &#x27;Google Cloud Storage object.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;Uri} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static Maybe&lt;Uri&gt; getDownloadUrl(@NonNull &#x27;
                         &#x27;final StorageReference storageRef) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;Uri&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void subscribe(MaybeEmitter&lt;Uri&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.getDownloadUrl());\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously retrieves a long lived &#x27;
                           &#x27;download URL with a revocable token.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link Uri} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Maybe&lt;Uri&gt; &#x27;
                           &#x27;getDownloadUrl(@NonNull final StorageReference &#x27;
                           &#x27;storageRef) {\n&#x27;
                           &#x27;      return Maybe.create(new &#x27;
                           &#x27;MaybeOnSubscribe&lt;Uri&gt;() {\n&#x27;
                           &#x27;         @Override\n&#x27;
                           &#x27;         public void subscribe(MaybeEmitter&lt;Uri&gt; &#x27;
                           &#x27;emitter) throws Exception {\n&#x27;
                           &#x27;            RxHandler.assignOnTask(emitter, &#x27;
                           &#x27;storageRef.getDownloadUrl());\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously downloads the object at this &#x27;
                         &#x27;{@link StorageReference} to a specified system &#x27;
                         &#x27;filepath.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef      represents a reference &#x27;
                         &#x27;to a Google Cloud Storage object.\n&#x27;
                         &#x27;     * @param destinationFile a File representing &#x27;
                         &#x27;the path the object should be downloaded to.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;FileDownloadTask.TaskSnapshot} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static &#x27;
                         &#x27;Maybe&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;getFile(@NonNull final StorageReference storageRef,\n&#x27;
                         &#x27;                                                               &#x27;
                         &#x27;@NonNull final File destinationFile) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;FileDownloadTask.TaskSnapshot&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.getFile(destinationFile));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously downloads the object at this &#x27;
                           &#x27;{@link StorageReference} to a specified system &#x27;
                           &#x27;filepath.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef      represents a &#x27;
                           &#x27;reference to a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param destinationFile a File representing &#x27;
                           &#x27;the path the object should be downloaded to.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link FileDownloadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static &#x27;
                           &#x27;Single&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;getFile(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                               &#x27;
                           &#x27;@NonNull final File destinationFile) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;FileDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;emitter) throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               &#x27;
                           &#x27;storageRef.getFile(destinationFile).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;FileDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;FileDownloadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously downloads the object at this &#x27;
                         &#x27;{@link StorageReference} to a specified system &#x27;
                         &#x27;filepath.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef     represents a reference &#x27;
                         &#x27;to a Google Cloud Storage object.\n&#x27;
                         &#x27;     * @param destinationUri a file system URI &#x27;
                         &#x27;representing the path the object should be &#x27;
                         &#x27;downloaded to.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;FileDownloadTask.TaskSnapshot} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static &#x27;
                         &#x27;Maybe&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;getFile(@NonNull final StorageReference storageRef,\n&#x27;
                         &#x27;                                                               &#x27;
                         &#x27;@NonNull final Uri destinationUri) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;FileDownloadTask.TaskSnapshot&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.getFile(destinationUri));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously downloads the object at this &#x27;
                           &#x27;{@link StorageReference} to a specified system &#x27;
                           &#x27;filepath.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef     represents a reference &#x27;
                           &#x27;to a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param destinationUri a file system URI &#x27;
                           &#x27;representing the path the object should be &#x27;
                           &#x27;downloaded to.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link FileDownloadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static &#x27;
                           &#x27;Single&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;getFile(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                               &#x27;
                           &#x27;@NonNull final Uri destinationUri) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;FileDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;emitter) throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               &#x27;
                           &#x27;storageRef.getFile(destinationUri).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;FileDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;FileDownloadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Retrieves metadata associated with an object &#x27;
                         &#x27;at this {@link StorageReference}.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef represents a reference to a &#x27;
                         &#x27;Google Cloud Storage object.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;StorageMetadata} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static Maybe&lt;StorageMetadata&gt; &#x27;
                         &#x27;getMetadata(@NonNull final StorageReference &#x27;
                         &#x27;storageRef) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;StorageMetadata&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;StorageMetadata&gt; emitter) &#x27;
                         &#x27;throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.getMetadata());\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Retrieves metadata associated with an object &#x27;
                           &#x27;at this {@link StorageReference}.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link StorageMetadata} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Maybe&lt;StorageMetadata&gt; &#x27;
                           &#x27;getMetadata(@NonNull final StorageReference &#x27;
                           &#x27;storageRef) {\n&#x27;
                           &#x27;      return Maybe.create(new &#x27;
                           &#x27;MaybeOnSubscribe&lt;StorageMetadata&gt;() {\n&#x27;
                           &#x27;         @Override\n&#x27;
                           &#x27;         public void &#x27;
                           &#x27;subscribe(MaybeEmitter&lt;StorageMetadata&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            RxHandler.assignOnTask(emitter, &#x27;
                           &#x27;storageRef.getMetadata());\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously downloads the object at this &#x27;
                         &#x27;{@link StorageReference} via a InputStream.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef represents a reference to a &#x27;
                         &#x27;Google Cloud Storage object.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;StreamDownloadTask.TaskSnapshot} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static &#x27;
                         &#x27;Maybe&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;getStream(@NonNull final StorageReference &#x27;
                         &#x27;storageRef) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;StreamDownloadTask.TaskSnapshot&gt;() &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.getStream());\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously downloads the object at this &#x27;
                           &#x27;{@link StorageReference} via a InputStream.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link StreamDownloadTask.TaskSnapshot} if &#x27;
                           &#x27;success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static &#x27;
                           &#x27;Single&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;getStream(@NonNull final StorageReference &#x27;
                           &#x27;storageRef) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;StreamDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;emitter) throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               &#x27;
                           &#x27;storageRef.getStream().addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;StreamDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;StreamDownloadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously downloads the object at this &#x27;
                         &#x27;{@link StorageReference} via a InputStream.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef represents a reference to a &#x27;
                         &#x27;Google Cloud Storage object.\n&#x27;
                         &#x27;     * @param processor  A &#x27;
                         &#x27;StreamDownloadTask.StreamProcessor that is &#x27;
                         &#x27;responsible for reading data from the InputStream.\n&#x27;
                         &#x27;     *                   The &#x27;
                         &#x27;StreamDownloadTask.StreamProcessor is called on a &#x27;
                         &#x27;background thread and checked exceptions thrown\n&#x27;
                         &#x27;     *                   from this object will be &#x27;
                         &#x27;returned as a failure to the OnFailureListener &#x27;
                         &#x27;registered on the StreamDownloadTask.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;StreamDownloadTask.TaskSnapshot} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static &#x27;
                         &#x27;Maybe&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;getStream(@NonNull final StorageReference &#x27;
                         &#x27;storageRef,\n&#x27;
                         &#x27;                                                                   &#x27;
                         &#x27;@NonNull final StreamDownloadTask.StreamProcessor &#x27;
                         &#x27;processor) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;StreamDownloadTask.TaskSnapshot&gt;() &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.getStream(processor));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously downloads the object at this &#x27;
                           &#x27;{@link StorageReference} via a InputStream.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param processor  A &#x27;
                           &#x27;StreamDownloadTask.StreamProcessor that is &#x27;
                           &#x27;responsible for reading data from the &#x27;
                           &#x27;InputStream.\n&#x27;
                           &#x27;    *                   The &#x27;
                           &#x27;StreamDownloadTask.StreamProcessor is called on a &#x27;
                           &#x27;background thread and checked exceptions thrown\n&#x27;
                           &#x27;    *                   from this object will be &#x27;
                           &#x27;returned as a failure to the OnFailureListener &#x27;
                           &#x27;registered on the StreamDownloadTask.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link StreamDownloadTask.TaskSnapshot} if &#x27;
                           &#x27;success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static &#x27;
                           &#x27;Single&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;getStream(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                                   &#x27;
                           &#x27;@NonNull final StreamDownloadTask.StreamProcessor &#x27;
                           &#x27;processor) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;StreamDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;emitter) throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               &#x27;
                           &#x27;storageRef.getStream(processor).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;StreamDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;StreamDownloadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously uploads byte data to this &#x27;
                         &#x27;{@link StorageReference}.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef represents a reference to a &#x27;
                         &#x27;Google Cloud Storage object.\n&#x27;
                         &#x27;     * @param bytes      The byte[] to upload.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;UploadTask.TaskSnapshot} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static Maybe&lt;UploadTask.TaskSnapshot&gt; &#x27;
                         &#x27;putBytes(@NonNull final StorageReference &#x27;
                         &#x27;storageRef,\n&#x27;
                         &#x27;                                                          &#x27;
                         &#x27;@NonNull final byte[] bytes) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;UploadTask.TaskSnapshot&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.putBytes(bytes));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously uploads byte data to this &#x27;
                           &#x27;{@link StorageReference}.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param bytes      The byte[] to upload.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link UploadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Single&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;putBytes(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                          &#x27;
                           &#x27;@NonNull final byte[] bytes) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;UploadTask.TaskSnapshot&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               &#x27;
                           &#x27;storageRef.putBytes(bytes).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;UploadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously uploads byte data to this &#x27;
                         &#x27;{@link StorageReference}.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef represents a reference to a &#x27;
                         &#x27;Google Cloud Storage object.\n&#x27;
                         &#x27;     * @param bytes      The byte[] to upload.\n&#x27;
                         &#x27;     * @param metadata   {@link StorageMetadata} &#x27;
                         &#x27;containing additional information (MIME type, etc.) &#x27;
                         &#x27;about the object being uploaded.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;UploadTask.TaskSnapshot} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static Maybe&lt;UploadTask.TaskSnapshot&gt; &#x27;
                         &#x27;putBytes(@NonNull final StorageReference &#x27;
                         &#x27;storageRef,\n&#x27;
                         &#x27;                                                          &#x27;
                         &#x27;@NonNull final byte[] bytes,\n&#x27;
                         &#x27;                                                          &#x27;
                         &#x27;@NonNull final StorageMetadata metadata) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;UploadTask.TaskSnapshot&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.putBytes(bytes, metadata));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously uploads byte data to this &#x27;
                           &#x27;{@link StorageReference}.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param bytes      The byte[] to upload.\n&#x27;
                           &#x27;    * @param metadata   {@link StorageMetadata} &#x27;
                           &#x27;containing additional information (MIME type, &#x27;
                           &#x27;etc.) about the object being uploaded.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link UploadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Single&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;putBytes(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                          &#x27;
                           &#x27;@NonNull final byte[] bytes,\n&#x27;
                           &#x27;                                                          &#x27;
                           &#x27;@NonNull final StorageMetadata metadata) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;UploadTask.TaskSnapshot&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               storageRef.putBytes(bytes, &#x27;
                           &#x27;metadata).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;UploadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously uploads from a content URI to &#x27;
                           &#x27;this {@link StorageReference}.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param uri        The source of the upload. &#x27;
                           &#x27;This can be a file:// scheme or any content URI. A &#x27;
                           &#x27;content resolver will be used to load the data.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link UploadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Single&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;putFile(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                         &#x27;
                           &#x27;@NonNull final Uri uri) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;UploadTask.TaskSnapshot&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               &#x27;
                           &#x27;storageRef.putFile(uri).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;UploadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously uploads from a content URI to &#x27;
                           &#x27;this {@link StorageReference}.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param uri        The source of the upload. &#x27;
                           &#x27;This can be a file:// scheme or any content URI. A &#x27;
                           &#x27;content resolver will be used to load the data.\n&#x27;
                           &#x27;    * @param metadata   {@link StorageMetadata} &#x27;
                           &#x27;containing additional information (MIME type, &#x27;
                           &#x27;etc.) about the object being uploaded.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link UploadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Single&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;putFile(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                         &#x27;
                           &#x27;@NonNull final Uri uri,\n&#x27;
                           &#x27;                                                         &#x27;
                           &#x27;@NonNull final StorageMetadata metadata) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;UploadTask.TaskSnapshot&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               storageRef.putFile(uri, &#x27;
                           &#x27;metadata).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;UploadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously uploads from a content URI to &#x27;
                           &#x27;this {@link StorageReference}.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef        represents a &#x27;
                           &#x27;reference to a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param uri               The source of the &#x27;
                           &#x27;upload. This can be a file:// scheme or any &#x27;
                           &#x27;content URI. A content resolver will be used to &#x27;
                           &#x27;load the data.\n&#x27;
                           &#x27;    * @param metadata          {@link &#x27;
                           &#x27;StorageMetadata} containing additional information &#x27;
                           &#x27;(MIME type, etc.) about the object being &#x27;
                           &#x27;uploaded.\n&#x27;
                           &#x27;    * @param existingUploadUri If set, an attempt &#x27;
                           &#x27;is made to resume an existing upload session as &#x27;
                           &#x27;defined by getUploadSessionUri().\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link UploadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Single&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;putFile(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                         &#x27;
                           &#x27;@NonNull final Uri uri,\n&#x27;
                           &#x27;                                                         &#x27;
                           &#x27;@NonNull final StorageMetadata metadata,\n&#x27;
                           &#x27;                                                         &#x27;
                           &#x27;@NonNull final Uri existingUploadUri) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;UploadTask.TaskSnapshot&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               storageRef.putFile(uri, metadata, &#x27;
                           &#x27;existingUploadUri).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;UploadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;   /**\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param stream     The InputStream to &#x27;
                           &#x27;upload.\n&#x27;
                           &#x27;    * @param metadata   {@link StorageMetadata} &#x27;
                           &#x27;containing additional information (MIME type, &#x27;
                           &#x27;etc.) about the object being uploaded.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link UploadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Single&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;putStream(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                           &#x27;
                           &#x27;@NonNull final InputStream stream,\n&#x27;
                           &#x27;                                                           &#x27;
                           &#x27;@NonNull final StorageMetadata metadata) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;UploadTask.TaskSnapshot&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               storageRef.putStream(stream, &#x27;
                           &#x27;metadata).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;UploadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously uploads from a content URI to &#x27;
                         &#x27;this {@link StorageReference}.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef represents a reference to a &#x27;
                         &#x27;Google Cloud Storage object.\n&#x27;
                         &#x27;     * @param uri        The source of the upload. &#x27;
                         &#x27;This can be a file:// scheme or any content URI. A &#x27;
                         &#x27;content resolver will be used to load the data.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;UploadTask.TaskSnapshot} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static Maybe&lt;UploadTask.TaskSnapshot&gt; &#x27;
                         &#x27;putFile(@NonNull final StorageReference storageRef,\n&#x27;
                         &#x27;                                                         &#x27;
                         &#x27;@NonNull final Uri uri) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;UploadTask.TaskSnapshot&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.putFile(uri));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously uploads a stream of data to &#x27;
                           &#x27;this {@link StorageReference}.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param stream     The InputStream to &#x27;
                           &#x27;upload.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link UploadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Single&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;putStream(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                           &#x27;
                           &#x27;@NonNull final InputStream stream) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;UploadTask.TaskSnapshot&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               &#x27;
                           &#x27;storageRef.putStream(stream).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;UploadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}}],
 [{&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously downloads the object from this &#x27;
                         &#x27;{@link StorageReference} a byte array will be &#x27;
                         &#x27;allocated large enough to hold the entire file in &#x27;
                         &#x27;memory.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef           represents a &#x27;
                         &#x27;reference to a Google Cloud Storage object.\n&#x27;
                         &#x27;     * @param maxDownloadSizeBytes the maximum &#x27;
                         &#x27;allowed size in bytes that will be allocated. Set &#x27;
                         &#x27;this parameter to prevent out of memory conditions &#x27;
                         &#x27;from occurring.\n&#x27;
                         &#x27;     *                             If the download &#x27;
                         &#x27;exceeds this limit, the task will fail and an &#x27;
                         &#x27;IndexOutOfBoundsException will be returned.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an byte[] &#x27;
                         &#x27;if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static Maybe&lt;byte[]&gt; getBytes(@NonNull &#x27;
                         &#x27;final StorageReference storageRef,\n&#x27;
                         &#x27;                                         final long &#x27;
                         &#x27;maxDownloadSizeBytes) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;byte[]&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;byte[]&gt; emitter) throws &#x27;
                         &#x27;Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.getBytes(maxDownloadSizeBytes));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously downloads the object from &#x27;
                           &#x27;this {@link StorageReference} a byte array will be &#x27;
                           &#x27;allocated large enough to hold the entire file in &#x27;
                           &#x27;memory.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef           represents a &#x27;
                           &#x27;reference to a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param maxDownloadSizeBytes the maximum &#x27;
                           &#x27;allowed size in bytes that will be allocated. Set &#x27;
                           &#x27;this parameter to prevent out of memory conditions &#x27;
                           &#x27;from occurring.\n&#x27;
                           &#x27;    *                             If the download &#x27;
                           &#x27;exceeds this limit, the task will fail and an &#x27;
                           &#x27;IndexOutOfBoundsException will be returned.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;byte[] if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Maybe&lt;byte[]&gt; getBytes(@NonNull &#x27;
                           &#x27;final StorageReference storageRef,\n&#x27;
                           &#x27;                                        final long &#x27;
                           &#x27;maxDownloadSizeBytes) {\n&#x27;
                           &#x27;      return Maybe.create(new &#x27;
                           &#x27;MaybeOnSubscribe&lt;byte[]&gt;() {\n&#x27;
                           &#x27;         @Override\n&#x27;
                           &#x27;         public void &#x27;
                           &#x27;subscribe(MaybeEmitter&lt;byte[]&gt; emitter) throws &#x27;
                           &#x27;Exception {\n&#x27;
                           &#x27;            RxHandler.assignOnTask(emitter, &#x27;
                           &#x27;storageRef.getBytes(maxDownloadSizeBytes));\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously retrieves a long lived &#x27;
                         &#x27;download URL with a revocable token.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef represents a reference to a &#x27;
                         &#x27;Google Cloud Storage object.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;Uri} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static Maybe&lt;Uri&gt; getDownloadUrl(@NonNull &#x27;
                         &#x27;final StorageReference storageRef) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;Uri&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void subscribe(MaybeEmitter&lt;Uri&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.getDownloadUrl());\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously retrieves a long lived &#x27;
                           &#x27;download URL with a revocable token.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link Uri} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Maybe&lt;Uri&gt; &#x27;
                           &#x27;getDownloadUrl(@NonNull final StorageReference &#x27;
                           &#x27;storageRef) {\n&#x27;
                           &#x27;      return Maybe.create(new &#x27;
                           &#x27;MaybeOnSubscribe&lt;Uri&gt;() {\n&#x27;
                           &#x27;         @Override\n&#x27;
                           &#x27;         public void subscribe(MaybeEmitter&lt;Uri&gt; &#x27;
                           &#x27;emitter) throws Exception {\n&#x27;
                           &#x27;            RxHandler.assignOnTask(emitter, &#x27;
                           &#x27;storageRef.getDownloadUrl());\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously downloads the object at this &#x27;
                         &#x27;{@link StorageReference} to a specified system &#x27;
                         &#x27;filepath.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef      represents a reference &#x27;
                         &#x27;to a Google Cloud Storage object.\n&#x27;
                         &#x27;     * @param destinationFile a File representing &#x27;
                         &#x27;the path the object should be downloaded to.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;FileDownloadTask.TaskSnapshot} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static &#x27;
                         &#x27;Maybe&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;getFile(@NonNull final StorageReference storageRef,\n&#x27;
                         &#x27;                                                               &#x27;
                         &#x27;@NonNull final File destinationFile) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;FileDownloadTask.TaskSnapshot&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.getFile(destinationFile));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously downloads the object at this &#x27;
                           &#x27;{@link StorageReference} to a specified system &#x27;
                           &#x27;filepath.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef      represents a &#x27;
                           &#x27;reference to a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param destinationFile a File representing &#x27;
                           &#x27;the path the object should be downloaded to.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link FileDownloadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static &#x27;
                           &#x27;Single&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;getFile(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                               &#x27;
                           &#x27;@NonNull final File destinationFile) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;FileDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;emitter) throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               &#x27;
                           &#x27;storageRef.getFile(destinationFile).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;FileDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;FileDownloadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously downloads the object at this &#x27;
                         &#x27;{@link StorageReference} to a specified system &#x27;
                         &#x27;filepath.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef     represents a reference &#x27;
                         &#x27;to a Google Cloud Storage object.\n&#x27;
                         &#x27;     * @param destinationUri a file system URI &#x27;
                         &#x27;representing the path the object should be &#x27;
                         &#x27;downloaded to.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;FileDownloadTask.TaskSnapshot} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static &#x27;
                         &#x27;Maybe&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;getFile(@NonNull final StorageReference storageRef,\n&#x27;
                         &#x27;                                                               &#x27;
                         &#x27;@NonNull final Uri destinationUri) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;FileDownloadTask.TaskSnapshot&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.getFile(destinationUri));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously downloads the object at this &#x27;
                           &#x27;{@link StorageReference} to a specified system &#x27;
                           &#x27;filepath.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef     represents a reference &#x27;
                           &#x27;to a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param destinationUri a file system URI &#x27;
                           &#x27;representing the path the object should be &#x27;
                           &#x27;downloaded to.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link FileDownloadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static &#x27;
                           &#x27;Single&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;getFile(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                               &#x27;
                           &#x27;@NonNull final Uri destinationUri) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;FileDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;emitter) throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;FileDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               &#x27;
                           &#x27;storageRef.getFile(destinationUri).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;FileDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;FileDownloadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Retrieves metadata associated with an object &#x27;
                         &#x27;at this {@link StorageReference}.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef represents a reference to a &#x27;
                         &#x27;Google Cloud Storage object.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;StorageMetadata} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static Maybe&lt;StorageMetadata&gt; &#x27;
                         &#x27;getMetadata(@NonNull final StorageReference &#x27;
                         &#x27;storageRef) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;StorageMetadata&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;StorageMetadata&gt; emitter) &#x27;
                         &#x27;throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.getMetadata());\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Retrieves metadata associated with an object &#x27;
                           &#x27;at this {@link StorageReference}.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link StorageMetadata} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Maybe&lt;StorageMetadata&gt; &#x27;
                           &#x27;getMetadata(@NonNull final StorageReference &#x27;
                           &#x27;storageRef) {\n&#x27;
                           &#x27;      return Maybe.create(new &#x27;
                           &#x27;MaybeOnSubscribe&lt;StorageMetadata&gt;() {\n&#x27;
                           &#x27;         @Override\n&#x27;
                           &#x27;         public void &#x27;
                           &#x27;subscribe(MaybeEmitter&lt;StorageMetadata&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            RxHandler.assignOnTask(emitter, &#x27;
                           &#x27;storageRef.getMetadata());\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously downloads the object at this &#x27;
                         &#x27;{@link StorageReference} via a InputStream.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef represents a reference to a &#x27;
                         &#x27;Google Cloud Storage object.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;StreamDownloadTask.TaskSnapshot} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static &#x27;
                         &#x27;Maybe&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;getStream(@NonNull final StorageReference &#x27;
                         &#x27;storageRef) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;StreamDownloadTask.TaskSnapshot&gt;() &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.getStream());\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously downloads the object at this &#x27;
                           &#x27;{@link StorageReference} via a InputStream.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link StreamDownloadTask.TaskSnapshot} if &#x27;
                           &#x27;success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static &#x27;
                           &#x27;Single&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;getStream(@NonNull final StorageReference &#x27;
                           &#x27;storageRef) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;StreamDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;emitter) throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               &#x27;
                           &#x27;storageRef.getStream().addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;StreamDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;StreamDownloadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously downloads the object at this &#x27;
                         &#x27;{@link StorageReference} via a InputStream.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef represents a reference to a &#x27;
                         &#x27;Google Cloud Storage object.\n&#x27;
                         &#x27;     * @param processor  A &#x27;
                         &#x27;StreamDownloadTask.StreamProcessor that is &#x27;
                         &#x27;responsible for reading data from the InputStream.\n&#x27;
                         &#x27;     *                   The &#x27;
                         &#x27;StreamDownloadTask.StreamProcessor is called on a &#x27;
                         &#x27;background thread and checked exceptions thrown\n&#x27;
                         &#x27;     *                   from this object will be &#x27;
                         &#x27;returned as a failure to the OnFailureListener &#x27;
                         &#x27;registered on the StreamDownloadTask.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;StreamDownloadTask.TaskSnapshot} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static &#x27;
                         &#x27;Maybe&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;getStream(@NonNull final StorageReference &#x27;
                         &#x27;storageRef,\n&#x27;
                         &#x27;                                                                   &#x27;
                         &#x27;@NonNull final StreamDownloadTask.StreamProcessor &#x27;
                         &#x27;processor) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;StreamDownloadTask.TaskSnapshot&gt;() &#x27;
                         &#x27;{\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.getStream(processor));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously downloads the object at this &#x27;
                           &#x27;{@link StorageReference} via a InputStream.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param processor  A &#x27;
                           &#x27;StreamDownloadTask.StreamProcessor that is &#x27;
                           &#x27;responsible for reading data from the &#x27;
                           &#x27;InputStream.\n&#x27;
                           &#x27;    *                   The &#x27;
                           &#x27;StreamDownloadTask.StreamProcessor is called on a &#x27;
                           &#x27;background thread and checked exceptions thrown\n&#x27;
                           &#x27;    *                   from this object will be &#x27;
                           &#x27;returned as a failure to the OnFailureListener &#x27;
                           &#x27;registered on the StreamDownloadTask.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link StreamDownloadTask.TaskSnapshot} if &#x27;
                           &#x27;success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static &#x27;
                           &#x27;Single&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;getStream(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                                   &#x27;
                           &#x27;@NonNull final StreamDownloadTask.StreamProcessor &#x27;
                           &#x27;processor) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;StreamDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;emitter) throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;StreamDownloadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               &#x27;
                           &#x27;storageRef.getStream(processor).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;StreamDownloadTask.TaskSnapshot&gt;() &#x27;
                           &#x27;{\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;StreamDownloadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously uploads byte data to this &#x27;
                         &#x27;{@link StorageReference}.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef represents a reference to a &#x27;
                         &#x27;Google Cloud Storage object.\n&#x27;
                         &#x27;     * @param bytes      The byte[] to upload.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;UploadTask.TaskSnapshot} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static Maybe&lt;UploadTask.TaskSnapshot&gt; &#x27;
                         &#x27;putBytes(@NonNull final StorageReference &#x27;
                         &#x27;storageRef,\n&#x27;
                         &#x27;                                                          &#x27;
                         &#x27;@NonNull final byte[] bytes) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;UploadTask.TaskSnapshot&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.putBytes(bytes));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously uploads byte data to this &#x27;
                           &#x27;{@link StorageReference}.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param bytes      The byte[] to upload.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link UploadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Single&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;putBytes(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                          &#x27;
                           &#x27;@NonNull final byte[] bytes) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;UploadTask.TaskSnapshot&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               &#x27;
                           &#x27;storageRef.putBytes(bytes).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;UploadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously uploads byte data to this &#x27;
                         &#x27;{@link StorageReference}.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef represents a reference to a &#x27;
                         &#x27;Google Cloud Storage object.\n&#x27;
                         &#x27;     * @param bytes      The byte[] to upload.\n&#x27;
                         &#x27;     * @param metadata   {@link StorageMetadata} &#x27;
                         &#x27;containing additional information (MIME type, etc.) &#x27;
                         &#x27;about the object being uploaded.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;UploadTask.TaskSnapshot} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static Maybe&lt;UploadTask.TaskSnapshot&gt; &#x27;
                         &#x27;putBytes(@NonNull final StorageReference &#x27;
                         &#x27;storageRef,\n&#x27;
                         &#x27;                                                          &#x27;
                         &#x27;@NonNull final byte[] bytes,\n&#x27;
                         &#x27;                                                          &#x27;
                         &#x27;@NonNull final StorageMetadata metadata) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;UploadTask.TaskSnapshot&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.putBytes(bytes, metadata));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously uploads byte data to this &#x27;
                           &#x27;{@link StorageReference}.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param bytes      The byte[] to upload.\n&#x27;
                           &#x27;    * @param metadata   {@link StorageMetadata} &#x27;
                           &#x27;containing additional information (MIME type, &#x27;
                           &#x27;etc.) about the object being uploaded.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link UploadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Single&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;putBytes(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                          &#x27;
                           &#x27;@NonNull final byte[] bytes,\n&#x27;
                           &#x27;                                                          &#x27;
                           &#x27;@NonNull final StorageMetadata metadata) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;UploadTask.TaskSnapshot&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               storageRef.putBytes(bytes, &#x27;
                           &#x27;metadata).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;UploadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously uploads from a content URI to &#x27;
                           &#x27;this {@link StorageReference}.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param uri        The source of the upload. &#x27;
                           &#x27;This can be a file:// scheme or any content URI. A &#x27;
                           &#x27;content resolver will be used to load the data.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link UploadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Single&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;putFile(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                         &#x27;
                           &#x27;@NonNull final Uri uri) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;UploadTask.TaskSnapshot&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               &#x27;
                           &#x27;storageRef.putFile(uri).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;UploadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously uploads from a content URI to &#x27;
                           &#x27;this {@link StorageReference}.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param uri        The source of the upload. &#x27;
                           &#x27;This can be a file:// scheme or any content URI. A &#x27;
                           &#x27;content resolver will be used to load the data.\n&#x27;
                           &#x27;    * @param metadata   {@link StorageMetadata} &#x27;
                           &#x27;containing additional information (MIME type, &#x27;
                           &#x27;etc.) about the object being uploaded.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link UploadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Single&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;putFile(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                         &#x27;
                           &#x27;@NonNull final Uri uri,\n&#x27;
                           &#x27;                                                         &#x27;
                           &#x27;@NonNull final StorageMetadata metadata) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;UploadTask.TaskSnapshot&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               storageRef.putFile(uri, &#x27;
                           &#x27;metadata).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;UploadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously uploads from a content URI to &#x27;
                           &#x27;this {@link StorageReference}.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef        represents a &#x27;
                           &#x27;reference to a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param uri               The source of the &#x27;
                           &#x27;upload. This can be a file:// scheme or any &#x27;
                           &#x27;content URI. A content resolver will be used to &#x27;
                           &#x27;load the data.\n&#x27;
                           &#x27;    * @param metadata          {@link &#x27;
                           &#x27;StorageMetadata} containing additional information &#x27;
                           &#x27;(MIME type, etc.) about the object being &#x27;
                           &#x27;uploaded.\n&#x27;
                           &#x27;    * @param existingUploadUri If set, an attempt &#x27;
                           &#x27;is made to resume an existing upload session as &#x27;
                           &#x27;defined by getUploadSessionUri().\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link UploadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Single&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;putFile(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                         &#x27;
                           &#x27;@NonNull final Uri uri,\n&#x27;
                           &#x27;                                                         &#x27;
                           &#x27;@NonNull final StorageMetadata metadata,\n&#x27;
                           &#x27;                                                         &#x27;
                           &#x27;@NonNull final Uri existingUploadUri) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;UploadTask.TaskSnapshot&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               storageRef.putFile(uri, metadata, &#x27;
                           &#x27;existingUploadUri).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;UploadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;
                           &#x27;\n&#x27;
                           &#x27;   /**\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param stream     The InputStream to &#x27;
                           &#x27;upload.\n&#x27;
                           &#x27;    * @param metadata   {@link StorageMetadata} &#x27;
                           &#x27;containing additional information (MIME type, &#x27;
                           &#x27;etc.) about the object being uploaded.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link UploadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Single&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;putStream(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                           &#x27;
                           &#x27;@NonNull final InputStream stream,\n&#x27;
                           &#x27;                                                           &#x27;
                           &#x27;@NonNull final StorageMetadata metadata) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;UploadTask.TaskSnapshot&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               storageRef.putStream(stream, &#x27;
                           &#x27;metadata).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;UploadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}},
  {&#x27;eq&#x27;: [{&#x27;CHUNK_OURS&#x27;: &#x27;    /**\n&#x27;
                         &#x27;     * Asynchronously uploads from a content URI to &#x27;
                         &#x27;this {@link StorageReference}.\n&#x27;
                         &#x27;     *\n&#x27;
                         &#x27;     * @param storageRef represents a reference to a &#x27;
                         &#x27;Google Cloud Storage object.\n&#x27;
                         &#x27;     * @param uri        The source of the upload. &#x27;
                         &#x27;This can be a file:// scheme or any content URI. A &#x27;
                         &#x27;content resolver will be used to load the data.\n&#x27;
                         &#x27;     * @return a {@link Maybe} which emits an {@link &#x27;
                         &#x27;UploadTask.TaskSnapshot} if success.\n&#x27;
                         &#x27;     */\n&#x27;
                         &#x27;    @NonNull\n&#x27;
                         &#x27;    public static Maybe&lt;UploadTask.TaskSnapshot&gt; &#x27;
                         &#x27;putFile(@NonNull final StorageReference storageRef,\n&#x27;
                         &#x27;                                                         &#x27;
                         &#x27;@NonNull final Uri uri) {\n&#x27;
                         &#x27;        return Maybe.create(new &#x27;
                         &#x27;MaybeOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                         &#x27;            @Override\n&#x27;
                         &#x27;            public void &#x27;
                         &#x27;subscribe(MaybeEmitter&lt;UploadTask.TaskSnapshot&gt; &#x27;
                         &#x27;emitter) throws Exception {\n&#x27;
                         &#x27;                RxHandler.assignOnTask(emitter, &#x27;
                         &#x27;storageRef.putFile(uri));\n&#x27;
                         &#x27;            }\n&#x27;
                         &#x27;        });\n&#x27;
                         &#x27;    }\n&#x27;,
           &#x27;CHUNK_THEIRS&#x27;: &#x27;   /**\n&#x27;
                           &#x27;    * Asynchronously uploads a stream of data to &#x27;
                           &#x27;this {@link StorageReference}.\n&#x27;
                           &#x27;    *\n&#x27;
                           &#x27;    * @param storageRef represents a reference to &#x27;
                           &#x27;a Google Cloud Storage object.\n&#x27;
                           &#x27;    * @param stream     The InputStream to &#x27;
                           &#x27;upload.\n&#x27;
                           &#x27;    * @return a {@link Single} which emits an &#x27;
                           &#x27;{@link UploadTask.TaskSnapshot} if success.\n&#x27;
                           &#x27;    */\n&#x27;
                           &#x27;   @NonNull\n&#x27;
                           &#x27;   public static Single&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;putStream(@NonNull final StorageReference &#x27;
                           &#x27;storageRef,\n&#x27;
                           &#x27;                                                           &#x27;
                           &#x27;@NonNull final InputStream stream) {\n&#x27;
                           &#x27;      return Single.create(new &#x27;
                           &#x27;SingleOnSubscribe&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;         public void subscribe(final &#x27;
                           &#x27;SingleEmitter&lt;UploadTask.TaskSnapshot&gt; emitter) &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;            final &#x27;
                           &#x27;StorageTask&lt;UploadTask.TaskSnapshot&gt; &#x27;
                           &#x27;taskSnapshotStorageTask =\n&#x27;
                           &#x27;               &#x27;
                           &#x27;storageRef.putStream(stream).addOnCompleteListener(new &#x27;
                           &#x27;OnCompleteListener&lt;UploadTask.TaskSnapshot&gt;() {\n&#x27;
                           &#x27;                  @Override\n&#x27;
                           &#x27;                  public void onComplete(@NonNull &#x27;
                           &#x27;Task&lt;UploadTask.TaskSnapshot&gt; task) {\n&#x27;
                           &#x27;                     if (task.isComplete()) {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onSuccess(task.getResult());\n&#x27;
                           &#x27;                     } else {\n&#x27;
                           &#x27;                        &#x27;
                           &#x27;emitter.onError(task.getException());\n&#x27;
                           &#x27;                     }\n&#x27;
                           &#x27;                  }\n&#x27;
                           &#x27;               });\n&#x27;
                           &#x27;            emitter.setCancellable(new &#x27;
                           &#x27;Cancellable() {\n&#x27;
                           &#x27;               @Override public void cancel() &#x27;
                           &#x27;throws Exception {\n&#x27;
                           &#x27;                  &#x27;
                           &#x27;taskSnapshotStorageTask.cancel();\n&#x27;
                           &#x27;               }\n&#x27;
                           &#x27;            });\n&#x27;
                           &#x27;         }\n&#x27;
                           &#x27;      });\n&#x27;
                           &#x27;   }\n&#x27;}],
   &#x27;mergers&#x27;: {&#x27;baseline&#x27;}}]]</pre>
          </body>
        </html>
        