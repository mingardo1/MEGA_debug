<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>333</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    333
                    <a href="332.html">prev</a>
                    <a href="334.html">next</a>
                    <a href="333_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_850ca0aa420995231841ce76f0c8aad7be417e7c_core/src/main/java/com/dtstack/flink/sql/parser/InsertSqlParser.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;850ca0aa420995231841ce76f0c8aad7be417e7c:core/src/main/java/com/dtstack/flink/sql/parser/InsertSqlParser.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;850ca0aa420995231841ce76f0c8aad7be417e7c^1:core/src/main/java/com/dtstack/flink/sql/parser/InsertSqlParser.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;850ca0aa420995231841ce76f0c8aad7be417e7c^2:core/src/main/java/com/dtstack/flink/sql/parser/InsertSqlParser.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;396b5b23ed96af799faad4c01abb6e2c09c428bb:core/src/main/java/com/dtstack/flink/sql/parser/InsertSqlParser.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[sbj]], subset: [[sbj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.parser;
  21 
  22 import org.apache.calcite.sql.SqlInsert;
  23 import org.apache.calcite.sql.SqlJoin;
  24 import org.apache.calcite.sql.SqlKind;
  25 import org.apache.calcite.sql.SqlNode;
  26 import org.apache.calcite.sql.SqlSelect;
  27 import org.apache.calcite.sql.SqlNodeList;
  28 import org.apache.calcite.sql.SqlBasicCall;
  29 import org.apache.calcite.sql.SqlMatchRecognize;
  30 import org.apache.calcite.sql.SqlOrderBy;
  31 import org.apache.calcite.sql.SqlIdentifier;
  32 import org.apache.calcite.sql.SqlAsOperator;
  33 import org.apache.calcite.sql.parser.SqlParserPos;
  34 import org.apache.commons.lang3.StringUtils;
  35 import com.google.common.collect.Lists;
  36 import org.apache.flink.table.planner.calcite.FlinkPlannerImpl;
  37 
  38 import java.util.List;
  39 
  40 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  41 
  42 /**
  43  * 解析flink sql
  44  * sql 只支持 insert 开头的
  45  * Date: 2018/6/22
  46  * Company: www.dtstack.com
  47  * @author xuchao
  48  */
  49 
  50 public class InsertSqlParser implements IParser {
  51 
  52     private FlinkPlanner flinkPlanner = new FlinkPlanner();
  53 
  54     // 用来标识当前解析节点的上一层节点是否为 insert 节点
  55     private static Boolean parentIsInsert = false;
  56 
  57     @Override
  58     public boolean verify(String sql) {
  59         return StringUtils.isNotBlank(sql) &amp;&amp; sql.trim().toLowerCase().startsWith(&quot;insert&quot;);
  60     }
  61 
  62     public static InsertSqlParser newInstance(){
  63         InsertSqlParser parser = new InsertSqlParser();
  64         return parser;
  65     }
  66 
  67     @Override
  68     public void parseSql(String sql, SqlTree sqlTree) throws Exception {
  69 
  70 
  71         SqlNode sqlNode = flinkPlanner.getParser().parse(sql);
  72 
  73         SqlParseResult sqlParseResult = new SqlParseResult();
  74         parseNode(sqlNode, sqlParseResult);
  75         sqlParseResult.setExecSql(sqlNode.toString());
  76         sqlTree.addExecSql(sqlParseResult);
  77     }
  78 
  79     private static void parseNode(SqlNode sqlNode, SqlParseResult sqlParseResult){
  80         SqlKind sqlKind = sqlNode.getKind();
  81         switch (sqlKind){
  82             case INSERT:
  83                 SqlNode sqlTarget = ((SqlInsert)sqlNode).getTargetTable();
  84                 SqlNode sqlSource = ((SqlInsert)sqlNode).getSource();
  85                 sqlParseResult.addTargetTable(sqlTarget.toString());
  86                 parentIsInsert = true;
  87                 parseNode(sqlSource, sqlParseResult);
  88                 break;
  89             case SELECT:
  90                 SqlSelect sqlSelect = (SqlSelect) sqlNode;
  91                 if (parentIsInsert) {
  92                     rebuildSelectNode(sqlSelect.getSelectList(), sqlSelect);
  93                 }
  94                 SqlNode sqlFrom = ((SqlSelect) sqlNode).getFrom();
  95                 if (sqlFrom.getKind() == IDENTIFIER) {
  96                     sqlParseResult.addSourceTable(sqlFrom.toString());
  97                 } else {
  98                     parentIsInsert = false;
  99                     parseNode(sqlFrom, sqlParseResult);
 100                 }
 101                 break;
 102             case JOIN:
 103                 SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 104                 SqlNode rightNode = ((SqlJoin)sqlNode).getRight();
 105 
 106                 if(leftNode.getKind() == IDENTIFIER){
 107                     sqlParseResult.addSourceTable(leftNode.toString());
 108                 }else{
 109                     parseNode(leftNode, sqlParseResult);
 110                 }
 111 
 112                 if(rightNode.getKind() == IDENTIFIER){
 113                     sqlParseResult.addSourceTable(rightNode.toString());
 114                 }else{
 115                     parseNode(rightNode, sqlParseResult);
 116                 }
 117                 break;
 118             case AS:
 119                 //不解析column,所以 as 相关的都是表
 120                 SqlNode identifierNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 121                 if(identifierNode.getKind() != IDENTIFIER){
 122                     parseNode(identifierNode, sqlParseResult);
 123                 }else {
 124                     sqlParseResult.addSourceTable(identifierNode.toString());
 125                 }
 126                 break;
 127             case MATCH_RECOGNIZE:
 128                 SqlMatchRecognize node = (SqlMatchRecognize) sqlNode;
 129                 sqlParseResult.addSourceTable(node.getTableRef().toString());
 130                 break;
 131             case UNION:
 132                 SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 133                 SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 134                 if(unionLeft.getKind() == IDENTIFIER){
 135                     sqlParseResult.addSourceTable(unionLeft.toString());
 136                 }else{
 137                     parseNode(unionLeft, sqlParseResult);
 138                 }
 139                 if(unionRight.getKind() == IDENTIFIER){
 140                     sqlParseResult.addSourceTable(unionRight.toString());
 141                 }else{
 142                     parseNode(unionRight, sqlParseResult);
 143                 }
 144                 break;
 145             case ORDER_BY:
 146                 SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 147                 parseNode(sqlOrderBy.query, sqlParseResult);
 148                 break;
 149             default:
 150                 //do nothing
 151                 break;
 152         }
 153     }
 154 
 155     /**
 156      * 将第一层 select 中的 sqlNode 转化为 AsNode，解决字段名冲突问题
 157      * 仅对 table.xx 这种类型的字段进行替换
 158      * @param selectList select Node 的 select 字段
 159      * @param sqlSelect 第一层解析出来的 selectNode
 160      */
 161     private static void rebuildSelectNode(SqlNodeList selectList, SqlSelect sqlSelect) {
 162         SqlNodeList sqlNodes = new SqlNodeList(selectList.getParserPosition());
 163 
 164         for (int index = 0; index &lt; selectList.size(); index++) {
 165 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 166 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 167             if (selectList.get(index).getKind().equals(SqlKind.AS)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 168                     || ((SqlIdentifier) selectList.get(index)).names.size() == 1) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 169                 sqlNodes.add(selectList.get(index));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 170                 continue;</span>
 171 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 172             if (!selectList.get(index).getClass().equals(SqlIdentifier.class)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 173                 throw new RuntimeException(String.format(&quot;Illegal statement! Please check the statement: %s&quot;,"> 173                 throw new RuntimeException(String.format(&quot;Illegal statement! Please check the statement: 🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 174                         selectList.get(index).toString()));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 175             }</span>
 176 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 177 
 178             if (selectList.get(index).getKind().equals(SqlKind.AS)
 179                     || (selectList.get(index).getClass().equals(SqlIdentifier.class)
 180                     &amp;&amp; ((SqlIdentifier) selectList.get(index)).names.size() == 1)) {
 181                 sqlNodes.add(selectList.get(index));
 182                 continue;
 183             }
 184 
 185             if (!selectList.get(index).getClass().equals(SqlIdentifier.class)) {
<abbr title=" 186                 throw new RuntimeException(String.format(&quot;Illegal statement! Please check the statement: %s&quot;,"> 186                 throw new RuntimeException(String.format(&quot;Illegal statement! Please check the statement: 🔵</abbr>
 187                         selectList.get(index).toString()));
 188             }
 189 
 190             sqlNodes.add(transformToAsNode(selectList.get(index)));
 191         }
 192         sqlSelect.setSelectList(sqlNodes);
 193     }
 194 
 195     /**
 196      * 将 sqlNode 转化为 AsNode
 197      * @param sqlNode 需要转化的 sqlNode
 198      * @return 重新构造的 AsNode
 199      */
 200     public static SqlBasicCall transformToAsNode(SqlNode sqlNode) {
 201         String asName = &quot;&quot;;
 202         SqlParserPos pos = new SqlParserPos(sqlNode.getParserPosition().getLineNum(),
 203                                             sqlNode.getParserPosition().getEndColumnNum());
 204         if (sqlNode.getKind().equals(SqlKind.IDENTIFIER)) {
 205             asName = ((SqlIdentifier) sqlNode).names.get(1);
 206         }
 207         SqlNode[] operands = new SqlNode[2];
 208         operands[0] = sqlNode;
 209         operands[1] = new SqlIdentifier(asName, null, pos);
 210         return new SqlBasicCall(new SqlAsOperator(), operands, pos);
 211     }
 212 
 213     public static class SqlParseResult {
 214 
 215         private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 216 
 217         private List&lt;String&gt; targetTableList = Lists.newArrayList();
 218 
 219         private String execSql;
 220 
 221         public void addSourceTable(String sourceTable){
 222             sourceTableList.add(sourceTable);
 223         }
 224 
 225         public void addTargetTable(String targetTable){
 226             targetTableList.add(targetTable);
 227         }
 228 
 229         public List&lt;String&gt; getSourceTableList() {
 230             return sourceTableList;
 231         }
 232 
 233         public List&lt;String&gt; getTargetTableList() {
 234             return targetTableList;
 235         }
 236 
 237         public String getExecSql() {
 238             return execSql;
 239         }
 240 
 241         public void setExecSql(String execSql) {
 242             this.execSql = execSql;
 243         }
 244     }
 245 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 
  20 package com.dtstack.flink.sql.parser;
  21 
  22 import org.apache.calcite.sql.SqlInsert;
  23 import org.apache.calcite.sql.SqlJoin;
  24 import org.apache.calcite.sql.SqlKind;
  25 import org.apache.calcite.sql.SqlNode;
  26 import org.apache.calcite.sql.SqlSelect;
  27 import org.apache.calcite.sql.SqlNodeList;
  28 import org.apache.calcite.sql.SqlBasicCall;
  29 import org.apache.calcite.sql.SqlMatchRecognize;
  30 import org.apache.calcite.sql.SqlOrderBy;
  31 import org.apache.calcite.sql.SqlIdentifier;
  32 import org.apache.calcite.sql.SqlAsOperator;
  33 import org.apache.calcite.sql.parser.SqlParserPos;
  34 import org.apache.commons.lang3.StringUtils;
  35 import com.google.common.collect.Lists;
  36 import org.apache.flink.table.planner.calcite.FlinkPlannerImpl;
  37 
  38 import java.util.List;
  39 
  40 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  41 
  42 /**
  43  * 解析flink sql
  44  * sql 只支持 insert 开头的
  45  * Date: 2018/6/22
  46  * Company: www.dtstack.com
  47  * @author xuchao
  48  */
  49 
  50 public class InsertSqlParser implements IParser {
  51 
  52     private FlinkPlanner flinkPlanner = new FlinkPlanner();
  53 
  54     // 用来标识当前解析节点的上一层节点是否为 insert 节点
  55     private static Boolean parentIsInsert = false;
  56 
  57     @Override
  58     public boolean verify(String sql) {
  59         return StringUtils.isNotBlank(sql) &amp;&amp; sql.trim().toLowerCase().startsWith(&quot;insert&quot;);
  60     }
  61 
  62     public static InsertSqlParser newInstance(){
  63         InsertSqlParser parser = new InsertSqlParser();
  64         return parser;
  65     }
  66 
  67     @Override
  68     public void parseSql(String sql, SqlTree sqlTree) throws Exception {
  69 
  70 
  71         SqlNode sqlNode = flinkPlanner.getParser().parse(sql);
  72 
  73         SqlParseResult sqlParseResult = new SqlParseResult();
  74         parseNode(sqlNode, sqlParseResult);
  75         sqlParseResult.setExecSql(sqlNode.toString());
  76         sqlTree.addExecSql(sqlParseResult);
  77     }
  78 
  79     private static void parseNode(SqlNode sqlNode, SqlParseResult sqlParseResult){
  80         SqlKind sqlKind = sqlNode.getKind();
  81         switch (sqlKind){
  82             case INSERT:
  83                 SqlNode sqlTarget = ((SqlInsert)sqlNode).getTargetTable();
  84                 SqlNode sqlSource = ((SqlInsert)sqlNode).getSource();
  85                 sqlParseResult.addTargetTable(sqlTarget.toString());
  86                 parentIsInsert = true;
  87                 parseNode(sqlSource, sqlParseResult);
  88                 break;
  89             case SELECT:
  90                 SqlSelect sqlSelect = (SqlSelect) sqlNode;
  91                 if (parentIsInsert) {
  92                     rebuildSelectNode(sqlSelect.getSelectList(), sqlSelect);
  93                 }
  94                 SqlNode sqlFrom = ((SqlSelect) sqlNode).getFrom();
  95                 if (sqlFrom.getKind() == IDENTIFIER) {
  96                     sqlParseResult.addSourceTable(sqlFrom.toString());
  97                 } else {
  98                     parentIsInsert = false;
  99                     parseNode(sqlFrom, sqlParseResult);
 100                 }
 101                 break;
 102             case JOIN:
 103                 SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 104                 SqlNode rightNode = ((SqlJoin)sqlNode).getRight();
 105 
 106                 if(leftNode.getKind() == IDENTIFIER){
 107                     sqlParseResult.addSourceTable(leftNode.toString());
 108                 }else{
 109                     parseNode(leftNode, sqlParseResult);
 110                 }
 111 
 112                 if(rightNode.getKind() == IDENTIFIER){
 113                     sqlParseResult.addSourceTable(rightNode.toString());
 114                 }else{
 115                     parseNode(rightNode, sqlParseResult);
 116                 }
 117                 break;
 118             case AS:
 119                 //不解析column,所以 as 相关的都是表
 120                 SqlNode identifierNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 121                 if(identifierNode.getKind() != IDENTIFIER){
 122                     parseNode(identifierNode, sqlParseResult);
 123                 }else {
 124                     sqlParseResult.addSourceTable(identifierNode.toString());
 125                 }
 126                 break;
 127             case MATCH_RECOGNIZE:
 128                 SqlMatchRecognize node = (SqlMatchRecognize) sqlNode;
 129                 sqlParseResult.addSourceTable(node.getTableRef().toString());
 130                 break;
 131             case UNION:
 132                 SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 133                 SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 134                 if(unionLeft.getKind() == IDENTIFIER){
 135                     sqlParseResult.addSourceTable(unionLeft.toString());
 136                 }else{
 137                     parseNode(unionLeft, sqlParseResult);
 138                 }
 139                 if(unionRight.getKind() == IDENTIFIER){
 140                     sqlParseResult.addSourceTable(unionRight.toString());
 141                 }else{
 142                     parseNode(unionRight, sqlParseResult);
 143                 }
 144                 break;
 145             case ORDER_BY:
 146                 SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 147                 parseNode(sqlOrderBy.query, sqlParseResult);
 148                 break;
 149             default:
 150                 //do nothing
 151                 break;
 152         }
 153     }
 154 
 155     /**
 156      * 将第一层 select 中的 sqlNode 转化为 AsNode，解决字段名冲突问题
 157      * 仅对 table.xx 这种类型的字段进行替换
 158      * @param selectList select Node 的 select 字段
 159      * @param sqlSelect 第一层解析出来的 selectNode
 160      */
 161     private static void rebuildSelectNode(SqlNodeList selectList, SqlSelect sqlSelect) {
 162         SqlNodeList sqlNodes = new SqlNodeList(selectList.getParserPosition());
 163 
 164         for (int index = 0; index &lt; selectList.size(); index++) {
 165 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
 166 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 167             if (selectList.get(index).getKind().equals(SqlKind.AS)</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 168                     || ((SqlIdentifier) selectList.get(index)).names.size() == 1) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 169                 sqlNodes.add(selectList.get(index));</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 170                 continue;</span>
 171 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 172             if (!selectList.get(index).getClass().equals(SqlIdentifier.class)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 173                 throw new RuntimeException(String.format(&quot;Illegal statement! Please check the statement: %s&quot;,"> 173                 throw new RuntimeException(String.format(&quot;Illegal statement! Please check the statement: 🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 174                         selectList.get(index).toString()));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 175             }</span>
 176 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 177 
 178             if (selectList.get(index).getKind().equals(SqlKind.AS)
 179                     || (selectList.get(index).getClass().equals(SqlIdentifier.class)
 180                     &amp;&amp; ((SqlIdentifier) selectList.get(index)).names.size() == 1)) {
 181                 sqlNodes.add(selectList.get(index));
 182                 continue;
 183             }
 184 
 185             if (!selectList.get(index).getClass().equals(SqlIdentifier.class)) {
<abbr title=" 186                 throw new RuntimeException(String.format(&quot;Illegal statement! Please check the statement: %s&quot;,"> 186                 throw new RuntimeException(String.format(&quot;Illegal statement! Please check the statement: 🔵</abbr>
 187                         selectList.get(index).toString()));
 188             }
 189 
 190             sqlNodes.add(transformToAsNode(selectList.get(index)));
 191         }
 192         sqlSelect.setSelectList(sqlNodes);
 193     }
 194 
 195     /**
 196      * 将 sqlNode 转化为 AsNode
 197      * @param sqlNode 需要转化的 sqlNode
 198      * @return 重新构造的 AsNode
 199      */
 200     public static SqlBasicCall transformToAsNode(SqlNode sqlNode) {
 201         String asName = &quot;&quot;;
 202         SqlParserPos pos = new SqlParserPos(sqlNode.getParserPosition().getLineNum(),
 203                                             sqlNode.getParserPosition().getEndColumnNum());
 204         if (sqlNode.getKind().equals(SqlKind.IDENTIFIER)) {
 205             asName = ((SqlIdentifier) sqlNode).names.get(1);
 206         }
 207         SqlNode[] operands = new SqlNode[2];
 208         operands[0] = sqlNode;
 209         operands[1] = new SqlIdentifier(asName, null, pos);
 210         return new SqlBasicCall(new SqlAsOperator(), operands, pos);
 211     }
 212 
 213     public static class SqlParseResult {
 214 
 215         private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 216 
 217         private List&lt;String&gt; targetTableList = Lists.newArrayList();
 218 
 219         private String execSql;
 220 
 221         public void addSourceTable(String sourceTable){
 222             sourceTableList.add(sourceTable);
 223         }
 224 
 225         public void addTargetTable(String targetTable){
 226             targetTableList.add(targetTable);
 227         }
 228 
 229         public List&lt;String&gt; getSourceTableList() {
 230             return sourceTableList;
 231         }
 232 
 233         public List&lt;String&gt; getTargetTableList() {
 234             return targetTableList;
 235         }
 236 
 237         public String getExecSql() {
 238             return execSql;
 239         }
 240 
 241         public void setExecSql(String execSql) {
 242             this.execSql = execSql;
 243         }
 244     }
 245 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.parser;
  19 
  20 import com.google.common.collect.Lists;
  21 import java.util.List;
  22 import org.apache.calcite.sql.SqlAsOperator;
  23 import org.apache.calcite.sql.SqlBasicCall;
  24 import org.apache.calcite.sql.SqlIdentifier;
  25 import org.apache.calcite.sql.SqlInsert;
  26 import org.apache.calcite.sql.SqlJoin;
  27 import org.apache.calcite.sql.SqlKind;
  28 import org.apache.calcite.sql.SqlMatchRecognize;
  29 import org.apache.calcite.sql.SqlNode;
  30 import org.apache.calcite.sql.SqlNodeList;
  31 import org.apache.calcite.sql.SqlOrderBy;
  32 import org.apache.calcite.sql.SqlSelect;
  33 import org.apache.calcite.sql.parser.SqlParserPos;
  34 import org.apache.commons.lang3.StringUtils;
  35 import org.apache.flink.table.planner.calcite.FlinkPlannerImpl;
  36 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  37 
  38 
  39 /**
  40  * 解析flink sql
  41  * sql 只支持 insert 开头的
  42  * Date: 2018/6/22
  43  * Company: www.dtstack.com
  44  * @author xuchao
  45  */
  46 public class InsertSqlParser implements IParser {
  47     private FlinkPlanner flinkPlanner = new FlinkPlanner();
  48 
  49     // 用来标识当前解析节点的上一层节点是否为 insert 节点
  50     // 用来标识当前解析节点的上一层节点是否为 insert 节点
  51     private static Boolean parentIsInsert = false;
  52 
  53     @Override
  54     public boolean verify(String sql) {
  55         return StringUtils.isNotBlank(sql) &amp;&amp; sql.trim().toLowerCase().startsWith(&quot;insert&quot;);
  56     }
  57 
  58     public static InsertSqlParser newInstance(){
  59         InsertSqlParser parser = new InsertSqlParser();
  60         return parser;
  61     }
  62 
  63     @Override
  64     public void parseSql(String sql, SqlTree sqlTree) throws Exception {
  65 
  66 
  67         SqlNode sqlNode = flinkPlanner.getParser().parse(sql);
  68 
  69         SqlParseResult sqlParseResult = new SqlParseResult();
  70         parseNode(sqlNode, sqlParseResult);
  71         sqlParseResult.setExecSql(sqlNode.toString());
  72         sqlTree.addExecSql(sqlParseResult);
  73     }
  74 
  75     private static void parseNode(SqlNode sqlNode, SqlParseResult sqlParseResult){
  76         SqlKind sqlKind = sqlNode.getKind();
  77         switch (sqlKind){
  78             case INSERT:
  79                 SqlNode sqlTarget = ((SqlInsert)sqlNode).getTargetTable();
  80                 SqlNode sqlSource = ((SqlInsert)sqlNode).getSource();
  81                 sqlParseResult.addTargetTable(sqlTarget.toString());
  82                 parentIsInsert = true;
  83                 parseNode(sqlSource, sqlParseResult);
  84                 break;
  85             case SELECT:
  86                 SqlSelect sqlSelect = (SqlSelect) sqlNode;
  87                 if (parentIsInsert) {
  88                     rebuildSelectNode(sqlSelect.getSelectList(), sqlSelect);
  89                 }
  90                 SqlNode sqlFrom = ((SqlSelect) sqlNode).getFrom();
  91                 if (sqlFrom.getKind() == IDENTIFIER) {
  92                     sqlParseResult.addSourceTable(sqlFrom.toString());
  93                 } else {
  94                     parentIsInsert = false;
  95                     parseNode(sqlFrom, sqlParseResult);
  96                 }
  97                 break;
  98             case JOIN:
  99                 SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 100                 SqlNode rightNode = ((SqlJoin)sqlNode).getRight();
 101 
 102                 if(leftNode.getKind() == IDENTIFIER){
 103                     sqlParseResult.addSourceTable(leftNode.toString());
 104                 }else{
 105                     parseNode(leftNode, sqlParseResult);
 106                 }
 107 
 108                 if(rightNode.getKind() == IDENTIFIER){
 109                     sqlParseResult.addSourceTable(rightNode.toString());
 110                 }else{
 111                     parseNode(rightNode, sqlParseResult);
 112                 }
 113                 break;
 114             case AS:
 115                 //不解析column,所以 as 相关的都是表
 116                 SqlNode identifierNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 117                 if(identifierNode.getKind() != IDENTIFIER){
 118                     parseNode(identifierNode, sqlParseResult);
 119                 }else {
 120                     sqlParseResult.addSourceTable(identifierNode.toString());
 121                 }
 122                 break;
 123             case MATCH_RECOGNIZE:
 124                 SqlMatchRecognize node = (SqlMatchRecognize) sqlNode;
 125                 sqlParseResult.addSourceTable(node.getTableRef().toString());
 126                 break;
 127             case UNION:
 128                 SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 129                 SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 130                 if(unionLeft.getKind() == IDENTIFIER){
 131                     sqlParseResult.addSourceTable(unionLeft.toString());
 132                 }else{
 133                     parseNode(unionLeft, sqlParseResult);
 134                 }
 135                 if(unionRight.getKind() == IDENTIFIER){
 136                     sqlParseResult.addSourceTable(unionRight.toString());
 137                 }else{
 138                     parseNode(unionRight, sqlParseResult);
 139                 }
 140                 break;
 141             case ORDER_BY:
 142                 SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 143                 parseNode(sqlOrderBy.query, sqlParseResult);
 144                 break;
 145             default:
 146                 //do nothing
 147                 break;
 148         }
 149     }
 150 
 151     /**
 152      * 将第一层 select 中的 sqlNode 转化为 AsNode，解决字段名冲突问题
 153      * 仅对 table.xx 这种类型的字段进行替换
 154      * @param selectList select Node 的 select 字段
 155      * @param sqlSelect 第一层解析出来的 selectNode
 156      */
 157     private static void rebuildSelectNode(SqlNodeList selectList, SqlSelect sqlSelect) {
 158         SqlNodeList sqlNodes = new SqlNodeList(selectList.getParserPosition());
 159         for (int index = 0; index &lt; selectList.size(); index++) {
 160 
 161 &lt;&lt;&lt;&lt;&lt;&lt;&lt; LEFT
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 162 </span>
 163 ||||||| BASE
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"><abbr title=" 164 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kwohrp23k5b6vdk93d3r*/"> 164 /*d94z9sk0k4hf9j3ijd - note the base isn&#x27;t actually empty, spork simply doesn&#x27;t generate a base - gd930kw🔵</abbr></span>
 165 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 166 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 167             if (!selectList.get(index).getClass().equals(SqlIdentifier.class)) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"><abbr title=" 168                 throw new RuntimeException(String.format(&quot;Illegal statement! Please check the statement: %s&quot;,"> 168                 throw new RuntimeException(String.format(&quot;Illegal statement! Please check the statement: 🔵</abbr></span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 169                         selectList.get(index).toString()));</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 170             }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0"> 171 </span>
 172 &gt;&gt;&gt;&gt;&gt;&gt;&gt; RIGHT
 173 
 174             if (selectList.get(index).getKind().equals(SqlKind.AS)
 175                     || (selectList.get(index).getClass().equals(SqlIdentifier.class)
 176                     &amp;&amp; ((SqlIdentifier) selectList.get(index)).names.size() == 1)) {
 177                 sqlNodes.add(selectList.get(index));
 178                 continue;
 179             }
 180 
 181             if (!selectList.get(index).getClass().equals(SqlIdentifier.class)) {
<abbr title=" 182                 throw new RuntimeException(String.format(&quot;Illegal statement! Please check the statement: %s&quot;,"> 182                 throw new RuntimeException(String.format(&quot;Illegal statement! Please check the statement: 🔵</abbr>
 183                         selectList.get(index).toString()));
 184             }
 185 
 186             sqlNodes.add(transformToAsNode(selectList.get(index)));
 187         }
 188         sqlSelect.setSelectList(sqlNodes);
 189     }
 190 
 191     /**
 192      * 将 sqlNode 转化为 AsNode
 193      * @param sqlNode 需要转化的 sqlNode
 194      * @return 重新构造的 AsNode
 195      */
 196     public static SqlBasicCall transformToAsNode(SqlNode sqlNode) {
 197         String asName = &quot;&quot;;
 198         SqlParserPos pos = new SqlParserPos(sqlNode.getParserPosition().getLineNum(),
 199                                             sqlNode.getParserPosition().getEndColumnNum());
 200         if (sqlNode.getKind().equals(SqlKind.IDENTIFIER)) {
 201             asName = ((SqlIdentifier) sqlNode).names.get(1);
 202         }
 203         SqlNode[] operands = new SqlNode[2];
 204         operands[0] = sqlNode;
 205         operands[1] = new SqlIdentifier(asName, null, pos);
 206         return new SqlBasicCall(new SqlAsOperator(), operands, pos);
 207     }
 208 
 209     public static class SqlParseResult {
 210         private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 211 
 212         private List&lt;String&gt; targetTableList = Lists.newArrayList();
 213 
 214         private String execSql;
 215 
 216         public void addSourceTable(String sourceTable) {
 217             sourceTableList.add(sourceTable);
 218         }
 219 
 220         public void addTargetTable(String targetTable) {
 221             targetTableList.add(targetTable);
 222         }
 223 
 224         public List&lt;String&gt; getSourceTableList() {
 225             return sourceTableList;
 226         }
 227 
 228         public List&lt;String&gt; getTargetTableList() {
 229             return targetTableList;
 230         }
 231 
 232         public String getExecSql() {
 233             return execSql;
 234         }
 235 
 236         public void setExecSql(String execSql) {
 237             this.execSql = execSql;
 238         }
 239     }
 240 }
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.parser;
  21  
  22  import org.apache.calcite.sql.SqlInsert;
  23  import org.apache.calcite.sql.SqlJoin;
  24  import org.apache.calcite.sql.SqlKind;
  25  import org.apache.calcite.sql.SqlNode;
  26  import org.apache.calcite.sql.SqlSelect;
  27  import org.apache.calcite.sql.SqlNodeList;
  28  import org.apache.calcite.sql.SqlBasicCall;
  29  import org.apache.calcite.sql.SqlMatchRecognize;
  30  import org.apache.calcite.sql.SqlOrderBy;
  31  import org.apache.calcite.sql.SqlIdentifier;
  32  import org.apache.calcite.sql.SqlAsOperator;
  33  import org.apache.calcite.sql.parser.SqlParserPos;
  34  import org.apache.commons.lang3.StringUtils;
  35  import com.google.common.collect.Lists;
  36  import org.apache.flink.table.planner.calcite.FlinkPlannerImpl;
  37  
  38  import java.util.List;
  39  
  40  import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  41  
  42  /**
  43   * 解析flink sql
  44   * sql 只支持 insert 开头的
  45   * Date: 2018/6/22
  46   * Company: www.dtstack.com
  47   * @author xuchao
  48   */
  49  
  50  public class InsertSqlParser implements IParser {
  51  
  52      private FlinkPlanner flinkPlanner = new FlinkPlanner();
  53  
  54      // 用来标识当前解析节点的上一层节点是否为 insert 节点
  55      private static Boolean parentIsInsert = false;
  56  
  57      @Override
  58      public boolean verify(String sql) {
  59          return StringUtils.isNotBlank(sql) &amp;&amp; sql.trim().toLowerCase().startsWith(&quot;insert&quot;);
  60      }
  61  
  62      public static InsertSqlParser newInstance(){
  63          InsertSqlParser parser = new InsertSqlParser();
  64          return parser;
  65      }
  66  
  67      @Override
  68      public void parseSql(String sql, SqlTree sqlTree) throws Exception {
  69  
  70  
  71          SqlNode sqlNode = flinkPlanner.getParser().parse(sql);
  72  
  73          SqlParseResult sqlParseResult = new SqlParseResult();
  74          parseNode(sqlNode, sqlParseResult);
  75          sqlParseResult.setExecSql(sqlNode.toString());
  76          sqlTree.addExecSql(sqlParseResult);
  77      }
  78  
  79      private static void parseNode(SqlNode sqlNode, SqlParseResult sqlParseResult){
  80          SqlKind sqlKind = sqlNode.getKind();
  81          switch (sqlKind){
  82              case INSERT:
  83                  SqlNode sqlTarget = ((SqlInsert)sqlNode).getTargetTable();
  84                  SqlNode sqlSource = ((SqlInsert)sqlNode).getSource();
  85                  sqlParseResult.addTargetTable(sqlTarget.toString());
  86                  parentIsInsert = true;
  87                  parseNode(sqlSource, sqlParseResult);
  88                  break;
  89              case SELECT:
  90                  SqlSelect sqlSelect = (SqlSelect) sqlNode;
  91                  if (parentIsInsert) {
  92                      rebuildSelectNode(sqlSelect.getSelectList(), sqlSelect);
  93                  }
  94                  SqlNode sqlFrom = ((SqlSelect) sqlNode).getFrom();
  95                  if (sqlFrom.getKind() == IDENTIFIER) {
  96                      sqlParseResult.addSourceTable(sqlFrom.toString());
  97                  } else {
  98                      parentIsInsert = false;
  99                      parseNode(sqlFrom, sqlParseResult);
 100                  }
 101                  break;
 102              case JOIN:
 103                  SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 104                  SqlNode rightNode = ((SqlJoin)sqlNode).getRight();
 105  
 106                  if(leftNode.getKind() == IDENTIFIER){
 107                      sqlParseResult.addSourceTable(leftNode.toString());
 108                  }else{
 109                      parseNode(leftNode, sqlParseResult);
 110                  }
 111  
 112                  if(rightNode.getKind() == IDENTIFIER){
 113                      sqlParseResult.addSourceTable(rightNode.toString());
 114                  }else{
 115                      parseNode(rightNode, sqlParseResult);
 116                  }
 117                  break;
 118              case AS:
 119                  //不解析column,所以 as 相关的都是表
 120                  SqlNode identifierNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 121                  if(identifierNode.getKind() != IDENTIFIER){
 122                      parseNode(identifierNode, sqlParseResult);
 123                  }else {
 124                      sqlParseResult.addSourceTable(identifierNode.toString());
 125                  }
 126                  break;
 127              case MATCH_RECOGNIZE:
 128                  SqlMatchRecognize node = (SqlMatchRecognize) sqlNode;
 129                  sqlParseResult.addSourceTable(node.getTableRef().toString());
 130                  break;
 131              case UNION:
 132                  SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 133                  SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 134                  if(unionLeft.getKind() == IDENTIFIER){
 135                      sqlParseResult.addSourceTable(unionLeft.toString());
 136                  }else{
 137                      parseNode(unionLeft, sqlParseResult);
 138                  }
 139                  if(unionRight.getKind() == IDENTIFIER){
 140                      sqlParseResult.addSourceTable(unionRight.toString());
 141                  }else{
 142                      parseNode(unionRight, sqlParseResult);
 143                  }
 144                  break;
 145              case ORDER_BY:
 146                  SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 147                  parseNode(sqlOrderBy.query, sqlParseResult);
 148                  break;
 149              default:
 150                  //do nothing
 151                  break;
 152          }
 153      }
 154  
 155      /**
 156       * 将第一层 select 中的 sqlNode 转化为 AsNode，解决字段名冲突问题
 157       * 仅对 table.xx 这种类型的字段进行替换
 158       * @param selectList select Node 的 select 字段
 159       * @param sqlSelect 第一层解析出来的 selectNode
 160       */
 161      private static void rebuildSelectNode(SqlNodeList selectList, SqlSelect sqlSelect) {
 162          SqlNodeList sqlNodes = new SqlNodeList(selectList.getParserPosition());
 163  
 164          for (int index = 0; index &lt; selectList.size(); index++) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +</span>




 166              if (selectList.get(index).getKind().equals(SqlKind.AS)
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 167 -                    || ((SqlIdentifier) selectList.get(index)).names.size() == 1) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +                    || (selectList.get(index).getClass().equals(SqlIdentifier.class)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +                    &amp;&amp; ((SqlIdentifier) selectList.get(index)).names.size() == 1)) {</span>
 170                  sqlNodes.add(selectList.get(index));
 171                  continue;
 172              }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 173 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +            if (!selectList.get(index).getClass().equals(SqlIdentifier.class)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +                throw new RuntimeException(String.format(&quot;Illegal statement! Please check the statement: %s&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 176 +                        selectList.get(index).toString()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 177 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 178 +</span>
 179              sqlNodes.add(transformToAsNode(selectList.get(index)));
 180          }
 181          sqlSelect.setSelectList(sqlNodes);
 182      }
 183  
 184      /**
 185       * 将 sqlNode 转化为 AsNode
 186       * @param sqlNode 需要转化的 sqlNode
 187       * @return 重新构造的 AsNode
 188       */
 189      public static SqlBasicCall transformToAsNode(SqlNode sqlNode) {
 190          String asName = &quot;&quot;;
 191          SqlParserPos pos = new SqlParserPos(sqlNode.getParserPosition().getLineNum(),
 192                                              sqlNode.getParserPosition().getEndColumnNum());
 193          if (sqlNode.getKind().equals(SqlKind.IDENTIFIER)) {
 194              asName = ((SqlIdentifier) sqlNode).names.get(1);
 195          }
 196          SqlNode[] operands = new SqlNode[2];
 197          operands[0] = sqlNode;
 198          operands[1] = new SqlIdentifier(asName, null, pos);
 199          return new SqlBasicCall(new SqlAsOperator(), operands, pos);
 200      }
 201  
 202      public static class SqlParseResult {
 203  
 204          private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 205  
 206          private List&lt;String&gt; targetTableList = Lists.newArrayList();
 207  
 208          private String execSql;
 209  
 210          public void addSourceTable(String sourceTable){
 211              sourceTableList.add(sourceTable);
 212          }
 213  
 214          public void addTargetTable(String targetTable){
 215              targetTableList.add(targetTable);
 216          }
 217  
 218          public List&lt;String&gt; getSourceTableList() {
 219              return sourceTableList;
 220          }
 221  
 222          public List&lt;String&gt; getTargetTableList() {
 223              return targetTableList;
 224          }
 225  
 226          public String getExecSql() {
 227              return execSql;
 228          }
 229  
 230          public void setExecSql(String execSql) {
 231              this.execSql = execSql;
 232          }
 233      }
 234  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  
  20  package com.dtstack.flink.sql.parser;
  21  
  22  import org.apache.calcite.sql.SqlInsert;
  23  import org.apache.calcite.sql.SqlJoin;
  24  import org.apache.calcite.sql.SqlKind;
  25  import org.apache.calcite.sql.SqlNode;
  26  import org.apache.calcite.sql.SqlSelect;
  27  import org.apache.calcite.sql.SqlNodeList;
  28  import org.apache.calcite.sql.SqlBasicCall;
  29  import org.apache.calcite.sql.SqlMatchRecognize;
  30  import org.apache.calcite.sql.SqlOrderBy;
  31  import org.apache.calcite.sql.SqlIdentifier;
  32  import org.apache.calcite.sql.SqlAsOperator;
  33  import org.apache.calcite.sql.parser.SqlParserPos;
  34  import org.apache.commons.lang3.StringUtils;
  35  import com.google.common.collect.Lists;
  36  import org.apache.flink.table.planner.calcite.FlinkPlannerImpl;
  37  
  38  import java.util.List;
  39  
  40  import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  41  
  42  /**
  43   * 解析flink sql
  44   * sql 只支持 insert 开头的
  45   * Date: 2018/6/22
  46   * Company: www.dtstack.com
  47   * @author xuchao
  48   */
  49  
  50  public class InsertSqlParser implements IParser {
  51  
  52      private FlinkPlanner flinkPlanner = new FlinkPlanner();
  53  
  54      // 用来标识当前解析节点的上一层节点是否为 insert 节点
  55      private static Boolean parentIsInsert = false;
  56  
  57      @Override
  58      public boolean verify(String sql) {
  59          return StringUtils.isNotBlank(sql) &amp;&amp; sql.trim().toLowerCase().startsWith(&quot;insert&quot;);
  60      }
  61  
  62      public static InsertSqlParser newInstance(){
  63          InsertSqlParser parser = new InsertSqlParser();
  64          return parser;
  65      }
  66  
  67      @Override
  68      public void parseSql(String sql, SqlTree sqlTree) throws Exception {
  69  
  70  
  71          SqlNode sqlNode = flinkPlanner.getParser().parse(sql);
  72  
  73          SqlParseResult sqlParseResult = new SqlParseResult();
  74          parseNode(sqlNode, sqlParseResult);
  75          sqlParseResult.setExecSql(sqlNode.toString());
  76          sqlTree.addExecSql(sqlParseResult);
  77      }
  78  
  79      private static void parseNode(SqlNode sqlNode, SqlParseResult sqlParseResult){
  80          SqlKind sqlKind = sqlNode.getKind();
  81          switch (sqlKind){
  82              case INSERT:
  83                  SqlNode sqlTarget = ((SqlInsert)sqlNode).getTargetTable();
  84                  SqlNode sqlSource = ((SqlInsert)sqlNode).getSource();
  85                  sqlParseResult.addTargetTable(sqlTarget.toString());
  86                  parentIsInsert = true;
  87                  parseNode(sqlSource, sqlParseResult);
  88                  break;
  89              case SELECT:
  90                  SqlSelect sqlSelect = (SqlSelect) sqlNode;
  91                  if (parentIsInsert) {
  92                      rebuildSelectNode(sqlSelect.getSelectList(), sqlSelect);
  93                  }
  94                  SqlNode sqlFrom = ((SqlSelect) sqlNode).getFrom();
  95                  if (sqlFrom.getKind() == IDENTIFIER) {
  96                      sqlParseResult.addSourceTable(sqlFrom.toString());
  97                  } else {
  98                      parentIsInsert = false;
  99                      parseNode(sqlFrom, sqlParseResult);
 100                  }
 101                  break;
 102              case JOIN:
 103                  SqlNode leftNode = ((SqlJoin)sqlNode).getLeft();
 104                  SqlNode rightNode = ((SqlJoin)sqlNode).getRight();
 105  
 106                  if(leftNode.getKind() == IDENTIFIER){
 107                      sqlParseResult.addSourceTable(leftNode.toString());
 108                  }else{
 109                      parseNode(leftNode, sqlParseResult);
 110                  }
 111  
 112                  if(rightNode.getKind() == IDENTIFIER){
 113                      sqlParseResult.addSourceTable(rightNode.toString());
 114                  }else{
 115                      parseNode(rightNode, sqlParseResult);
 116                  }
 117                  break;
 118              case AS:
 119                  //不解析column,所以 as 相关的都是表
 120                  SqlNode identifierNode = ((SqlBasicCall)sqlNode).getOperands()[0];
 121                  if(identifierNode.getKind() != IDENTIFIER){
 122                      parseNode(identifierNode, sqlParseResult);
 123                  }else {
 124                      sqlParseResult.addSourceTable(identifierNode.toString());
 125                  }
 126                  break;
 127              case MATCH_RECOGNIZE:
 128                  SqlMatchRecognize node = (SqlMatchRecognize) sqlNode;
 129                  sqlParseResult.addSourceTable(node.getTableRef().toString());
 130                  break;
 131              case UNION:
 132                  SqlNode unionLeft = ((SqlBasicCall)sqlNode).getOperands()[0];
 133                  SqlNode unionRight = ((SqlBasicCall)sqlNode).getOperands()[1];
 134                  if(unionLeft.getKind() == IDENTIFIER){
 135                      sqlParseResult.addSourceTable(unionLeft.toString());
 136                  }else{
 137                      parseNode(unionLeft, sqlParseResult);
 138                  }
 139                  if(unionRight.getKind() == IDENTIFIER){
 140                      sqlParseResult.addSourceTable(unionRight.toString());
 141                  }else{
 142                      parseNode(unionRight, sqlParseResult);
 143                  }
 144                  break;
 145              case ORDER_BY:
 146                  SqlOrderBy sqlOrderBy  = (SqlOrderBy) sqlNode;
 147                  parseNode(sqlOrderBy.query, sqlParseResult);
 148                  break;
 149              default:
 150                  //do nothing
 151                  break;
 152          }
 153      }
 154  
 155      /**
 156       * 将第一层 select 中的 sqlNode 转化为 AsNode，解决字段名冲突问题
 157       * 仅对 table.xx 这种类型的字段进行替换
 158       * @param selectList select Node 的 select 字段
 159       * @param sqlSelect 第一层解析出来的 selectNode
 160       */
 161      private static void rebuildSelectNode(SqlNodeList selectList, SqlSelect sqlSelect) {
 162          SqlNodeList sqlNodes = new SqlNodeList(selectList.getParserPosition());
 163  
 164          for (int index = 0; index &lt; selectList.size(); index++) {
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +            if (!selectList.get(index).getClass().equals(SqlIdentifier.class)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +                throw new RuntimeException(String.format(&quot;Illegal statement! Please check the statement: %s&quot;,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 167 +                        selectList.get(index).toString()));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +</span>
 170              if (selectList.get(index).getKind().equals(SqlKind.AS)
 171                      || ((SqlIdentifier) selectList.get(index)).names.size() == 1) {


 172                  sqlNodes.add(selectList.get(index));
 173                  continue;
 174              }






 175              sqlNodes.add(transformToAsNode(selectList.get(index)));
 176          }
 177          sqlSelect.setSelectList(sqlNodes);
 178      }
 179  
 180      /**
 181       * 将 sqlNode 转化为 AsNode
 182       * @param sqlNode 需要转化的 sqlNode
 183       * @return 重新构造的 AsNode
 184       */
 185      public static SqlBasicCall transformToAsNode(SqlNode sqlNode) {
 186          String asName = &quot;&quot;;
 187          SqlParserPos pos = new SqlParserPos(sqlNode.getParserPosition().getLineNum(),
 188                                              sqlNode.getParserPosition().getEndColumnNum());
 189          if (sqlNode.getKind().equals(SqlKind.IDENTIFIER)) {
 190              asName = ((SqlIdentifier) sqlNode).names.get(1);
 191          }
 192          SqlNode[] operands = new SqlNode[2];
 193          operands[0] = sqlNode;
 194          operands[1] = new SqlIdentifier(asName, null, pos);
 195          return new SqlBasicCall(new SqlAsOperator(), operands, pos);
 196      }
 197  
 198      public static class SqlParseResult {
 199  
 200          private List&lt;String&gt; sourceTableList = Lists.newArrayList();
 201  
 202          private List&lt;String&gt; targetTableList = Lists.newArrayList();
 203  
 204          private String execSql;
 205  
 206          public void addSourceTable(String sourceTable){
 207              sourceTableList.add(sourceTable);
 208          }
 209  
 210          public void addTargetTable(String targetTable){
 211              targetTableList.add(targetTable);
 212          }
 213  
 214          public List&lt;String&gt; getSourceTableList() {
 215              return sourceTableList;
 216          }
 217  
 218          public List&lt;String&gt; getTargetTableList() {
 219              return targetTableList;
 220          }
 221  
 222          public String getExecSql() {
 223              return execSql;
 224          }
 225  
 226          public void setExecSql(String execSql) {
 227              this.execSql = execSql;
 228          }
 229      }
 230  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            