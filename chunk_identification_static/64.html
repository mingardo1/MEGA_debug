<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>64</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    64
                    <a href="63.html">prev</a>
                    <a href="65.html">next</a>
                    <a href="64_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    AriaLyy/Aria_99d857f3383c60ae4ae008f74e7d2b32afe9c26a_Aria/src/main/java/com/arialyy/aria/util/BufferedRandomAccessFile.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;99d857f3383c60ae4ae008f74e7d2b32afe9c26a:Aria/src/main/java/com/arialyy/aria/util/BufferedRandomAccessFile.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;99d857f3383c60ae4ae008f74e7d2b32afe9c26a^1:Aria/src/main/java/com/arialyy/aria/util/BufferedRandomAccessFile.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;99d857f3383c60ae4ae008f74e7d2b32afe9c26a^2:Aria/src/main/java/com/arialyy/aria/util/BufferedRandomAccessFile.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\AriaLyy\Aria show &quot;41154d47fb8664ddca206122d28b50a6a3b8e9a6:Aria/src/main/java/com/arialyy/aria/util/BufferedRandomAccessFile.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[bj]], subset: [[bj]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /**
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  * http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.arialyy.aria.util;
  20 
  21 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  22 import java.io.*;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  23 import java.util.Arrays;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  24 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  25 //import org.apache.log4j.Logger;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  26 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  27 /**</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  28  * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like a</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  29  * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a private buffer so that most</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  30  * operations do not require a disk access.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  31  * &lt;P&gt;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  32  *</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  33  * Note: The operations on this class are unmonitored. Also, the correct</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  34  * functioning of the &lt;code&gt;RandomAccessFile&lt;/code&gt; methods that are not</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  35  * overridden here relies on the implementation of those methods in the</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  36  * superclass.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  37  * Author : Avinash Lakshman ( alakshman@facebook.com) Prashant Malik ( pmalik@facebook.com )</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  38  */</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  39 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  40 public final class BufferedRandomAccessFile extends RandomAccessFile {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  41   //private static final Logger logger_ = Logger.getLogger(BufferedRandomAccessFile.class);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  42   static final        int  LogBuffSz_ = 16; // 64K buffer</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  43   public static final int  BuffSz_    = (1 &lt;&lt; LogBuffSz_);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  44   static final        long BuffMask_  = ~(((long) BuffSz_) - 1L);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  45 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  46   /*</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  47    * This implementation is based on the buffer implementation in Modula-3&#x27;s</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  48    * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; interfaces.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  49    */</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  50   private boolean dirty_; // true iff unflushed bytes exist</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  51   private boolean closed_; // true iff the file is closed</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  52   private long    curr_; // current position in file</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  53   private long    lo_, hi_; // bounds on characters in &quot;buff&quot;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  54   private byte[]  buff_; // local buffer</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  55   private long    maxHi_; // this.lo + this.buff.length</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  56   private boolean hitEOF_; // buffer contains last file block?</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  57   private long    diskPos_; // disk position</span>
  58 ||||||| GitAnalyzerPlus_base
  59 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  60 import java.io.File;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  61 import java.io.FileNotFoundException;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  62 import java.io.IOException;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  63 import java.io.RandomAccessFile;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  64 import java.util.Arrays;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  65 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  66 //import org.apache.log4j.Logger;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  67 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  68 /**</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  69  * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like a</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  70  * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a private buffer so that most</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  71  * operations do not require a disk access.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  72  * &lt;P&gt;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  73  *</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  74  * Note: The operations on this class are unmonitored. Also, the correct</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  75  * functioning of the &lt;code&gt;RandomAccessFile&lt;/code&gt; methods that are not</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  76  * overridden here relies on the implementation of those methods in the</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  77  * superclass.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  78  * Author : Avinash Lakshman ( alakshman@facebook.com) Prashant Malik ( pmalik@facebook.com )</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  79  */</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  80 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  81 public final class BufferedRandomAccessFile extends RandomAccessFile {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  82   //private static final Logger logger_ = Logger.getLogger(BufferedRandomAccessFile.class);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  83   static final int LogBuffSz_ = 16; // 64K buffer</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  84   public static final int BuffSz_ = (1 &lt;&lt; LogBuffSz_);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  85   static final long BuffMask_ = ~(((long) BuffSz_) - 1L);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  86 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  87   /*</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  88    * This implementation is based on the buffer implementation in Modula-3&#x27;s</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  89    * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; interfaces.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  90    */</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  91   private boolean dirty_; // true iff unflushed bytes exist</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  92   private boolean closed_; // true iff the file is closed</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  93   private long curr_; // current position in file</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  94   private long lo_, hi_; // bounds on characters in &quot;buff&quot;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  95   private byte[] buff_; // local buffer</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  96   private long maxHi_; // this.lo + this.buff.length</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  97   private boolean hitEOF_; // buffer contains last file block?</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  98   private long diskPos_; // disk position</span>
  99 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 100 
 101     /*
 102      * To describe the above fields, we introduce the following abstractions for
 103      * the file &quot;f&quot;:
 104      *
 105      * len(f) the length of the file curr(f) the current position in the file
 106      * c(f) the abstract contents of the file disk(f) the contents of f&#x27;s
 107      * backing disk file closed(f) true iff the file is closed
 108      *
 109      * &quot;curr(f)&quot; is an index in the closed interval [0, len(f)]. &quot;c(f)&quot; is a
 110      * character sequence of length &quot;len(f)&quot;. &quot;c(f)&quot; and &quot;disk(f)&quot; may differ if
 111      * &quot;c(f)&quot; contains unflushed writes not reflected in &quot;disk(f)&quot;. The flush
 112      * operation has the effect of making &quot;disk(f)&quot; identical to &quot;c(f)&quot;.
 113      *
 114      * A file is said to be *valid* if the following conditions hold:
 115      *
 116      * V1. The &quot;closed&quot; and &quot;curr&quot; fields are correct:
 117      *
 118      * f.closed == closed(f) f.curr == curr(f)
 119      *
 120      * V2. The current position is either contained in the buffer, or just past
 121      * the buffer:
 122      *
 123      * f.lo &lt;= f.curr &lt;= f.hi
 124      *
 125      * V3. Any (possibly) unflushed characters are stored in &quot;f.buff&quot;:
 126      *
 127      * (forall i in [f.lo, f.curr): c(f)[i] == f.buff[i - f.lo])
 128      *
 129      * V4. For all characters not covered by V3, c(f) and disk(f) agree:
 130      *
 131      * (forall i in [f.lo, len(f)): i not in [f.lo, f.curr) =&gt; c(f)[i] ==
 132      * disk(f)[i])
 133      *
 134      * V5. &quot;f.dirty&quot; is true iff the buffer contains bytes that should be
 135      * flushed to the file; by V3 and V4, only part of the buffer can be dirty.
 136      *
 137      * f.dirty == (exists i in [f.lo, f.curr): c(f)[i] != f.buff[i - f.lo])
 138      *
 139      * V6. this.maxHi == this.lo + this.buff.length
 140      *
 141      * Note that &quot;f.buff&quot; can be &quot;null&quot; in a valid file, since the range of
 142      * characters in V3 is empty when &quot;f.lo == f.curr&quot;.
 143      *
 144      * A file is said to be *ready* if the buffer contains the current position,
 145      * i.e., when:
 146      *
 147      * R1. !f.closed &amp;&amp; f.buff != null &amp;&amp; f.lo &lt;= f.curr &amp;&amp; f.curr &lt; f.hi
 148      *
 149      * When a file is ready, reading or writing a single byte can be performed
 150      * by reading or writing the in-memory buffer without performing a disk
 151      * operation.
 152      */
 153 
 154   /**
 155    * Open a new &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; on &lt;code&gt;file&lt;/code&gt;
 156    * in mode &lt;code&gt;mode&lt;/code&gt;, which should be &quot;r&quot; for reading only, or
 157    * &quot;rw&quot; for reading and writing.
 158    */
 159   public BufferedRandomAccessFile(File file, String mode) throws IOException {
 160     super(file, mode);
 161     this.init(0);
 162   }
 163 
 164   public BufferedRandomAccessFile(File file, String mode, int size) throws IOException {
 165     super(file, mode);
 166     this.init(size);
 167   }
 168 
 169   /**
 170    * Open a new &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; on the file named
 171    * &lt;code&gt;name&lt;/code&gt; in mode &lt;code&gt;mode&lt;/code&gt;, which should be &quot;r&quot; for
 172    * reading only, or &quot;rw&quot; for reading and writing.
 173    */
 174   public BufferedRandomAccessFile(String name, String mode) throws IOException {
 175     super(name, mode);
 176     this.init(0);
 177   }
 178 
 179   public BufferedRandomAccessFile(String name, String mode, int size) throws FileNotFoundException {
 180     super(name, mode);
 181     this.init(size);
 182   }
 183 
 184   private void init(int size) {
 185     this.dirty_ = this.closed_ = false;
 186     this.lo_ = this.curr_ = this.hi_ = 0;
 187     this.buff_ = (size &gt; BuffSz_) ? new byte[size] : new byte[BuffSz_];
 188     this.maxHi_ = (long) BuffSz_;
 189     this.hitEOF_ = false;
 190     this.diskPos_ = 0L;
 191   }
 192 
 193   public void close() throws IOException {
 194     this.flush();
 195     this.closed_ = true;
 196     super.close();
 197   }
 198 
 199   /**
 200    * Flush any bytes in the file&#x27;s buffer that have not yet been written to
 201    * disk. If the file was created read-only, this method is a no-op.
 202    */
 203   public void flush() throws IOException {
 204     this.flushBuffer();
 205   }
 206 
 207   /* Flush any dirty bytes in the buffer to disk. */
 208   private void flushBuffer() throws IOException {
 209     if (this.dirty_) {
 210       if (this.diskPos_ != this.lo_) super.seek(this.lo_);
 211       int len = (int) (this.curr_ - this.lo_);
 212       super.write(this.buff_, 0, len);
 213       this.diskPos_ = this.curr_;
 214       this.dirty_ = false;
 215     }
 216   }
 217 
 218   /*
 219    * Read at most &quot;this.buff.length&quot; bytes into &quot;this.buff&quot;, returning the
 220    * number of bytes read. If the return result is less than
 221    * &quot;this.buff.length&quot;, then EOF was read.
 222    */
 223   private int fillBuffer() throws IOException {
 224     int cnt = 0;
 225     int rem = this.buff_.length;
 226     while (rem &gt; 0) {
 227       int n = super.read(this.buff_, cnt, rem);
 228       if (n &lt; 0) break;
 229       cnt += n;
 230       rem -= n;
 231     }
 232     if ((cnt &lt; 0) &amp;&amp; (this.hitEOF_ = (cnt &lt; this.buff_.length))) {
 233       // make sure buffer that wasn&#x27;t read is initialized with -1
 234       Arrays.fill(this.buff_, cnt, this.buff_.length, (byte) 0xff);
 235     }
 236     this.diskPos_ += cnt;
 237     return cnt;
 238   }
 239 
 240   /*
 241    * This method positions &lt;code&gt;this.curr&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt;.
 242    * If &lt;code&gt;pos&lt;/code&gt; does not fall in the current buffer, it flushes the
 243    * current buffer and loads the correct one.&lt;p&gt;
 244    *
 245    * On exit from this routine &lt;code&gt;this.curr == this.hi&lt;/code&gt; iff &lt;code&gt;pos&lt;/code&gt;
 246    * is at or past the end-of-file, which can only happen if the file was
 247    * opened in read-only mode.
 248    */
 249   public void seek(long pos) throws IOException {
 250     if (pos &gt;= this.hi_ || pos &lt; this.lo_) {
 251       // seeking outside of current buffer -- flush and read
 252       this.flushBuffer();
 253       this.lo_ = pos &amp; BuffMask_; // start at BuffSz boundary
 254       this.maxHi_ = this.lo_ + (long) this.buff_.length;
 255       if (this.diskPos_ != this.lo_) {
 256         super.seek(this.lo_);
 257         this.diskPos_ = this.lo_;
 258       }
 259       int n = this.fillBuffer();
 260       this.hi_ = this.lo_ + (long) n;
 261     } else {
 262       // seeking inside current buffer -- no read required
 263       if (pos &lt; this.curr_) {
 264         // if seeking backwards, we must flush to maintain V4
 265         this.flushBuffer();
 266       }
 267     }
 268     this.curr_ = pos;
 269   }
 270 
 271   public long getFilePointer() {
 272     return this.curr_;
 273   }
 274 
 275   public long length() throws IOException {
 276     return Math.max(this.curr_, super.length());
 277   }
 278 
 279   public int read() throws IOException {
 280     if (this.curr_ &gt;= this.hi_) {
 281       // test for EOF
 282       // if (this.hi &lt; this.maxHi) return -1;
 283       if (this.hitEOF_) return -1;
 284 
 285       // slow path -- read another buffer
 286       this.seek(this.curr_);
 287       if (this.curr_ == this.hi_) return -1;
 288     }
 289     byte res = this.buff_[(int) (this.curr_ - this.lo_)];
 290     this.curr_++;
 291     return ((int) res) &amp; 0xFF; // convert byte -&gt; int
 292   }
 293 
 294   public int read(byte[] b) throws IOException {
 295     return this.read(b, 0, b.length);
 296   }
 297 
 298   public int read(byte[] b, int off, int len) throws IOException {
 299     if (this.curr_ &gt;= this.hi_) {
 300       // test for EOF
 301       // if (this.hi &lt; this.maxHi) return -1;
 302       if (this.hitEOF_) return -1;
 303 
 304       // slow path -- read another buffer
 305       this.seek(this.curr_);
 306       if (this.curr_ == this.hi_) return -1;
 307     }
 308     len = Math.min(len, (int) (this.hi_ - this.curr_));
 309     int buffOff = (int) (this.curr_ - this.lo_);
 310     System.arraycopy(this.buff_, buffOff, b, off, len);
 311     this.curr_ += len;
 312     return len;
 313   }
 314 
 315   public void write(int b) throws IOException {
 316     if (this.curr_ &gt;= this.hi_) {
 317       if (this.hitEOF_ &amp;&amp; this.hi_ &lt; this.maxHi_) {
 318         // at EOF -- bump &quot;hi&quot;
 319         this.hi_++;
 320       } else {
 321         // slow path -- write current buffer; read next one
 322         this.seek(this.curr_);
 323         if (this.curr_ == this.hi_) {
 324           // appending to EOF -- bump &quot;hi&quot;
 325           this.hi_++;
 326         }
 327       }
 328     }
 329     this.buff_[(int) (this.curr_ - this.lo_)] = (byte) b;
 330     this.curr_++;
 331     this.dirty_ = true;
 332   }
 333 
 334   public void write(byte[] b) throws IOException {
 335     this.write(b, 0, b.length);
 336   }
 337 
 338   public void write(byte[] b, int off, int len) throws IOException {
 339     while (len &gt; 0) {
 340       int n = this.writeAtMost(b, off, len);
 341       off += n;
 342       len -= n;
 343       this.dirty_ = true;
 344     }
 345   }
 346 
 347   /*
 348    * Write at most &quot;len&quot; bytes to &quot;b&quot; starting at position &quot;off&quot;, and return
 349    * the number of bytes written.
 350    */
 351   private int writeAtMost(byte[] b, int off, int len) throws IOException {
 352     if (this.curr_ &gt;= this.hi_) {
 353       if (this.hitEOF_ &amp;&amp; this.hi_ &lt; this.maxHi_) {
 354         // at EOF -- bump &quot;hi&quot;
 355         this.hi_ = this.maxHi_;
 356       } else {
 357         // slow path -- write current buffer; read next one
 358         this.seek(this.curr_);
 359         if (this.curr_ == this.hi_) {
 360           // appending to EOF -- bump &quot;hi&quot;
 361           this.hi_ = this.maxHi_;
 362         }
 363       }
 364     }
 365     len = Math.min(len, (int) (this.hi_ - this.curr_));
 366     int buffOff = (int) (this.curr_ - this.lo_);
 367     System.arraycopy(b, off, this.buff_, buffOff, len);
 368     this.curr_ += len;
 369     return len;
 370   }
 371 }</pre></td>
                            <td><pre>   1 /**
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  * http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 package com.arialyy.aria.util;
  20 
  21 &lt;&lt;&lt;&lt;&lt;&lt;&lt; MINE
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  22 import java.io.*;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  23 import java.util.Arrays;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  24 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  25 //import org.apache.log4j.Logger;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  26 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  27 /**</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  28  * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like a</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  29  * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a private buffer so that most</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  30  * operations do not require a disk access.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  31  * &lt;P&gt;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  32  *</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  33  * Note: The operations on this class are unmonitored. Also, the correct</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  34  * functioning of the &lt;code&gt;RandomAccessFile&lt;/code&gt; methods that are not</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  35  * overridden here relies on the implementation of those methods in the</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  36  * superclass.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  37  * Author : Avinash Lakshman ( alakshman@facebook.com) Prashant Malik ( pmalik@facebook.com )</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  38  */</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  39 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  40 public final class BufferedRandomAccessFile extends RandomAccessFile {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  41   //private static final Logger logger_ = Logger.getLogger(BufferedRandomAccessFile.class);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  42   static final        int  LogBuffSz_ = 16; // 64K buffer</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  43   public static final int  BuffSz_    = (1 &lt;&lt; LogBuffSz_);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  44   static final        long BuffMask_  = ~(((long) BuffSz_) - 1L);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  45 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  46   /*</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  47    * This implementation is based on the buffer implementation in Modula-3&#x27;s</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  48    * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; interfaces.</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  49    */</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  50   private boolean dirty_; // true iff unflushed bytes exist</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  51   private boolean closed_; // true iff the file is closed</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  52   private long    curr_; // current position in file</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  53   private long    lo_, hi_; // bounds on characters in &quot;buff&quot;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  54   private byte[]  buff_; // local buffer</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  55   private long    maxHi_; // this.lo + this.buff.length</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  56   private boolean hitEOF_; // buffer contains last file block?</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  57   private long    diskPos_; // disk position</span>
  58 ||||||| BASE
  59 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  60 import java.io.File;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  61 import java.io.FileNotFoundException;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  62 import java.io.IOException;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  63 import java.io.RandomAccessFile;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  64 import java.util.Arrays;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  65 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  66 //import org.apache.log4j.Logger;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  67 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  68 /**</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  69  * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like a</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  70  * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a private buffer so that most</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  71  * operations do not require a disk access.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  72  * &lt;P&gt;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  73  *</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  74  * Note: The operations on this class are unmonitored. Also, the correct</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  75  * functioning of the &lt;code&gt;RandomAccessFile&lt;/code&gt; methods that are not</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  76  * overridden here relies on the implementation of those methods in the</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  77  * superclass.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  78  * Author : Avinash Lakshman ( alakshman@facebook.com) Prashant Malik ( pmalik@facebook.com )</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  79  */</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  80 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  81 public final class BufferedRandomAccessFile extends RandomAccessFile {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  82   //private static final Logger logger_ = Logger.getLogger(BufferedRandomAccessFile.class);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  83   static final int LogBuffSz_ = 16; // 64K buffer</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  84   public static final int BuffSz_ = (1 &lt;&lt; LogBuffSz_);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  85   static final long BuffMask_ = ~(((long) BuffSz_) - 1L);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  86 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  87   /*</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  88    * This implementation is based on the buffer implementation in Modula-3&#x27;s</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  89    * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; interfaces.</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  90    */</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  91   private boolean dirty_; // true iff unflushed bytes exist</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  92   private boolean closed_; // true iff the file is closed</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  93   private long curr_; // current position in file</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  94   private long lo_, hi_; // bounds on characters in &quot;buff&quot;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  95   private byte[] buff_; // local buffer</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  96   private long maxHi_; // this.lo + this.buff.length</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  97   private boolean hitEOF_; // buffer contains last file block?</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  98   private long diskPos_; // disk position</span>
  99 &gt;&gt;&gt;&gt;&gt;&gt;&gt; YOURS
 100 
 101     /*
 102      * To describe the above fields, we introduce the following abstractions for
 103      * the file &quot;f&quot;:
 104      *
 105      * len(f) the length of the file curr(f) the current position in the file
 106      * c(f) the abstract contents of the file disk(f) the contents of f&#x27;s
 107      * backing disk file closed(f) true iff the file is closed
 108      *
 109      * &quot;curr(f)&quot; is an index in the closed interval [0, len(f)]. &quot;c(f)&quot; is a
 110      * character sequence of length &quot;len(f)&quot;. &quot;c(f)&quot; and &quot;disk(f)&quot; may differ if
 111      * &quot;c(f)&quot; contains unflushed writes not reflected in &quot;disk(f)&quot;. The flush
 112      * operation has the effect of making &quot;disk(f)&quot; identical to &quot;c(f)&quot;.
 113      *
 114      * A file is said to be *valid* if the following conditions hold:
 115      *
 116      * V1. The &quot;closed&quot; and &quot;curr&quot; fields are correct:
 117      *
 118      * f.closed == closed(f) f.curr == curr(f)
 119      *
 120      * V2. The current position is either contained in the buffer, or just past
 121      * the buffer:
 122      *
 123      * f.lo &lt;= f.curr &lt;= f.hi
 124      *
 125      * V3. Any (possibly) unflushed characters are stored in &quot;f.buff&quot;:
 126      *
 127      * (forall i in [f.lo, f.curr): c(f)[i] == f.buff[i - f.lo])
 128      *
 129      * V4. For all characters not covered by V3, c(f) and disk(f) agree:
 130      *
 131      * (forall i in [f.lo, len(f)): i not in [f.lo, f.curr) =&gt; c(f)[i] ==
 132      * disk(f)[i])
 133      *
 134      * V5. &quot;f.dirty&quot; is true iff the buffer contains bytes that should be
 135      * flushed to the file; by V3 and V4, only part of the buffer can be dirty.
 136      *
 137      * f.dirty == (exists i in [f.lo, f.curr): c(f)[i] != f.buff[i - f.lo])
 138      *
 139      * V6. this.maxHi == this.lo + this.buff.length
 140      *
 141      * Note that &quot;f.buff&quot; can be &quot;null&quot; in a valid file, since the range of
 142      * characters in V3 is empty when &quot;f.lo == f.curr&quot;.
 143      *
 144      * A file is said to be *ready* if the buffer contains the current position,
 145      * i.e., when:
 146      *
 147      * R1. !f.closed &amp;&amp; f.buff != null &amp;&amp; f.lo &lt;= f.curr &amp;&amp; f.curr &lt; f.hi
 148      *
 149      * When a file is ready, reading or writing a single byte can be performed
 150      * by reading or writing the in-memory buffer without performing a disk
 151      * operation.
 152      */
 153 
 154   /**
 155    * Open a new &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; on &lt;code&gt;file&lt;/code&gt;
 156    * in mode &lt;code&gt;mode&lt;/code&gt;, which should be &quot;r&quot; for reading only, or
 157    * &quot;rw&quot; for reading and writing.
 158    */
 159   public BufferedRandomAccessFile(File file, String mode) throws IOException {
 160     super(file, mode);
 161     this.init(0);
 162   }
 163 
 164   public BufferedRandomAccessFile(File file, String mode, int size) throws IOException {
 165     super(file, mode);
 166     this.init(size);
 167   }
 168 
 169   /**
 170    * Open a new &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; on the file named
 171    * &lt;code&gt;name&lt;/code&gt; in mode &lt;code&gt;mode&lt;/code&gt;, which should be &quot;r&quot; for
 172    * reading only, or &quot;rw&quot; for reading and writing.
 173    */
 174   public BufferedRandomAccessFile(String name, String mode) throws IOException {
 175     super(name, mode);
 176     this.init(0);
 177   }
 178 
 179   public BufferedRandomAccessFile(String name, String mode, int size) throws FileNotFoundException {
 180     super(name, mode);
 181     this.init(size);
 182   }
 183 
 184   private void init(int size) {
 185     this.dirty_ = this.closed_ = false;
 186     this.lo_ = this.curr_ = this.hi_ = 0;
 187     this.buff_ = (size &gt; BuffSz_) ? new byte[size] : new byte[BuffSz_];
 188     this.maxHi_ = (long) BuffSz_;
 189     this.hitEOF_ = false;
 190     this.diskPos_ = 0L;
 191   }
 192 
 193   public void close() throws IOException {
 194     this.flush();
 195     this.closed_ = true;
 196     super.close();
 197   }
 198 
 199   /**
 200    * Flush any bytes in the file&#x27;s buffer that have not yet been written to
 201    * disk. If the file was created read-only, this method is a no-op.
 202    */
 203   public void flush() throws IOException {
 204     this.flushBuffer();
 205   }
 206 
 207   /* Flush any dirty bytes in the buffer to disk. */
 208   private void flushBuffer() throws IOException {
 209     if (this.dirty_) {
 210       if (this.diskPos_ != this.lo_) super.seek(this.lo_);
 211       int len = (int) (this.curr_ - this.lo_);
 212       super.write(this.buff_, 0, len);
 213       this.diskPos_ = this.curr_;
 214       this.dirty_ = false;
 215     }
 216   }
 217 
 218   /*
 219    * Read at most &quot;this.buff.length&quot; bytes into &quot;this.buff&quot;, returning the
 220    * number of bytes read. If the return result is less than
 221    * &quot;this.buff.length&quot;, then EOF was read.
 222    */
 223   private int fillBuffer() throws IOException {
 224     int cnt = 0;
 225     int rem = this.buff_.length;
 226     while (rem &gt; 0) {
 227       int n = super.read(this.buff_, cnt, rem);
 228       if (n &lt; 0) break;
 229       cnt += n;
 230       rem -= n;
 231     }
 232     if ((cnt &lt; 0) &amp;&amp; (this.hitEOF_ = (cnt &lt; this.buff_.length))) {
 233       // make sure buffer that wasn&#x27;t read is initialized with -1
 234       Arrays.fill(this.buff_, cnt, this.buff_.length, (byte) 0xff);
 235     }
 236     this.diskPos_ += cnt;
 237     return cnt;
 238   }
 239 
 240   /*
 241    * This method positions &lt;code&gt;this.curr&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt;.
 242    * If &lt;code&gt;pos&lt;/code&gt; does not fall in the current buffer, it flushes the
 243    * current buffer and loads the correct one.&lt;p&gt;
 244    *
 245    * On exit from this routine &lt;code&gt;this.curr == this.hi&lt;/code&gt; iff &lt;code&gt;pos&lt;/code&gt;
 246    * is at or past the end-of-file, which can only happen if the file was
 247    * opened in read-only mode.
 248    */
 249   public void seek(long pos) throws IOException {
 250     if (pos &gt;= this.hi_ || pos &lt; this.lo_) {
 251       // seeking outside of current buffer -- flush and read
 252       this.flushBuffer();
 253       this.lo_ = pos &amp; BuffMask_; // start at BuffSz boundary
 254       this.maxHi_ = this.lo_ + (long) this.buff_.length;
 255       if (this.diskPos_ != this.lo_) {
 256         super.seek(this.lo_);
 257         this.diskPos_ = this.lo_;
 258       }
 259       int n = this.fillBuffer();
 260       this.hi_ = this.lo_ + (long) n;
 261     } else {
 262       // seeking inside current buffer -- no read required
 263       if (pos &lt; this.curr_) {
 264         // if seeking backwards, we must flush to maintain V4
 265         this.flushBuffer();
 266       }
 267     }
 268     this.curr_ = pos;
 269   }
 270 
 271   public long getFilePointer() {
 272     return this.curr_;
 273   }
 274 
 275   public long length() throws IOException {
 276     return Math.max(this.curr_, super.length());
 277   }
 278 
 279   public int read() throws IOException {
 280     if (this.curr_ &gt;= this.hi_) {
 281       // test for EOF
 282       // if (this.hi &lt; this.maxHi) return -1;
 283       if (this.hitEOF_) return -1;
 284 
 285       // slow path -- read another buffer
 286       this.seek(this.curr_);
 287       if (this.curr_ == this.hi_) return -1;
 288     }
 289     byte res = this.buff_[(int) (this.curr_ - this.lo_)];
 290     this.curr_++;
 291     return ((int) res) &amp; 0xFF; // convert byte -&gt; int
 292   }
 293 
 294   public int read(byte[] b) throws IOException {
 295     return this.read(b, 0, b.length);
 296   }
 297 
 298   public int read(byte[] b, int off, int len) throws IOException {
 299     if (this.curr_ &gt;= this.hi_) {
 300       // test for EOF
 301       // if (this.hi &lt; this.maxHi) return -1;
 302       if (this.hitEOF_) return -1;
 303 
 304       // slow path -- read another buffer
 305       this.seek(this.curr_);
 306       if (this.curr_ == this.hi_) return -1;
 307     }
 308     len = Math.min(len, (int) (this.hi_ - this.curr_));
 309     int buffOff = (int) (this.curr_ - this.lo_);
 310     System.arraycopy(this.buff_, buffOff, b, off, len);
 311     this.curr_ += len;
 312     return len;
 313   }
 314 
 315   public void write(int b) throws IOException {
 316     if (this.curr_ &gt;= this.hi_) {
 317       if (this.hitEOF_ &amp;&amp; this.hi_ &lt; this.maxHi_) {
 318         // at EOF -- bump &quot;hi&quot;
 319         this.hi_++;
 320       } else {
 321         // slow path -- write current buffer; read next one
 322         this.seek(this.curr_);
 323         if (this.curr_ == this.hi_) {
 324           // appending to EOF -- bump &quot;hi&quot;
 325           this.hi_++;
 326         }
 327       }
 328     }
 329     this.buff_[(int) (this.curr_ - this.lo_)] = (byte) b;
 330     this.curr_++;
 331     this.dirty_ = true;
 332   }
 333 
 334   public void write(byte[] b) throws IOException {
 335     this.write(b, 0, b.length);
 336   }
 337 
 338   public void write(byte[] b, int off, int len) throws IOException {
 339     while (len &gt; 0) {
 340       int n = this.writeAtMost(b, off, len);
 341       off += n;
 342       len -= n;
 343       this.dirty_ = true;
 344     }
 345   }
 346 
 347   /*
 348    * Write at most &quot;len&quot; bytes to &quot;b&quot; starting at position &quot;off&quot;, and return
 349    * the number of bytes written.
 350    */
 351   private int writeAtMost(byte[] b, int off, int len) throws IOException {
 352     if (this.curr_ &gt;= this.hi_) {
 353       if (this.hitEOF_ &amp;&amp; this.hi_ &lt; this.maxHi_) {
 354         // at EOF -- bump &quot;hi&quot;
 355         this.hi_ = this.maxHi_;
 356       } else {
 357         // slow path -- write current buffer; read next one
 358         this.seek(this.curr_);
 359         if (this.curr_ == this.hi_) {
 360           // appending to EOF -- bump &quot;hi&quot;
 361           this.hi_ = this.maxHi_;
 362         }
 363       }
 364     }
 365     len = Math.min(len, (int) (this.hi_ - this.curr_));
 366     int buffOff = (int) (this.curr_ - this.lo_);
 367     System.arraycopy(b, off, this.buff_, buffOff, len);
 368     this.curr_ += len;
 369     return len;
 370   }
 371 }</pre></td>
                            <td><pre>   1 /**
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  * http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.arialyy.aria.util;
  19 
  20 import java.io.*;
  21 import java.io.File;
  22 import java.io.FileNotFoundException;
  23 import java.io.IOException;
  24 import java.io.RandomAccessFile;
  25 import java.util.Arrays;
  26 
  27 
  28 // import org.apache.log4j.Logger;
  29 /**
  30  * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like a
  31  * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a private buffer so that most
  32  * operations do not require a disk access.
  33  * &lt;P&gt;
  34  *
  35  * Note: The operations on this class are unmonitored. Also, the correct
  36  * functioning of the &lt;code&gt;RandomAccessFile&lt;/code&gt; methods that are not
  37  * overridden here relies on the implementation of those methods in the
  38  * superclass.
  39  * Author : Avinash Lakshman ( alakshman@facebook.com) Prashant Malik ( pmalik@facebook.com )
  40  */
  41 public final class BufferedRandomAccessFile extends RandomAccessFile {
  42 //private static final Logger logger_ = Logger.getLogger(BufferedRandomAccessFile.class);
  43     // 64K buffer
  44     static final int LogBuffSz_ = 16;
  45 
  46     public static final int BuffSz_ = 1 &lt;&lt; LogBuffSz_;
  47 
  48     static final long BuffMask_ = ~(((long) (BuffSz_)) - 1L);
  49 
  50 /*
  51  * This implementation is based on the buffer implementation in Modula-3&#x27;s
  52  * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; interfaces.
  53  */
  54     // true iff unflushed bytes exist
  55     private boolean dirty_;
  56 
  57     // true iff the file is closed
  58     private boolean closed_;
  59 
  60 // current position in file
  61     private long curr_;
  62 
  63     private long lo_;
  64 
  65     // bounds on characters in &quot;buff&quot;
  66     private long hi_;
  67 
  68 // local buffer
  69     private byte[] buff_;
  70 
  71     // this.lo + this.buff.length
  72     private long maxHi_;
  73 
  74 // buffer contains last file block?
  75     private boolean hitEOF_;
  76 
  77     // disk position
  78     private long diskPos_;
  79 
  80     /* To describe the above fields, we introduce the following abstractions for
  81     the file &quot;f&quot;:
  82 
  83     len(f) the length of the file curr(f) the current position in the file
  84     c(f) the abstract contents of the file disk(f) the contents of f&#x27;s
  85     backing disk file closed(f) true iff the file is closed
  86 
  87     &quot;curr(f)&quot; is an index in the closed interval [0, len(f)]. &quot;c(f)&quot; is a
  88     character sequence of length &quot;len(f)&quot;. &quot;c(f)&quot; and &quot;disk(f)&quot; may differ if
  89     &quot;c(f)&quot; contains unflushed writes not reflected in &quot;disk(f)&quot;. The flush
  90     operation has the effect of making &quot;disk(f)&quot; identical to &quot;c(f)&quot;.
  91 
  92     A file is said to be *valid* if the following conditions hold:
  93 
  94     V1. The &quot;closed&quot; and &quot;curr&quot; fields are correct:
  95 
  96     f.closed == closed(f) f.curr == curr(f)
  97 
  98     V2. The current position is either contained in the buffer, or just past
  99     the buffer:
 100 
 101     f.lo &lt;= f.curr &lt;= f.hi
 102 
 103     V3. Any (possibly) unflushed characters are stored in &quot;f.buff&quot;:
 104 
 105     (forall i in [f.lo, f.curr): c(f)[i] == f.buff[i - f.lo])
 106 
 107     V4. For all characters not covered by V3, c(f) and disk(f) agree:
 108 
 109     (forall i in [f.lo, len(f)): i not in [f.lo, f.curr) =&gt; c(f)[i] ==
 110     disk(f)[i])
 111 
 112     V5. &quot;f.dirty&quot; is true iff the buffer contains bytes that should be
 113     flushed to the file; by V3 and V4, only part of the buffer can be dirty.
 114 
 115     f.dirty == (exists i in [f.lo, f.curr): c(f)[i] != f.buff[i - f.lo])
 116 
 117     V6. this.maxHi == this.lo + this.buff.length
 118 
 119     Note that &quot;f.buff&quot; can be &quot;null&quot; in a valid file, since the range of
 120     characters in V3 is empty when &quot;f.lo == f.curr&quot;.
 121 
 122     A file is said to be *ready* if the buffer contains the current position,
 123     i.e., when:
 124 
 125     R1. !f.closed &amp;&amp; f.buff != null &amp;&amp; f.lo &lt;= f.curr &amp;&amp; f.curr &lt; f.hi
 126 
 127     When a file is ready, reading or writing a single byte can be performed
 128     by reading or writing the in-memory buffer without performing a disk
 129     operation.
 130      */
 131 /**
 132  * Open a new &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; on &lt;code&gt;file&lt;/code&gt;
 133  * in mode &lt;code&gt;mode&lt;/code&gt;, which should be &quot;r&quot; for reading only, or
 134  * &quot;rw&quot; for reading and writing.
 135  */
 136     public BufferedRandomAccessFile(File file, String mode) throws IOException {
 137         super(file, mode);
 138         this.init(0);
 139     }
 140 
 141     public BufferedRandomAccessFile(File file, String mode, int size) throws IOException {
 142         super(file, mode);
 143         this.init(size);
 144     }
 145 
 146 /**
 147  * Open a new &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; on the file named
 148  * &lt;code&gt;name&lt;/code&gt; in mode &lt;code&gt;mode&lt;/code&gt;, which should be &quot;r&quot; for
 149  * reading only, or &quot;rw&quot; for reading and writing.
 150  */
 151     public BufferedRandomAccessFile(String name, String mode) throws IOException {
 152         super(name, mode);
 153         this.init(0);
 154     }
 155 
 156     public BufferedRandomAccessFile(String name, String mode, int size) throws FileNotFoundException {
 157         super(name, mode);
 158         this.init(size);
 159     }
 160 
 161     private void init(int size) {
 162         this.dirty_ = this.closed_ = false;
 163         this.lo_ = this.curr_ = this.hi_ = 0;
 164         this.buff_ = (size &gt; BuffSz_) ? new byte[size] : new byte[BuffSz_];
 165         this.maxHi_ = ((long) (BuffSz_));
 166         this.hitEOF_ = false;
 167         this.diskPos_ = 0L;
 168     }
 169 
 170     public void close() throws IOException {
 171         this.flush();
 172         this.closed_ = true;
 173         super.close();
 174     }
 175 
 176     /**
 177      * Flush any bytes in the file&#x27;s buffer that have not yet been written to
 178      * disk. If the file was created read-only, this method is a no-op.
 179      */
 180     public void flush() throws IOException {
 181         this.flushBuffer();
 182     }
 183 
 184 /* Flush any dirty bytes in the buffer to disk. */
 185     private void flushBuffer() throws IOException {
 186         if (this.dirty_) {
 187             if (this.diskPos_ != this.lo_) {
 188                 super.seek(this.lo_);
 189             }
 190             int len = ((int) (this.curr_ - this.lo_));
 191             super.write(this.buff_, 0, len);
 192             this.diskPos_ = this.curr_;
 193             this.dirty_ = false;
 194         }
 195     }
 196 
 197     /* Read at most &quot;this.buff.length&quot; bytes into &quot;this.buff&quot;, returning the
 198     number of bytes read. If the return result is less than
 199     &quot;this.buff.length&quot;, then EOF was read.
 200      */
 201     private int fillBuffer() throws IOException {
 202         int cnt = 0;
 203         int rem = this.buff_.length;
 204         while (rem &gt; 0) {
 205             int n = super.read(this.buff_, cnt, rem);
 206             if (n &lt; 0) {
 207                 break;
 208             }
 209             cnt += n;
 210             rem -= n;
 211         }
 212         if ((cnt &lt; 0) &amp;&amp; (this.hitEOF_ = cnt &lt; this.buff_.length)) {
 213     // make sure buffer that wasn&#x27;t read is initialized with -1
 214             Arrays.fill(this.buff_, cnt, this.buff_.length, ((byte) (0xff)));
 215         }
 216         this.diskPos_ += cnt;
 217         return cnt;
 218     }
 219 
 220 /*
 221  * This method positions &lt;code&gt;this.curr&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt;.
 222  * If &lt;code&gt;pos&lt;/code&gt; does not fall in the current buffer, it flushes the
 223  * current buffer and loads the correct one.&lt;p&gt;
 224  *
 225  * On exit from this routine &lt;code&gt;this.curr == this.hi&lt;/code&gt; iff &lt;code&gt;pos&lt;/code&gt;
 226  * is at or past the end-of-file, which can only happen if the file was
 227  * opened in read-only mode.
 228  */
 229     public void seek(long pos) throws IOException {
 230         if ((pos &gt;= this.hi_) || (pos &lt; this.lo_)) {
 231     // seeking outside of current buffer -- flush and read
 232             this.flushBuffer();
 233             // start at BuffSz boundary
 234             this.lo_ = pos &amp; BuffMask_;
 235             this.maxHi_ = this.lo_ + ((long) (this.buff_.length));
 236             if (this.diskPos_ != this.lo_) {
 237                 super.seek(this.lo_);
 238                 this.diskPos_ = this.lo_;
 239             }
 240             int n = this.fillBuffer();
 241             this.hi_ = this.lo_ + ((long) (n));
 242         } else // seeking inside current buffer -- no read required
 243         if (pos &lt; this.curr_) {
 244             // if seeking backwards, we must flush to maintain V4
 245             this.flushBuffer();
 246         }
 247         this.curr_ = pos;
 248     }
 249 
 250     public long getFilePointer() {
 251         return this.curr_;
 252     }
 253 
 254     public long length() throws IOException {
 255         return Math.max(this.curr_, super.length());
 256     }
 257 
 258     public int read() throws IOException {
 259         if (this.curr_ &gt;= this.hi_) {
 260             // test for EOF
 261     // if (this.hi &lt; this.maxHi) return -1;
 262             if (this.hitEOF_) {
 263                 return -1;
 264             }
 265             // slow path -- read another buffer
 266             this.seek(this.curr_);
 267             if (this.curr_ == this.hi_) {
 268                 return -1;
 269             }
 270         }
 271         byte res = this.buff_[((int) (this.curr_ - this.lo_))];
 272         this.curr_++;
 273         // convert byte -&gt; int
 274         return ((int) (res)) &amp; 0xff;
 275     }
 276 
 277     public int read(byte[] b) throws IOException {
 278         return this.read(b, 0, b.length);
 279     }
 280 
 281     public int read(byte[] b, int off, int len) throws IOException {
 282         if (this.curr_ &gt;= this.hi_) {
 283     // test for EOF
 284     // if (this.hi &lt; this.maxHi) return -1;
 285             if (this.hitEOF_) {
 286                 return -1;
 287             }
 288             // slow path -- read another buffer
 289             this.seek(this.curr_);
 290             if (this.curr_ == this.hi_) {
 291                 return -1;
 292             }
 293         }
 294         len = Math.min(len, ((int) (this.hi_ - this.curr_)));
 295         int buffOff = ((int) (this.curr_ - this.lo_));
 296         System.arraycopy(this.buff_, buffOff, b, off, len);
 297         this.curr_ += len;
 298         return len;
 299     }
 300 
 301     public void write(int b) throws IOException {
 302         if (this.curr_ &gt;= this.hi_) {
 303             if (this.hitEOF_ &amp;&amp; (this.hi_ &lt; this.maxHi_)) {
 304         // at EOF -- bump &quot;hi&quot;
 305                 this.hi_++;
 306             } else {
 307         // slow path -- write current buffer; read next one
 308                 this.seek(this.curr_);
 309                 if (this.curr_ == this.hi_) {
 310         // appending to EOF -- bump &quot;hi&quot;
 311                     this.hi_++;
 312                 }
 313             }
 314         }
 315         this.buff_[((int) (this.curr_ - this.lo_))] = ((byte) (b));
 316         this.curr_++;
 317         this.dirty_ = true;
 318     }
 319 
 320     public void write(byte[] b) throws IOException {
 321         this.write(b, 0, b.length);
 322     }
 323 
 324     public void write(byte[] b, int off, int len) throws IOException {
 325         while (len &gt; 0) {
 326             int n = this.writeAtMost(b, off, len);
 327             off += n;
 328             len -= n;
 329             this.dirty_ = true;
 330         }
 331     }
 332 
 333 /*
 334  * Write at most &quot;len&quot; bytes to &quot;b&quot; starting at position &quot;off&quot;, and return
 335  * the number of bytes written.
 336  */
 337     private int writeAtMost(byte[] b, int off, int len) throws IOException {
 338         if (this.curr_ &gt;= this.hi_) {
 339             if (this.hitEOF_ &amp;&amp; (this.hi_ &lt; this.maxHi_)) {
 340         // at EOF -- bump &quot;hi&quot;
 341                 this.hi_ = this.maxHi_;
 342             } else {
 343         // slow path -- write current buffer; read next one
 344                 this.seek(this.curr_);
 345                 if (this.curr_ == this.hi_) {
 346         // appending to EOF -- bump &quot;hi&quot;
 347                     this.hi_ = this.maxHi_;
 348                 }
 349             }
 350         }
 351         len = Math.min(len, ((int) (this.hi_ - this.curr_)));
 352         int buffOff = ((int) (this.curr_ - this.lo_));
 353         System.arraycopy(b, off, this.buff_, buffOff, len);
 354         this.curr_ += len;
 355         return len;
 356     }
 357 }
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre><span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   1 +/**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   2 + * Licensed to the Apache Software Foundation (ASF) under one</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   3 + * or more contributor license agreements.  See the NOTICE file</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   4 + * distributed with this work for additional information</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   5 + * regarding copyright ownership.  The ASF licenses this file</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   6 + * to you under the Apache License, Version 2.0 (the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   7 + * &quot;License&quot;); you may not use this file except in compliance</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   8 + * with the License.  You may obtain a copy of the License at</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   9 + *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  10 + * http://www.apache.org/licenses/LICENSE-2.0</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  11 + *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  12 + * Unless required by applicable law or agreed to in writing, software</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  13 + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  14 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  15 + * See the License for the specific language governing permissions and</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  16 + * limitations under the License.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  17 + */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  18 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  19 +package com.arialyy.aria.util;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  20 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  21 +import java.io.*;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  22 +import java.util.Arrays;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +//import org.apache.log4j.Logger;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +/**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 + * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like a</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 + * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a private buffer so that most</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 + * operations do not require a disk access.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 + * &lt;P&gt;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 + *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 + * Note: The operations on this class are unmonitored. Also, the correct</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 + * functioning of the &lt;code&gt;RandomAccessFile&lt;/code&gt; methods that are not</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 + * overridden here relies on the implementation of those methods in the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 + * superclass.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 + * Author : Avinash Lakshman ( alakshman@facebook.com) Prashant Malik ( pmalik@facebook.com )</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  37 + */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  38 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  39 +public final class BufferedRandomAccessFile extends RandomAccessFile {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  40 +  //private static final Logger logger_ = Logger.getLogger(BufferedRandomAccessFile.class);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  41 +  static final        int  LogBuffSz_ = 16; // 64K buffer</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  42 +  public static final int  BuffSz_    = (1 &lt;&lt; LogBuffSz_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  43 +  static final        long BuffMask_  = ~(((long) BuffSz_) - 1L);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  44 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +  /*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  46 +   * This implementation is based on the buffer implementation in Modula-3&#x27;s</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  47 +   * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; interfaces.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  48 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  49 +  private boolean dirty_; // true iff unflushed bytes exist</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  50 +  private boolean closed_; // true iff the file is closed</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  51 +  private long    curr_; // current position in file</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  52 +  private long    lo_, hi_; // bounds on characters in &quot;buff&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  53 +  private byte[]  buff_; // local buffer</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  54 +  private long    maxHi_; // this.lo + this.buff.length</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  55 +  private boolean hitEOF_; // buffer contains last file block?</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  56 +  private long    diskPos_; // disk position</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  58 +    /*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +     * To describe the above fields, we introduce the following abstractions for</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +     * the file &quot;f&quot;:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +     * len(f) the length of the file curr(f) the current position in the file</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +     * c(f) the abstract contents of the file disk(f) the contents of f&#x27;s</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +     * backing disk file closed(f) true iff the file is closed</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  65 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  66 +     * &quot;curr(f)&quot; is an index in the closed interval [0, len(f)]. &quot;c(f)&quot; is a</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  67 +     * character sequence of length &quot;len(f)&quot;. &quot;c(f)&quot; and &quot;disk(f)&quot; may differ if</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  68 +     * &quot;c(f)&quot; contains unflushed writes not reflected in &quot;disk(f)&quot;. The flush</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  69 +     * operation has the effect of making &quot;disk(f)&quot; identical to &quot;c(f)&quot;.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  70 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  71 +     * A file is said to be *valid* if the following conditions hold:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  73 +     * V1. The &quot;closed&quot; and &quot;curr&quot; fields are correct:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  74 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  75 +     * f.closed == closed(f) f.curr == curr(f)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  76 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  77 +     * V2. The current position is either contained in the buffer, or just past</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  78 +     * the buffer:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  79 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  80 +     * f.lo &lt;= f.curr &lt;= f.hi</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  81 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  82 +     * V3. Any (possibly) unflushed characters are stored in &quot;f.buff&quot;:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  83 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  84 +     * (forall i in [f.lo, f.curr): c(f)[i] == f.buff[i - f.lo])</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  85 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  86 +     * V4. For all characters not covered by V3, c(f) and disk(f) agree:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  87 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  88 +     * (forall i in [f.lo, len(f)): i not in [f.lo, f.curr) =&gt; c(f)[i] ==</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  89 +     * disk(f)[i])</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  90 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  91 +     * V5. &quot;f.dirty&quot; is true iff the buffer contains bytes that should be</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  92 +     * flushed to the file; by V3 and V4, only part of the buffer can be dirty.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  94 +     * f.dirty == (exists i in [f.lo, f.curr): c(f)[i] != f.buff[i - f.lo])</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  96 +     * V6. this.maxHi == this.lo + this.buff.length</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  97 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  98 +     * Note that &quot;f.buff&quot; can be &quot;null&quot; in a valid file, since the range of</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  99 +     * characters in V3 is empty when &quot;f.lo == f.curr&quot;.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 100 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 101 +     * A file is said to be *ready* if the buffer contains the current position,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 102 +     * i.e., when:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 103 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +     * R1. !f.closed &amp;&amp; f.buff != null &amp;&amp; f.lo &lt;= f.curr &amp;&amp; f.curr &lt; f.hi</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 105 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 106 +     * When a file is ready, reading or writing a single byte can be performed</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 107 +     * by reading or writing the in-memory buffer without performing a disk</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 108 +     * operation.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 111 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 112 +   * Open a new &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; on &lt;code&gt;file&lt;/code&gt;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +   * in mode &lt;code&gt;mode&lt;/code&gt;, which should be &quot;r&quot; for reading only, or</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +   * &quot;rw&quot; for reading and writing.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 115 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 116 +  public BufferedRandomAccessFile(File file, String mode) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +    super(file, mode);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +    this.init(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +  public BufferedRandomAccessFile(File file, String mode, int size) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 122 +    super(file, mode);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 123 +    this.init(size);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 124 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 126 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 127 +   * Open a new &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; on the file named</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 128 +   * &lt;code&gt;name&lt;/code&gt; in mode &lt;code&gt;mode&lt;/code&gt;, which should be &quot;r&quot; for</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 129 +   * reading only, or &quot;rw&quot; for reading and writing.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 130 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +  public BufferedRandomAccessFile(String name, String mode) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +    super(name, mode);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +    this.init(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 134 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 135 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 136 +  public BufferedRandomAccessFile(String name, String mode, int size) throws FileNotFoundException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 137 +    super(name, mode);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +    this.init(size);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 139 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 140 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 141 +  private void init(int size) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 142 +    this.dirty_ = this.closed_ = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +    this.lo_ = this.curr_ = this.hi_ = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 144 +    this.buff_ = (size &gt; BuffSz_) ? new byte[size] : new byte[BuffSz_];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 145 +    this.maxHi_ = (long) BuffSz_;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 146 +    this.hitEOF_ = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +    this.diskPos_ = 0L;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +  public void close() throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +    this.flush();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +    this.closed_ = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +    super.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 155 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 156 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 157 +   * Flush any bytes in the file&#x27;s buffer that have not yet been written to</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 158 +   * disk. If the file was created read-only, this method is a no-op.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +  public void flush() throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +    this.flushBuffer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +  /* Flush any dirty bytes in the buffer to disk. */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +  private void flushBuffer() throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +    if (this.dirty_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 167 +      if (this.diskPos_ != this.lo_) super.seek(this.lo_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +      int len = (int) (this.curr_ - this.lo_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +      super.write(this.buff_, 0, len);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +      this.diskPos_ = this.curr_;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 171 +      this.dirty_ = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 172 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 173 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +  /*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 176 +   * Read at most &quot;this.buff.length&quot; bytes into &quot;this.buff&quot;, returning the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 177 +   * number of bytes read. If the return result is less than</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 178 +   * &quot;this.buff.length&quot;, then EOF was read.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 179 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 180 +  private int fillBuffer() throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +    int cnt = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 182 +    int rem = this.buff_.length;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +    while (rem &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +      int n = super.read(this.buff_, cnt, rem);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +      if (n &lt; 0) break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +      cnt += n;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +      rem -= n;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +    if ((cnt &lt; 0) &amp;&amp; (this.hitEOF_ = (cnt &lt; this.buff_.length))) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +      // make sure buffer that wasn&#x27;t read is initialized with -1</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +      Arrays.fill(this.buff_, cnt, this.buff_.length, (byte) 0xff);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +    this.diskPos_ += cnt;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 194 +    return cnt;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 195 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 196 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +  /*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 198 +   * This method positions &lt;code&gt;this.curr&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt;.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 199 +   * If &lt;code&gt;pos&lt;/code&gt; does not fall in the current buffer, it flushes the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 200 +   * current buffer and loads the correct one.&lt;p&gt;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +   *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 202 +   * On exit from this routine &lt;code&gt;this.curr == this.hi&lt;/code&gt; iff &lt;code&gt;pos&lt;/code&gt;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 203 +   * is at or past the end-of-file, which can only happen if the file was</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 204 +   * opened in read-only mode.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 205 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 206 +  public void seek(long pos) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +    if (pos &gt;= this.hi_ || pos &lt; this.lo_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +      // seeking outside of current buffer -- flush and read</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +      this.flushBuffer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +      this.lo_ = pos &amp; BuffMask_; // start at BuffSz boundary</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +      this.maxHi_ = this.lo_ + (long) this.buff_.length;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +      if (this.diskPos_ != this.lo_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +        super.seek(this.lo_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +        this.diskPos_ = this.lo_;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +      int n = this.fillBuffer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +      this.hi_ = this.lo_ + (long) n;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +      // seeking inside current buffer -- no read required</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +      if (pos &lt; this.curr_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +        // if seeking backwards, we must flush to maintain V4</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +        this.flushBuffer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +    this.curr_ = pos;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +  public long getFilePointer() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +    return this.curr_;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +  public long length() throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 233 +    return Math.max(this.curr_, super.length());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 236 +  public int read() throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +    if (this.curr_ &gt;= this.hi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +      // test for EOF</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +      // if (this.hi &lt; this.maxHi) return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +      if (this.hitEOF_) return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +      // slow path -- read another buffer</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +      this.seek(this.curr_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +      if (this.curr_ == this.hi_) return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 245 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 246 +    byte res = this.buff_[(int) (this.curr_ - this.lo_)];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 247 +    this.curr_++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +    return ((int) res) &amp; 0xFF; // convert byte -&gt; int</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +  public int read(byte[] b) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +    return this.read(b, 0, b.length);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 255 +  public int read(byte[] b, int off, int len) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 256 +    if (this.curr_ &gt;= this.hi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 257 +      // test for EOF</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +      // if (this.hi &lt; this.maxHi) return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +      if (this.hitEOF_) return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 260 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 261 +      // slow path -- read another buffer</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 262 +      this.seek(this.curr_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 263 +      if (this.curr_ == this.hi_) return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 264 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 265 +    len = Math.min(len, (int) (this.hi_ - this.curr_));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 266 +    int buffOff = (int) (this.curr_ - this.lo_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 267 +    System.arraycopy(this.buff_, buffOff, b, off, len);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 268 +    this.curr_ += len;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 269 +    return len;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 270 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 272 +  public void write(int b) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 273 +    if (this.curr_ &gt;= this.hi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 274 +      if (this.hitEOF_ &amp;&amp; this.hi_ &lt; this.maxHi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 275 +        // at EOF -- bump &quot;hi&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 276 +        this.hi_++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 277 +      } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 278 +        // slow path -- write current buffer; read next one</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 279 +        this.seek(this.curr_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 280 +        if (this.curr_ == this.hi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 281 +          // appending to EOF -- bump &quot;hi&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 282 +          this.hi_++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 283 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 284 +      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 285 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 286 +    this.buff_[(int) (this.curr_ - this.lo_)] = (byte) b;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 287 +    this.curr_++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 288 +    this.dirty_ = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 289 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 291 +  public void write(byte[] b) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 292 +    this.write(b, 0, b.length);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 293 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 294 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 295 +  public void write(byte[] b, int off, int len) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 296 +    while (len &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 297 +      int n = this.writeAtMost(b, off, len);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 298 +      off += n;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 299 +      len -= n;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 300 +      this.dirty_ = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 301 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 302 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 303 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 304 +  /*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 305 +   * Write at most &quot;len&quot; bytes to &quot;b&quot; starting at position &quot;off&quot;, and return</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 306 +   * the number of bytes written.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 307 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 308 +  private int writeAtMost(byte[] b, int off, int len) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 309 +    if (this.curr_ &gt;= this.hi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 310 +      if (this.hitEOF_ &amp;&amp; this.hi_ &lt; this.maxHi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 311 +        // at EOF -- bump &quot;hi&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +        this.hi_ = this.maxHi_;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 313 +      } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 314 +        // slow path -- write current buffer; read next one</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +        this.seek(this.curr_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 316 +        if (this.curr_ == this.hi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 317 +          // appending to EOF -- bump &quot;hi&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 318 +          this.hi_ = this.maxHi_;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 319 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 320 +      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 321 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 322 +    len = Math.min(len, (int) (this.hi_ - this.curr_));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 323 +    int buffOff = (int) (this.curr_ - this.lo_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 324 +    System.arraycopy(b, off, this.buff_, buffOff, len);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 325 +    this.curr_ += len;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 326 +    return len;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 327 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 328 +}</span></pre></td>
                            <td><pre><span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   1 +/**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   2 + * Licensed to the Apache Software Foundation (ASF) under one</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   3 + * or more contributor license agreements.  See the NOTICE file</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   4 + * distributed with this work for additional information</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   5 + * regarding copyright ownership.  The ASF licenses this file</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   6 + * to you under the Apache License, Version 2.0 (the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   7 + * &quot;License&quot;); you may not use this file except in compliance</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   8 + * with the License.  You may obtain a copy of the License at</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">   9 + *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  10 + * http://www.apache.org/licenses/LICENSE-2.0</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  11 + *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  12 + * Unless required by applicable law or agreed to in writing, software</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  13 + * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  14 + * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  15 + * See the License for the specific language governing permissions and</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  16 + * limitations under the License.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  17 + */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  18 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  19 +package com.arialyy.aria.util;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  20 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  21 +import java.io.File;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  22 +import java.io.FileNotFoundException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  23 +import java.io.IOException;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  24 +import java.io.RandomAccessFile;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  25 +import java.util.Arrays;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  26 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  27 +//import org.apache.log4j.Logger;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  28 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  29 +/**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  30 + * A &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; is like a</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 + * &lt;code&gt;RandomAccessFile&lt;/code&gt;, but it uses a private buffer so that most</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 + * operations do not require a disk access.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  33 + * &lt;P&gt;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  34 + *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  35 + * Note: The operations on this class are unmonitored. Also, the correct</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  36 + * functioning of the &lt;code&gt;RandomAccessFile&lt;/code&gt; methods that are not</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  37 + * overridden here relies on the implementation of those methods in the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  38 + * superclass.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  39 + * Author : Avinash Lakshman ( alakshman@facebook.com) Prashant Malik ( pmalik@facebook.com )</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  40 + */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  41 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  42 +public final class BufferedRandomAccessFile extends RandomAccessFile {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  43 +  //private static final Logger logger_ = Logger.getLogger(BufferedRandomAccessFile.class);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  44 +  static final int LogBuffSz_ = 16; // 64K buffer</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +  public static final int BuffSz_ = (1 &lt;&lt; LogBuffSz_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  46 +  static final long BuffMask_ = ~(((long) BuffSz_) - 1L);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  47 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  48 +  /*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  49 +   * This implementation is based on the buffer implementation in Modula-3&#x27;s</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  50 +   * &quot;Rd&quot;, &quot;Wr&quot;, &quot;RdClass&quot;, and &quot;WrClass&quot; interfaces.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  51 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  52 +  private boolean dirty_; // true iff unflushed bytes exist</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  53 +  private boolean closed_; // true iff the file is closed</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  54 +  private long curr_; // current position in file</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  55 +  private long lo_, hi_; // bounds on characters in &quot;buff&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  56 +  private byte[] buff_; // local buffer</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +  private long maxHi_; // this.lo + this.buff.length</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  58 +  private boolean hitEOF_; // buffer contains last file block?</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +  private long diskPos_; // disk position</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  60 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  61 +    /*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  62 +     * To describe the above fields, we introduce the following abstractions for</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  63 +     * the file &quot;f&quot;:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  64 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  65 +     * len(f) the length of the file curr(f) the current position in the file</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  66 +     * c(f) the abstract contents of the file disk(f) the contents of f&#x27;s</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  67 +     * backing disk file closed(f) true iff the file is closed</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  68 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  69 +     * &quot;curr(f)&quot; is an index in the closed interval [0, len(f)]. &quot;c(f)&quot; is a</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  70 +     * character sequence of length &quot;len(f)&quot;. &quot;c(f)&quot; and &quot;disk(f)&quot; may differ if</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  71 +     * &quot;c(f)&quot; contains unflushed writes not reflected in &quot;disk(f)&quot;. The flush</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  72 +     * operation has the effect of making &quot;disk(f)&quot; identical to &quot;c(f)&quot;.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  73 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  74 +     * A file is said to be *valid* if the following conditions hold:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  75 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  76 +     * V1. The &quot;closed&quot; and &quot;curr&quot; fields are correct:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  77 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  78 +     * f.closed == closed(f) f.curr == curr(f)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  79 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  80 +     * V2. The current position is either contained in the buffer, or just past</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  81 +     * the buffer:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  82 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  83 +     * f.lo &lt;= f.curr &lt;= f.hi</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  84 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  85 +     * V3. Any (possibly) unflushed characters are stored in &quot;f.buff&quot;:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  86 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  87 +     * (forall i in [f.lo, f.curr): c(f)[i] == f.buff[i - f.lo])</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  88 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  89 +     * V4. For all characters not covered by V3, c(f) and disk(f) agree:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  90 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  91 +     * (forall i in [f.lo, len(f)): i not in [f.lo, f.curr) =&gt; c(f)[i] ==</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  92 +     * disk(f)[i])</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  93 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  94 +     * V5. &quot;f.dirty&quot; is true iff the buffer contains bytes that should be</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  95 +     * flushed to the file; by V3 and V4, only part of the buffer can be dirty.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  96 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  97 +     * f.dirty == (exists i in [f.lo, f.curr): c(f)[i] != f.buff[i - f.lo])</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  98 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  99 +     * V6. this.maxHi == this.lo + this.buff.length</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 100 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 101 +     * Note that &quot;f.buff&quot; can be &quot;null&quot; in a valid file, since the range of</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 102 +     * characters in V3 is empty when &quot;f.lo == f.curr&quot;.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 103 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 104 +     * A file is said to be *ready* if the buffer contains the current position,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 105 +     * i.e., when:</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 106 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 107 +     * R1. !f.closed &amp;&amp; f.buff != null &amp;&amp; f.lo &lt;= f.curr &amp;&amp; f.curr &lt; f.hi</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 108 +     *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 109 +     * When a file is ready, reading or writing a single byte can be performed</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 110 +     * by reading or writing the in-memory buffer without performing a disk</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 111 +     * operation.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 112 +     */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 114 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 115 +   * Open a new &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; on &lt;code&gt;file&lt;/code&gt;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 116 +   * in mode &lt;code&gt;mode&lt;/code&gt;, which should be &quot;r&quot; for reading only, or</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 117 +   * &quot;rw&quot; for reading and writing.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 118 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 119 +  public BufferedRandomAccessFile(File file, String mode) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 120 +    super(file, mode);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 121 +    this.init(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 122 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 123 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 124 +  public BufferedRandomAccessFile(File file, String mode, int size) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 125 +    super(file, mode);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 126 +    this.init(size);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 127 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 128 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 129 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 130 +   * Open a new &lt;code&gt;BufferedRandomAccessFile&lt;/code&gt; on the file named</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 131 +   * &lt;code&gt;name&lt;/code&gt; in mode &lt;code&gt;mode&lt;/code&gt;, which should be &quot;r&quot; for</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 132 +   * reading only, or &quot;rw&quot; for reading and writing.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 134 +  public BufferedRandomAccessFile(String name, String mode) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 135 +    super(name, mode);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 136 +    this.init(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 137 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 138 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 139 +  public BufferedRandomAccessFile(String name, String mode, int size) throws FileNotFoundException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 140 +    super(name, mode);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 141 +    this.init(size);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 142 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 144 +  private void init(int size) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 145 +    this.dirty_ = this.closed_ = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 146 +    this.lo_ = this.curr_ = this.hi_ = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 147 +    this.buff_ = (size &gt; BuffSz_) ? new byte[size] : new byte[BuffSz_];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 148 +    this.maxHi_ = (long) BuffSz_;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 149 +    this.hitEOF_ = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 150 +    this.diskPos_ = 0L;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 153 +  public void close() throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +    this.flush();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 155 +    this.closed_ = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 156 +    super.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 157 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 158 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +  /**</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +   * Flush any bytes in the file&#x27;s buffer that have not yet been written to</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +   * disk. If the file was created read-only, this method is a no-op.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +  public void flush() throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +    this.flushBuffer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 167 +  /* Flush any dirty bytes in the buffer to disk. */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +  private void flushBuffer() throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +    if (this.dirty_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +      if (this.diskPos_ != this.lo_) super.seek(this.lo_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 171 +      int len = (int) (this.curr_ - this.lo_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 172 +      super.write(this.buff_, 0, len);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 173 +      this.diskPos_ = this.curr_;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +      this.dirty_ = false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 176 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 177 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 178 +  /*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 179 +   * Read at most &quot;this.buff.length&quot; bytes into &quot;this.buff&quot;, returning the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 180 +   * number of bytes read. If the return result is less than</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +   * &quot;this.buff.length&quot;, then EOF was read.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 182 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +  private int fillBuffer() throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +    int cnt = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +    int rem = this.buff_.length;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +    while (rem &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +      int n = super.read(this.buff_, cnt, rem);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +      if (n &lt; 0) break;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +      cnt += n;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 190 +      rem -= n;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 191 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 192 +    if ((cnt &lt; 0) &amp;&amp; (this.hitEOF_ = (cnt &lt; this.buff_.length))) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 193 +      // make sure buffer that wasn&#x27;t read is initialized with -1</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 194 +      Arrays.fill(this.buff_, cnt, this.buff_.length, (byte) 0xff);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 195 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 196 +    this.diskPos_ += cnt;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 197 +    return cnt;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 198 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 199 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 200 +  /*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 201 +   * This method positions &lt;code&gt;this.curr&lt;/code&gt; at position &lt;code&gt;pos&lt;/code&gt;.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 202 +   * If &lt;code&gt;pos&lt;/code&gt; does not fall in the current buffer, it flushes the</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 203 +   * current buffer and loads the correct one.&lt;p&gt;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 204 +   *</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 205 +   * On exit from this routine &lt;code&gt;this.curr == this.hi&lt;/code&gt; iff &lt;code&gt;pos&lt;/code&gt;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 206 +   * is at or past the end-of-file, which can only happen if the file was</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +   * opened in read-only mode.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +  public void seek(long pos) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +    if (pos &gt;= this.hi_ || pos &lt; this.lo_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +      // seeking outside of current buffer -- flush and read</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +      this.flushBuffer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +      this.lo_ = pos &amp; BuffMask_; // start at BuffSz boundary</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +      this.maxHi_ = this.lo_ + (long) this.buff_.length;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +      if (this.diskPos_ != this.lo_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +        super.seek(this.lo_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +        this.diskPos_ = this.lo_;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 219 +      int n = this.fillBuffer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 220 +      this.hi_ = this.lo_ + (long) n;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 221 +    } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 222 +      // seeking inside current buffer -- no read required</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 223 +      if (pos &lt; this.curr_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 224 +        // if seeking backwards, we must flush to maintain V4</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 225 +        this.flushBuffer();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 226 +      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 227 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 228 +    this.curr_ = pos;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 229 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 230 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 231 +  public long getFilePointer() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 232 +    return this.curr_;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 233 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 234 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 235 +  public long length() throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 236 +    return Math.max(this.curr_, super.length());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 237 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 238 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 239 +  public int read() throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 240 +    if (this.curr_ &gt;= this.hi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 241 +      // test for EOF</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 242 +      // if (this.hi &lt; this.maxHi) return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 243 +      if (this.hitEOF_) return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 244 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 245 +      // slow path -- read another buffer</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 246 +      this.seek(this.curr_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 247 +      if (this.curr_ == this.hi_) return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 248 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 249 +    byte res = this.buff_[(int) (this.curr_ - this.lo_)];</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 250 +    this.curr_++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 251 +    return ((int) res) &amp; 0xFF; // convert byte -&gt; int</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 252 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 253 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 254 +  public int read(byte[] b) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 255 +    return this.read(b, 0, b.length);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 256 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 257 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 258 +  public int read(byte[] b, int off, int len) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 259 +    if (this.curr_ &gt;= this.hi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 260 +      // test for EOF</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 261 +      // if (this.hi &lt; this.maxHi) return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 262 +      if (this.hitEOF_) return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 263 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 264 +      // slow path -- read another buffer</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 265 +      this.seek(this.curr_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 266 +      if (this.curr_ == this.hi_) return -1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 267 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 268 +    len = Math.min(len, (int) (this.hi_ - this.curr_));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 269 +    int buffOff = (int) (this.curr_ - this.lo_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 270 +    System.arraycopy(this.buff_, buffOff, b, off, len);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 271 +    this.curr_ += len;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 272 +    return len;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 273 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 274 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 275 +  public void write(int b) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 276 +    if (this.curr_ &gt;= this.hi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 277 +      if (this.hitEOF_ &amp;&amp; this.hi_ &lt; this.maxHi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 278 +        // at EOF -- bump &quot;hi&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 279 +        this.hi_++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 280 +      } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 281 +        // slow path -- write current buffer; read next one</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 282 +        this.seek(this.curr_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 283 +        if (this.curr_ == this.hi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 284 +          // appending to EOF -- bump &quot;hi&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 285 +          this.hi_++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 286 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 287 +      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 288 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 289 +    this.buff_[(int) (this.curr_ - this.lo_)] = (byte) b;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 290 +    this.curr_++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 291 +    this.dirty_ = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 292 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 293 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 294 +  public void write(byte[] b) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 295 +    this.write(b, 0, b.length);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 296 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 297 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 298 +  public void write(byte[] b, int off, int len) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 299 +    while (len &gt; 0) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 300 +      int n = this.writeAtMost(b, off, len);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 301 +      off += n;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 302 +      len -= n;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 303 +      this.dirty_ = true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 304 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 305 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 306 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 307 +  /*</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 308 +   * Write at most &quot;len&quot; bytes to &quot;b&quot; starting at position &quot;off&quot;, and return</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 309 +   * the number of bytes written.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 310 +   */</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 311 +  private int writeAtMost(byte[] b, int off, int len) throws IOException {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 312 +    if (this.curr_ &gt;= this.hi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 313 +      if (this.hitEOF_ &amp;&amp; this.hi_ &lt; this.maxHi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 314 +        // at EOF -- bump &quot;hi&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 315 +        this.hi_ = this.maxHi_;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 316 +      } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 317 +        // slow path -- write current buffer; read next one</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 318 +        this.seek(this.curr_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 319 +        if (this.curr_ == this.hi_) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 320 +          // appending to EOF -- bump &quot;hi&quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 321 +          this.hi_ = this.maxHi_;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 322 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 323 +      }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 324 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 325 +    len = Math.min(len, (int) (this.hi_ - this.curr_));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 326 +    int buffOff = (int) (this.curr_ - this.lo_);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 327 +    System.arraycopy(b, off, this.buff_, buffOff, len);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 328 +    this.curr_ += len;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 329 +    return len;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 330 +  }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 331 +}</span></pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            