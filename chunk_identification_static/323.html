<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>323</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    323
                    <a href="322.html">prev</a>
                    <a href="324.html">next</a>
                    <a href="323_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    CyanogenMod/android_packages_apps_Trebuchet_29923f5082093b6211894f49edc653c29b28d99b_src/com/android/launcher3/LauncherBackupHelper.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;29923f5082093b6211894f49edc653c29b28d99b:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;29923f5082093b6211894f49edc653c29b28d99b^1:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;29923f5082093b6211894f49edc653c29b28d99b^2:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\CyanogenMod\android_packages_apps_Trebuchet show &quot;d6518c4b9569ddf9a8d66e4e60dc77c18e0ecb05:src/com/android/launcher3/LauncherBackupHelper.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b]], subset: [[b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19 import com.google.protobuf.nano.MessageNano;
  20 
  21 import com.android.launcher3.LauncherSettings.Favorites;
  22 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23 import com.android.launcher3.backup.BackupProtos;
  24 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25 import com.android.launcher3.backup.BackupProtos.Favorite;
  26 import com.android.launcher3.backup.BackupProtos.Journal;
  27 import com.android.launcher3.backup.BackupProtos.Key;
  28 import com.android.launcher3.backup.BackupProtos.Resource;
  29 import com.android.launcher3.backup.BackupProtos.Screen;
  30 import com.android.launcher3.backup.BackupProtos.Widget;
  31 import com.android.launcher3.compat.UserManagerCompat;
  32 import com.android.launcher3.compat.UserHandleCompat;
  33 
  34 import android.app.backup.BackupDataInputStream;
  35 import android.app.backup.BackupDataOutput;
  36 import android.app.backup.BackupHelper;
  37 import android.app.backup.BackupManager;
  38 import android.appwidget.AppWidgetManager;
  39 import android.appwidget.AppWidgetProviderInfo;
  40 import android.content.ComponentName;
  41 import android.content.ContentResolver;
  42 import android.content.ContentValues;
  43 import android.content.Context;
  44 import android.content.Intent;
  45 import android.database.Cursor;
  46 import android.graphics.Bitmap;
  47 import android.graphics.BitmapFactory;
  48 import android.graphics.drawable.Drawable;
  49 import android.os.ParcelFileDescriptor;
  50 import android.text.TextUtils;
  51 import android.util.Base64;
  52 import android.util.Log;
  53 
  54 import java.io.ByteArrayOutputStream;
  55 import java.io.FileInputStream;
  56 import java.io.FileOutputStream;
  57 import java.io.IOException;
  58 import java.net.URISyntaxException;
  59 import java.util.ArrayList;
  60 import java.util.HashMap;
  61 import java.util.HashSet;
  62 import java.util.List;
  63 import java.util.Set;
  64 import java.util.zip.CRC32;
  65 
  66 /**
  67  * Persist the launcher home state across calamities.
  68  */
  69 public class LauncherBackupHelper implements BackupHelper {
  70 
  71     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  72     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  73     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  74     private static final boolean DEBUG_PAYLOAD = false;
  75 
  76     private static final int MAX_JOURNAL_SIZE = 1000000;
  77 
  78     /** icons are large, dribble them out */
  79     private static final int MAX_ICONS_PER_PASS = 10;
  80 
  81     /** widgets contain previews, which are very large, dribble them out */
  82     private static final int MAX_WIDGETS_PER_PASS = 5;
  83 
  84     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  85 
  86     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  87 
  88     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  89 
  90     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  91             android.graphics.Bitmap.CompressFormat.PNG;
  92 
  93     private static BackupManager sBackupManager;
  94 
  95     private static final String[] FAVORITE_PROJECTION = {
  96             Favorites._ID,                     // 0
  97             Favorites.MODIFIED,                // 1
  98             Favorites.INTENT,                  // 2
  99             Favorites.APPWIDGET_PROVIDER,      // 3
 100             Favorites.APPWIDGET_ID,            // 4
 101             Favorites.CELLX,                   // 5
 102             Favorites.CELLY,                   // 6
 103             Favorites.CONTAINER,               // 7
 104             Favorites.ICON,                    // 8
 105             Favorites.ICON_PACKAGE,            // 9
 106             Favorites.ICON_RESOURCE,           // 10
 107             Favorites.ICON_TYPE,               // 11
 108             Favorites.ITEM_TYPE,               // 12
 109             Favorites.SCREEN,                  // 13
 110             Favorites.SPANX,                   // 14
 111             Favorites.SPANY,                   // 15
 112             Favorites.TITLE,                   // 16
 113             Favorites.PROFILE_ID,              // 17
 114     };
 115 
 116     private static final int ID_INDEX = 0;
 117     private static final int ID_MODIFIED = 1;
 118     private static final int INTENT_INDEX = 2;
 119     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 120     private static final int APPWIDGET_ID_INDEX = 4;
 121     private static final int CELLX_INDEX = 5;
 122     private static final int CELLY_INDEX = 6;
 123     private static final int CONTAINER_INDEX = 7;
 124     private static final int ICON_INDEX = 8;
 125     private static final int ICON_PACKAGE_INDEX = 9;
 126     private static final int ICON_RESOURCE_INDEX = 10;
 127     private static final int ICON_TYPE_INDEX = 11;
 128     private static final int ITEM_TYPE_INDEX = 12;
 129     private static final int SCREEN_INDEX = 13;
 130     private static final int SPANX_INDEX = 14;
 131     private static final int SPANY_INDEX = 15;
 132     private static final int TITLE_INDEX = 16;
 133     private static final int PROFILE_ID_INDEX = 17;
 134 
 135     private static final String[] SCREEN_PROJECTION = {
 136             WorkspaceScreens._ID,              // 0
 137             WorkspaceScreens.MODIFIED,         // 1
 138             WorkspaceScreens.SCREEN_RANK       // 2
 139     };
 140 
 141     private static final int SCREEN_RANK_INDEX = 2;
 142 
 143     private static IconCache mIconCache;
 144 
 145     private final Context mContext;
 146 
 147     private final boolean mRestoreEnabled;
 148 
 149     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 150 
 151     private final ArrayList&lt;Key&gt; mKeys;
 152 
 153     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 154         mContext = context;
 155         mRestoreEnabled = restoreEnabled;
 156         mKeys = new ArrayList&lt;Key&gt;();
 157     }
 158 
 159     private void dataChanged() {
 160         if (sBackupManager == null) {
 161             sBackupManager = new BackupManager(mContext);
 162         }
 163         sBackupManager.dataChanged();
 164     }
 165 
 166     /**
 167      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 168      *
 169      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 170      *
 171      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 172      *
 173      * @param oldState notes from the last backup
 174      * @param data incremental key/value pairs to persist off-device
 175      * @param newState notes for the next backup
 176      * @throws IOException
 177      */
 178     @Override
 179     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 180             ParcelFileDescriptor newState) {
 181         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 182 
 183         Journal in = readJournal(oldState);
 184         Journal out = new Journal();
 185 
 186         long lastBackupTime = in.t;
 187         out.t = System.currentTimeMillis();
 188         out.rows = 0;
 189         out.bytes = 0;
 190 
 191         Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 192 
 193         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 194         try {
 195             backupFavorites(in, data, out, keys);
 196             backupScreens(in, data, out, keys);
 197             backupIcons(in, data, out, keys);
 198             backupWidgets(in, data, out, keys);
 199         } catch (IOException e) {
 200             Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 201         }
 202 
 203 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
 204 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 205             out.key = keys.toArray(new BackupProtos.Key[keys.size()]);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 206         } else {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 207             out = in;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 208         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0"> 209 </span>
 210 &lt;&lt;&lt;&lt;&lt;&lt;&lt; OURS
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0"> 211         out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>
 212 =======
 213 &gt;&gt;&gt;&gt;&gt;&gt;&gt; THEIRS
 214         writeJournal(newState, out);
 215         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 216     }
 217 =======
 218         out.key = keys.toArray(BackupProtos.Key.emptyArray());
 219 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
 220         writeJournal(newState, out);
 221         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 222     }
 223 
 224     /**
 225      * Restore launcher configuration from the restored data stream.
 226      *
 227      * &lt;P&gt;Keys may arrive in any order.
 228      *
 229      * @param data the key/value pair from the server
 230      */
 231     @Override
 232     public void restoreEntity(BackupDataInputStream data) {
 233         if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 234         byte[] buffer = new byte[512];
 235             String backupKey = data.getKey();
 236             int dataSize = data.size();
 237             if (buffer.length &lt; dataSize) {
 238                 buffer = new byte[dataSize];
 239             }
 240             Key key = null;
 241         int bytesRead = 0;
 242         try {
 243             bytesRead = data.read(buffer, 0, dataSize);
 244             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 245         } catch (IOException e) {
 246             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 247         }
 248         try {
 249             key = backupKeyToKey(backupKey);
 250             mKeys.add(key);
 251             switch (key.type) {
 252                 case Key.FAVORITE:
 253                     restoreFavorite(key, buffer, dataSize, mKeys);
 254                     break;
 255 
 256                 case Key.SCREEN:
 257                     restoreScreen(key, buffer, dataSize, mKeys);
 258                     break;
 259 
 260                 case Key.ICON:
 261                     restoreIcon(key, buffer, dataSize, mKeys);
 262                     break;
 263 
 264                 case Key.WIDGET:
 265                     restoreWidget(key, buffer, dataSize, mKeys);
 266                     break;
 267 
 268                 default:
 269                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 270                     break;
 271             }
 272         } catch (KeyParsingException e) {
 273             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 274         }
 275 
 276     }
 277 
 278     /**
 279      * Record the restore state for the next backup.
 280      *
 281      * @param newState notes about the backup state after restore.
 282      */
 283     @Override
 284     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 285         // clear the output journal time, to force a full backup to
 286         // will catch any changes the restore process might have made
 287         Journal out = new Journal();
 288         out.t = 0;
 289         out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 290         writeJournal(newState, out);
 291         Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 292         mKeys.clear();
 293     }
 294 
 295     /**
 296      * Write all modified favorites to the data stream.
 297      *
 298      *
 299      * @param in notes from last backup
 300      * @param data output stream for key/value pairs
 301      * @param out notes about this backup
 302      * @param keys keys to mark as clean in the notes for next backup
 303      * @throws IOException
 304      */
 305     private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 306             ArrayList&lt;Key&gt; keys)
 307             throws IOException {
 308         // read the old ID set
 309         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 310         if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 311 
 312         // persist things that have changed since the last backup
 313         ContentResolver cr = mContext.getContentResolver();
 314         // Don&#x27;t backup apps in other profiles for now.
 315         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 316                 getUserSelectionArg(), null, null);
 317         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 318         try {
 319             cursor.moveToPosition(-1);
 320             while(cursor.moveToNext()) {
 321                 final long id = cursor.getLong(ID_INDEX);
 322                 final long updateTime = cursor.getLong(ID_MODIFIED);
 323                 Key key = getKey(Key.FAVORITE, id);
 324                 keys.add(key);
 325                 final String backupKey = keyToBackupKey(key);
 326                 currentIds.add(backupKey);
 327                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 328                     byte[] blob = packFavorite(cursor);
 329                     writeRowToBackup(key, blob, out, data);
 330                 } else {
 331                     if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 332                 }
 333             }
 334         } finally {
 335             cursor.close();
 336         }
 337         if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 338 
 339         // these IDs must have been deleted
 340         savedIds.removeAll(currentIds);
 341         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 342     }
 343 
 344     /**
 345      * Read a favorite from the stream.
 346      *
 347      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 348      *
 349      * @param key identifier for the row
 350      * @param buffer the serialized proto from the stream, may be larger than dataSize
 351      * @param dataSize the size of the proto from the stream
 352      * @param keys keys to mark as clean in the notes for next backup
 353      */
 354     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 355         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 356         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 357                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 358 
 359         if (!mRestoreEnabled) {
 360             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 361             return;
 362         }
 363 
 364         try {
 365             ContentResolver cr = mContext.getContentResolver();
 366             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 367             cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 368         } catch (InvalidProtocolBufferNanoException e) {
 369             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 370         }
 371     }
 372 
 373     /**
 374      * Write all modified screens to the data stream.
 375      *
 376      *
 377      * @param in notes from last backup
 378      * @param data output stream for key/value pairs
 379      * @param out notes about this backup
 380      * @param keys keys to mark as clean in the notes for next backup
 381      * @throws IOException
 382      */
 383     private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 384             ArrayList&lt;Key&gt; keys)
 385             throws IOException {
 386         // read the old ID set
 387         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 388         if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 389 
 390         // persist things that have changed since the last backup
 391         ContentResolver cr = mContext.getContentResolver();
 392         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 393                 null, null, null);
 394         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 395         try {
 396             cursor.moveToPosition(-1);
 397             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 398             while(cursor.moveToNext()) {
 399                 final long id = cursor.getLong(ID_INDEX);
 400                 final long updateTime = cursor.getLong(ID_MODIFIED);
 401                 Key key = getKey(Key.SCREEN, id);
 402                 keys.add(key);
 403                 final String backupKey = keyToBackupKey(key);
 404                 currentIds.add(backupKey);
 405                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 406                     byte[] blob = packScreen(cursor);
 407                     writeRowToBackup(key, blob, out, data);
 408                 } else {
 409                     if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 410                 }
 411             }
 412         } finally {
 413             cursor.close();
 414         }
 415         if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 416 
 417         // these IDs must have been deleted
 418         savedIds.removeAll(currentIds);
 419         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 420     }
 421 
 422     /**
 423      * Read a screen from the stream.
 424      *
 425      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 426      *
 427      * @param key identifier for the row
 428      * @param buffer the serialized proto from the stream, may be larger than dataSize
 429      * @param dataSize the size of the proto from the stream
 430      * @param keys keys to mark as clean in the notes for next backup
 431      */
 432     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 433         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 434         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 435                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 436 
 437         if (!mRestoreEnabled) {
 438             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 439             return;
 440         }
 441 
 442         try {
 443             ContentResolver cr = mContext.getContentResolver();
 444             ContentValues values = unpackScreen(buffer, 0, dataSize);
 445             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 446 
 447         } catch (InvalidProtocolBufferNanoException e) {
 448             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 449         }
 450     }
 451 
 452     /**
 453      * Write all the static icon resources we need to render placeholders
 454      * for a package that is not installed.
 455      *
 456      * @param in notes from last backup
 457      * @param data output stream for key/value pairs
 458      * @param out notes about this backup
 459      * @param keys keys to mark as clean in the notes for next backup
 460      * @throws IOException
 461      */
 462     private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 463             ArrayList&lt;Key&gt; keys) throws IOException {
 464         // persist icons that haven&#x27;t been persisted yet
 465         if (!initializeIconCache()) {
 466             dataChanged(); // try again later
 467             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 468             return;
 469         }
 470         final ContentResolver cr = mContext.getContentResolver();
 471         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 472         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 473 
 474         // read the old ID set
 475         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 476         if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 477 
 478         // Don&#x27;t backup apps in other profiles for now.
 479         int startRows = out.rows;
 480         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 481 
 482         String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 483                 Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 484                 getUserSelectionArg();
 485         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 486                 where, null, null);
 487         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 488         try {
 489             cursor.moveToPosition(-1);
 490             while(cursor.moveToNext()) {
 491                 final long id = cursor.getLong(ID_INDEX);
 492                 final String intentDescription = cursor.getString(INTENT_INDEX);
 493                 try {
 494                     Intent intent = Intent.parseUri(intentDescription, 0);
 495                     ComponentName cn = intent.getComponent();
 496                     Key key = null;
 497                     String backupKey = null;
 498                     if (cn != null) {
 499                         key = getKey(Key.ICON, cn.flattenToShortString());
 500                         backupKey = keyToBackupKey(key);
 501                         currentIds.add(backupKey);
 502                     } else {
 503                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 504                     }
 505                     if (savedIds.contains(backupKey)) {
 506                         if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 507 
 508                         // remember that we already backed this up previously
 509                         keys.add(key);
 510                     } else if (backupKey != null) {
 511                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 512                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 513                             if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 514                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 515                             keys.add(key);
 516                             if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 517                                 byte[] blob = packIcon(dpi, icon);
 518                                 writeRowToBackup(key, blob, out, data);
 519                             }
 520                         } else {
 521                             if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 522                             // too many icons for this pass, request another.
 523                             dataChanged();
 524                         }
 525                     }
 526                 } catch (URISyntaxException e) {
 527                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 528                 } catch (IOException e) {
 529                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 530                 }
 531 
 532             }
 533         } finally {
 534             cursor.close();
 535         }
 536         if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 537 
 538         // these IDs must have been deleted
 539         savedIds.removeAll(currentIds);
 540         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 541     }
 542 
 543     /**
 544      * Read an icon from the stream.
 545      *
 546      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 547      *
 548      * @param key identifier for the row
 549      * @param buffer the serialized proto from the stream, may be larger than dataSize
 550      * @param dataSize the size of the proto from the stream
 551      * @param keys keys to mark as clean in the notes for next backup
 552      */
 553     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 554         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 555         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 556                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 557 
 558         try {
 559             Resource res = unpackIcon(buffer, 0, dataSize);
 560             if (DEBUG) {
 561                 Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 562             }
 563             if (DEBUG_PAYLOAD) {
 564                 Log.d(TAG, &quot;read &quot; +
 565                         Base64.encodeToString(res.data, 0, res.data.length,
 566                                 Base64.NO_WRAP));
 567             }
 568             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 569             if (icon == null) {
 570                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 571             }
 572 
 573             if (!mRestoreEnabled) {
 574                 if (VERBOSE) {
 575                     Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 576                 }
 577                 return;
 578             } else {
 579                 if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 580                 IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name),
 581                         icon, res.dpi);
 582             }
 583         } catch (IOException e) {
 584             Log.d(TAG, &quot;failed to save restored icon for: &quot; + key.name, e);
 585         }
 586     }
 587 
 588     /**
 589      * Write all the static widget resources we need to render placeholders
 590      * for a package that is not installed.
 591      *
 592      * @param in notes from last backup
 593      * @param data output stream for key/value pairs
 594      * @param out notes about this backup
 595      * @param keys keys to mark as clean in the notes for next backup
 596      * @throws IOException
 597      */
 598     private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 599             ArrayList&lt;Key&gt; keys) throws IOException {
 600         // persist static widget info that hasn&#x27;t been persisted yet
 601         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 602         if (appState == null || !initializeIconCache()) {
 603             Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 604             return;
 605         }
 606         final ContentResolver cr = mContext.getContentResolver();
 607         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 608         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 609         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 610         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 611         if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 612 
 613         // read the old ID set
 614         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 615         if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 616 
 617         int startRows = out.rows;
 618         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 619         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 620                 + getUserSelectionArg();
 621         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 622                 where, null, null);
 623         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 624         try {
 625             cursor.moveToPosition(-1);
 626             while(cursor.moveToNext()) {
 627                 final long id = cursor.getLong(ID_INDEX);
 628                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 629                 final int spanX = cursor.getInt(SPANX_INDEX);
 630                 final int spanY = cursor.getInt(SPANY_INDEX);
 631                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 632                 Key key = null;
 633                 String backupKey = null;
 634                 if (provider != null) {
 635                     key = getKey(Key.WIDGET, providerName);
 636                     backupKey = keyToBackupKey(key);
 637                     currentIds.add(backupKey);
 638                 } else {
 639                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 640                 }
 641                 if (savedIds.contains(backupKey)) {
 642                     if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 643 
 644                     // remember that we already backed this up previously
 645                     keys.add(key);
 646                 } else if (backupKey != null) {
 647                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 648                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 649                         if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 650                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 651                                 spanY * profile.cellHeightPx, widgetSpacingLayout);
 652                         byte[] blob = packWidget(dpi, previewLoader, mIconCache, provider);
 653                         keys.add(key);
 654                         writeRowToBackup(key, blob, out, data);
 655 
 656                     } else {
 657                         if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 658                         // too many widgets for this pass, request another.
 659                         dataChanged();
 660                     }
 661                 }
 662             }
 663         } finally {
 664             cursor.close();
 665         }
 666         if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 667 
 668         // these IDs must have been deleted
 669         savedIds.removeAll(currentIds);
 670         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 671     }
 672 
 673     /**
 674      * Read a widget from the stream.
 675      *
 676      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 677      *
 678      * @param key identifier for the row
 679      * @param buffer the serialized proto from the stream, may be larger than dataSize
 680      * @param dataSize the size of the proto from the stream
 681      * @param keys keys to mark as clean in the notes for next backup
 682      */
 683     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 684         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 685         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 686                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 687         try {
 688             Widget widget = unpackWidget(buffer, 0, dataSize);
 689             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 690             if (widget.icon.data != null)  {
 691                 Bitmap icon = BitmapFactory
 692                         .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 693                 if (icon == null) {
 694                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 695                 } else {
 696                     IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider),
 697                             icon, widget.icon.dpi);
 698                 }
 699             }
 700 
 701             if (!mRestoreEnabled) {
 702                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 703                 return;
 704             } else {
 705                 // future site of widget table mutation
 706             }
 707         } catch (InvalidProtocolBufferNanoException e) {
 708             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 709         }
 710     }
 711 
 712     /** create a new key, with an integer ID.
 713      *
 714      * &lt;P&gt; Keys contain their own checksum instead of using
 715      * the heavy-weight CheckedMessage wrapper.
 716      */
 717     private Key getKey(int type, long id) {
 718         Key key = new Key();
 719         key.type = type;
 720         key.id = id;
 721         key.checksum = checkKey(key);
 722         return key;
 723     }
 724 
 725     /** create a new key for a named object.
 726      *
 727      * &lt;P&gt; Keys contain their own checksum instead of using
 728      * the heavy-weight CheckedMessage wrapper.
 729      */
 730     private Key getKey(int type, String name) {
 731         Key key = new Key();
 732         key.type = type;
 733         key.name = name;
 734         key.checksum = checkKey(key);
 735         return key;
 736     }
 737 
 738     /** keys need to be strings, serialize and encode. */
 739     private String keyToBackupKey(Key key) {
 740         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 741     }
 742 
 743     /** keys need to be strings, decode and parse. */
 744     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 745         try {
 746             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 747             if (key.checksum != checkKey(key)) {
 748                 key = null;
 749                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 750             }
 751             return key;
 752         } catch (InvalidProtocolBufferNanoException e) {
 753             throw new KeyParsingException(e);
 754         } catch (IllegalArgumentException e) {
 755             throw new KeyParsingException(e);
 756         }
 757     }
 758 
 759     private String getKeyName(Key key) {
 760         if (TextUtils.isEmpty(key.name)) {
 761             return Long.toString(key.id);
 762         } else {
 763             return key.name;
 764         }
 765 
 766     }
 767 
 768     private String geKeyType(Key key) {
 769         switch (key.type) {
 770             case Key.FAVORITE:
 771                 return &quot;favorite&quot;;
 772             case Key.SCREEN:
 773                 return &quot;screen&quot;;
 774             case Key.ICON:
 775                 return &quot;icon&quot;;
 776             case Key.WIDGET:
 777                 return &quot;widget&quot;;
 778             default:
 779                 return &quot;anonymous&quot;;
 780         }
 781     }
 782 
 783     /** Compute the checksum over the important bits of a key. */
 784     private long checkKey(Key key) {
 785         CRC32 checksum = new CRC32();
 786         checksum.update(key.type);
 787         checksum.update((int) (key.id &amp; 0xffff));
 788         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 789         if (!TextUtils.isEmpty(key.name)) {
 790             checksum.update(key.name.getBytes());
 791         }
 792         return checksum.getValue();
 793     }
 794 
 795     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 796     private byte[] packFavorite(Cursor c) {
 797         Favorite favorite = new Favorite();
 798         favorite.id = c.getLong(ID_INDEX);
 799         favorite.screen = c.getInt(SCREEN_INDEX);
 800         favorite.container = c.getInt(CONTAINER_INDEX);
 801         favorite.cellX = c.getInt(CELLX_INDEX);
 802         favorite.cellY = c.getInt(CELLY_INDEX);
 803         favorite.spanX = c.getInt(SPANX_INDEX);
 804         favorite.spanY = c.getInt(SPANY_INDEX);
 805         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 806         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 807             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 808             if (!TextUtils.isEmpty(iconPackage)) {
 809                 favorite.iconPackage = iconPackage;
 810             }
 811             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 812             if (!TextUtils.isEmpty(iconResource)) {
 813                 favorite.iconResource = iconResource;
 814             }
 815         }
 816         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 817             byte[] blob = c.getBlob(ICON_INDEX);
 818             if (blob != null &amp;&amp; blob.length &gt; 0) {
 819                 favorite.icon = blob;
 820             }
 821         }
 822         String title = c.getString(TITLE_INDEX);
 823         if (!TextUtils.isEmpty(title)) {
 824             favorite.title = title;
 825         }
 826         String intentDescription = c.getString(INTENT_INDEX);
 827         if (!TextUtils.isEmpty(intentDescription)) {
 828             try {
 829                 Intent intent = Intent.parseUri(intentDescription, 0);
 830                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 831                 favorite.intent = intent.toUri(0);
 832             } catch (URISyntaxException e) {
 833                 Log.e(TAG, &quot;Invalid intent&quot;, e);
 834            }
 835         }
 836         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 837         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 838             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 839             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 840             if (!TextUtils.isEmpty(appWidgetProvider)) {
 841                 favorite.appWidgetProvider = appWidgetProvider;
 842             }
 843         }
 844 
 845         return writeCheckedBytes(favorite);
 846     }
 847 
 848     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 849     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 850             throws InvalidProtocolBufferNanoException {
 851         Favorite favorite = new Favorite();
 852         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 853         if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 854                 (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 855         ContentValues values = new ContentValues();
 856         values.put(Favorites._ID, favorite.id);
 857         values.put(Favorites.SCREEN, favorite.screen);
 858         values.put(Favorites.CONTAINER, favorite.container);
 859         values.put(Favorites.CELLX, favorite.cellX);
 860         values.put(Favorites.CELLY, favorite.cellY);
 861         values.put(Favorites.SPANX, favorite.spanX);
 862         values.put(Favorites.SPANY, favorite.spanY);
 863         values.put(Favorites.ICON_TYPE, favorite.iconType);
 864         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 865             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 866             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 867         }
 868         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 869             values.put(Favorites.ICON, favorite.icon);
 870         }
 871         if (!TextUtils.isEmpty(favorite.title)) {
 872             values.put(Favorites.TITLE, favorite.title);
 873         } else {
 874             values.put(Favorites.TITLE, &quot;&quot;);
 875         }
 876         if (!TextUtils.isEmpty(favorite.intent)) {
 877             values.put(Favorites.INTENT, favorite.intent);
 878         }
 879         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 880 
 881         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 882         long userSerialNumber =
 883                 UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
 884         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 885 
 886         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 887             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 888                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 889             }
 890             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 891             values.put(LauncherSettings.Favorites.RESTORED,
 892                     LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
 893                     LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
 894                     LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
 895         } else {
 896             // Let LauncherModel know we&#x27;ve been here.
 897             values.put(LauncherSettings.Favorites.RESTORED, 1);
 898         }
 899 
 900         return values;
 901     }
 902 
 903     /** Serialize a Screen for persistence, including a checksum wrapper. */
 904     private byte[] packScreen(Cursor c) {
 905         Screen screen = new Screen();
 906         screen.id = c.getLong(ID_INDEX);
 907         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 908 
 909         return writeCheckedBytes(screen);
 910     }
 911 
 912     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 913     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 914             throws InvalidProtocolBufferNanoException {
 915         Screen screen = new Screen();
 916         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 917         if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 918         ContentValues values = new ContentValues();
 919         values.put(WorkspaceScreens._ID, screen.id);
 920         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 921         return values;
 922     }
 923 
 924     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 925     private byte[] packIcon(int dpi, Bitmap icon) {
 926         Resource res = new Resource();
 927         res.dpi = dpi;
 928         ByteArrayOutputStream os = new ByteArrayOutputStream();
 929         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 930             res.data = os.toByteArray();
 931         }
 932         return writeCheckedBytes(res);
 933     }
 934 
 935     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 936     private static Resource unpackIcon(byte[] buffer, int offset, int dataSize)
 937             throws InvalidProtocolBufferNanoException {
 938         Resource res = new Resource();
 939         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 940         if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 941         return res;
 942     }
 943 
 944     /** Serialize a widget for persistence, including a checksum wrapper. */
 945     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 946             ComponentName provider) {
 947         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 948         Widget widget = new Widget();
 949         widget.provider = provider.flattenToShortString();
 950         widget.label = info.label;
 951         widget.configure = info.configure != null;
 952         if (info.icon != 0) {
 953             widget.icon = new Resource();
 954             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 955             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 956             ByteArrayOutputStream os = new ByteArrayOutputStream();
 957             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 958                 widget.icon.data = os.toByteArray();
 959                 widget.icon.dpi = dpi;
 960             }
 961         }
 962         if (info.previewImage != 0) {
 963             widget.preview = new Resource();
 964             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 965             ByteArrayOutputStream os = new ByteArrayOutputStream();
 966             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 967                 widget.preview.data = os.toByteArray();
 968                 widget.preview.dpi = dpi;
 969             }
 970         }
 971         return writeCheckedBytes(widget);
 972     }
 973 
 974     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 975     private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 976             throws InvalidProtocolBufferNanoException {
 977         Widget widget = new Widget();
 978         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 979         if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 980         return widget;
 981     }
 982 
 983     /**
 984      * Read the old journal from the input file.
 985      *
 986      * In the event of any error, just pretend we didn&#x27;t have a journal,
 987      * in that case, do a full backup.
 988      *
 989      * @param oldState the read-0only file descriptor pointing to the old journal
 990      * @return a Journal protocol buffer
 991      */
 992     private Journal readJournal(ParcelFileDescriptor oldState) {
 993         Journal journal = new Journal();
 994         if (oldState == null) {
 995             return journal;
 996         }
 997         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 998         try {
 999             int availableBytes = inStream.available();
1000             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1001             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1002                 byte[] buffer = new byte[availableBytes];
1003                 int bytesRead = 0;
1004                 boolean valid = false;
1005                 InvalidProtocolBufferNanoException lastProtoException = null;
1006                 while (availableBytes &gt; 0) {
1007                     try {
1008                         // OMG what are you doing? This is crazy inefficient!
1009                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1010                         // However, we don&#x27;t know how many bytes to expect (oops).
1011                         // So we have to step through *slowly*, watching for the end.
1012                         int result = inStream.read(buffer, bytesRead, 1);
1013                         if (result &gt; 0) {
1014                             availableBytes -= result;
1015                             bytesRead += result;
1016                             if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
1017                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
1018                             }
1019                         } else {
1020                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1021                             // stop reading and see what there is to parse
1022                             availableBytes = 0;
1023                         }
1024                     } catch (IOException e) {
1025                         buffer = null;
1026                         availableBytes = 0;
1027                     }
1028 
1029                     // check the buffer to see if we have a valid journal
1030                     try {
1031                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1032                         // if we are here, then we have read a valid, checksum-verified journal
1033                         valid = true;
1034                         availableBytes = 0;
1035                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1036                     } catch (InvalidProtocolBufferNanoException e) {
1037                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1038                         lastProtoException = e;
1039                         journal.clear();
1040                     }
1041                 }
1042                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1043                 if (!valid) {
1044                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1045                 }
1046             }
1047         } catch (IOException e) {
1048             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1049         } finally {
1050             try {
1051                 inStream.close();
1052             } catch (IOException e) {
1053                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1054             }
1055         }
1056         return journal;
1057     }
1058 
1059     private void writeRowToBackup(Key key, byte[] blob, Journal out,
1060             BackupDataOutput data) throws IOException {
1061         String backupKey = keyToBackupKey(key);
1062         data.writeEntityHeader(backupKey, blob.length);
1063         data.writeEntityData(blob, blob.length);
1064         out.rows++;
1065         out.bytes += blob.length;
1066         if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1067                 getKeyName(key) + &quot;/&quot; + blob.length);
1068         if(DEBUG_PAYLOAD) {
1069             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1070             final int chunkSize = 1024;
1071             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1072                 int end = offset + chunkSize;
1073                 end = Math.min(end, encoded.length());
1074                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1075             }
1076         }
1077     }
1078 
1079     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1080         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1081         for(int i = 0; i &lt; in.key.length; i++) {
1082             Key key = in.key[i];
1083             if (key.type == type) {
1084                 savedIds.add(keyToBackupKey(key));
1085             }
1086         }
1087         return savedIds;
1088     }
1089 
1090     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1091             throws IOException {
1092         int rows = 0;
1093         for(String deleted: deletedIds) {
1094             if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1095             data.writeEntityHeader(deleted, -1);
1096             rows++;
1097         }
1098         return rows;
1099     }
1100 
1101     /**
1102      * Write the new journal to the output file.
1103      *
1104      * In the event of any error, just pretend we didn&#x27;t have a journal,
1105      * in that case, do a full backup.
1106 
1107      * @param newState the write-only file descriptor pointing to the new journal
1108      * @param journal a Journal protocol buffer
1109      */
1110     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1111         FileOutputStream outStream = null;
1112         try {
1113             outStream = new FileOutputStream(newState.getFileDescriptor());
1114             final byte[] journalBytes = writeCheckedBytes(journal);
1115             outStream.write(journalBytes);
1116             outStream.close();
1117             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1118         } catch (IOException e) {
1119             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1120         }
1121     }
1122 
1123     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1124     private byte[] writeCheckedBytes(MessageNano proto) {
1125         CheckedMessage wrapper = new CheckedMessage();
1126         wrapper.payload = MessageNano.toByteArray(proto);
1127         CRC32 checksum = new CRC32();
1128         checksum.update(wrapper.payload);
1129         wrapper.checksum = checksum.getValue();
1130         return MessageNano.toByteArray(wrapper);
1131     }
1132 
1133     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1134     private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)
1135             throws InvalidProtocolBufferNanoException {
1136         CheckedMessage wrapper = new CheckedMessage();
1137         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1138         CRC32 checksum = new CRC32();
1139         checksum.update(wrapper.payload);
1140         if (wrapper.checksum != checksum.getValue()) {
1141             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1142         }
1143         return wrapper.payload;
1144     }
1145 
1146     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1147         if (mWidgetMap == null) {
1148             List&lt;AppWidgetProviderInfo&gt; widgets =
1149                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1150             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1151             for (AppWidgetProviderInfo info : widgets) {
1152                 mWidgetMap.put(info.provider, info);
1153             }
1154         }
1155         return mWidgetMap.get(component);
1156     }
1157 
1158 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1159 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1160     private boolean initializeIconCache() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1161         if (mIconCache != null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1162             return true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1163         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1164 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1165         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1166         if (appState == null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1167             Throwable stackTrace = new Throwable();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1168             stackTrace.fillInStackTrace();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1169             Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1170             return false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1171         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1172         mIconCache = appState.getIconCache();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1173         return mIconCache != null;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1174     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1175 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1176 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1177    // check if the launcher is in a state to support backup</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1178     private boolean launcherIsReady() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1179         ContentResolver cr = mContext.getContentResolver();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1180         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1181         if (cursor == null) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1182             // launcher data has been wiped, do nothing</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1183             return false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1184         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1185         cursor.close();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1186 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1187         if (!initializeIconCache()) {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1188             // launcher services are unavailable, try again later</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1189             dataChanged();</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1190             return false;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1191         }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1192 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1193         return true;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1194     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1195 </span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1196     private String getUserSelectionArg() {</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1197         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1198                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1199     }</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">1200 </span>
1201 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1202             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1203             for (AppWidgetProviderInfo info : widgets) {</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1204                 mWidgetMap.put(info.provider, info);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1205             }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1206         }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1207         return mWidgetMap.get(component);</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1208     }</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">1209 </span>
1210 &lt;&lt;&lt;&lt;&lt;&lt;&lt; OURS
1211 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1212 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1213     private boolean initializeIconCache() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1214         if (mIconCache != null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1215             return true;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1216         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1217 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1218         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1219         if (appState == null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1220             Throwable stackTrace = new Throwable();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1221             stackTrace.fillInStackTrace();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1222             Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1223             return false;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1224         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1225         mIconCache = appState.getIconCache();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1226         return mIconCache != null;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1227     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1228 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1229 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1230    // check if the launcher is in a state to support backup</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1231     private boolean launcherIsReady() {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1232         ContentResolver cr = mContext.getContentResolver();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1233         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1234         if (cursor == null) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1235             // launcher data has been wiped, do nothing</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1236             return false;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1237         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1238         cursor.close();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1239 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1240         if (!initializeIconCache()) {</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1241             // launcher services are unavailable, try again later</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1242             dataChanged();</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1243             return false;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1244         }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1245 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1246         return true;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1247     }</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">1248 </span>
1249 &gt;&gt;&gt;&gt;&gt;&gt;&gt; THEIRS
1250     private class KeyParsingException extends Throwable {
1251         private KeyParsingException(Throwable cause) {
1252             super(cause);
1253         }
1254 
1255         public KeyParsingException(String reason) {
1256             super(reason);
1257         }
1258     }
1259 }
1260 =======
1261 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
1262     private class KeyParsingException extends Throwable {
1263         private KeyParsingException(Throwable cause) {
1264             super(cause);
1265         }
1266 
1267         public KeyParsingException(String reason) {
1268             super(reason);
1269         }
1270     }
1271 }</pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19 import com.google.protobuf.nano.MessageNano;
  20 
  21 import com.android.launcher3.LauncherSettings.Favorites;
  22 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23 import com.android.launcher3.backup.BackupProtos;
  24 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25 import com.android.launcher3.backup.BackupProtos.Favorite;
  26 import com.android.launcher3.backup.BackupProtos.Journal;
  27 import com.android.launcher3.backup.BackupProtos.Key;
  28 import com.android.launcher3.backup.BackupProtos.Resource;
  29 import com.android.launcher3.backup.BackupProtos.Screen;
  30 import com.android.launcher3.backup.BackupProtos.Widget;
  31 import com.android.launcher3.compat.UserManagerCompat;
  32 import com.android.launcher3.compat.UserHandleCompat;
  33 
  34 import android.app.backup.BackupDataInputStream;
  35 import android.app.backup.BackupDataOutput;
  36 import android.app.backup.BackupHelper;
  37 import android.app.backup.BackupManager;
  38 import android.appwidget.AppWidgetManager;
  39 import android.appwidget.AppWidgetProviderInfo;
  40 import android.content.ComponentName;
  41 import android.content.ContentResolver;
  42 import android.content.ContentValues;
  43 import android.content.Context;
  44 import android.content.Intent;
  45 import android.database.Cursor;
  46 import android.graphics.Bitmap;
  47 import android.graphics.BitmapFactory;
  48 import android.graphics.drawable.Drawable;
  49 import android.os.ParcelFileDescriptor;
  50 import android.text.TextUtils;
  51 import android.util.Base64;
  52 import android.util.Log;
  53 
  54 import java.io.ByteArrayOutputStream;
  55 import java.io.FileInputStream;
  56 import java.io.FileOutputStream;
  57 import java.io.IOException;
  58 import java.net.URISyntaxException;
  59 import java.util.ArrayList;
  60 import java.util.HashMap;
  61 import java.util.HashSet;
  62 import java.util.List;
  63 import java.util.Set;
  64 import java.util.zip.CRC32;
  65 
  66 /**
  67  * Persist the launcher home state across calamities.
  68  */
  69 public class LauncherBackupHelper implements BackupHelper {
  70 
  71     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  72     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  73     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  74     private static final boolean DEBUG_PAYLOAD = false;
  75 
  76     private static final int MAX_JOURNAL_SIZE = 1000000;
  77 
  78     /** icons are large, dribble them out */
  79     private static final int MAX_ICONS_PER_PASS = 10;
  80 
  81     /** widgets contain previews, which are very large, dribble them out */
  82     private static final int MAX_WIDGETS_PER_PASS = 5;
  83 
  84     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  85 
  86     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  87 
  88     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  89 
  90     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  91             android.graphics.Bitmap.CompressFormat.PNG;
  92 
  93     private static BackupManager sBackupManager;
  94 
  95     private static final String[] FAVORITE_PROJECTION = {
  96             Favorites._ID,                     // 0
  97             Favorites.MODIFIED,                // 1
  98             Favorites.INTENT,                  // 2
  99             Favorites.APPWIDGET_PROVIDER,      // 3
 100             Favorites.APPWIDGET_ID,            // 4
 101             Favorites.CELLX,                   // 5
 102             Favorites.CELLY,                   // 6
 103             Favorites.CONTAINER,               // 7
 104             Favorites.ICON,                    // 8
 105             Favorites.ICON_PACKAGE,            // 9
 106             Favorites.ICON_RESOURCE,           // 10
 107             Favorites.ICON_TYPE,               // 11
 108             Favorites.ITEM_TYPE,               // 12
 109             Favorites.SCREEN,                  // 13
 110             Favorites.SPANX,                   // 14
 111             Favorites.SPANY,                   // 15
 112             Favorites.TITLE,                   // 16
 113             Favorites.PROFILE_ID,              // 17
 114     };
 115 
 116     private static final int ID_INDEX = 0;
 117     private static final int ID_MODIFIED = 1;
 118     private static final int INTENT_INDEX = 2;
 119     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 120     private static final int APPWIDGET_ID_INDEX = 4;
 121     private static final int CELLX_INDEX = 5;
 122     private static final int CELLY_INDEX = 6;
 123     private static final int CONTAINER_INDEX = 7;
 124     private static final int ICON_INDEX = 8;
 125     private static final int ICON_PACKAGE_INDEX = 9;
 126     private static final int ICON_RESOURCE_INDEX = 10;
 127     private static final int ICON_TYPE_INDEX = 11;
 128     private static final int ITEM_TYPE_INDEX = 12;
 129     private static final int SCREEN_INDEX = 13;
 130     private static final int SPANX_INDEX = 14;
 131     private static final int SPANY_INDEX = 15;
 132     private static final int TITLE_INDEX = 16;
 133     private static final int PROFILE_ID_INDEX = 17;
 134 
 135     private static final String[] SCREEN_PROJECTION = {
 136             WorkspaceScreens._ID,              // 0
 137             WorkspaceScreens.MODIFIED,         // 1
 138             WorkspaceScreens.SCREEN_RANK       // 2
 139     };
 140 
 141     private static final int SCREEN_RANK_INDEX = 2;
 142 
 143     private static IconCache mIconCache;
 144 
 145     private final Context mContext;
 146 
 147     private final boolean mRestoreEnabled;
 148 
 149     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 150 
 151     private final ArrayList&lt;Key&gt; mKeys;
 152 
 153     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 154         mContext = context;
 155         mRestoreEnabled = restoreEnabled;
 156         mKeys = new ArrayList&lt;Key&gt;();
 157     }
 158 
 159     private void dataChanged() {
 160         if (sBackupManager == null) {
 161             sBackupManager = new BackupManager(mContext);
 162         }
 163         sBackupManager.dataChanged();
 164     }
 165 
 166     /**
 167      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 168      *
 169      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 170      *
 171      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 172      *
 173      * @param oldState notes from the last backup
 174      * @param data incremental key/value pairs to persist off-device
 175      * @param newState notes for the next backup
 176      * @throws IOException
 177      */
 178     @Override
 179     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 180             ParcelFileDescriptor newState) {
 181         if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 182 
 183         Journal in = readJournal(oldState);
 184         Journal out = new Journal();
 185 
 186         long lastBackupTime = in.t;
 187         out.t = System.currentTimeMillis();
 188         out.rows = 0;
 189         out.bytes = 0;
 190 
 191         Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 192 
 193         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 194         if (launcherIsReady()) {
 195             try {
 196                 backupFavorites(in, data, out, keys);
 197                 backupScreens(in, data, out, keys);
 198                 backupIcons(in, data, out, keys);
 199                 backupWidgets(in, data, out, keys);
 200             } catch (IOException e) {
 201                 Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 202             }
 203             out.key = keys.toArray(new BackupProtos.Key[keys.size()]);
 204         } else {
 205             out = in;
 206         }
 207 
 208         writeJournal(newState, out);
 209         Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 210     }
 211 
 212     /**
 213      * Restore launcher configuration from the restored data stream.
 214      *
 215      * &lt;P&gt;Keys may arrive in any order.
 216      *
 217      * @param data the key/value pair from the server
 218      */
 219     @Override
 220     public void restoreEntity(BackupDataInputStream data) {
 221         if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
 222         byte[] buffer = new byte[512];
 223             String backupKey = data.getKey();
 224             int dataSize = data.size();
 225             if (buffer.length &lt; dataSize) {
 226                 buffer = new byte[dataSize];
 227             }
 228             Key key = null;
 229         int bytesRead = 0;
 230         try {
 231             bytesRead = data.read(buffer, 0, dataSize);
 232             if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 233         } catch (IOException e) {
 234             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 235         }
 236         try {
 237             key = backupKeyToKey(backupKey);
 238             mKeys.add(key);
 239             switch (key.type) {
 240                 case Key.FAVORITE:
 241                     restoreFavorite(key, buffer, dataSize, mKeys);
 242                     break;
 243 
 244                 case Key.SCREEN:
 245                     restoreScreen(key, buffer, dataSize, mKeys);
 246                     break;
 247 
 248                 case Key.ICON:
 249                     restoreIcon(key, buffer, dataSize, mKeys);
 250                     break;
 251 
 252                 case Key.WIDGET:
 253                     restoreWidget(key, buffer, dataSize, mKeys);
 254                     break;
 255 
 256                 default:
 257                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 258                     break;
 259             }
 260         } catch (KeyParsingException e) {
 261             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 262         }
 263 
 264     }
 265 
 266     /**
 267      * Record the restore state for the next backup.
 268      *
 269      * @param newState notes about the backup state after restore.
 270      */
 271     @Override
 272     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 273         // clear the output journal time, to force a full backup to
 274         // will catch any changes the restore process might have made
 275         Journal out = new Journal();
 276         out.t = 0;
 277         out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 278         writeJournal(newState, out);
 279         Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 280         mKeys.clear();
 281     }
 282 
 283     /**
 284      * Write all modified favorites to the data stream.
 285      *
 286      *
 287      * @param in notes from last backup
 288      * @param data output stream for key/value pairs
 289      * @param out notes about this backup
 290      * @param keys keys to mark as clean in the notes for next backup
 291      * @throws IOException
 292      */
 293     private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 294             ArrayList&lt;Key&gt; keys)
 295             throws IOException {
 296         // read the old ID set
 297         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 298         if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 299 
 300         // persist things that have changed since the last backup
 301         ContentResolver cr = mContext.getContentResolver();
 302         // Don&#x27;t backup apps in other profiles for now.
 303         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 304                 getUserSelectionArg(), null, null);
 305         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 306         try {
 307             cursor.moveToPosition(-1);
 308             while(cursor.moveToNext()) {
 309                 final long id = cursor.getLong(ID_INDEX);
 310                 final long updateTime = cursor.getLong(ID_MODIFIED);
 311                 Key key = getKey(Key.FAVORITE, id);
 312                 keys.add(key);
 313                 final String backupKey = keyToBackupKey(key);
 314                 currentIds.add(backupKey);
 315                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 316                     byte[] blob = packFavorite(cursor);
 317                     writeRowToBackup(key, blob, out, data);
 318                 } else {
 319                     if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 320                 }
 321             }
 322         } finally {
 323             cursor.close();
 324         }
 325         if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 326 
 327         // these IDs must have been deleted
 328         savedIds.removeAll(currentIds);
 329         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 330     }
 331 
 332     /**
 333      * Read a favorite from the stream.
 334      *
 335      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 336      *
 337      * @param key identifier for the row
 338      * @param buffer the serialized proto from the stream, may be larger than dataSize
 339      * @param dataSize the size of the proto from the stream
 340      * @param keys keys to mark as clean in the notes for next backup
 341      */
 342     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 343         if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 344         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 345                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 346 
 347         if (!mRestoreEnabled) {
 348             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 349             return;
 350         }
 351 
 352         try {
 353             ContentResolver cr = mContext.getContentResolver();
 354             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 355             cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 356         } catch (InvalidProtocolBufferNanoException e) {
 357             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 358         }
 359     }
 360 
 361     /**
 362      * Write all modified screens to the data stream.
 363      *
 364      *
 365      * @param in notes from last backup
 366      * @param data output stream for key/value pairs
 367      * @param out notes about this backup
 368      * @param keys keys to mark as clean in the notes for next backup
 369      * @throws IOException
 370      */
 371     private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 372             ArrayList&lt;Key&gt; keys)
 373             throws IOException {
 374         // read the old ID set
 375         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 376         if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 377 
 378         // persist things that have changed since the last backup
 379         ContentResolver cr = mContext.getContentResolver();
 380         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 381                 null, null, null);
 382         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 383         try {
 384             cursor.moveToPosition(-1);
 385             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 386             while(cursor.moveToNext()) {
 387                 final long id = cursor.getLong(ID_INDEX);
 388                 final long updateTime = cursor.getLong(ID_MODIFIED);
 389                 Key key = getKey(Key.SCREEN, id);
 390                 keys.add(key);
 391                 final String backupKey = keyToBackupKey(key);
 392                 currentIds.add(backupKey);
 393                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 394                     byte[] blob = packScreen(cursor);
 395                     writeRowToBackup(key, blob, out, data);
 396                 } else {
 397                     if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 398                 }
 399             }
 400         } finally {
 401             cursor.close();
 402         }
 403         if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 404 
 405         // these IDs must have been deleted
 406         savedIds.removeAll(currentIds);
 407         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 408     }
 409 
 410     /**
 411      * Read a screen from the stream.
 412      *
 413      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 414      *
 415      * @param key identifier for the row
 416      * @param buffer the serialized proto from the stream, may be larger than dataSize
 417      * @param dataSize the size of the proto from the stream
 418      * @param keys keys to mark as clean in the notes for next backup
 419      */
 420     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 421         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 422         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 423                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 424 
 425         if (!mRestoreEnabled) {
 426             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 427             return;
 428         }
 429 
 430         try {
 431             ContentResolver cr = mContext.getContentResolver();
 432             ContentValues values = unpackScreen(buffer, 0, dataSize);
 433             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 434 
 435         } catch (InvalidProtocolBufferNanoException e) {
 436             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 437         }
 438     }
 439 
 440     /**
 441      * Write all the static icon resources we need to render placeholders
 442      * for a package that is not installed.
 443      *
 444      * @param in notes from last backup
 445      * @param data output stream for key/value pairs
 446      * @param out notes about this backup
 447      * @param keys keys to mark as clean in the notes for next backup
 448      * @throws IOException
 449      */
 450     private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 451             ArrayList&lt;Key&gt; keys) throws IOException {
 452         // persist icons that haven&#x27;t been persisted yet
 453         if (!initializeIconCache()) {
 454             dataChanged(); // try again later
 455             if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 456             return;
 457         }
 458         final ContentResolver cr = mContext.getContentResolver();
 459         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 460         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 461 
 462         // read the old ID set
 463         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 464         if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 465 
 466         // Don&#x27;t backup apps in other profiles for now.
 467         int startRows = out.rows;
 468         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 469 
 470         String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +
 471                 Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +
 472                 getUserSelectionArg();
 473         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 474                 where, null, null);
 475         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 476         try {
 477             cursor.moveToPosition(-1);
 478             while(cursor.moveToNext()) {
 479                 final long id = cursor.getLong(ID_INDEX);
 480                 final String intentDescription = cursor.getString(INTENT_INDEX);
 481                 try {
 482                     Intent intent = Intent.parseUri(intentDescription, 0);
 483                     ComponentName cn = intent.getComponent();
 484                     Key key = null;
 485                     String backupKey = null;
 486                     if (cn != null) {
 487                         key = getKey(Key.ICON, cn.flattenToShortString());
 488                         backupKey = keyToBackupKey(key);
 489                         currentIds.add(backupKey);
 490                     } else {
 491                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 492                     }
 493                     if (savedIds.contains(backupKey)) {
 494                         if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 495 
 496                         // remember that we already backed this up previously
 497                         keys.add(key);
 498                     } else if (backupKey != null) {
 499                         if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 500                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 501                             if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
 502                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 503                             keys.add(key);
 504                             if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {
 505                                 byte[] blob = packIcon(dpi, icon);
 506                                 writeRowToBackup(key, blob, out, data);
 507                             }
 508                         } else {
 509                             if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 510                             // too many icons for this pass, request another.
 511                             dataChanged();
 512                         }
 513                     }
 514                 } catch (URISyntaxException e) {
 515                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 516                 } catch (IOException e) {
 517                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 518                 }
 519 
 520             }
 521         } finally {
 522             cursor.close();
 523         }
 524         if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 525 
 526         // these IDs must have been deleted
 527         savedIds.removeAll(currentIds);
 528         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 529     }
 530 
 531     /**
 532      * Read an icon from the stream.
 533      *
 534      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 535      *
 536      * @param key identifier for the row
 537      * @param buffer the serialized proto from the stream, may be larger than dataSize
 538      * @param dataSize the size of the proto from the stream
 539      * @param keys keys to mark as clean in the notes for next backup
 540      */
 541     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 542         if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 543         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 544                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 545 
 546         try {
 547             Resource res = unpackIcon(buffer, 0, dataSize);
 548             if (DEBUG) {
 549                 Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);
 550             }
 551             if (DEBUG_PAYLOAD) {
 552                 Log.d(TAG, &quot;read &quot; +
 553                         Base64.encodeToString(res.data, 0, res.data.length,
 554                                 Base64.NO_WRAP));
 555             }
 556             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 557             if (icon == null) {
 558                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 559             }
 560 
 561             if (!mRestoreEnabled) {
 562                 if (VERBOSE) {
 563                     Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 564                 }
 565                 return;
 566             } else {
 567                 if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 568                 IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name),
 569                         icon, res.dpi);
 570             }
 571         } catch (IOException e) {
 572             Log.d(TAG, &quot;failed to save restored icon for: &quot; + key.name, e);
 573         }
 574     }
 575 
 576     /**
 577      * Write all the static widget resources we need to render placeholders
 578      * for a package that is not installed.
 579      *
 580      * @param in notes from last backup
 581      * @param data output stream for key/value pairs
 582      * @param out notes about this backup
 583      * @param keys keys to mark as clean in the notes for next backup
 584      * @throws IOException
 585      */
 586     private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 587             ArrayList&lt;Key&gt; keys) throws IOException {
 588         // persist static widget info that hasn&#x27;t been persisted yet
 589         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 590         if (appState == null || !initializeIconCache()) {
 591             Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 592             return;
 593         }
 594         final ContentResolver cr = mContext.getContentResolver();
 595         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 596         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 597         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 598         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 599         if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 600 
 601         // read the old ID set
 602         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 603         if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 604 
 605         int startRows = out.rows;
 606         if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
 607         String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;
 608                 + getUserSelectionArg();
 609         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 610                 where, null, null);
 611         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 612         try {
 613             cursor.moveToPosition(-1);
 614             while(cursor.moveToNext()) {
 615                 final long id = cursor.getLong(ID_INDEX);
 616                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 617                 final int spanX = cursor.getInt(SPANX_INDEX);
 618                 final int spanY = cursor.getInt(SPANY_INDEX);
 619                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 620                 Key key = null;
 621                 String backupKey = null;
 622                 if (provider != null) {
 623                     key = getKey(Key.WIDGET, providerName);
 624                     backupKey = keyToBackupKey(key);
 625                     currentIds.add(backupKey);
 626                 } else {
 627                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 628                 }
 629                 if (savedIds.contains(backupKey)) {
 630                     if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 631 
 632                     // remember that we already backed this up previously
 633                     keys.add(key);
 634                 } else if (backupKey != null) {
 635                     if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 636                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 637                         if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 638                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 639                                 spanY * profile.cellHeightPx, widgetSpacingLayout);
 640                         byte[] blob = packWidget(dpi, previewLoader, mIconCache, provider);
 641                         keys.add(key);
 642                         writeRowToBackup(key, blob, out, data);
 643 
 644                     } else {
 645                         if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 646                         // too many widgets for this pass, request another.
 647                         dataChanged();
 648                     }
 649                 }
 650             }
 651         } finally {
 652             cursor.close();
 653         }
 654         if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 655 
 656         // these IDs must have been deleted
 657         savedIds.removeAll(currentIds);
 658         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 659     }
 660 
 661     /**
 662      * Read a widget from the stream.
 663      *
 664      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 665      *
 666      * @param key identifier for the row
 667      * @param buffer the serialized proto from the stream, may be larger than dataSize
 668      * @param dataSize the size of the proto from the stream
 669      * @param keys keys to mark as clean in the notes for next backup
 670      */
 671     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 672         if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 673         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 674                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 675         try {
 676             Widget widget = unpackWidget(buffer, 0, dataSize);
 677             if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 678             if (widget.icon.data != null)  {
 679                 Bitmap icon = BitmapFactory
 680                         .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 681                 if (icon == null) {
 682                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 683                 } else {
 684                     IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider),
 685                             icon, widget.icon.dpi);
 686                 }
 687             }
 688 
 689             if (!mRestoreEnabled) {
 690                 if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 691                 return;
 692             } else {
 693                 // future site of widget table mutation
 694             }
 695         } catch (InvalidProtocolBufferNanoException e) {
 696             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 697         }
 698     }
 699 
 700     /** create a new key, with an integer ID.
 701      *
 702      * &lt;P&gt; Keys contain their own checksum instead of using
 703      * the heavy-weight CheckedMessage wrapper.
 704      */
 705     private Key getKey(int type, long id) {
 706         Key key = new Key();
 707         key.type = type;
 708         key.id = id;
 709         key.checksum = checkKey(key);
 710         return key;
 711     }
 712 
 713     /** create a new key for a named object.
 714      *
 715      * &lt;P&gt; Keys contain their own checksum instead of using
 716      * the heavy-weight CheckedMessage wrapper.
 717      */
 718     private Key getKey(int type, String name) {
 719         Key key = new Key();
 720         key.type = type;
 721         key.name = name;
 722         key.checksum = checkKey(key);
 723         return key;
 724     }
 725 
 726     /** keys need to be strings, serialize and encode. */
 727     private String keyToBackupKey(Key key) {
 728         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 729     }
 730 
 731     /** keys need to be strings, decode and parse. */
 732     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 733         try {
 734             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 735             if (key.checksum != checkKey(key)) {
 736                 key = null;
 737                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 738             }
 739             return key;
 740         } catch (InvalidProtocolBufferNanoException e) {
 741             throw new KeyParsingException(e);
 742         } catch (IllegalArgumentException e) {
 743             throw new KeyParsingException(e);
 744         }
 745     }
 746 
 747     private String getKeyName(Key key) {
 748         if (TextUtils.isEmpty(key.name)) {
 749             return Long.toString(key.id);
 750         } else {
 751             return key.name;
 752         }
 753 
 754     }
 755 
 756     private String geKeyType(Key key) {
 757         switch (key.type) {
 758             case Key.FAVORITE:
 759                 return &quot;favorite&quot;;
 760             case Key.SCREEN:
 761                 return &quot;screen&quot;;
 762             case Key.ICON:
 763                 return &quot;icon&quot;;
 764             case Key.WIDGET:
 765                 return &quot;widget&quot;;
 766             default:
 767                 return &quot;anonymous&quot;;
 768         }
 769     }
 770 
 771     /** Compute the checksum over the important bits of a key. */
 772     private long checkKey(Key key) {
 773         CRC32 checksum = new CRC32();
 774         checksum.update(key.type);
 775         checksum.update((int) (key.id &amp; 0xffff));
 776         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 777         if (!TextUtils.isEmpty(key.name)) {
 778             checksum.update(key.name.getBytes());
 779         }
 780         return checksum.getValue();
 781     }
 782 
 783     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 784     private byte[] packFavorite(Cursor c) {
 785         Favorite favorite = new Favorite();
 786         favorite.id = c.getLong(ID_INDEX);
 787         favorite.screen = c.getInt(SCREEN_INDEX);
 788         favorite.container = c.getInt(CONTAINER_INDEX);
 789         favorite.cellX = c.getInt(CELLX_INDEX);
 790         favorite.cellY = c.getInt(CELLY_INDEX);
 791         favorite.spanX = c.getInt(SPANX_INDEX);
 792         favorite.spanY = c.getInt(SPANY_INDEX);
 793         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 794         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 795             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 796             if (!TextUtils.isEmpty(iconPackage)) {
 797                 favorite.iconPackage = iconPackage;
 798             }
 799             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 800             if (!TextUtils.isEmpty(iconResource)) {
 801                 favorite.iconResource = iconResource;
 802             }
 803         }
 804         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 805             byte[] blob = c.getBlob(ICON_INDEX);
 806             if (blob != null &amp;&amp; blob.length &gt; 0) {
 807                 favorite.icon = blob;
 808             }
 809         }
 810         String title = c.getString(TITLE_INDEX);
 811         if (!TextUtils.isEmpty(title)) {
 812             favorite.title = title;
 813         }
 814         String intentDescription = c.getString(INTENT_INDEX);
 815         if (!TextUtils.isEmpty(intentDescription)) {
 816             try {
 817                 Intent intent = Intent.parseUri(intentDescription, 0);
 818                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 819                 favorite.intent = intent.toUri(0);
 820             } catch (URISyntaxException e) {
 821                 Log.e(TAG, &quot;Invalid intent&quot;, e);
 822            }
 823         }
 824         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 825         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 826             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 827             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 828             if (!TextUtils.isEmpty(appWidgetProvider)) {
 829                 favorite.appWidgetProvider = appWidgetProvider;
 830             }
 831         }
 832 
 833         return writeCheckedBytes(favorite);
 834     }
 835 
 836     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 837     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 838             throws InvalidProtocolBufferNanoException {
 839         Favorite favorite = new Favorite();
 840         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 841         if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 842                 (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 843         ContentValues values = new ContentValues();
 844         values.put(Favorites._ID, favorite.id);
 845         values.put(Favorites.SCREEN, favorite.screen);
 846         values.put(Favorites.CONTAINER, favorite.container);
 847         values.put(Favorites.CELLX, favorite.cellX);
 848         values.put(Favorites.CELLY, favorite.cellY);
 849         values.put(Favorites.SPANX, favorite.spanX);
 850         values.put(Favorites.SPANY, favorite.spanY);
 851         values.put(Favorites.ICON_TYPE, favorite.iconType);
 852         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 853             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 854             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 855         }
 856         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 857             values.put(Favorites.ICON, favorite.icon);
 858         }
 859         if (!TextUtils.isEmpty(favorite.title)) {
 860             values.put(Favorites.TITLE, favorite.title);
 861         } else {
 862             values.put(Favorites.TITLE, &quot;&quot;);
 863         }
 864         if (!TextUtils.isEmpty(favorite.intent)) {
 865             values.put(Favorites.INTENT, favorite.intent);
 866         }
 867         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 868 
 869         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 870         long userSerialNumber =
 871                 UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);
 872         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 873 
 874         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 875             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 876                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 877             }
 878             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
 879             values.put(LauncherSettings.Favorites.RESTORED,
 880                     LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |
 881                     LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |
 882                     LauncherAppWidgetInfo.FLAG_UI_NOT_READY);
 883         } else {
 884             // Let LauncherModel know we&#x27;ve been here.
 885             values.put(LauncherSettings.Favorites.RESTORED, 1);
 886         }
 887 
 888         return values;
 889     }
 890 
 891     /** Serialize a Screen for persistence, including a checksum wrapper. */
 892     private byte[] packScreen(Cursor c) {
 893         Screen screen = new Screen();
 894         screen.id = c.getLong(ID_INDEX);
 895         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 896 
 897         return writeCheckedBytes(screen);
 898     }
 899 
 900     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 901     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 902             throws InvalidProtocolBufferNanoException {
 903         Screen screen = new Screen();
 904         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 905         if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 906         ContentValues values = new ContentValues();
 907         values.put(WorkspaceScreens._ID, screen.id);
 908         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 909         return values;
 910     }
 911 
 912     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 913     private byte[] packIcon(int dpi, Bitmap icon) {
 914         Resource res = new Resource();
 915         res.dpi = dpi;
 916         ByteArrayOutputStream os = new ByteArrayOutputStream();
 917         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 918             res.data = os.toByteArray();
 919         }
 920         return writeCheckedBytes(res);
 921     }
 922 
 923     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
 924     private static Resource unpackIcon(byte[] buffer, int offset, int dataSize)
 925             throws InvalidProtocolBufferNanoException {
 926         Resource res = new Resource();
 927         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 928         if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 929         return res;
 930     }
 931 
 932     /** Serialize a widget for persistence, including a checksum wrapper. */
 933     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 934             ComponentName provider) {
 935         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 936         Widget widget = new Widget();
 937         widget.provider = provider.flattenToShortString();
 938         widget.label = info.label;
 939         widget.configure = info.configure != null;
 940         if (info.icon != 0) {
 941             widget.icon = new Resource();
 942             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 943             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 944             ByteArrayOutputStream os = new ByteArrayOutputStream();
 945             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 946                 widget.icon.data = os.toByteArray();
 947                 widget.icon.dpi = dpi;
 948             }
 949         }
 950         if (info.previewImage != 0) {
 951             widget.preview = new Resource();
 952             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 953             ByteArrayOutputStream os = new ByteArrayOutputStream();
 954             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 955                 widget.preview.data = os.toByteArray();
 956                 widget.preview.dpi = dpi;
 957             }
 958         }
 959         return writeCheckedBytes(widget);
 960     }
 961 
 962     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
 963     private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
 964             throws InvalidProtocolBufferNanoException {
 965         Widget widget = new Widget();
 966         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 967         if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 968         return widget;
 969     }
 970 
 971     /**
 972      * Read the old journal from the input file.
 973      *
 974      * In the event of any error, just pretend we didn&#x27;t have a journal,
 975      * in that case, do a full backup.
 976      *
 977      * @param oldState the read-0only file descriptor pointing to the old journal
 978      * @return a Journal protocol buffer
 979      */
 980     private Journal readJournal(ParcelFileDescriptor oldState) {
 981         Journal journal = new Journal();
 982         if (oldState == null) {
 983             return journal;
 984         }
 985         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
 986         try {
 987             int availableBytes = inStream.available();
 988             if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
 989             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
 990                 byte[] buffer = new byte[availableBytes];
 991                 int bytesRead = 0;
 992                 boolean valid = false;
 993                 InvalidProtocolBufferNanoException lastProtoException = null;
 994                 while (availableBytes &gt; 0) {
 995                     try {
 996                         // OMG what are you doing? This is crazy inefficient!
 997                         // If we read a byte that is not ours, we will cause trouble: b/12491813
 998                         // However, we don&#x27;t know how many bytes to expect (oops).
 999                         // So we have to step through *slowly*, watching for the end.
1000                         int result = inStream.read(buffer, bytesRead, 1);
1001                         if (result &gt; 0) {
1002                             availableBytes -= result;
1003                             bytesRead += result;
1004                             if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
1005                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
1006                             }
1007                         } else {
1008                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1009                             // stop reading and see what there is to parse
1010                             availableBytes = 0;
1011                         }
1012                     } catch (IOException e) {
1013                         buffer = null;
1014                         availableBytes = 0;
1015                     }
1016 
1017                     // check the buffer to see if we have a valid journal
1018                     try {
1019                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1020                         // if we are here, then we have read a valid, checksum-verified journal
1021                         valid = true;
1022                         availableBytes = 0;
1023                         if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1024                     } catch (InvalidProtocolBufferNanoException e) {
1025                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1026                         lastProtoException = e;
1027                         journal.clear();
1028                     }
1029                 }
1030                 if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1031                 if (!valid) {
1032                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1033                 }
1034             }
1035         } catch (IOException e) {
1036             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1037         } finally {
1038             try {
1039                 inStream.close();
1040             } catch (IOException e) {
1041                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1042             }
1043         }
1044         return journal;
1045     }
1046 
1047     private void writeRowToBackup(Key key, byte[] blob, Journal out,
1048             BackupDataOutput data) throws IOException {
1049         String backupKey = keyToBackupKey(key);
1050         data.writeEntityHeader(backupKey, blob.length);
1051         data.writeEntityData(blob, blob.length);
1052         out.rows++;
1053         out.bytes += blob.length;
1054         if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1055                 getKeyName(key) + &quot;/&quot; + blob.length);
1056         if(DEBUG_PAYLOAD) {
1057             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1058             final int chunkSize = 1024;
1059             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1060                 int end = offset + chunkSize;
1061                 end = Math.min(end, encoded.length());
1062                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1063             }
1064         }
1065     }
1066 
1067     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1068         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1069         for(int i = 0; i &lt; in.key.length; i++) {
1070             Key key = in.key[i];
1071             if (key.type == type) {
1072                 savedIds.add(keyToBackupKey(key));
1073             }
1074         }
1075         return savedIds;
1076     }
1077 
1078     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1079             throws IOException {
1080         int rows = 0;
1081         for(String deleted: deletedIds) {
1082             if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1083             data.writeEntityHeader(deleted, -1);
1084             rows++;
1085         }
1086         return rows;
1087     }
1088 
1089     /**
1090      * Write the new journal to the output file.
1091      *
1092      * In the event of any error, just pretend we didn&#x27;t have a journal,
1093      * in that case, do a full backup.
1094 
1095      * @param newState the write-only file descriptor pointing to the new journal
1096      * @param journal a Journal protocol buffer
1097      */
1098     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1099         FileOutputStream outStream = null;
1100         try {
1101             outStream = new FileOutputStream(newState.getFileDescriptor());
1102             final byte[] journalBytes = writeCheckedBytes(journal);
1103             outStream.write(journalBytes);
1104             outStream.close();
1105             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1106         } catch (IOException e) {
1107             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1108         }
1109     }
1110 
1111     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1112     private byte[] writeCheckedBytes(MessageNano proto) {
1113         CheckedMessage wrapper = new CheckedMessage();
1114         wrapper.payload = MessageNano.toByteArray(proto);
1115         CRC32 checksum = new CRC32();
1116         checksum.update(wrapper.payload);
1117         wrapper.checksum = checksum.getValue();
1118         return MessageNano.toByteArray(wrapper);
1119     }
1120 
1121     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
1122     private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)
1123             throws InvalidProtocolBufferNanoException {
1124         CheckedMessage wrapper = new CheckedMessage();
1125         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1126         CRC32 checksum = new CRC32();
1127         checksum.update(wrapper.payload);
1128         if (wrapper.checksum != checksum.getValue()) {
1129             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1130         }
1131         return wrapper.payload;
1132     }
1133 
1134     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1135         if (mWidgetMap == null) {
1136             List&lt;AppWidgetProviderInfo&gt; widgets =
1137                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1138             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1139             for (AppWidgetProviderInfo info : widgets) {
1140                 mWidgetMap.put(info.provider, info);
1141             }
1142         }
1143         return mWidgetMap.get(component);
1144     }
1145 
1146 
1147     private boolean initializeIconCache() {
1148         if (mIconCache != null) {
1149             return true;
1150         }
1151 
1152         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1153         if (appState == null) {
1154             Throwable stackTrace = new Throwable();
1155             stackTrace.fillInStackTrace();
1156             Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);
1157             return false;
1158         }
1159         mIconCache = appState.getIconCache();
1160         return mIconCache != null;
1161     }
1162 
1163 
1164    // check if the launcher is in a state to support backup
1165     private boolean launcherIsReady() {
1166         ContentResolver cr = mContext.getContentResolver();
1167         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1168         if (cursor == null) {
1169             // launcher data has been wiped, do nothing
1170             return false;
1171         }
1172         cursor.close();
1173 
1174         if (!initializeIconCache()) {
1175             // launcher services are unavailable, try again later
1176             dataChanged();
1177             return false;
1178         }
1179 
1180         return true;
1181     }
1182 
1183     private String getUserSelectionArg() {
1184         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1185                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1186     }
1187 
1188     private class KeyParsingException extends Throwable {
1189         private KeyParsingException(Throwable cause) {
1190             super(cause);
1191         }
1192 
1193         public KeyParsingException(String reason) {
1194             super(reason);
1195         }
1196     }
1197 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Copyright (C) 2013 The Android Open Source Project
   3  *
   4  * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5  * you may not use this file except in compliance with the License.
   6  * You may obtain a copy of the License at
   7  *
   8  *      http://www.apache.org/licenses/LICENSE-2.0
   9  *
  10  * Unless required by applicable law or agreed to in writing, software
  11  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13  * See the License for the specific language governing permissions and
  14  * limitations under the License.
  15  */
  16 package com.android.launcher3;
  17 
  18 import android.app.backup.BackupDataInputStream;
  19 import android.app.backup.BackupDataOutput;
  20 import android.app.backup.BackupHelper;
  21 import android.app.backup.BackupManager;
  22 import android.appwidget.AppWidgetManager;
  23 import android.appwidget.AppWidgetProviderInfo;
  24 import android.content.ComponentName;
  25 import android.content.ContentResolver;
  26 import android.content.ContentValues;
  27 import android.content.Context;
  28 import android.content.Intent;
  29 import android.database.Cursor;
  30 import android.graphics.Bitmap;
  31 import android.graphics.BitmapFactory;
  32 import android.graphics.drawable.Drawable;
  33 import android.os.ParcelFileDescriptor;
  34 import android.text.TextUtils;
  35 import android.util.Base64;
  36 import android.util.Log;
  37 import com.android.launcher3.LauncherSettings.Favorites;
  38 import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  39 import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  40 import com.android.launcher3.backup.BackupProtos.Favorite;
  41 import com.android.launcher3.backup.BackupProtos.Journal;
  42 import com.android.launcher3.backup.BackupProtos.Key;
  43 import com.android.launcher3.backup.BackupProtos.Resource;
  44 import com.android.launcher3.backup.BackupProtos.Screen;
  45 import com.android.launcher3.backup.BackupProtos.Widget;
  46 import com.android.launcher3.backup.BackupProtos;
  47 import com.android.launcher3.compat.UserHandleCompat;
  48 import com.android.launcher3.compat.UserManagerCompat;
  49 import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  50 import com.google.protobuf.nano.MessageNano;
  51 import java.io.ByteArrayOutputStream;
  52 import java.io.FileInputStream;
  53 import java.io.FileOutputStream;
  54 import java.io.IOException;
  55 import java.net.URISyntaxException;
  56 import java.util.ArrayList;
  57 import java.util.HashMap;
  58 import java.util.HashSet;
  59 import java.util.List;
  60 import java.util.Set;
  61 import java.util.zip.CRC32;
  62 
  63 
  64 /**
  65  * Persist the launcher home state across calamities.
  66  */
  67 public class LauncherBackupHelper implements BackupHelper {
  68     private static final String TAG = &quot;LauncherBackupHelper&quot;;
  69 
  70     private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  71 
  72     private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  73 
  74     private static final boolean DEBUG_PAYLOAD = false;
  75 
  76     private static final int MAX_JOURNAL_SIZE = 1000000;
  77 
  78     /**
  79      * icons are large, dribble them out
  80      */
  81     private static final int MAX_ICONS_PER_PASS = 10;
  82 
  83     /**
  84      * widgets contain previews, which are very large, dribble them out
  85      */
  86     private static final int MAX_WIDGETS_PER_PASS = 5;
  87 
  88     public static final int IMAGE_COMPRESSION_QUALITY = 75;
  89 
  90     public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  91 
  92     public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  93 
  94     private static final Bitmap.CompressFormat IMAGE_FORMAT =
  95             android.graphics.Bitmap.CompressFormat.PNG;
  96 
  97     private static BackupManager sBackupManager;
  98 
  99     private static final String[] FAVORITE_PROJECTION = new java.lang.String[]{ Favorites._ID, // 0
 100     Favorites.MODIFIED, // 1
 101     Favorites.INTENT, // 2
 102     Favorites.APPWIDGET_PROVIDER// 3
 103     , Favorites.APPWIDGET_ID// 4
 104     , Favorites.CELLX, // 5
 105     Favorites.CELLY, // 6
 106     Favorites.CONTAINER, // 7
 107     Favorites.ICON, // 8
 108     Favorites.ICON_PACKAGE// 9
 109     , Favorites.ICON_RESOURCE// 10
 110     , Favorites.ICON_TYPE, // 11
 111     Favorites.ITEM_TYPE, // 12
 112     Favorites.SCREEN, // 13
 113     Favorites.SPANX, // 14
 114     Favorites.SPANY, // 15
 115     Favorites.TITLE, // 16
 116             // 17
 117     Favorites.PROFILE_ID };
 118 
 119     private static final int ID_INDEX = 0;
 120 
 121     private static final int ID_MODIFIED = 1;
 122 
 123     private static final int INTENT_INDEX = 2;
 124 
 125     private static final int APPWIDGET_PROVIDER_INDEX = 3;
 126 
 127     private static final int APPWIDGET_ID_INDEX = 4;
 128 
 129     private static final int CELLX_INDEX = 5;
 130 
 131     private static final int CELLY_INDEX = 6;
 132 
 133     private static final int CONTAINER_INDEX = 7;
 134 
 135     private static final int ICON_INDEX = 8;
 136 
 137     private static final int ICON_PACKAGE_INDEX = 9;
 138 
 139     private static final int ICON_RESOURCE_INDEX = 10;
 140 
 141     private static final int ICON_TYPE_INDEX = 11;
 142 
 143     private static final int ITEM_TYPE_INDEX = 12;
 144 
 145     private static final int SCREEN_INDEX = 13;
 146 
 147     private static final int SPANX_INDEX = 14;
 148 
 149     private static final int SPANY_INDEX = 15;
 150 
 151     private static final int TITLE_INDEX = 16;
 152 
 153     private static final int PROFILE_ID_INDEX = 17;
 154 
 155     private static final String[] SCREEN_PROJECTION = new java.lang.String[]{ WorkspaceScreens._ID, // 0
 156     WorkspaceScreens.MODIFIED// 1
 157     , WorkspaceScreens.SCREEN_RANK// 2
 158      };
 159 
 160     private static final int SCREEN_RANK_INDEX = 2;
 161 
 162     private static IconCache mIconCache;
 163 
 164     private final Context mContext;
 165 
 166     private final boolean mRestoreEnabled;
 167 
 168     private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 169 
 170     private final ArrayList&lt;Key&gt; mKeys;
 171 
 172     public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 173         mContext = context;
 174         mRestoreEnabled = restoreEnabled;
 175         mKeys = new ArrayList&lt;Key&gt;();
 176     }
 177 
 178     private void dataChanged() {
 179         if (sBackupManager == null) {
 180             sBackupManager = new BackupManager(mContext);
 181         }
 182         sBackupManager.dataChanged();
 183     }
 184 
 185     /**
 186      * Back up launcher data so we can restore the user&#x27;s state on a new device.
 187      *
 188      * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 189      *
 190      * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 191      *
 192      * @param oldState notes from the last backup
 193      * @param data incremental key/value pairs to persist off-device
 194      * @param newState notes for the next backup
 195      * @throws IOException
 196      */
 197     @Override
<abbr title=" 198     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor newState) {"> 198     public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data, ParcelFileDescriptor 🔵</abbr>
 199         if (VERBOSE) {
 200             Log.v(TAG, &quot;onBackup&quot;);
 201         }
 202         Journal in = readJournal(oldState);
 203         Journal out = new Journal();
 204         long lastBackupTime = in.t;
 205         out.t = System.currentTimeMillis();
 206         out.rows = 0;
 207         out.bytes = 0;
 208         Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 209         ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
 210         if (launcherIsReady()) {
 211             try {
 212                 backupFavorites(in, data, out, keys);
 213                 backupScreens(in, data, out, keys);
 214                 backupIcons(in, data, out, keys);
 215                 backupWidgets(in, data, out, keys);
 216             } catch (IOException e) {
 217                 Log.e(TAG, &quot;launcher backup has failed&quot;, e);
 218             }
 219             out.key = keys.toArray(new BackupProtos.Key[keys.size()]);
 220         } else {
 221             out = in;
 222         }
 223         writeJournal(newState, out);
 224         Log.v(TAG, (((&quot;onBackup: wrote &quot; + out.bytes) + &quot;b in &quot;) + out.rows) + &quot; rows.&quot;);
 225     }
 226 
 227     /**
 228      * Restore launcher configuration from the restored data stream.
 229      *
 230      * &lt;P&gt;Keys may arrive in any order.
 231      *
 232      * @param data the key/value pair from the server
 233      */
 234     @Override
 235     public void restoreEntity(BackupDataInputStream data) {
 236         if (VERBOSE) {
 237             Log.v(TAG, &quot;restoreEntity&quot;);
 238         }
 239         byte[] buffer = new byte[512];
 240         String backupKey = data.getKey();
 241         int dataSize = data.size();
 242         if (buffer.length &lt; dataSize) {
 243             buffer = new byte[dataSize];
 244         }
 245         Key key = null;
 246         int bytesRead = 0;
 247         try {
 248             bytesRead = data.read(buffer, 0, dataSize);
 249             if (DEBUG) {
 250                 Log.d(TAG, (((&quot;read &quot; + bytesRead) + &quot; of &quot;) + dataSize) + &quot; available&quot;);
 251             }
 252         } catch (IOException e) {
 253             Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 254         }
 255         try {
 256             key = backupKeyToKey(backupKey);
 257             mKeys.add(key);
 258             switch (key.type) {
 259                 case Key.FAVORITE :
 260                     restoreFavorite(key, buffer, dataSize, mKeys);
 261                     break;
 262                 case Key.SCREEN :
 263                     restoreScreen(key, buffer, dataSize, mKeys);
 264                     break;
 265                 case Key.ICON :
 266                     restoreIcon(key, buffer, dataSize, mKeys);
 267                     break;
 268                 case Key.WIDGET :
 269                     restoreWidget(key, buffer, dataSize, mKeys);
 270                     break;
 271                 default :
 272                     Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 273                     break;
 274             }
 275         } catch (LauncherBackupHelper.KeyParsingException e) {
 276             Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 277         }
 278     }
 279 
 280     /**
 281      * Record the restore state for the next backup.
 282      *
 283      * @param newState notes about the backup state after restore.
 284      */
 285     @Override
 286     public void writeNewStateDescription(ParcelFileDescriptor newState) {
 287         // clear the output journal time, to force a full backup to
 288         // will catch any changes the restore process might have made
 289         Journal out = new Journal();
 290         out.t = 0;
 291         out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);
 292         writeJournal(newState, out);
 293         Log.v(TAG, (&quot;onRestore: read &quot; + mKeys.size()) + &quot; rows&quot;);
 294         mKeys.clear();
 295     }
 296 
 297     /**
 298      * Write all modified favorites to the data stream.
 299      *
 300      *
 301      * @param in notes from last backup
 302      * @param data output stream for key/value pairs
 303      * @param out notes about this backup
 304      * @param keys keys to mark as clean in the notes for next backup
 305      * @throws IOException
 306      */
<abbr title=" 307     private void backupFavorites(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws IOException {"> 307     private void backupFavorites(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) thr🔵</abbr>
 308         // read the old ID set
 309         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 310         if (DEBUG) {
 311             Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 312         }
 313         // persist things that have changed since the last backup
 314         ContentResolver cr = mContext.getContentResolver();
 315         // Don&#x27;t backup apps in other profiles for now.
<abbr title=" 316         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, getUserSelectionArg(), null, null);"> 316         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, getUserSelectionArg(), null,🔵</abbr>
 317         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 318         try {
 319             cursor.moveToPosition(-1);
 320             while (cursor.moveToNext()) {
 321                 final long id = cursor.getLong(ID_INDEX);
 322                 final long updateTime = cursor.getLong(ID_MODIFIED);
 323                 Key key = getKey(Key.FAVORITE, id);
 324                 keys.add(key);
 325                 final String backupKey = keyToBackupKey(key);
 326                 currentIds.add(backupKey);
 327                 if ((!savedIds.contains(backupKey)) || (updateTime &gt;= in.t)) {
 328                     byte[] blob = packFavorite(cursor);
 329                     writeRowToBackup(key, blob, out, data);
 330                 } else if (VERBOSE) {
 331                     Log.v(TAG, ((&quot;favorite &quot; + id) + &quot; was too old: &quot;) + updateTime);
 332                 }
 333             }
 334         } finally {
 335             cursor.close();
 336         }
 337         if (DEBUG) {
 338             Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 339         }
 340         // these IDs must have been deleted
 341         savedIds.removeAll(currentIds);
 342         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 343     }
 344 
 345     /**
 346      * Read a favorite from the stream.
 347      *
 348      * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 349      *
 350      * @param key identifier for the row
 351      * @param buffer the serialized proto from the stream, may be larger than dataSize
 352      * @param dataSize the size of the proto from the stream
 353      * @param keys keys to mark as clean in the notes for next backup
 354      */
 355     private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 356         if (VERBOSE) {
 357             Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 358         }
 359         if (DEBUG) {
<abbr title=" 360             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 360             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, 🔵</abbr>
 361         }
 362         if (!mRestoreEnabled) {
 363             if (VERBOSE) {
 364                 Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 365             }
 366             return;
 367         }
 368         try {
 369             ContentResolver cr = mContext.getContentResolver();
 370             ContentValues values = unpackFavorite(buffer, 0, dataSize);
 371             cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);
 372         } catch (InvalidProtocolBufferNanoException e) {
 373             Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 374         }
 375     }
 376 
 377     /**
 378      * Write all modified screens to the data stream.
 379      *
 380      *
 381      * @param in notes from last backup
 382      * @param data output stream for key/value pairs
 383      * @param out notes about this backup
 384      * @param keys keys to mark as clean in the notes for next backup
 385      * @throws IOException
 386      */
 387     private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 388             ArrayList&lt;Key&gt; keys)
 389             throws IOException {
 390         // read the old ID set
 391         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 392         if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 393 
 394         // persist things that have changed since the last backup
 395         ContentResolver cr = mContext.getContentResolver();
 396         Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 397                 null, null, null);
 398         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 399         try {
 400             cursor.moveToPosition(-1);
 401             if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 402             while(cursor.moveToNext()) {
 403                 final long id = cursor.getLong(ID_INDEX);
 404                 final long updateTime = cursor.getLong(ID_MODIFIED);
 405                 Key key = getKey(Key.SCREEN, id);
 406                 keys.add(key);
 407                 final String backupKey = keyToBackupKey(key);
 408                 currentIds.add(backupKey);
 409                 if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 410                     byte[] blob = packScreen(cursor);
 411                     writeRowToBackup(key, blob, out, data);
 412                 } else {
 413                     if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 414                 }
 415             }
 416         } finally {
 417             cursor.close();
 418         }
 419         if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 420 
 421         // these IDs must have been deleted
 422         savedIds.removeAll(currentIds);
 423         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 424     }
 425 
 426     /**
 427      * Read a screen from the stream.
 428      *
 429      * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 430      *
 431      * @param key identifier for the row
 432      * @param buffer the serialized proto from the stream, may be larger than dataSize
 433      * @param dataSize the size of the proto from the stream
 434      * @param keys keys to mark as clean in the notes for next backup
 435      */
 436     private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 437         if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 438         if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 439                 Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 440 
 441         if (!mRestoreEnabled) {
 442             if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 443             return;
 444         }
 445 
 446         try {
 447             ContentResolver cr = mContext.getContentResolver();
 448             ContentValues values = unpackScreen(buffer, 0, dataSize);
 449             cr.insert(WorkspaceScreens.CONTENT_URI, values);
 450 
 451         } catch (InvalidProtocolBufferNanoException e) {
 452             Log.e(TAG, &quot;failed to decode screen&quot;, e);
 453         }
 454     }
 455 
 456     /**
 457      * Write all the static icon resources we need to render placeholders
 458      * for a package that is not installed.
 459      *
 460      * @param in notes from last backup
 461      * @param data output stream for key/value pairs
 462      * @param out notes about this backup
 463      * @param keys keys to mark as clean in the notes for next backup
 464      * @throws IOException
 465      */
<abbr title=" 466     private void backupIcons(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws IOException {"> 466     private void backupIcons(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws 🔵</abbr>
 467         // persist icons that haven&#x27;t been persisted yet
 468         if (!initializeIconCache()) {
 469             dataChanged();// try again later
 470 
 471             if (DEBUG) {
 472                 Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 473             }
 474             return;
 475         }
 476         final ContentResolver cr = mContext.getContentResolver();
 477         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 478         final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
 479         // read the old ID set
 480         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 481         if (DEBUG) {
 482             Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 483         }
 484         // Don&#x27;t backup apps in other profiles for now.
 485         int startRows = out.rows;
 486         if (DEBUG) {
 487             Log.d(TAG, &quot;starting here: &quot; + startRows);
 488         }
<abbr title=" 489         String where = ((((((((&quot;(&quot; + Favorites.ITEM_TYPE) + &quot;=&quot;) + Favorites.ITEM_TYPE_APPLICATION) + &quot; OR &quot;) + Favorites.ITEM_TYPE) + &quot;=&quot;) + Favorites.ITEM_TYPE_SHORTCUT) + &quot;) AND &quot;) + getUserSelectionArg();"> 489         String where = ((((((((&quot;(&quot; + Favorites.ITEM_TYPE) + &quot;=&quot;) + Favorites.ITEM_TYPE_APPLICATION) + &quot; O🔵</abbr>
 490         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, where, null, null);
 491         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 492         try {
 493             cursor.moveToPosition(-1);
 494             while (cursor.moveToNext()) {
 495                 final long id = cursor.getLong(ID_INDEX);
 496                 final String intentDescription = cursor.getString(INTENT_INDEX);
 497                 try {
 498                     Intent intent = Intent.parseUri(intentDescription, 0);
 499                     ComponentName cn = intent.getComponent();
 500                     Key key = null;
 501                     String backupKey = null;
 502                     if (cn != null) {
 503                         key = getKey(Key.ICON, cn.flattenToShortString());
 504                         backupKey = keyToBackupKey(key);
 505                         currentIds.add(backupKey);
 506                     } else {
 507                         Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 508                     }
 509                     if (savedIds.contains(backupKey)) {
 510                         if (VERBOSE) {
 511                             Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 512                         }
 513                         // remember that we already backed this up previously
 514                         keys.add(key);
 515                     } else if (backupKey != null) {
 516                         if (DEBUG) {
 517                             Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 518                         }
 519                         if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 520                             if (VERBOSE) {
 521                                 Log.v(TAG, &quot;saving icon &quot; + backupKey);
 522                             }
 523                             Bitmap icon = mIconCache.getIcon(intent, myUserHandle);
 524                             keys.add(key);
 525                             if ((icon != null) &amp;&amp; (!mIconCache.isDefaultIcon(icon, myUserHandle))) {
 526                                 byte[] blob = packIcon(dpi, icon);
 527                                 writeRowToBackup(key, blob, out, data);
 528                             }
 529                         } else {
 530                             if (VERBOSE) {
 531                                 Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 532                             }
 533                             // too many icons for this pass, request another.
 534                             dataChanged();
 535                         }
 536                     }
 537                 } catch (URISyntaxException e) {
 538                     Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 539                 } catch (IOException e) {
 540                     Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 541                 }
 542             }
 543         } finally {
 544             cursor.close();
 545         }
 546         if (DEBUG) {
 547             Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 548         }
 549         // these IDs must have been deleted
 550         savedIds.removeAll(currentIds);
 551         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 552     }
 553 
 554     /**
 555      * Read an icon from the stream.
 556      *
 557      * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 558      *
 559      * @param key identifier for the row
 560      * @param buffer the serialized proto from the stream, may be larger than dataSize
 561      * @param dataSize the size of the proto from the stream
 562      * @param keys keys to mark as clean in the notes for next backup
 563      */
 564     private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 565         if (VERBOSE) {
 566             Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 567         }
 568         if (DEBUG) {
<abbr title=" 569             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 569             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, 🔵</abbr>
 570         }
 571         try {
 572             Resource res = unpackIcon(buffer, 0, dataSize);
 573             if (DEBUG) {
 574                 Log.d(TAG, (&quot;unpacked &quot; + res.dpi) + &quot; dpi icon&quot;);
 575             }
 576             if (DEBUG_PAYLOAD) {
<abbr title=" 577                 Log.d(TAG, &quot;read &quot; + Base64.encodeToString(res.data, 0, res.data.length, Base64.NO_WRAP));"> 577                 Log.d(TAG, &quot;read &quot; + Base64.encodeToString(res.data, 0, res.data.length, Base64.NO_WRAP))🔵</abbr>
 578             }
 579             Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 580             if (icon == null) {
 581                 Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 582             }
 583             if (!mRestoreEnabled) {
 584                 if (VERBOSE) {
 585                     Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 586                 }
 587                 return;
 588             } else {
 589                 if (VERBOSE) {
 590                     Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);
 591                 }
<abbr title=" 592                 IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name), icon, res.dpi);"> 592                 IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name), icon, res.dp🔵</abbr>
 593             }
 594         } catch (IOException e) {
 595             Log.d(TAG, &quot;failed to save restored icon for: &quot; + key.name, e);
 596         }
 597     }
 598 
 599     /**
 600      * Write all the static widget resources we need to render placeholders
 601      * for a package that is not installed.
 602      *
 603      * @param in notes from last backup
 604      * @param data output stream for key/value pairs
 605      * @param out notes about this backup
 606      * @param keys keys to mark as clean in the notes for next backup
 607      * @throws IOException
 608      */
<abbr title=" 609     private void backupWidgets(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throws IOException {"> 609     private void backupWidgets(Journal in, BackupDataOutput data, Journal out, ArrayList&lt;Key&gt; keys) throw🔵</abbr>
 610         // persist static widget info that hasn&#x27;t been persisted yet
 611         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
 612         if ((appState == null) || (!initializeIconCache())) {
 613             Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);
 614             return;
 615         }
 616         final ContentResolver cr = mContext.getContentResolver();
 617         final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 618         final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
 619         final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 620         final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 621         if (DEBUG) {
 622             Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 623         }
 624         // read the old ID set
 625         Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 626         if (DEBUG) {
 627             Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 628         }
 629         int startRows = out.rows;
 630         if (DEBUG) {
 631             Log.d(TAG, &quot;starting here: &quot; + startRows);
 632         }
<abbr title=" 633         String where = (((Favorites.ITEM_TYPE + &quot;=&quot;) + Favorites.ITEM_TYPE_APPWIDGET) + &quot; AND &quot;) + getUserSelectionArg();"> 633         String where = (((Favorites.ITEM_TYPE + &quot;=&quot;) + Favorites.ITEM_TYPE_APPWIDGET) + &quot; AND &quot;) + getUse🔵</abbr>
 634         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, where, null, null);
 635         Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 636         try {
 637             cursor.moveToPosition(-1);
 638             while (cursor.moveToNext()) {
 639                 final long id = cursor.getLong(ID_INDEX);
 640                 final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 641                 final int spanX = cursor.getInt(SPANX_INDEX);
 642                 final int spanY = cursor.getInt(SPANY_INDEX);
 643                 final ComponentName provider = ComponentName.unflattenFromString(providerName);
 644                 Key key = null;
 645                 String backupKey = null;
 646                 if (provider != null) {
 647                     key = getKey(Key.WIDGET, providerName);
 648                     backupKey = keyToBackupKey(key);
 649                     currentIds.add(backupKey);
 650                 } else {
 651                     Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 652                 }
 653                 if (savedIds.contains(backupKey)) {
 654                     if (VERBOSE) {
 655                         Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 656                     }
 657                     // remember that we already backed this up previously
 658                     keys.add(key);
 659                 } else if (backupKey != null) {
 660                     if (DEBUG) {
 661                         Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 662                     }
 663                     if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 664                         if (VERBOSE) {
 665                             Log.v(TAG, &quot;saving widget &quot; + backupKey);
 666                         }
<abbr title=" 667                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx, spanY * profile.cellHeightPx, widgetSpacingLayout);"> 667                         previewLoader.setPreviewSize(spanX * profile.cellWidthPx, spanY * profile.cellHei🔵</abbr>
 668                         byte[] blob = packWidget(dpi, previewLoader, mIconCache, provider);
 669                         keys.add(key);
 670                         writeRowToBackup(key, blob, out, data);
 671                     } else {
 672                         if (VERBOSE) {
 673                             Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 674                         }
 675                         // too many widgets for this pass, request another.
 676                         dataChanged();
 677                     }
 678                 }
 679             }
 680         } finally {
 681             cursor.close();
 682         }
 683         if (DEBUG) {
 684             Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 685         }
 686         // these IDs must have been deleted
 687         savedIds.removeAll(currentIds);
 688         out.rows += removeDeletedKeysFromBackup(savedIds, data);
 689     }
 690 
 691     /**
 692      * Read a widget from the stream.
 693      *
 694      * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 695      *
 696      * @param key identifier for the row
 697      * @param buffer the serialized proto from the stream, may be larger than dataSize
 698      * @param dataSize the size of the proto from the stream
 699      * @param keys keys to mark as clean in the notes for next backup
 700      */
 701     private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 702         if (VERBOSE) {
 703             Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 704         }
 705         if (DEBUG) {
<abbr title=" 706             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));"> 706             Log.d(TAG, ((&quot;read (&quot; + buffer.length) + &quot;): &quot;) + Base64.encodeToString(buffer, 0, dataSize, 🔵</abbr>
 707         }
 708         try {
 709             Widget widget = unpackWidget(buffer, 0, dataSize);
 710             if (DEBUG) {
 711                 Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 712             }
 713             if (widget.icon.data != null) {
<abbr title=" 714                 Bitmap icon = BitmapFactory.decodeByteArray(widget.icon.data, 0, widget.icon.data.length);"> 714                 Bitmap icon = BitmapFactory.decodeByteArray(widget.icon.data, 0, widget.icon.data.length)🔵</abbr>
 715                 if (icon == null) {
 716                     Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
 717                 } else {
<abbr title=" 718                     IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider), icon, widget.icon.dpi);"> 718                     IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider), i🔵</abbr>
 719                 }
 720             }
 721             if (!mRestoreEnabled) {
 722                 if (VERBOSE) {
 723                     Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 724                 }
 725                 return;
 726             } else {
 727                 // future site of widget table mutation
 728             }
 729         } catch (InvalidProtocolBufferNanoException e) {
 730             Log.e(TAG, &quot;failed to decode widget&quot;, e);
 731         }
 732     }
 733 
 734     /** create a new key, with an integer ID.
 735      *
 736      * &lt;P&gt; Keys contain their own checksum instead of using
 737      * the heavy-weight CheckedMessage wrapper.
 738      */
 739     private Key getKey(int type, long id) {
 740         Key key = new Key();
 741         key.type = type;
 742         key.id = id;
 743         key.checksum = checkKey(key);
 744         return key;
 745     }
 746 
 747     /** create a new key for a named object.
 748      *
 749      * &lt;P&gt; Keys contain their own checksum instead of using
 750      * the heavy-weight CheckedMessage wrapper.
 751      */
 752     private Key getKey(int type, String name) {
 753         Key key = new Key();
 754         key.type = type;
 755         key.name = name;
 756         key.checksum = checkKey(key);
 757         return key;
 758     }
 759 
 760     /** keys need to be strings, serialize and encode. */
 761     private String keyToBackupKey(Key key) {
 762         return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 763     }
 764 
 765     /** keys need to be strings, decode and parse. */
 766     private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 767         try {
 768             Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 769             if (key.checksum != checkKey(key)) {
 770                 key = null;
 771                 throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 772             }
 773             return key;
 774         } catch (InvalidProtocolBufferNanoException e) {
 775             throw new KeyParsingException(e);
 776         } catch (IllegalArgumentException e) {
 777             throw new KeyParsingException(e);
 778         }
 779     }
 780 
 781     private String getKeyName(Key key) {
 782         if (TextUtils.isEmpty(key.name)) {
 783             return Long.toString(key.id);
 784         } else {
 785             return key.name;
 786         }
 787 
 788     }
 789 
 790     private String geKeyType(Key key) {
 791         switch (key.type) {
 792             case Key.FAVORITE:
 793                 return &quot;favorite&quot;;
 794             case Key.SCREEN:
 795                 return &quot;screen&quot;;
 796             case Key.ICON:
 797                 return &quot;icon&quot;;
 798             case Key.WIDGET:
 799                 return &quot;widget&quot;;
 800             default:
 801                 return &quot;anonymous&quot;;
 802         }
 803     }
 804 
 805     /** Compute the checksum over the important bits of a key. */
 806     private long checkKey(Key key) {
 807         CRC32 checksum = new CRC32();
 808         checksum.update(key.type);
 809         checksum.update((int) (key.id &amp; 0xffff));
 810         checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 811         if (!TextUtils.isEmpty(key.name)) {
 812             checksum.update(key.name.getBytes());
 813         }
 814         return checksum.getValue();
 815     }
 816 
 817     /** Serialize a Favorite for persistence, including a checksum wrapper. */
 818     private byte[] packFavorite(Cursor c) {
 819         Favorite favorite = new Favorite();
 820         favorite.id = c.getLong(ID_INDEX);
 821         favorite.screen = c.getInt(SCREEN_INDEX);
 822         favorite.container = c.getInt(CONTAINER_INDEX);
 823         favorite.cellX = c.getInt(CELLX_INDEX);
 824         favorite.cellY = c.getInt(CELLY_INDEX);
 825         favorite.spanX = c.getInt(SPANX_INDEX);
 826         favorite.spanY = c.getInt(SPANY_INDEX);
 827         favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 828         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 829             String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 830             if (!TextUtils.isEmpty(iconPackage)) {
 831                 favorite.iconPackage = iconPackage;
 832             }
 833             String iconResource = c.getString(ICON_RESOURCE_INDEX);
 834             if (!TextUtils.isEmpty(iconResource)) {
 835                 favorite.iconResource = iconResource;
 836             }
 837         }
 838         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 839             byte[] blob = c.getBlob(ICON_INDEX);
 840             if ((blob != null) &amp;&amp; (blob.length &gt; 0)) {
 841                 favorite.icon = blob;
 842             }
 843         }
 844         String title = c.getString(TITLE_INDEX);
 845         if (!TextUtils.isEmpty(title)) {
 846             favorite.title = title;
 847         }
 848         String intentDescription = c.getString(INTENT_INDEX);
 849         if (!TextUtils.isEmpty(intentDescription)) {
 850             try {
 851                 Intent intent = Intent.parseUri(intentDescription, 0);
 852                 intent.removeExtra(ItemInfo.EXTRA_PROFILE);
 853                 favorite.intent = intent.toUri(0);
 854             } catch (URISyntaxException e) {
 855                 Log.e(TAG, &quot;Invalid intent&quot;, e);
 856             }
 857         }
 858         favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 859         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 860             favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 861             String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 862             if (!TextUtils.isEmpty(appWidgetProvider)) {
 863                 favorite.appWidgetProvider = appWidgetProvider;
 864             }
 865         }
 866         return writeCheckedBytes(favorite);
 867     }
 868 
 869     /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
<abbr title=" 870     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 870     private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize) throws InvalidProtocolB🔵</abbr>
 871         Favorite favorite = new Favorite();
 872         MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 873         if (VERBOSE) {
<abbr title=" 874             Log.v(TAG, ((&quot;unpacked favorite &quot; + favorite.itemType) + &quot;, &quot;) + (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));"> 874             Log.v(TAG, ((&quot;unpacked favorite &quot; + favorite.itemType) + &quot;, &quot;) + (TextUtils.isEmpty(favorite.🔵</abbr>
 875         }
 876         ContentValues values = new ContentValues();
 877         values.put(Favorites._ID, favorite.id);
 878         values.put(Favorites.SCREEN, favorite.screen);
 879         values.put(Favorites.CONTAINER, favorite.container);
 880         values.put(Favorites.CELLX, favorite.cellX);
 881         values.put(Favorites.CELLY, favorite.cellY);
 882         values.put(Favorites.SPANX, favorite.spanX);
 883         values.put(Favorites.SPANY, favorite.spanY);
 884         values.put(Favorites.ICON_TYPE, favorite.iconType);
 885         if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 886             values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 887             values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 888         }
 889         if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 890             values.put(Favorites.ICON, favorite.icon);
 891         }
 892         if (!TextUtils.isEmpty(favorite.title)) {
 893             values.put(Favorites.TITLE, favorite.title);
 894         } else {
 895             values.put(Favorites.TITLE, &quot;&quot;);
 896         }
 897         if (!TextUtils.isEmpty(favorite.intent)) {
 898             values.put(Favorites.INTENT, favorite.intent);
 899         }
 900         values.put(Favorites.ITEM_TYPE, favorite.itemType);
 901         UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();
<abbr title=" 902         long userSerialNumber = UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);"> 902         long userSerialNumber = UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHand🔵</abbr>
 903         values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);
 904         if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 905             if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 906                 values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 907             }
 908             values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
<abbr title=" 909             values.put(LauncherSettings.Favorites.RESTORED, (LauncherAppWidgetInfo.FLAG_ID_NOT_VALID | LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY) | LauncherAppWidgetInfo.FLAG_UI_NOT_READY);"> 909             values.put(LauncherSettings.Favorites.RESTORED, (LauncherAppWidgetInfo.FLAG_ID_NOT_VALID | La🔵</abbr>
 910         } else {
 911         // Let LauncherModel know we&#x27;ve been here.
 912             values.put(LauncherSettings.Favorites.RESTORED, 1);
 913         }
 914         return values;
 915     }
 916 
 917     /** Serialize a Screen for persistence, including a checksum wrapper. */
 918     private byte[] packScreen(Cursor c) {
 919         Screen screen = new Screen();
 920         screen.id = c.getLong(ID_INDEX);
 921         screen.rank = c.getInt(SCREEN_RANK_INDEX);
 922 
 923         return writeCheckedBytes(screen);
 924     }
 925 
 926     /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
<abbr title=" 927     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 927     private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBuf🔵</abbr>
 928         Screen screen = new Screen();
 929         MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 930         if (VERBOSE) {
 931             Log.v(TAG, ((&quot;unpacked screen &quot; + screen.id) + &quot;/&quot;) + screen.rank);
 932         }
 933         ContentValues values = new ContentValues();
 934         values.put(WorkspaceScreens._ID, screen.id);
 935         values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 936         return values;
 937     }
 938 
 939     /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 940     private byte[] packIcon(int dpi, Bitmap icon) {
 941         Resource res = new Resource();
 942         res.dpi = dpi;
 943         ByteArrayOutputStream os = new ByteArrayOutputStream();
 944         if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 945             res.data = os.toByteArray();
 946         }
 947         return writeCheckedBytes(res);
 948     }
 949 
 950     /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
<abbr title=" 951     private static Resource unpackIcon(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 951     private static Resource unpackIcon(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBuf🔵</abbr>
 952         Resource res = new Resource();
 953         MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 954         if (VERBOSE) {
 955             Log.v(TAG, ((&quot;unpacked icon &quot; + res.dpi) + &quot;/&quot;) + res.data.length);
 956         }
 957         return res;
 958     }
 959 
 960     /** Serialize a widget for persistence, including a checksum wrapper. */
 961     private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 962             ComponentName provider) {
 963         final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 964         Widget widget = new Widget();
 965         widget.provider = provider.flattenToShortString();
 966         widget.label = info.label;
 967         widget.configure = info.configure != null;
 968         if (info.icon != 0) {
 969             widget.icon = new Resource();
 970             Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 971             Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 972             ByteArrayOutputStream os = new ByteArrayOutputStream();
 973             if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 974                 widget.icon.data = os.toByteArray();
 975                 widget.icon.dpi = dpi;
 976             }
 977         }
 978         if (info.previewImage != 0) {
 979             widget.preview = new Resource();
 980             Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 981             ByteArrayOutputStream os = new ByteArrayOutputStream();
 982             if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 983                 widget.preview.data = os.toByteArray();
 984                 widget.preview.dpi = dpi;
 985             }
 986         }
 987         return writeCheckedBytes(widget);
 988     }
 989 
 990     /** Deserialize a widget from persistence, after verifying checksum wrapper. */
<abbr title=" 991     private Widget unpackWidget(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {"> 991     private Widget unpackWidget(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNano🔵</abbr>
 992         Widget widget = new Widget();
 993         MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
 994         if (VERBOSE) {
 995             Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
 996         }
 997         return widget;
 998     }
 999 
1000     /**
1001      * Read the old journal from the input file.
1002      *
1003      * In the event of any error, just pretend we didn&#x27;t have a journal,
1004      * in that case, do a full backup.
1005      *
1006      * @param oldState the read-0only file descriptor pointing to the old journal
1007      * @return a Journal protocol buffer
1008      */
1009     private Journal readJournal(ParcelFileDescriptor oldState) {
1010         Journal journal = new Journal();
1011         if (oldState == null) {
1012             return journal;
1013         }
1014         FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1015         try {
1016             int availableBytes = inStream.available();
1017             if (DEBUG) {
1018                 Log.d(TAG, &quot;available &quot; + availableBytes);
1019             }
1020             if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1021                 byte[] buffer = new byte[availableBytes];
1022                 int bytesRead = 0;
1023                 boolean valid = false;
1024                 InvalidProtocolBufferNanoException lastProtoException = null;
1025                 while (availableBytes &gt; 0) {
1026                     try {
1027                         // OMG what are you doing? This is crazy inefficient!
1028                         // If we read a byte that is not ours, we will cause trouble: b/12491813
1029                         // However, we don&#x27;t know how many bytes to expect (oops).
1030                         // So we have to step through *slowly*, watching for the end.
1031                         int result = inStream.read(buffer, bytesRead, 1);
1032                         if (result &gt; 0) {
1033                             availableBytes -= result;
1034                             bytesRead += result;
1035                             if (DEBUG &amp;&amp; ((bytesRead % 100) == 0)) {
1036                                 Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
1037                             }
1038                         } else {
1039                             Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1040                             // stop reading and see what there is to parse
1041                             availableBytes = 0;
1042                         }
1043                     } catch (IOException e) {
1044                         buffer = null;
1045                         availableBytes = 0;
1046                     }
1047                     // check the buffer to see if we have a valid journal
1048                     try {
1049                         MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1050                         // if we are here, then we have read a valid, checksum-verified journal
1051                         valid = true;
1052                         availableBytes = 0;
1053                         if (VERBOSE) {
1054                             Log.v(TAG, (&quot;read &quot; + bytesRead) + &quot; bytes of journal&quot;);
1055                         }
1056                     } catch (InvalidProtocolBufferNanoException e) {
1057                         // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1058                         lastProtoException = e;
1059                         journal.clear();
1060                     }
1061                 }
1062                 if (DEBUG) {
1063                     Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1064                 }
1065                 if (!valid) {
1066                     Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1067                 }
1068             }
1069         } catch (IOException e) {
1070             Log.w(TAG, &quot;failed to close the journal&quot;, e);
1071         } finally {
1072             try {
1073                 inStream.close();
1074             } catch (IOException e) {
1075                 Log.w(TAG, &quot;failed to close the journal&quot;, e);
1076             }
1077         }
1078         return journal;
1079     }
1080 
1081     private void writeRowToBackup(Key key, byte[] blob, Journal out,
1082             BackupDataOutput data) throws IOException {
1083         String backupKey = keyToBackupKey(key);
1084         data.writeEntityHeader(backupKey, blob.length);
1085         data.writeEntityData(blob, blob.length);
1086         out.rows++;
1087         out.bytes += blob.length;
1088         if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1089                 getKeyName(key) + &quot;/&quot; + blob.length);
1090         if(DEBUG_PAYLOAD) {
1091             String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1092             final int chunkSize = 1024;
1093             for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1094                 int end = offset + chunkSize;
1095                 end = Math.min(end, encoded.length());
1096                 Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1097             }
1098         }
1099     }
1100 
1101     private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1102         Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1103         for(int i = 0; i &lt; in.key.length; i++) {
1104             Key key = in.key[i];
1105             if (key.type == type) {
1106                 savedIds.add(keyToBackupKey(key));
1107             }
1108         }
1109         return savedIds;
1110     }
1111 
1112     private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1113             throws IOException {
1114         int rows = 0;
1115         for(String deleted: deletedIds) {
1116             if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1117             data.writeEntityHeader(deleted, -1);
1118             rows++;
1119         }
1120         return rows;
1121     }
1122 
1123     /**
1124      * Write the new journal to the output file.
1125      *
1126      * In the event of any error, just pretend we didn&#x27;t have a journal,
1127      * in that case, do a full backup.
1128 
1129      * @param newState the write-only file descriptor pointing to the new journal
1130      * @param journal a Journal protocol buffer
1131      */
1132     private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1133         FileOutputStream outStream = null;
1134         try {
1135             outStream = new FileOutputStream(newState.getFileDescriptor());
1136             final byte[] journalBytes = writeCheckedBytes(journal);
1137             outStream.write(journalBytes);
1138             outStream.close();
1139             if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1140         } catch (IOException e) {
1141             Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1142         }
1143     }
1144 
1145     /** Wrap a proto in a CheckedMessage and compute the checksum. */
1146     private byte[] writeCheckedBytes(MessageNano proto) {
1147         CheckedMessage wrapper = new CheckedMessage();
1148         wrapper.payload = MessageNano.toByteArray(proto);
1149         CRC32 checksum = new CRC32();
1150         checksum.update(wrapper.payload);
1151         wrapper.checksum = checksum.getValue();
1152         return MessageNano.toByteArray(wrapper);
1153     }
1154 
1155     /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
<abbr title="1156     private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize) throws InvalidProtocolBufferNanoException {">1156     private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize) throws InvalidProtoco🔵</abbr>
1157         CheckedMessage wrapper = new CheckedMessage();
1158         MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1159         CRC32 checksum = new CRC32();
1160         checksum.update(wrapper.payload);
1161         if (wrapper.checksum != checksum.getValue()) {
1162             throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1163         }
1164         return wrapper.payload;
1165     }
1166 
1167     private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1168         if (mWidgetMap == null) {
1169             List&lt;AppWidgetProviderInfo&gt; widgets =
1170                     AppWidgetManager.getInstance(mContext).getInstalledProviders();
1171             mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1172             for (AppWidgetProviderInfo info : widgets) {
1173                 mWidgetMap.put(info.provider, info);
1174             }
1175         }
1176         return mWidgetMap.get(component);
1177     }
1178 
1179     private boolean initializeIconCache() {
1180         if (mIconCache != null) {
1181             return true;
1182         }
1183         final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
1184         if (appState == null) {
1185             Throwable stackTrace = new Throwable();
1186             stackTrace.fillInStackTrace();
1187             Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);
1188             return false;
1189         }
1190         mIconCache = appState.getIconCache();
1191         return mIconCache != null;
1192     }
1193 
1194 // check if the launcher is in a state to support backup
1195     private boolean launcherIsReady() {
1196         ContentResolver cr = mContext.getContentResolver();
1197         Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);
1198         if (cursor == null) {
1199             // launcher data has been wiped, do nothing
1200             return false;
1201         }
1202         cursor.close();
1203         if (!initializeIconCache()) {
1204             // launcher services are unavailable, try again later
1205             dataChanged();
1206             return false;
1207         }
1208         return true;
1209     }
1210 
1211     private String getUserSelectionArg() {
1212         return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)
1213                 .getSerialNumberForUser(UserHandleCompat.myUserHandle());
1214     }
1215 
1216     private class KeyParsingException extends Throwable {
1217         private KeyParsingException(Throwable cause) {
1218             super(cause);
1219         }
1220 
1221         public KeyParsingException(String reason) {
1222             super(reason);
1223         }
1224     }
1225 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Copyright (C) 2013 The Android Open Source Project
   3   *
   4   * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
   5   * you may not use this file except in compliance with the License.
   6   * You may obtain a copy of the License at
   7   *
   8   *      http://www.apache.org/licenses/LICENSE-2.0
   9   *
  10   * Unless required by applicable law or agreed to in writing, software
  11   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  12   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  13   * See the License for the specific language governing permissions and
  14   * limitations under the License.
  15   */
  16  package com.android.launcher3;
  17  
  18  import com.google.protobuf.nano.InvalidProtocolBufferNanoException;
  19  import com.google.protobuf.nano.MessageNano;
  20  
  21  import com.android.launcher3.LauncherSettings.Favorites;
  22  import com.android.launcher3.LauncherSettings.WorkspaceScreens;
  23  import com.android.launcher3.backup.BackupProtos;
  24  import com.android.launcher3.backup.BackupProtos.CheckedMessage;
  25  import com.android.launcher3.backup.BackupProtos.Favorite;
  26  import com.android.launcher3.backup.BackupProtos.Journal;
  27  import com.android.launcher3.backup.BackupProtos.Key;
  28  import com.android.launcher3.backup.BackupProtos.Resource;
  29  import com.android.launcher3.backup.BackupProtos.Screen;
  30  import com.android.launcher3.backup.BackupProtos.Widget;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  31 +import com.android.launcher3.compat.UserManagerCompat;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  32 +import com.android.launcher3.compat.UserHandleCompat;</span>
  33  
  34  import android.app.backup.BackupDataInputStream;
  35  import android.app.backup.BackupDataOutput;
  36  import android.app.backup.BackupHelper;
  37  import android.app.backup.BackupManager;
  38  import android.appwidget.AppWidgetManager;
  39  import android.appwidget.AppWidgetProviderInfo;
  40  import android.content.ComponentName;
  41  import android.content.ContentResolver;
  42  import android.content.ContentValues;
  43  import android.content.Context;
  44  import android.content.Intent;
  45  import android.database.Cursor;
  46  import android.graphics.Bitmap;
  47  import android.graphics.BitmapFactory;
  48  import android.graphics.drawable.Drawable;
  49  import android.os.ParcelFileDescriptor;
  50  import android.text.TextUtils;
  51  import android.util.Base64;
  52  import android.util.Log;
  53  
  54  import java.io.ByteArrayOutputStream;
  55  import java.io.FileInputStream;
  56  import java.io.FileOutputStream;
  57  import java.io.IOException;
  58  import java.net.URISyntaxException;
  59  import java.util.ArrayList;
  60  import java.util.HashMap;
  61  import java.util.HashSet;
  62  import java.util.List;
  63  import java.util.Set;
  64  import java.util.zip.CRC32;
  65  
  66  /**
  67   * Persist the launcher home state across calamities.
  68   */
  69  public class LauncherBackupHelper implements BackupHelper {
  70  
  71      private static final String TAG = &quot;LauncherBackupHelper&quot;;
  72      private static final boolean VERBOSE = LauncherBackupAgentHelper.VERBOSE;
  73      private static final boolean DEBUG = LauncherBackupAgentHelper.DEBUG;
  74      private static final boolean DEBUG_PAYLOAD = false;
  75  
  76      private static final int MAX_JOURNAL_SIZE = 1000000;
  77  
  78      /** icons are large, dribble them out */
  79      private static final int MAX_ICONS_PER_PASS = 10;
  80  
  81      /** widgets contain previews, which are very large, dribble them out */
  82      private static final int MAX_WIDGETS_PER_PASS = 5;
  83  
  84      public static final int IMAGE_COMPRESSION_QUALITY = 75;
  85  
  86      public static final String LAUNCHER_PREFIX = &quot;L&quot;;
  87  
  88      public static final String LAUNCHER_PREFS_PREFIX = &quot;LP&quot;;
  89  
  90      private static final Bitmap.CompressFormat IMAGE_FORMAT =
  91              android.graphics.Bitmap.CompressFormat.PNG;
  92  
  93      private static BackupManager sBackupManager;
  94  
  95      private static final String[] FAVORITE_PROJECTION = {
  96              Favorites._ID,                     // 0
  97              Favorites.MODIFIED,                // 1
  98              Favorites.INTENT,                  // 2
  99              Favorites.APPWIDGET_PROVIDER,      // 3
 100              Favorites.APPWIDGET_ID,            // 4
 101              Favorites.CELLX,                   // 5
 102              Favorites.CELLY,                   // 6
 103              Favorites.CONTAINER,               // 7
 104              Favorites.ICON,                    // 8
 105              Favorites.ICON_PACKAGE,            // 9
 106              Favorites.ICON_RESOURCE,           // 10
 107              Favorites.ICON_TYPE,               // 11
 108              Favorites.ITEM_TYPE,               // 12
 109              Favorites.SCREEN,                  // 13
 110              Favorites.SPANX,                   // 14
 111              Favorites.SPANY,                   // 15
 112              Favorites.TITLE,                   // 16
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 113 +            Favorites.PROFILE_ID,              // 17</span>
 114      };
 115  
 116      private static final int ID_INDEX = 0;
 117      private static final int ID_MODIFIED = 1;
 118      private static final int INTENT_INDEX = 2;
 119      private static final int APPWIDGET_PROVIDER_INDEX = 3;
 120      private static final int APPWIDGET_ID_INDEX = 4;
 121      private static final int CELLX_INDEX = 5;
 122      private static final int CELLY_INDEX = 6;
 123      private static final int CONTAINER_INDEX = 7;
 124      private static final int ICON_INDEX = 8;
 125      private static final int ICON_PACKAGE_INDEX = 9;
 126      private static final int ICON_RESOURCE_INDEX = 10;
 127      private static final int ICON_TYPE_INDEX = 11;
 128      private static final int ITEM_TYPE_INDEX = 12;
 129      private static final int SCREEN_INDEX = 13;
 130      private static final int SPANX_INDEX = 14;
 131      private static final int SPANY_INDEX = 15;
 132      private static final int TITLE_INDEX = 16;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 133 +    private static final int PROFILE_ID_INDEX = 17;</span>
 134  
 135      private static final String[] SCREEN_PROJECTION = {
 136              WorkspaceScreens._ID,              // 0
 137              WorkspaceScreens.MODIFIED,         // 1
 138              WorkspaceScreens.SCREEN_RANK       // 2
 139      };
 140  
 141      private static final int SCREEN_RANK_INDEX = 2;
 142  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 143 +    private static IconCache mIconCache;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 144 +</span>
 145      private final Context mContext;
 146  
 147      private final boolean mRestoreEnabled;
 148  
 149      private HashMap&lt;ComponentName, AppWidgetProviderInfo&gt; mWidgetMap;
 150  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 151 -    private ArrayList&lt;Key&gt; mKeys;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 152 +    private final ArrayList&lt;Key&gt; mKeys;</span>
 153  
 154      public LauncherBackupHelper(Context context, boolean restoreEnabled) {
 155          mContext = context;
 156          mRestoreEnabled = restoreEnabled;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 157 +        mKeys = new ArrayList&lt;Key&gt;();</span>
 158      }
 159  
 160      private void dataChanged() {
 161          if (sBackupManager == null) {
 162              sBackupManager = new BackupManager(mContext);
 163          }
 164          sBackupManager.dataChanged();
 165      }
 166  
 167      /**
 168       * Back up launcher data so we can restore the user&#x27;s state on a new device.
 169       *
 170       * &lt;P&gt;The journal is a timestamp and a list of keys that were saved as of that time.
 171       *
 172       * &lt;P&gt;Keys may come back in any order, so each key/value is one complete row of the database.
 173       *
 174       * @param oldState notes from the last backup
 175       * @param data incremental key/value pairs to persist off-device
 176       * @param newState notes for the next backup
 177       * @throws IOException
 178       */
 179      @Override
 180      public void performBackup(ParcelFileDescriptor oldState, BackupDataOutput data,
 181              ParcelFileDescriptor newState) {
 182          if (VERBOSE) Log.v(TAG, &quot;onBackup&quot;);
 183  
 184          Journal in = readJournal(oldState);
 185          Journal out = new Journal();
 186  
 187          long lastBackupTime = in.t;
 188          out.t = System.currentTimeMillis();
 189          out.rows = 0;
 190          out.bytes = 0;
 191  
 192          Log.v(TAG, &quot;lastBackupTime = &quot; + lastBackupTime);
 193  
 194          ArrayList&lt;Key&gt; keys = new ArrayList&lt;Key&gt;();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 195 -        try {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 196 -            backupFavorites(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 197 -            backupScreens(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 198 -            backupIcons(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 199 -            backupWidgets(in, data, out, keys);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 200 -        } catch (IOException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 201 -            Log.e(TAG, &quot;launcher backup has failed&quot;, e);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 202 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 203 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 204 -        out.key = keys.toArray(BackupProtos.Key.emptyArray());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 205 +        if (launcherIsReady()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 206 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 207 +                backupFavorites(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 208 +                backupScreens(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 209 +                backupIcons(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 210 +                backupWidgets(in, data, out, keys);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 211 +            } catch (IOException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 212 +                Log.e(TAG, &quot;launcher backup has failed&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 213 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 214 +            out.key = keys.toArray(new BackupProtos.Key[keys.size()]);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 215 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 216 +            out = in;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 217 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 218 +</span>
 219          writeJournal(newState, out);
 220          Log.v(TAG, &quot;onBackup: wrote &quot; + out.bytes + &quot;b in &quot; + out.rows + &quot; rows.&quot;);
 221      }
 222  
 223      /**
 224       * Restore launcher configuration from the restored data stream.
 225       *
 226       * &lt;P&gt;Keys may arrive in any order.
 227       *
 228       * @param data the key/value pair from the server
 229       */
 230      @Override
 231      public void restoreEntity(BackupDataInputStream data) {
 232          if (VERBOSE) Log.v(TAG, &quot;restoreEntity&quot;);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 233 -        if (mKeys == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 234 -            mKeys = new ArrayList&lt;Key&gt;();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 235 -        }</span>
 236          byte[] buffer = new byte[512];
 237              String backupKey = data.getKey();
 238              int dataSize = data.size();
 239              if (buffer.length &lt; dataSize) {
 240                  buffer = new byte[dataSize];
 241              }
 242              Key key = null;
 243          int bytesRead = 0;
 244          try {
 245              bytesRead = data.read(buffer, 0, dataSize);
 246              if (DEBUG) Log.d(TAG, &quot;read &quot; + bytesRead + &quot; of &quot; + dataSize + &quot; available&quot;);
 247          } catch (IOException e) {
 248              Log.e(TAG, &quot;failed to read entity from restore data&quot;, e);
 249          }
 250          try {
 251              key = backupKeyToKey(backupKey);
 252              mKeys.add(key);
 253              switch (key.type) {
 254                  case Key.FAVORITE:
 255                      restoreFavorite(key, buffer, dataSize, mKeys);
 256                      break;
 257  
 258                  case Key.SCREEN:
 259                      restoreScreen(key, buffer, dataSize, mKeys);
 260                      break;
 261  
 262                  case Key.ICON:
 263                      restoreIcon(key, buffer, dataSize, mKeys);
 264                      break;
 265  
 266                  case Key.WIDGET:
 267                      restoreWidget(key, buffer, dataSize, mKeys);
 268                      break;
 269  
 270                  default:
 271                      Log.w(TAG, &quot;unknown restore entity type: &quot; + key.type);
 272                      break;
 273              }
 274          } catch (KeyParsingException e) {
 275              Log.w(TAG, &quot;ignoring unparsable backup key: &quot; + backupKey);
 276          }
 277  
 278      }
 279  
 280      /**
 281       * Record the restore state for the next backup.
 282       *
 283       * @param newState notes about the backup state after restore.
 284       */
 285      @Override
 286      public void writeNewStateDescription(ParcelFileDescriptor newState) {
 287          // clear the output journal time, to force a full backup to
 288          // will catch any changes the restore process might have made
 289          Journal out = new Journal();
 290          out.t = 0;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 291 -        out.key = mKeys.toArray(BackupProtos.Key.emptyArray());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 292 +        out.key = mKeys.toArray(new BackupProtos.Key[mKeys.size()]);</span>
 293          writeJournal(newState, out);
 294          Log.v(TAG, &quot;onRestore: read &quot; + mKeys.size() + &quot; rows&quot;);
 295          mKeys.clear();
 296      }
 297  
 298      /**
 299       * Write all modified favorites to the data stream.
 300       *
 301       *
 302       * @param in notes from last backup
 303       * @param data output stream for key/value pairs
 304       * @param out notes about this backup
 305       * @param keys keys to mark as clean in the notes for next backup
 306       * @throws IOException
 307       */
 308      private void backupFavorites(Journal in, BackupDataOutput data, Journal out,
 309              ArrayList&lt;Key&gt; keys)
 310              throws IOException {
 311          // read the old ID set
 312          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.FAVORITE, in);
 313          if (DEBUG) Log.d(TAG, &quot;favorite savedIds.size()=&quot; + savedIds.size());
 314  
 315          // persist things that have changed since the last backup
 316          ContentResolver cr = mContext.getContentResolver();
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 317 +        // Don&#x27;t backup apps in other profiles for now.</span>
 318          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 319 -                null, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 320 +                getUserSelectionArg(), null, null);</span>
 321          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 322          try {
 323              cursor.moveToPosition(-1);
 324              while(cursor.moveToNext()) {
 325                  final long id = cursor.getLong(ID_INDEX);
 326                  final long updateTime = cursor.getLong(ID_MODIFIED);
 327                  Key key = getKey(Key.FAVORITE, id);
 328                  keys.add(key);
 329                  final String backupKey = keyToBackupKey(key);
 330                  currentIds.add(backupKey);
 331                  if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 332                      byte[] blob = packFavorite(cursor);
 333                      writeRowToBackup(key, blob, out, data);
 334                  } else {
 335                      if (VERBOSE) Log.v(TAG, &quot;favorite &quot; + id + &quot; was too old: &quot; + updateTime);
 336                  }
 337              }
 338          } finally {
 339              cursor.close();
 340          }
 341          if (DEBUG) Log.d(TAG, &quot;favorite currentIds.size()=&quot; + currentIds.size());
 342  
 343          // these IDs must have been deleted
 344          savedIds.removeAll(currentIds);
 345          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 346      }
 347  
 348      /**
 349       * Read a favorite from the stream.
 350       *
 351       * &lt;P&gt;Keys arrive in any order, so screens and containers may not exist yet.
 352       *
 353       * @param key identifier for the row
 354       * @param buffer the serialized proto from the stream, may be larger than dataSize
 355       * @param dataSize the size of the proto from the stream
 356       * @param keys keys to mark as clean in the notes for next backup
 357       */
 358      private void restoreFavorite(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 359          if (VERBOSE) Log.v(TAG, &quot;unpacking favorite &quot; + key.id);
 360          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 361                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 362  
 363          if (!mRestoreEnabled) {
 364              if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 365              return;
 366          }
 367  
 368          try {
 369              ContentResolver cr = mContext.getContentResolver();
 370              ContentValues values = unpackFavorite(buffer, 0, dataSize);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 371 -            cr.insert(Favorites.CONTENT_URI, values);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 372 +            cr.insert(Favorites.CONTENT_URI_NO_NOTIFICATION, values);</span>
 373          } catch (InvalidProtocolBufferNanoException e) {
 374              Log.e(TAG, &quot;failed to decode favorite&quot;, e);
 375          }
 376      }
 377  
 378      /**
 379       * Write all modified screens to the data stream.
 380       *
 381       *
 382       * @param in notes from last backup
 383       * @param data output stream for key/value pairs
 384       * @param out notes about this backup
 385       * @param keys keys to mark as clean in the notes for next backup
 386       * @throws IOException
 387       */
 388      private void backupScreens(Journal in, BackupDataOutput data, Journal out,
 389              ArrayList&lt;Key&gt; keys)
 390              throws IOException {
 391          // read the old ID set
 392          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.SCREEN, in);
 393          if (DEBUG) Log.d(TAG, &quot;screen savedIds.size()=&quot; + savedIds.size());
 394  
 395          // persist things that have changed since the last backup
 396          ContentResolver cr = mContext.getContentResolver();
 397          Cursor cursor = cr.query(WorkspaceScreens.CONTENT_URI, SCREEN_PROJECTION,
 398                  null, null, null);
 399          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 400          try {
 401              cursor.moveToPosition(-1);
 402              if (DEBUG) Log.d(TAG, &quot;dumping screens after: &quot; + in.t);
 403              while(cursor.moveToNext()) {
 404                  final long id = cursor.getLong(ID_INDEX);
 405                  final long updateTime = cursor.getLong(ID_MODIFIED);
 406                  Key key = getKey(Key.SCREEN, id);
 407                  keys.add(key);
 408                  final String backupKey = keyToBackupKey(key);
 409                  currentIds.add(backupKey);
 410                  if (!savedIds.contains(backupKey) || updateTime &gt;= in.t) {
 411                      byte[] blob = packScreen(cursor);
 412                      writeRowToBackup(key, blob, out, data);
 413                  } else {
 414                      if (VERBOSE) Log.v(TAG, &quot;screen &quot; + id + &quot; was too old: &quot; + updateTime);
 415                  }
 416              }
 417          } finally {
 418              cursor.close();
 419          }
 420          if (DEBUG) Log.d(TAG, &quot;screen currentIds.size()=&quot; + currentIds.size());
 421  
 422          // these IDs must have been deleted
 423          savedIds.removeAll(currentIds);
 424          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 425      }
 426  
 427      /**
 428       * Read a screen from the stream.
 429       *
 430       * &lt;P&gt;Keys arrive in any order, so children of this screen may already exist.
 431       *
 432       * @param key identifier for the row
 433       * @param buffer the serialized proto from the stream, may be larger than dataSize
 434       * @param dataSize the size of the proto from the stream
 435       * @param keys keys to mark as clean in the notes for next backup
 436       */
 437      private void restoreScreen(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 438          if (VERBOSE) Log.v(TAG, &quot;unpacking screen &quot; + key.id);
 439          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 440                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 441  
 442          if (!mRestoreEnabled) {
 443              if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 444              return;
 445          }
 446  
 447          try {
 448              ContentResolver cr = mContext.getContentResolver();
 449              ContentValues values = unpackScreen(buffer, 0, dataSize);
 450              cr.insert(WorkspaceScreens.CONTENT_URI, values);
 451  
 452          } catch (InvalidProtocolBufferNanoException e) {
 453              Log.e(TAG, &quot;failed to decode screen&quot;, e);
 454          }
 455      }
 456  
 457      /**
 458       * Write all the static icon resources we need to render placeholders
 459       * for a package that is not installed.
 460       *
 461       * @param in notes from last backup
 462       * @param data output stream for key/value pairs
 463       * @param out notes about this backup
 464       * @param keys keys to mark as clean in the notes for next backup
 465       * @throws IOException
 466       */
 467      private void backupIcons(Journal in, BackupDataOutput data, Journal out,
 468              ArrayList&lt;Key&gt; keys) throws IOException {
 469          // persist icons that haven&#x27;t been persisted yet
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 470 -        final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 471 -        if (appState == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 472 +        if (!initializeIconCache()) {</span>
 473              dataChanged(); // try again later
 474              if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying icon backup&quot;);
 475              return;
 476          }
 477          final ContentResolver cr = mContext.getContentResolver();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 478 -        final IconCache iconCache = appState.getIconCache();</span>
 479          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 480 +        final UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();</span>
 481  
 482          // read the old ID set
 483          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.ICON, in);
 484          if (DEBUG) Log.d(TAG, &quot;icon savedIds.size()=&quot; + savedIds.size());
 485  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 486 +        // Don&#x27;t backup apps in other profiles for now.</span>
 487          int startRows = out.rows;
 488          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 489 -        String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 490 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 491 +        String where = &quot;(&quot; + Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPLICATION + &quot; OR &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 492 +                Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_SHORTCUT + &quot;) AND &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 493 +                getUserSelectionArg();</span>
 494          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 495                  where, null, null);
 496          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 497          try {
 498              cursor.moveToPosition(-1);
 499              while(cursor.moveToNext()) {
 500                  final long id = cursor.getLong(ID_INDEX);
 501                  final String intentDescription = cursor.getString(INTENT_INDEX);
 502                  try {
 503                      Intent intent = Intent.parseUri(intentDescription, 0);
 504                      ComponentName cn = intent.getComponent();
 505                      Key key = null;
 506                      String backupKey = null;
 507                      if (cn != null) {
 508                          key = getKey(Key.ICON, cn.flattenToShortString());
 509                          backupKey = keyToBackupKey(key);
 510                          currentIds.add(backupKey);
 511                      } else {
 512                          Log.w(TAG, &quot;empty intent on application favorite: &quot; + id);
 513                      }
 514                      if (savedIds.contains(backupKey)) {
 515                          if (VERBOSE) Log.v(TAG, &quot;already saved icon &quot; + backupKey);
 516  
 517                          // remember that we already backed this up previously
 518                          keys.add(key);
 519                      } else if (backupKey != null) {
 520                          if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 521                          if ((out.rows - startRows) &lt; MAX_ICONS_PER_PASS) {
 522                              if (VERBOSE) Log.v(TAG, &quot;saving icon &quot; + backupKey);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 523 -                            Bitmap icon = iconCache.getIcon(intent);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 524 +                            Bitmap icon = mIconCache.getIcon(intent, myUserHandle);</span>
 525                              keys.add(key);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 526 -                            if (icon != null &amp;&amp; !iconCache.isDefaultIcon(icon)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 527 +                            if (icon != null &amp;&amp; !mIconCache.isDefaultIcon(icon, myUserHandle)) {</span>
 528                                  byte[] blob = packIcon(dpi, icon);
 529                                  writeRowToBackup(key, blob, out, data);
 530                              }
 531                          } else {
 532                              if (VERBOSE) Log.d(TAG, &quot;deferring icon backup &quot; + backupKey);
 533                              // too many icons for this pass, request another.
 534                              dataChanged();
 535                          }
 536                      }
 537                  } catch (URISyntaxException e) {
 538                      Log.e(TAG, &quot;invalid URI on application favorite: &quot; + id);
 539                  } catch (IOException e) {
 540                      Log.e(TAG, &quot;unable to save application icon for favorite: &quot; + id);
 541                  }
 542  
 543              }
 544          } finally {
 545              cursor.close();
 546          }
 547          if (DEBUG) Log.d(TAG, &quot;icon currentIds.size()=&quot; + currentIds.size());
 548  
 549          // these IDs must have been deleted
 550          savedIds.removeAll(currentIds);
 551          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 552      }
 553  
 554      /**
 555       * Read an icon from the stream.
 556       *
 557       * &lt;P&gt;Keys arrive in any order, so shortcuts that use this icon may already exist.
 558       *
 559       * @param key identifier for the row
 560       * @param buffer the serialized proto from the stream, may be larger than dataSize
 561       * @param dataSize the size of the proto from the stream
 562       * @param keys keys to mark as clean in the notes for next backup
 563       */
 564      private void restoreIcon(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 565          if (VERBOSE) Log.v(TAG, &quot;unpacking icon &quot; + key.id);
 566          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 567                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 568 +</span>
 569          try {
 570              Resource res = unpackIcon(buffer, 0, dataSize);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 571 -            if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 572 -            if (DEBUG_PAYLOAD) Log.d(TAG, &quot;read &quot; +</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 573 -                    Base64.encodeToString(res.data, 0, res.data.length,</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 574 -                            Base64.NO_WRAP));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 575 +            if (DEBUG) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 576 +                Log.d(TAG, &quot;unpacked &quot; + res.dpi + &quot; dpi icon&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 577 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 578 +            if (DEBUG_PAYLOAD) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 579 +                Log.d(TAG, &quot;read &quot; +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 580 +                        Base64.encodeToString(res.data, 0, res.data.length,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 581 +                                Base64.NO_WRAP));</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 582 +            }</span>
 583              Bitmap icon = BitmapFactory.decodeByteArray(res.data, 0, res.data.length);
 584              if (icon == null) {
 585                  Log.w(TAG, &quot;failed to unpack icon for &quot; + key.name);
 586              }
 587  
 588              if (!mRestoreEnabled) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 589 -                if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 590 +                if (VERBOSE) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 591 +                    Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 592 +                }</span>
 593                  return;
 594              } else {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 595 -                // future site of icon cache mutation</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 596 -            }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 597 -        } catch (InvalidProtocolBufferNanoException e) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 598 -            Log.e(TAG, &quot;failed to decode icon&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 599 +                if (VERBOSE) Log.v(TAG, &quot;saving restored icon as: &quot; + key.name);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 600 +                IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(key.name),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 601 +                        icon, res.dpi);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 602 +            }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 603 +        } catch (IOException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 604 +            Log.d(TAG, &quot;failed to save restored icon for: &quot; + key.name, e);</span>
 605          }
 606      }
 607  
 608      /**
 609       * Write all the static widget resources we need to render placeholders
 610       * for a package that is not installed.
 611       *
 612       * @param in notes from last backup
 613       * @param data output stream for key/value pairs
 614       * @param out notes about this backup
 615       * @param keys keys to mark as clean in the notes for next backup
 616       * @throws IOException
 617       */
 618      private void backupWidgets(Journal in, BackupDataOutput data, Journal out,
 619              ArrayList&lt;Key&gt; keys) throws IOException {
 620          // persist static widget info that hasn&#x27;t been persisted yet
 621          final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 622 -        if (appState == null) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 623 -            dataChanged(); // try again later</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 624 -            if (DEBUG) Log.d(TAG, &quot;Launcher is not initialized, delaying widget backup&quot;);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 625 +        if (appState == null || !initializeIconCache()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 626 +            Log.w(TAG, &quot;Failed to get icon cache during restore&quot;);</span>
 627              return;
 628          }
 629          final ContentResolver cr = mContext.getContentResolver();
 630          final WidgetPreviewLoader previewLoader = new WidgetPreviewLoader(mContext);
 631          final PagedViewCellLayout widgetSpacingLayout = new PagedViewCellLayout(mContext);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 632 -        final IconCache iconCache = appState.getIconCache();</span>
 633          final int dpi = mContext.getResources().getDisplayMetrics().densityDpi;
 634          final DeviceProfile profile = appState.getDynamicGrid().getDeviceProfile();
 635          if (DEBUG) Log.d(TAG, &quot;cellWidthPx: &quot; + profile.cellWidthPx);
 636  
 637          // read the old ID set
 638          Set&lt;String&gt; savedIds = getSavedIdsByType(Key.WIDGET, in);
 639          if (DEBUG) Log.d(TAG, &quot;widgets savedIds.size()=&quot; + savedIds.size());
 640  
 641          int startRows = out.rows;
 642          if (DEBUG) Log.d(TAG, &quot;starting here: &quot; + startRows);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 643 -        String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 644 +        String where = Favorites.ITEM_TYPE + &quot;=&quot; + Favorites.ITEM_TYPE_APPWIDGET + &quot; AND &quot;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 645 +                + getUserSelectionArg();</span>
 646          Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION,
 647                  where, null, null);
 648          Set&lt;String&gt; currentIds = new HashSet&lt;String&gt;(cursor.getCount());
 649          try {
 650              cursor.moveToPosition(-1);
 651              while(cursor.moveToNext()) {
 652                  final long id = cursor.getLong(ID_INDEX);
 653                  final String providerName = cursor.getString(APPWIDGET_PROVIDER_INDEX);
 654                  final int spanX = cursor.getInt(SPANX_INDEX);
 655                  final int spanY = cursor.getInt(SPANY_INDEX);
 656                  final ComponentName provider = ComponentName.unflattenFromString(providerName);
 657                  Key key = null;
 658                  String backupKey = null;
 659                  if (provider != null) {
 660                      key = getKey(Key.WIDGET, providerName);
 661                      backupKey = keyToBackupKey(key);
 662                      currentIds.add(backupKey);
 663                  } else {
 664                      Log.w(TAG, &quot;empty intent on appwidget: &quot; + id);
 665                  }
 666                  if (savedIds.contains(backupKey)) {
 667                      if (VERBOSE) Log.v(TAG, &quot;already saved widget &quot; + backupKey);
 668  
 669                      // remember that we already backed this up previously
 670                      keys.add(key);
 671                  } else if (backupKey != null) {
 672                      if (DEBUG) Log.d(TAG, &quot;I can count this high: &quot; + out.rows);
 673                      if ((out.rows - startRows) &lt; MAX_WIDGETS_PER_PASS) {
 674                          if (VERBOSE) Log.v(TAG, &quot;saving widget &quot; + backupKey);
 675                          previewLoader.setPreviewSize(spanX * profile.cellWidthPx,
 676                                  spanY * profile.cellHeightPx, widgetSpacingLayout);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 677 -                        byte[] blob = packWidget(dpi, previewLoader, iconCache, provider);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 678 +                        byte[] blob = packWidget(dpi, previewLoader, mIconCache, provider);</span>
 679                          keys.add(key);
 680                          writeRowToBackup(key, blob, out, data);
 681  
 682                      } else {
 683                          if (VERBOSE) Log.d(TAG, &quot;deferring widget backup &quot; + backupKey);
 684                          // too many widgets for this pass, request another.
 685                          dataChanged();
 686                      }
 687                  }
 688              }
 689          } finally {
 690              cursor.close();
 691          }
 692          if (DEBUG) Log.d(TAG, &quot;widget currentIds.size()=&quot; + currentIds.size());
 693  
 694          // these IDs must have been deleted
 695          savedIds.removeAll(currentIds);
 696          out.rows += removeDeletedKeysFromBackup(savedIds, data);
 697      }
 698  
 699      /**
 700       * Read a widget from the stream.
 701       *
 702       * &lt;P&gt;Keys arrive in any order, so widgets that use this data may already exist.
 703       *
 704       * @param key identifier for the row
 705       * @param buffer the serialized proto from the stream, may be larger than dataSize
 706       * @param dataSize the size of the proto from the stream
 707       * @param keys keys to mark as clean in the notes for next backup
 708       */
 709      private void restoreWidget(Key key, byte[] buffer, int dataSize, ArrayList&lt;Key&gt; keys) {
 710          if (VERBOSE) Log.v(TAG, &quot;unpacking widget &quot; + key.id);
 711          if (DEBUG) Log.d(TAG, &quot;read (&quot; + buffer.length + &quot;): &quot; +
 712                  Base64.encodeToString(buffer, 0, dataSize, Base64.NO_WRAP));
 713          try {
 714              Widget widget = unpackWidget(buffer, 0, dataSize);
 715              if (DEBUG) Log.d(TAG, &quot;unpacked &quot; + widget.provider);
 716              if (widget.icon.data != null)  {
 717                  Bitmap icon = BitmapFactory
 718                          .decodeByteArray(widget.icon.data, 0, widget.icon.data.length);
 719                  if (icon == null) {
 720                      Log.w(TAG, &quot;failed to unpack widget icon for &quot; + key.name);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 721 +                } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 722 +                    IconCache.preloadIcon(mContext, ComponentName.unflattenFromString(widget.provider),</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 723 +                            icon, widget.icon.dpi);</span>
 724                  }
 725              }
 726  
 727              if (!mRestoreEnabled) {
 728                  if (VERBOSE) Log.v(TAG, &quot;restore not enabled: skipping database mutation&quot;);
 729                  return;
 730              } else {
 731                  // future site of widget table mutation
 732              }
 733          } catch (InvalidProtocolBufferNanoException e) {
 734              Log.e(TAG, &quot;failed to decode widget&quot;, e);
 735          }
 736      }
 737  
 738      /** create a new key, with an integer ID.
 739       *
 740       * &lt;P&gt; Keys contain their own checksum instead of using
 741       * the heavy-weight CheckedMessage wrapper.
 742       */
 743      private Key getKey(int type, long id) {
 744          Key key = new Key();
 745          key.type = type;
 746          key.id = id;
 747          key.checksum = checkKey(key);
 748          return key;
 749      }
 750  
 751      /** create a new key for a named object.
 752       *
 753       * &lt;P&gt; Keys contain their own checksum instead of using
 754       * the heavy-weight CheckedMessage wrapper.
 755       */
 756      private Key getKey(int type, String name) {
 757          Key key = new Key();
 758          key.type = type;
 759          key.name = name;
 760          key.checksum = checkKey(key);
 761          return key;
 762      }
 763  
 764      /** keys need to be strings, serialize and encode. */
 765      private String keyToBackupKey(Key key) {
 766          return Base64.encodeToString(Key.toByteArray(key), Base64.NO_WRAP);
 767      }
 768  
 769      /** keys need to be strings, decode and parse. */
 770      private Key backupKeyToKey(String backupKey) throws KeyParsingException {
 771          try {
 772              Key key = Key.parseFrom(Base64.decode(backupKey, Base64.DEFAULT));
 773              if (key.checksum != checkKey(key)) {
 774                  key = null;
 775                  throw new KeyParsingException(&quot;invalid key read from stream&quot; + backupKey);
 776              }
 777              return key;
 778          } catch (InvalidProtocolBufferNanoException e) {
 779              throw new KeyParsingException(e);
 780          } catch (IllegalArgumentException e) {
 781              throw new KeyParsingException(e);
 782          }
 783      }
 784  
 785      private String getKeyName(Key key) {
 786          if (TextUtils.isEmpty(key.name)) {
 787              return Long.toString(key.id);
 788          } else {
 789              return key.name;
 790          }
 791  
 792      }
 793  
 794      private String geKeyType(Key key) {
 795          switch (key.type) {
 796              case Key.FAVORITE:
 797                  return &quot;favorite&quot;;
 798              case Key.SCREEN:
 799                  return &quot;screen&quot;;
 800              case Key.ICON:
 801                  return &quot;icon&quot;;
 802              case Key.WIDGET:
 803                  return &quot;widget&quot;;
 804              default:
 805                  return &quot;anonymous&quot;;
 806          }
 807      }
 808  
 809      /** Compute the checksum over the important bits of a key. */
 810      private long checkKey(Key key) {
 811          CRC32 checksum = new CRC32();
 812          checksum.update(key.type);
 813          checksum.update((int) (key.id &amp; 0xffff));
 814          checksum.update((int) ((key.id &gt;&gt; 32) &amp; 0xffff));
 815          if (!TextUtils.isEmpty(key.name)) {
 816              checksum.update(key.name.getBytes());
 817          }
 818          return checksum.getValue();
 819      }
 820  
 821      /** Serialize a Favorite for persistence, including a checksum wrapper. */
 822      private byte[] packFavorite(Cursor c) {
 823          Favorite favorite = new Favorite();
 824          favorite.id = c.getLong(ID_INDEX);
 825          favorite.screen = c.getInt(SCREEN_INDEX);
 826          favorite.container = c.getInt(CONTAINER_INDEX);
 827          favorite.cellX = c.getInt(CELLX_INDEX);
 828          favorite.cellY = c.getInt(CELLY_INDEX);
 829          favorite.spanX = c.getInt(SPANX_INDEX);
 830          favorite.spanY = c.getInt(SPANY_INDEX);
 831          favorite.iconType = c.getInt(ICON_TYPE_INDEX);
 832          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 833              String iconPackage = c.getString(ICON_PACKAGE_INDEX);
 834              if (!TextUtils.isEmpty(iconPackage)) {
 835                  favorite.iconPackage = iconPackage;
 836              }
 837              String iconResource = c.getString(ICON_RESOURCE_INDEX);
 838              if (!TextUtils.isEmpty(iconResource)) {
 839                  favorite.iconResource = iconResource;
 840              }
 841          }
 842          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 843              byte[] blob = c.getBlob(ICON_INDEX);
 844              if (blob != null &amp;&amp; blob.length &gt; 0) {
 845                  favorite.icon = blob;
 846              }
 847          }
 848          String title = c.getString(TITLE_INDEX);
 849          if (!TextUtils.isEmpty(title)) {
 850              favorite.title = title;
 851          }
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 852 -        String intent = c.getString(INTENT_INDEX);</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 853 -        if (!TextUtils.isEmpty(intent)) {</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 854 -            favorite.intent = intent;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 855 +        String intentDescription = c.getString(INTENT_INDEX);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 856 +        if (!TextUtils.isEmpty(intentDescription)) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 857 +            try {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 858 +                Intent intent = Intent.parseUri(intentDescription, 0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 859 +                intent.removeExtra(ItemInfo.EXTRA_PROFILE);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 860 +                favorite.intent = intent.toUri(0);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 861 +            } catch (URISyntaxException e) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 862 +                Log.e(TAG, &quot;Invalid intent&quot;, e);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 863 +           }</span>
 864          }
 865          favorite.itemType = c.getInt(ITEM_TYPE_INDEX);
 866          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 867              favorite.appWidgetId = c.getInt(APPWIDGET_ID_INDEX);
 868              String appWidgetProvider = c.getString(APPWIDGET_PROVIDER_INDEX);
 869              if (!TextUtils.isEmpty(appWidgetProvider)) {
 870                  favorite.appWidgetProvider = appWidgetProvider;
 871              }
 872          }
 873  
 874          return writeCheckedBytes(favorite);
 875      }
 876  
 877      /** Deserialize a Favorite from persistence, after verifying checksum wrapper. */
 878      private ContentValues unpackFavorite(byte[] buffer, int offset, int dataSize)
 879              throws InvalidProtocolBufferNanoException {
 880          Favorite favorite = new Favorite();
 881          MessageNano.mergeFrom(favorite, readCheckedBytes(buffer, offset, dataSize));
 882          if (VERBOSE) Log.v(TAG, &quot;unpacked favorite &quot; + favorite.itemType + &quot;, &quot; +
 883                  (TextUtils.isEmpty(favorite.title) ? favorite.id : favorite.title));
 884          ContentValues values = new ContentValues();
 885          values.put(Favorites._ID, favorite.id);
 886          values.put(Favorites.SCREEN, favorite.screen);
 887          values.put(Favorites.CONTAINER, favorite.container);
 888          values.put(Favorites.CELLX, favorite.cellX);
 889          values.put(Favorites.CELLY, favorite.cellY);
 890          values.put(Favorites.SPANX, favorite.spanX);
 891          values.put(Favorites.SPANY, favorite.spanY);
 892          values.put(Favorites.ICON_TYPE, favorite.iconType);
 893          if (favorite.iconType == Favorites.ICON_TYPE_RESOURCE) {
 894              values.put(Favorites.ICON_PACKAGE, favorite.iconPackage);
 895              values.put(Favorites.ICON_RESOURCE, favorite.iconResource);
 896          }
 897          if (favorite.iconType == Favorites.ICON_TYPE_BITMAP) {
 898              values.put(Favorites.ICON, favorite.icon);
 899          }
 900          if (!TextUtils.isEmpty(favorite.title)) {
 901              values.put(Favorites.TITLE, favorite.title);
 902          } else {
 903              values.put(Favorites.TITLE, &quot;&quot;);
 904          }
 905          if (!TextUtils.isEmpty(favorite.intent)) {
 906              values.put(Favorites.INTENT, favorite.intent);
 907          }
 908          values.put(Favorites.ITEM_TYPE, favorite.itemType);
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 909 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 910 +        UserHandleCompat myUserHandle = UserHandleCompat.myUserHandle();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 911 +        long userSerialNumber =</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 912 +                UserManagerCompat.getInstance(mContext).getSerialNumberForUser(myUserHandle);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 913 +        values.put(LauncherSettings.Favorites.PROFILE_ID, userSerialNumber);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 914 +</span>
 915          if (favorite.itemType == Favorites.ITEM_TYPE_APPWIDGET) {
 916              if (!TextUtils.isEmpty(favorite.appWidgetProvider)) {
 917                  values.put(Favorites.APPWIDGET_PROVIDER, favorite.appWidgetProvider);
 918              }
 919              values.put(Favorites.APPWIDGET_ID, favorite.appWidgetId);
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 920 -        }</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 921 -</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 922 -        // Let LauncherModel know we&#x27;ve been here.</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 923 -        values.put(LauncherSettings.Favorites.RESTORED, 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 924 +            values.put(LauncherSettings.Favorites.RESTORED,</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 925 +                    LauncherAppWidgetInfo.FLAG_ID_NOT_VALID |</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 926 +                    LauncherAppWidgetInfo.FLAG_PROVIDER_NOT_READY |</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 927 +                    LauncherAppWidgetInfo.FLAG_UI_NOT_READY);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 928 +        } else {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 929 +            // Let LauncherModel know we&#x27;ve been here.</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 930 +            values.put(LauncherSettings.Favorites.RESTORED, 1);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 931 +        }</span>
 932  
 933          return values;
 934      }
 935  
 936      /** Serialize a Screen for persistence, including a checksum wrapper. */
 937      private byte[] packScreen(Cursor c) {
 938          Screen screen = new Screen();
 939          screen.id = c.getLong(ID_INDEX);
 940          screen.rank = c.getInt(SCREEN_RANK_INDEX);
 941  
 942          return writeCheckedBytes(screen);
 943      }
 944  
 945      /** Deserialize a Screen from persistence, after verifying checksum wrapper. */
 946      private ContentValues unpackScreen(byte[] buffer, int offset, int dataSize)
 947              throws InvalidProtocolBufferNanoException {
 948          Screen screen = new Screen();
 949          MessageNano.mergeFrom(screen, readCheckedBytes(buffer, offset, dataSize));
 950          if (VERBOSE) Log.v(TAG, &quot;unpacked screen &quot; + screen.id + &quot;/&quot; + screen.rank);
 951          ContentValues values = new ContentValues();
 952          values.put(WorkspaceScreens._ID, screen.id);
 953          values.put(WorkspaceScreens.SCREEN_RANK, screen.rank);
 954          return values;
 955      }
 956  
 957      /** Serialize an icon Resource for persistence, including a checksum wrapper. */
 958      private byte[] packIcon(int dpi, Bitmap icon) {
 959          Resource res = new Resource();
 960          res.dpi = dpi;
 961          ByteArrayOutputStream os = new ByteArrayOutputStream();
 962          if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 963              res.data = os.toByteArray();
 964          }
 965          return writeCheckedBytes(res);
 966      }
 967  
 968      /** Deserialize an icon resource from persistence, after verifying checksum wrapper. */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 969 -    private Resource unpackIcon(byte[] buffer, int offset, int dataSize)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 970 +    private static Resource unpackIcon(byte[] buffer, int offset, int dataSize)</span>
 971              throws InvalidProtocolBufferNanoException {
 972          Resource res = new Resource();
 973          MessageNano.mergeFrom(res, readCheckedBytes(buffer, offset, dataSize));
 974          if (VERBOSE) Log.v(TAG, &quot;unpacked icon &quot; + res.dpi + &quot;/&quot; + res.data.length);
 975          return res;
 976      }
 977  
 978      /** Serialize a widget for persistence, including a checksum wrapper. */
 979      private byte[] packWidget(int dpi, WidgetPreviewLoader previewLoader, IconCache iconCache,
 980              ComponentName provider) {
 981          final AppWidgetProviderInfo info = findAppWidgetProviderInfo(provider);
 982          Widget widget = new Widget();
 983          widget.provider = provider.flattenToShortString();
 984          widget.label = info.label;
 985          widget.configure = info.configure != null;
 986          if (info.icon != 0) {
 987              widget.icon = new Resource();
 988              Drawable fullResIcon = iconCache.getFullResIcon(provider.getPackageName(), info.icon);
 989              Bitmap icon = Utilities.createIconBitmap(fullResIcon, mContext);
 990              ByteArrayOutputStream os = new ByteArrayOutputStream();
 991              if (icon.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
 992                  widget.icon.data = os.toByteArray();
 993                  widget.icon.dpi = dpi;
 994              }
 995          }
 996          if (info.previewImage != 0) {
 997              widget.preview = new Resource();
 998              Bitmap preview = previewLoader.generateWidgetPreview(info, null);
 999              ByteArrayOutputStream os = new ByteArrayOutputStream();
1000              if (preview.compress(IMAGE_FORMAT, IMAGE_COMPRESSION_QUALITY, os)) {
1001                  widget.preview.data = os.toByteArray();
1002                  widget.preview.dpi = dpi;
1003              }
1004          }
1005          return writeCheckedBytes(widget);
1006      }
1007  
1008      /** Deserialize a widget from persistence, after verifying checksum wrapper. */
1009      private Widget unpackWidget(byte[] buffer, int offset, int dataSize)
1010              throws InvalidProtocolBufferNanoException {
1011          Widget widget = new Widget();
1012          MessageNano.mergeFrom(widget, readCheckedBytes(buffer, offset, dataSize));
1013          if (VERBOSE) Log.v(TAG, &quot;unpacked widget &quot; + widget.provider);
1014          return widget;
1015      }
1016  
1017      /**
1018       * Read the old journal from the input file.
1019       *
1020       * In the event of any error, just pretend we didn&#x27;t have a journal,
1021       * in that case, do a full backup.
1022       *
1023       * @param oldState the read-0only file descriptor pointing to the old journal
1024       * @return a Journal protocol buffer
1025       */
1026      private Journal readJournal(ParcelFileDescriptor oldState) {
1027          Journal journal = new Journal();
1028          if (oldState == null) {
1029              return journal;
1030          }
1031          FileInputStream inStream = new FileInputStream(oldState.getFileDescriptor());
1032          try {
1033              int availableBytes = inStream.available();
1034              if (DEBUG) Log.d(TAG, &quot;available &quot; + availableBytes);
1035              if (availableBytes &lt; MAX_JOURNAL_SIZE) {
1036                  byte[] buffer = new byte[availableBytes];
1037                  int bytesRead = 0;
1038                  boolean valid = false;
1039                  InvalidProtocolBufferNanoException lastProtoException = null;
1040                  while (availableBytes &gt; 0) {
1041                      try {
1042                          // OMG what are you doing? This is crazy inefficient!
1043                          // If we read a byte that is not ours, we will cause trouble: b/12491813
1044                          // However, we don&#x27;t know how many bytes to expect (oops).
1045                          // So we have to step through *slowly*, watching for the end.
1046                          int result = inStream.read(buffer, bytesRead, 1);
1047                          if (result &gt; 0) {
1048                              availableBytes -= result;
1049                              bytesRead += result;
1050                              if (DEBUG &amp;&amp; (bytesRead % 100 == 0)) {
1051                                  Log.d(TAG, &quot;read some bytes: &quot; + bytesRead);
1052                              }
1053                          } else {
1054                              Log.w(TAG, &quot;unexpected end of file while reading journal.&quot;);
1055                              // stop reading and see what there is to parse
1056                              availableBytes = 0;
1057                          }
1058                      } catch (IOException e) {
1059                          buffer = null;
1060                          availableBytes = 0;
1061                      }
1062  
1063                      // check the buffer to see if we have a valid journal
1064                      try {
1065                          MessageNano.mergeFrom(journal, readCheckedBytes(buffer, 0, bytesRead));
1066                          // if we are here, then we have read a valid, checksum-verified journal
1067                          valid = true;
1068                          availableBytes = 0;
1069                          if (VERBOSE) Log.v(TAG, &quot;read &quot; + bytesRead + &quot; bytes of journal&quot;);
1070                      } catch (InvalidProtocolBufferNanoException e) {
1071                          // if we don&#x27;t have the whole journal yet, mergeFrom will throw. keep going.
1072                          lastProtoException = e;
1073                          journal.clear();
1074                      }
1075                  }
1076                  if (DEBUG) Log.d(TAG, &quot;journal bytes read: &quot; + bytesRead);
1077                  if (!valid) {
1078                      Log.w(TAG, &quot;could not find a valid journal&quot;, lastProtoException);
1079                  }
1080              }
1081          } catch (IOException e) {
1082              Log.w(TAG, &quot;failed to close the journal&quot;, e);
1083          } finally {
1084              try {
1085                  inStream.close();
1086              } catch (IOException e) {
1087                  Log.w(TAG, &quot;failed to close the journal&quot;, e);
1088              }
1089          }
1090          return journal;
1091      }
1092  
1093      private void writeRowToBackup(Key key, byte[] blob, Journal out,
1094              BackupDataOutput data) throws IOException {
1095          String backupKey = keyToBackupKey(key);
1096          data.writeEntityHeader(backupKey, blob.length);
1097          data.writeEntityData(blob, blob.length);
1098          out.rows++;
1099          out.bytes += blob.length;
1100          if (VERBOSE) Log.v(TAG, &quot;saving &quot; + geKeyType(key) + &quot; &quot; + backupKey + &quot;: &quot; +
1101                  getKeyName(key) + &quot;/&quot; + blob.length);
1102          if(DEBUG_PAYLOAD) {
1103              String encoded = Base64.encodeToString(blob, 0, blob.length, Base64.NO_WRAP);
1104              final int chunkSize = 1024;
1105              for (int offset = 0; offset &lt; encoded.length(); offset += chunkSize) {
1106                  int end = offset + chunkSize;
1107                  end = Math.min(end, encoded.length());
1108                  Log.w(TAG, &quot;wrote &quot; + encoded.substring(offset, end));
1109              }
1110          }
1111      }
1112  
1113      private Set&lt;String&gt; getSavedIdsByType(int type, Journal in) {
1114          Set&lt;String&gt; savedIds = new HashSet&lt;String&gt;();
1115          for(int i = 0; i &lt; in.key.length; i++) {
1116              Key key = in.key[i];
1117              if (key.type == type) {
1118                  savedIds.add(keyToBackupKey(key));
1119              }
1120          }
1121          return savedIds;
1122      }
1123  
1124      private int removeDeletedKeysFromBackup(Set&lt;String&gt; deletedIds, BackupDataOutput data)
1125              throws IOException {
1126          int rows = 0;
1127          for(String deleted: deletedIds) {
1128              if (VERBOSE) Log.v(TAG, &quot;dropping deleted item &quot; + deleted);
1129              data.writeEntityHeader(deleted, -1);
1130              rows++;
1131          }
1132          return rows;
1133      }
1134  
1135      /**
1136       * Write the new journal to the output file.
1137       *
1138       * In the event of any error, just pretend we didn&#x27;t have a journal,
1139       * in that case, do a full backup.
1140  
1141       * @param newState the write-only file descriptor pointing to the new journal
1142       * @param journal a Journal protocol buffer
1143       */
1144      private void writeJournal(ParcelFileDescriptor newState, Journal journal) {
1145          FileOutputStream outStream = null;
1146          try {
1147              outStream = new FileOutputStream(newState.getFileDescriptor());
1148              final byte[] journalBytes = writeCheckedBytes(journal);
1149              outStream.write(journalBytes);
1150              outStream.close();
1151              if (VERBOSE) Log.v(TAG, &quot;wrote &quot; + journalBytes.length + &quot; bytes of journal&quot;);
1152          } catch (IOException e) {
1153              Log.w(TAG, &quot;failed to write backup journal&quot;, e);
1154          }
1155      }
1156  
1157      /** Wrap a proto in a CheckedMessage and compute the checksum. */
1158      private byte[] writeCheckedBytes(MessageNano proto) {
1159          CheckedMessage wrapper = new CheckedMessage();
1160          wrapper.payload = MessageNano.toByteArray(proto);
1161          CRC32 checksum = new CRC32();
1162          checksum.update(wrapper.payload);
1163          wrapper.checksum = checksum.getValue();
1164          return MessageNano.toByteArray(wrapper);
1165      }
1166  
1167      /** Unwrap a proto message from a CheckedMessage, verifying the checksum. */
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">1168 -    private byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1169 +    private static byte[] readCheckedBytes(byte[] buffer, int offset, int dataSize)</span>
1170              throws InvalidProtocolBufferNanoException {
1171          CheckedMessage wrapper = new CheckedMessage();
1172          MessageNano.mergeFrom(wrapper, buffer, offset, dataSize);
1173          CRC32 checksum = new CRC32();
1174          checksum.update(wrapper.payload);
1175          if (wrapper.checksum != checksum.getValue()) {
1176              throw new InvalidProtocolBufferNanoException(&quot;checksum does not match&quot;);
1177          }
1178          return wrapper.payload;
1179      }
1180  
1181      private AppWidgetProviderInfo findAppWidgetProviderInfo(ComponentName component) {
1182          if (mWidgetMap == null) {
1183              List&lt;AppWidgetProviderInfo&gt; widgets =
1184                      AppWidgetManager.getInstance(mContext).getInstalledProviders();
1185              mWidgetMap = new HashMap&lt;ComponentName, AppWidgetProviderInfo&gt;(widgets.size());
1186              for (AppWidgetProviderInfo info : widgets) {
1187                  mWidgetMap.put(info.provider, info);
1188              }
1189          }
1190          return mWidgetMap.get(component);
1191      }
1192  
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1193 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1194 +    private boolean initializeIconCache() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1195 +        if (mIconCache != null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1196 +            return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1197 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1198 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1199 +        final LauncherAppState appState = LauncherAppState.getInstanceNoCreate();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1200 +        if (appState == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1201 +            Throwable stackTrace = new Throwable();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1202 +            stackTrace.fillInStackTrace();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1203 +            Log.w(TAG, &quot;Failed to get app state during backup/restore&quot;, stackTrace);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1204 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1205 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1206 +        mIconCache = appState.getIconCache();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1207 +        return mIconCache != null;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1208 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1209 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1210 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1211 +   // check if the launcher is in a state to support backup</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1212 +    private boolean launcherIsReady() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1213 +        ContentResolver cr = mContext.getContentResolver();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1214 +        Cursor cursor = cr.query(Favorites.CONTENT_URI, FAVORITE_PROJECTION, null, null, null);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1215 +        if (cursor == null) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1216 +            // launcher data has been wiped, do nothing</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1217 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1218 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1219 +        cursor.close();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1220 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1221 +        if (!initializeIconCache()) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1222 +            // launcher services are unavailable, try again later</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1223 +            dataChanged();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1224 +            return false;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1225 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1226 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1227 +        return true;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1228 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1229 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1230 +    private String getUserSelectionArg() {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1231 +        return Favorites.PROFILE_ID + &#x27;=&#x27; + UserManagerCompat.getInstance(mContext)</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1232 +                .getSerialNumberForUser(UserHandleCompat.myUserHandle());</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1233 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">1234 +</span>
1235      private class KeyParsingException extends Throwable {
1236          private KeyParsingException(Throwable cause) {
1237              super(cause);
1238          }
1239  
1240          public KeyParsingException(String reason) {
1241              super(reason);
1242          }
1243      }
1244  }</pre></td>
                            <td><pre></pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            