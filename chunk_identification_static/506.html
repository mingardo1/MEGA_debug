<!DOCTYPE html>
    <html lang="en">
              <head>
                <meta charset="utf-8">
                <title>506</title>
                    <style>
                        #top {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        #bottom {
                            height: 48vh;
                            overflow-y: auto;
                        }
                        abbr {
                          /* Here is the delay */
                          transition-delay:0s;
                        }
                    </style>
              </head>
              <body>
                <span style="height: 4vh">
                    506
                    <a href="505.html">prev</a>
                    <a href="507.html">next</a>
                    <a href="506_chunks.html">chunks</a>
                    <a href="index.html">index</a>
                    DTStack/flinkStreamSQL_07c4ccdd6f1f5fed2b5b800377edca583bc33bbe_core/src/main/java/com/dtstack/flink/sql/util/ParseUtils.java
                    <textarea rows=1 onclick='navigator.clipboard.writeText(this.value)'>cd C:\studies\se\mega\git-analyzer-plus\notebooks\debug
del /Q *
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;07c4ccdd6f1f5fed2b5b800377edca583bc33bbe:core/src/main/java/com/dtstack/flink/sql/util/ParseUtils.java&quot; &gt; committed.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;07c4ccdd6f1f5fed2b5b800377edca583bc33bbe^1:core/src/main/java/com/dtstack/flink/sql/util/ParseUtils.java&quot; &gt; ours.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;07c4ccdd6f1f5fed2b5b800377edca583bc33bbe^2:core/src/main/java/com/dtstack/flink/sql/util/ParseUtils.java&quot; &gt; theirs.java
git -C C:\studies\se\mega\project-dirs\projects_Java_desc-stars-1000\DTStack\flinkStreamSQL show &quot;e1736f333f6ce46e1045ac877bcaa38cbc20c6cc:core/src/main/java/com/dtstack/flink/sql/util/ParseUtils.java&quot; &gt; base.java
copy ours.java 1ours.java
copy ours.java 2ours.java
copy theirs.java 1theirs.java
copy theirs.java 2theirs.java
copy base.java 1base.java
copy base.java 2base.java
&quot;C:\Program Files\Java\jdk1.8.0_241\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\jFSTMerge\build\libs\jFSTMerge-all.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\1theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\jfstmerge.java --show-base
&quot;C:\Program Files\Eclipse Adoptium\jdk-17.0.11.9-hotspot\bin\java.exe&quot; -Dfile.encoding=UTF-8 -jar &quot;C:\studies\se\spork\target\spork-0.5.0-SNAPSHOT.jar&quot; C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2ours.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2base.java C:\studies\se\mega\git-analyzer-plus\notebooks\debug\2theirs.java -o C:\studies\se\mega\git-analyzer-plus\notebooks\debug\spork.java
del /Q 1*.java
del /Q 2*.java
del /Q jfstmerge.java.merge
</textarea>
                    {strict: [[b], [b]], subset: [[b], [b]]}
                </span>
                <div id="top">

                    <table>
                        <tr>
                            <th>line based (standard git)</th>
                            <th>jfstmerge</th>
                            <th>spork</th>
                        </tr>
                        <tr>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 /*
  20  * Licensed to the Apache Software Foundation (ASF) under one
  21  * or more contributor license agreements.  See the NOTICE file
  22  * distributed with this work for additional information
  23  * regarding copyright ownership.  The ASF licenses this file
  24  * to you under the Apache License, Version 2.0 (the
  25  * &quot;License&quot;); you may not use this file except in compliance
  26  * with the License.  You may obtain a copy of the License at
  27  *
  28  *     http://www.apache.org/licenses/LICENSE-2.0
  29  *
  30  * Unless required by applicable law or agreed to in writing, software
  31  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  32  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  33  * See the License for the specific language governing permissions and
  34  * limitations under the License.
  35  */
  36 
  37 package com.dtstack.flink.sql.util;
  38 
  39 import com.google.common.collect.HashBasedTable;
  40 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  41 import com.google.common.collect.HashBiMap;</span>
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  42 import org.apache.calcite.sql.*;</span>
  43 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  44 import org.apache.calcite.sql.*;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  45 import org.apache.commons.lang3.StringUtils;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  46 import org.apache.flink.api.java.tuple.Tuple2;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  47 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  48 import java.util.Arrays;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  49 import java.util.List;</span>
  50 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  51 </span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  52 import org.apache.calcite.sql.SqlBasicCall;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  53 import org.apache.calcite.sql.SqlIdentifier;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  54 import org.apache.calcite.sql.SqlJoin;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  55 import org.apache.calcite.sql.SqlKind;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  56 import org.apache.calcite.sql.SqlNode;</span>
  57 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  58 import org.apache.commons.lang3.StringUtils;
  59 import org.apache.flink.api.java.tuple.Tuple2;
  60 
  61 &lt;&lt;&lt;&lt;&lt;&lt;&lt; GitAnalyzerPlus_ours
<span style="background-color: rgba(255, 167, 0, 0.24); margin: 0">  62 import java.util.*;</span>
  63 ||||||| GitAnalyzerPlus_base
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  64 import java.util.List;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  65 import java.util.Map;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  66 import java.util.Set;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  67 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  68 import static org.apache.calcite.sql.SqlKind.*;</span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  69 </span>
<span style="background-color: rgba(0, 0, 0, 0.15); margin: 0">  70 /**</span>
  71 =======
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  72 import java.util.Arrays;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  73 import java.util.List;</span>
<span style="background-color: rgba(0, 0, 255, 0.24); margin: 0">  74 import java.util.Set;</span>
  75 &gt;&gt;&gt;&gt;&gt;&gt;&gt; GitAnalyzerPlus_theirs
  76 
  77 import static org.apache.calcite.sql.SqlKind.AS;
  78 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  79 import static org.apache.calcite.sql.SqlKind.JOIN;
  80 
  81 
  82 /**
  83  * @Auther: jiangjunjie
  84  * @Date: 2019-06-30 14:57
  85  * @Description:
  86  */
  87 public class ParseUtils {
  88     public static void parseAnd(SqlNode conditionNode, List&lt;SqlNode&gt; sqlNodeList) {
<abbr title="  89         if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().size() == 2) {">  89         if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().sizðŸ”µ</abbr>
  90             parseAnd(((SqlBasicCall) conditionNode).getOperands()[0], sqlNodeList);
  91             sqlNodeList.add(((SqlBasicCall) conditionNode).getOperands()[1]);
  92         } else {
  93             sqlNodeList.add(conditionNode);
  94         }
  95     }
  96 
  97     public static void parseJoinCompareOperate(SqlNode condition, List&lt;String&gt; sqlJoinCompareOperate) {
  98         SqlBasicCall joinCondition = (SqlBasicCall) condition;
  99         if (joinCondition.getKind() == SqlKind.AND) {
 100             List&lt;SqlNode&gt; operandList = joinCondition.getOperandList();
 101             for (SqlNode sqlNode : operandList) {
 102                 parseJoinCompareOperate(sqlNode, sqlJoinCompareOperate);
 103             }
 104         } else {
 105             String operator = transformNotEqualsOperator(joinCondition.getKind());
 106             sqlJoinCompareOperate.add(operator);
 107         }
 108     }
 109 
 110     public static String transformNotEqualsOperator(SqlKind sqlKind) {
 111         if (StringUtils.equalsIgnoreCase(sqlKind.toString(), &quot;NOT_EQUALS&quot;)) {
 112             return &quot;!=&quot;;
 113         }
 114         return sqlKind.sql;
 115     }
 116 
 117     /**
 118      *  parse multi join table name, child query RealTabName is null
 119      * @param leftJoin
 120      * @param aliasAndRealTabName
 121      */
<abbr title=" 122     public static void parseLeftNodeTableName(SqlNode leftJoin, List&lt;Tuple2&lt;String, String&gt;&gt; aliasAndRealTabName, Set&lt;String&gt; sideTableSet) {"> 122     public static void parseLeftNodeTableName(SqlNode leftJoin, List&lt;Tuple2&lt;String, String&gt;&gt; aliasAndRealðŸ”µ</abbr>
 123         if (leftJoin.getKind() == IDENTIFIER) {
 124             SqlIdentifier sqlIdentifier = (SqlIdentifier) leftJoin;
 125             if (sqlIdentifier.names.size() == 1 &amp;&amp; !sideTableSet.contains(sqlIdentifier.names.get(0))) {
<abbr title=" 126                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(sqlIdentifier.names.get(0), sqlIdentifier.names.get(0)));"> 126                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(sqlIdentifier.names.get(0), sqlIdentifier.names.get(ðŸ”µ</abbr>
 127             }
 128         } else if (leftJoin.getKind() == AS) {
 129             SqlNode sqlNode = ((SqlBasicCall) leftJoin).getOperands()[0];
 130             if (sideTableSet.contains(sqlNode.toString())) {
 131                 return;
 132             }
 133             if (sqlNode.getKind() == IDENTIFIER) {
<abbr title=" 134                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(), sqlNode.toString()));"> 134                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(ðŸ”µ</abbr>
 135             } else {
 136                 // child query
<abbr title=" 137                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(), null));"> 137                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(ðŸ”µ</abbr>
 138             }
 139         } else if (leftJoin.getKind() == JOIN) {
 140             parseLeftNodeTableName(((SqlJoin) leftJoin).getLeft(), aliasAndRealTabName, sideTableSet);
 141             parseLeftNodeTableName(((SqlJoin) leftJoin).getRight(), aliasAndRealTabName, sideTableSet);
 142         }
 143     }
 144 
<abbr title=" 145     public static SqlNode replaceJoinConditionTabName(SqlNode conditionNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tabAlias) {"> 145     public static SqlNode replaceJoinConditionTabName(SqlNode conditionNode, HashBasedTable&lt;String, StrinðŸ”µ</abbr>
<abbr title=" 146         if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().size() == 2) {"> 146         if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().sizðŸ”µ</abbr>
 147             SqlNode[] operands = ((SqlBasicCall) conditionNode).getOperands();
<abbr title=" 148             Arrays.stream(operands).forEach(op -&gt; replaceJoinConditionTabName(op, mappingTable, tabAlias));"> 148             Arrays.stream(operands).forEach(op -&gt; replaceJoinConditionTabName(op, mappingTable, tabAlias)ðŸ”µ</abbr>
 149         } else {
 150             SqlNode[] operands = ((SqlBasicCall) conditionNode).getOperands();
 151             for (int i = 0; i &lt; operands.length; i++) {
 152                 SqlNode sqlNode = operands[i];
 153                 SqlNode replaceNode = replaceNodeInfo(sqlNode, mappingTable, tabAlias);
 154                 operands[i] = replaceNode;
 155             }
 156         }
 157         return conditionNode;
 158     }
 159 
<abbr title=" 160     public static SqlNode replaceNodeInfo(SqlNode parseNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tabAlias) {"> 160     public static SqlNode replaceNodeInfo(SqlNode parseNode, HashBasedTable&lt;String, String, String&gt; mappiðŸ”µ</abbr>
 161         if (parseNode.getKind() == IDENTIFIER) {
 162             SqlIdentifier sqlIdentifier = (SqlIdentifier) parseNode;
 163 
 164 
 165             return sqlIdentifier;
 166         }
 167         return parseNode;
 168     }
 169 
<abbr title=" 170     public static void fillFieldNameMapping(HashBasedTable&lt;String, String, String&gt; midTableMapping, String[] fieldNames, String tableAlias) {"> 170     public static void fillFieldNameMapping(HashBasedTable&lt;String, String, String&gt; midTableMapping, StrinðŸ”µ</abbr>
 171         Arrays.asList(fieldNames).forEach(fieldName -&gt; {
 172             String mappingTableName = dealDuplicateFieldName(midTableMapping, fieldName);
 173             midTableMapping.put(tableAlias, fieldName, mappingTableName);
 174         });
 175     }
 176 
<abbr title=" 177     public static String dealDuplicateFieldName(HashBasedTable&lt;String, String, String&gt; mappingTable, String fieldName) {"> 177     public static String dealDuplicateFieldName(HashBasedTable&lt;String, String, String&gt; mappingTable, StriðŸ”µ</abbr>
 178         String mappingFieldName = fieldName;
 179         int index = 1;
 180         while (!mappingTable.column(mappingFieldName).isEmpty()) {
 181             mappingFieldName = suffixWithChar(fieldName, &#x27;0&#x27;, index);
 182             index++;
 183         }
 184         return mappingFieldName;
 185     }
 186 
<abbr title=" 187     public static String dealDuplicateFieldName(HashBiMap&lt;String, String&gt; refFieldMap, String fieldName) {"> 187     public static String dealDuplicateFieldName(HashBiMap&lt;String, String&gt; refFieldMap, String fieldName) ðŸ”µ</abbr>
 188         String mappingFieldName = fieldName;
 189         int index = 1;
 190         while (refFieldMap.inverse().get(mappingFieldName) != null ) {
 191             mappingFieldName = suffixWithChar(fieldName, &#x27;0&#x27;, index);
 192             index++;
 193         }
 194 
 195         return mappingFieldName;
 196     }
 197 
 198     public static String dealDuplicateFieldName(Map&lt;String, String&gt; refFieldMap, String fieldName) {
 199         String mappingFieldName = fieldName;
 200         int index = 1;
 201         while (refFieldMap.containsKey(mappingFieldName)){
 202             mappingFieldName = suffixWithChar(fieldName, &#x27;0&#x27;, index);
 203             index++;
 204         }
 205 
 206         return mappingFieldName;
 207     }
 208 
 209     public static String suffixWithChar(String str, char padChar, int repeat){
 210         StringBuilder stringBuilder = new StringBuilder(str);
 211         for(int i=0; i&lt;repeat; i++){
 212             stringBuilder.append(padChar);
 213         }
 214 
 215         return stringBuilder.toString();
 216     }
 217 }</pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 
  19 /*
  20  * Licensed to the Apache Software Foundation (ASF) under one
  21  * or more contributor license agreements.  See the NOTICE file
  22  * distributed with this work for additional information
  23  * regarding copyright ownership.  The ASF licenses this file
  24  * to you under the Apache License, Version 2.0 (the
  25  * &quot;License&quot;); you may not use this file except in compliance
  26  * with the License.  You may obtain a copy of the License at
  27  *
  28  *     http://www.apache.org/licenses/LICENSE-2.0
  29  *
  30  * Unless required by applicable law or agreed to in writing, software
  31  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  32  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  33  * See the License for the specific language governing permissions and
  34  * limitations under the License.
  35  */
  36 
  37 package com.dtstack.flink.sql.util;
  38 
  39 import com.google.common.collect.HashBasedTable;
  40 import com.google.common.collect.HashBiMap;
  41 
  42 import org.apache.calcite.sql.SqlBasicCall;
  43 import org.apache.calcite.sql.SqlIdentifier;
  44 import org.apache.calcite.sql.SqlJoin;
  45 import org.apache.calcite.sql.SqlKind;
  46 import org.apache.calcite.sql.SqlNode;
  47 import org.apache.commons.lang3.StringUtils;
  48 import org.apache.flink.api.java.tuple.Tuple2;
  49 
  50 import java.util.*;
  51 
  52 import static org.apache.calcite.sql.SqlKind.AS;
  53 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  54 import static org.apache.calcite.sql.SqlKind.JOIN;
  55 
  56 
  57 /**
  58  * @Auther: jiangjunjie
  59  * @Date: 2019-06-30 14:57
  60  * @Description:
  61  */
  62 public class ParseUtils {
  63     public static void parseAnd(SqlNode conditionNode, List&lt;SqlNode&gt; sqlNodeList) {
<abbr title="  64         if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().size() == 2) {">  64         if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().sizðŸ”µ</abbr>
  65             parseAnd(((SqlBasicCall) conditionNode).getOperands()[0], sqlNodeList);
  66             sqlNodeList.add(((SqlBasicCall) conditionNode).getOperands()[1]);
  67         } else {
  68             sqlNodeList.add(conditionNode);
  69         }
  70     }
  71 
  72     public static void parseJoinCompareOperate(SqlNode condition, List&lt;String&gt; sqlJoinCompareOperate) {
  73         SqlBasicCall joinCondition = (SqlBasicCall) condition;
  74         if (joinCondition.getKind() == SqlKind.AND) {
  75             List&lt;SqlNode&gt; operandList = joinCondition.getOperandList();
  76             for (SqlNode sqlNode : operandList) {
  77                 parseJoinCompareOperate(sqlNode, sqlJoinCompareOperate);
  78             }
  79         } else {
  80             String operator = transformNotEqualsOperator(joinCondition.getKind());
  81             sqlJoinCompareOperate.add(operator);
  82         }
  83     }
  84 
  85     public static String transformNotEqualsOperator(SqlKind sqlKind) {
  86         if (StringUtils.equalsIgnoreCase(sqlKind.toString(), &quot;NOT_EQUALS&quot;)) {
  87             return &quot;!=&quot;;
  88         }
  89         return sqlKind.sql;
  90     }
  91 
  92     /**
  93      *  parse multi join table name, child query RealTabName is null
  94      * @param leftJoin
  95      * @param aliasAndRealTabName
  96      */
<abbr title="  97     public static void parseLeftNodeTableName(SqlNode leftJoin, List&lt;Tuple2&lt;String, String&gt;&gt; aliasAndRealTabName, Set&lt;String&gt; sideTableSet) {">  97     public static void parseLeftNodeTableName(SqlNode leftJoin, List&lt;Tuple2&lt;String, String&gt;&gt; aliasAndRealðŸ”µ</abbr>
  98         if (leftJoin.getKind() == IDENTIFIER) {
  99             SqlIdentifier sqlIdentifier = (SqlIdentifier) leftJoin;
 100             if (sqlIdentifier.names.size() == 1 &amp;&amp; !sideTableSet.contains(sqlIdentifier.names.get(0))) {
<abbr title=" 101                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(sqlIdentifier.names.get(0), sqlIdentifier.names.get(0)));"> 101                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(sqlIdentifier.names.get(0), sqlIdentifier.names.get(ðŸ”µ</abbr>
 102             }
 103         } else if (leftJoin.getKind() == AS) {
 104             SqlNode sqlNode = ((SqlBasicCall) leftJoin).getOperands()[0];
 105             if (sideTableSet.contains(sqlNode.toString())) {
 106                 return;
 107             }
 108             if (sqlNode.getKind() == IDENTIFIER) {
<abbr title=" 109                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(), sqlNode.toString()));"> 109                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(ðŸ”µ</abbr>
 110             } else {
 111                 // child query
<abbr title=" 112                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(), null));"> 112                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(ðŸ”µ</abbr>
 113             }
 114         } else if (leftJoin.getKind() == JOIN) {
 115             parseLeftNodeTableName(((SqlJoin) leftJoin).getLeft(), aliasAndRealTabName, sideTableSet);
 116             parseLeftNodeTableName(((SqlJoin) leftJoin).getRight(), aliasAndRealTabName, sideTableSet);
 117         }
 118     }
 119 
<abbr title=" 120     public static SqlNode replaceJoinConditionTabName(SqlNode conditionNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tabAlias) {"> 120     public static SqlNode replaceJoinConditionTabName(SqlNode conditionNode, HashBasedTable&lt;String, StrinðŸ”µ</abbr>
<abbr title=" 121         if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().size() == 2) {"> 121         if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().sizðŸ”µ</abbr>
 122             SqlNode[] operands = ((SqlBasicCall) conditionNode).getOperands();
<abbr title=" 123             Arrays.stream(operands).forEach(op -&gt; replaceJoinConditionTabName(op, mappingTable, tabAlias));"> 123             Arrays.stream(operands).forEach(op -&gt; replaceJoinConditionTabName(op, mappingTable, tabAlias)ðŸ”µ</abbr>
 124         } else {
 125             SqlNode[] operands = ((SqlBasicCall) conditionNode).getOperands();
 126             for (int i = 0; i &lt; operands.length; i++) {
 127                 SqlNode sqlNode = operands[i];
 128                 SqlNode replaceNode = replaceNodeInfo(sqlNode, mappingTable, tabAlias);
 129                 operands[i] = replaceNode;
 130             }
 131         }
 132         return conditionNode;
 133     }
 134 
<abbr title=" 135     public static SqlNode replaceNodeInfo(SqlNode parseNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tabAlias) {"> 135     public static SqlNode replaceNodeInfo(SqlNode parseNode, HashBasedTable&lt;String, String, String&gt; mappiðŸ”µ</abbr>
 136         if (parseNode.getKind() == IDENTIFIER) {
 137             SqlIdentifier sqlIdentifier = (SqlIdentifier) parseNode;
 138 
 139 
 140             return sqlIdentifier;
 141         }
 142         return parseNode;
 143     }
 144 
<abbr title=" 145     public static void fillFieldNameMapping(HashBasedTable&lt;String, String, String&gt; midTableMapping, String[] fieldNames, String tableAlias) {"> 145     public static void fillFieldNameMapping(HashBasedTable&lt;String, String, String&gt; midTableMapping, StrinðŸ”µ</abbr>
 146         Arrays.asList(fieldNames).forEach(fieldName -&gt; {
 147             String mappingTableName = dealDuplicateFieldName(midTableMapping, fieldName);
 148             midTableMapping.put(tableAlias, fieldName, mappingTableName);
 149         });
 150     }
 151 
<abbr title=" 152     public static String dealDuplicateFieldName(HashBasedTable&lt;String, String, String&gt; mappingTable, String fieldName) {"> 152     public static String dealDuplicateFieldName(HashBasedTable&lt;String, String, String&gt; mappingTable, StriðŸ”µ</abbr>
 153         String mappingFieldName = fieldName;
 154         int index = 1;
 155         while (!mappingTable.column(mappingFieldName).isEmpty()) {
 156             mappingFieldName = suffixWithChar(fieldName, &#x27;0&#x27;, index);
 157             index++;
 158         }
 159         return mappingFieldName;
 160     }
 161 
<abbr title=" 162     public static String dealDuplicateFieldName(HashBiMap&lt;String, String&gt; refFieldMap, String fieldName) {"> 162     public static String dealDuplicateFieldName(HashBiMap&lt;String, String&gt; refFieldMap, String fieldName) ðŸ”µ</abbr>
 163         String mappingFieldName = fieldName;
 164         int index = 1;
 165         while (refFieldMap.inverse().get(mappingFieldName) != null ) {
 166             mappingFieldName = suffixWithChar(fieldName, &#x27;0&#x27;, index);
 167             index++;
 168         }
 169 
 170         return mappingFieldName;
 171     }
 172 
 173     public static String dealDuplicateFieldName(Map&lt;String, String&gt; refFieldMap, String fieldName) {
 174         String mappingFieldName = fieldName;
 175         int index = 1;
 176         while (refFieldMap.containsKey(mappingFieldName)){
 177             mappingFieldName = suffixWithChar(fieldName, &#x27;0&#x27;, index);
 178             index++;
 179         }
 180 
 181         return mappingFieldName;
 182     }
 183 
 184     public static String suffixWithChar(String str, char padChar, int repeat){
 185         StringBuilder stringBuilder = new StringBuilder(str);
 186         for(int i=0; i&lt;repeat; i++){
 187             stringBuilder.append(padChar);
 188         }
 189 
 190         return stringBuilder.toString();
 191     }
 192 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                            <td><pre>   1 /*
   2  * Licensed to the Apache Software Foundation (ASF) under one
   3  * or more contributor license agreements.  See the NOTICE file
   4  * distributed with this work for additional information
   5  * regarding copyright ownership.  The ASF licenses this file
   6  * to you under the Apache License, Version 2.0 (the
   7  * &quot;License&quot;); you may not use this file except in compliance
   8  * with the License.  You may obtain a copy of the License at
   9  *
  10  *     http://www.apache.org/licenses/LICENSE-2.0
  11  *
  12  * Unless required by applicable law or agreed to in writing, software
  13  * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15  * See the License for the specific language governing permissions and
  16  * limitations under the License.
  17  */
  18 package com.dtstack.flink.sql.util;
  19 
  20 import com.google.common.collect.HashBasedTable;
  21 import com.google.common.collect.HashBiMap;
  22 import java.util.*;
  23 import org.apache.calcite.sql.SqlBasicCall;
  24 import org.apache.calcite.sql.SqlIdentifier;
  25 import org.apache.calcite.sql.SqlJoin;
  26 import org.apache.calcite.sql.SqlKind;
  27 import org.apache.calcite.sql.SqlNode;
  28 import org.apache.commons.lang3.StringUtils;
  29 import org.apache.flink.api.java.tuple.Tuple2;
  30 import static org.apache.calcite.sql.SqlKind.AS;
  31 import static org.apache.calcite.sql.SqlKind.IDENTIFIER;
  32 import static org.apache.calcite.sql.SqlKind.JOIN;
  33 
  34 
  35 /**
  36  * @Auther: jiangjunjie
  37  * @Date: 2019-06-30 14:57
  38  * @Description:
  39  */
  40 public class ParseUtils {
  41     public static void parseAnd(SqlNode conditionNode, List&lt;SqlNode&gt; sqlNodeList) {
<abbr title="  42         if ((conditionNode.getKind() == SqlKind.AND) &amp;&amp; (((SqlBasicCall) (conditionNode)).getOperandList().size() == 2)) {">  42         if ((conditionNode.getKind() == SqlKind.AND) &amp;&amp; (((SqlBasicCall) (conditionNode)).getOperandList(ðŸ”µ</abbr>
  43             parseAnd(((SqlBasicCall) (conditionNode)).getOperands()[0], sqlNodeList);
  44             sqlNodeList.add(((SqlBasicCall) (conditionNode)).getOperands()[1]);
  45         } else {
  46             sqlNodeList.add(conditionNode);
  47         }
  48     }
  49 
  50     public static void parseJoinCompareOperate(SqlNode condition, List&lt;String&gt; sqlJoinCompareOperate) {
  51         SqlBasicCall joinCondition = ((SqlBasicCall) (condition));
  52         if (joinCondition.getKind() == SqlKind.AND) {
  53             List&lt;SqlNode&gt; operandList = joinCondition.getOperandList();
  54             for (SqlNode sqlNode : operandList) {
  55                 parseJoinCompareOperate(sqlNode, sqlJoinCompareOperate);
  56             }
  57         } else {
  58             String operator = transformNotEqualsOperator(joinCondition.getKind());
  59             sqlJoinCompareOperate.add(operator);
  60         }
  61     }
  62 
  63     public static String transformNotEqualsOperator(SqlKind sqlKind) {
  64         if (StringUtils.equalsIgnoreCase(sqlKind.toString(), &quot;NOT_EQUALS&quot;)) {
  65             return &quot;!=&quot;;
  66         }
  67         return sqlKind.sql;
  68     }
  69 
  70     /**
  71      *  parse multi join table name, child query RealTabName is null
  72      * @param leftJoin
  73      * @param aliasAndRealTabName
  74      */
<abbr title="  75     public static void parseLeftNodeTableName(SqlNode leftJoin, List&lt;Tuple2&lt;String, String&gt;&gt; aliasAndRealTabName, Set&lt;String&gt; sideTableSet) {">  75     public static void parseLeftNodeTableName(SqlNode leftJoin, List&lt;Tuple2&lt;String, String&gt;&gt; aliasAndRealðŸ”µ</abbr>
  76         if (leftJoin.getKind() == IDENTIFIER) {
  77             SqlIdentifier sqlIdentifier = ((SqlIdentifier) (leftJoin));
<abbr title="  78             if ((sqlIdentifier.names.size() == 1) &amp;&amp; (!sideTableSet.contains(sqlIdentifier.names.get(0)))) {">  78             if ((sqlIdentifier.names.size() == 1) &amp;&amp; (!sideTableSet.contains(sqlIdentifier.names.get(0)))ðŸ”µ</abbr>
<abbr title="  79                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(sqlIdentifier.names.get(0), sqlIdentifier.names.get(0)));">  79                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(sqlIdentifier.names.get(0), sqlIdentifier.names.get(ðŸ”µ</abbr>
  80             }
  81         } else if (leftJoin.getKind() == AS) {
  82             SqlNode sqlNode = ((SqlBasicCall) (leftJoin)).getOperands()[0];
  83             if (sideTableSet.contains(sqlNode.toString())) {
  84                 return;
  85             }
  86             if (sqlNode.getKind() == IDENTIFIER) {
<abbr title="  87                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) (leftJoin)).getOperands()[1].toString(), sqlNode.toString()));">  87                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) (leftJoin)).getOperands()[1].toStrinðŸ”µ</abbr>
  88             } else {
  89                 // child query
<abbr title="  90                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) (leftJoin)).getOperands()[1].toString(), null));">  90                 aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) (leftJoin)).getOperands()[1].toStrinðŸ”µ</abbr>
  91             }
  92         } else if (leftJoin.getKind() == JOIN) {
  93             parseLeftNodeTableName(((SqlJoin) (leftJoin)).getLeft(), aliasAndRealTabName, sideTableSet);
  94             parseLeftNodeTableName(((SqlJoin) (leftJoin)).getRight(), aliasAndRealTabName, sideTableSet);
  95         }
  96     }
  97 
<abbr title="  98     public static SqlNode replaceJoinConditionTabName(SqlNode conditionNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tabAlias) {">  98     public static SqlNode replaceJoinConditionTabName(SqlNode conditionNode, HashBasedTable&lt;String, StrinðŸ”µ</abbr>
<abbr title="  99         if ((conditionNode.getKind() == SqlKind.AND) &amp;&amp; (((SqlBasicCall) (conditionNode)).getOperandList().size() == 2)) {">  99         if ((conditionNode.getKind() == SqlKind.AND) &amp;&amp; (((SqlBasicCall) (conditionNode)).getOperandList(ðŸ”µ</abbr>
 100             SqlNode[] operands = ((SqlBasicCall) (conditionNode)).getOperands();
<abbr title=" 101             Arrays.stream(operands).forEach(( op) -&gt; replaceJoinConditionTabName(op, mappingTable, tabAlias));"> 101             Arrays.stream(operands).forEach(( op) -&gt; replaceJoinConditionTabName(op, mappingTable, tabAliðŸ”µ</abbr>
 102         } else {
 103             SqlNode[] operands = ((SqlBasicCall) (conditionNode)).getOperands();
 104             for (int i = 0; i &lt; operands.length; i++) {
 105                 SqlNode sqlNode = operands[i];
 106                 SqlNode replaceNode = replaceNodeInfo(sqlNode, mappingTable, tabAlias);
 107                 operands[i] = replaceNode;
 108             }
 109         }
 110         return conditionNode;
 111     }
 112 
<abbr title=" 113     public static SqlNode replaceNodeInfo(SqlNode parseNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tabAlias) {"> 113     public static SqlNode replaceNodeInfo(SqlNode parseNode, HashBasedTable&lt;String, String, String&gt; mappiðŸ”µ</abbr>
 114         if (parseNode.getKind() == IDENTIFIER) {
 115             SqlIdentifier sqlIdentifier = ((SqlIdentifier) (parseNode));
 116             return sqlIdentifier;
 117         }
 118         return parseNode;
 119     }
 120 
<abbr title=" 121     public static void fillFieldNameMapping(HashBasedTable&lt;String, String, String&gt; midTableMapping, String[] fieldNames, String tableAlias) {"> 121     public static void fillFieldNameMapping(HashBasedTable&lt;String, String, String&gt; midTableMapping, StrinðŸ”µ</abbr>
 122         Arrays.asList(fieldNames).forEach(fieldName -&gt; {
 123             String mappingTableName = dealDuplicateFieldName(midTableMapping, fieldName);
 124             midTableMapping.put(tableAlias, fieldName, mappingTableName);
 125         });
 126     }
 127 
<abbr title=" 128     public static String dealDuplicateFieldName(HashBasedTable&lt;String, String, String&gt; mappingTable, String fieldName) {"> 128     public static String dealDuplicateFieldName(HashBasedTable&lt;String, String, String&gt; mappingTable, StriðŸ”µ</abbr>
 129         String mappingFieldName = fieldName;
 130         int index = 1;
 131         while (!mappingTable.column(mappingFieldName).isEmpty()) {
 132             mappingFieldName = suffixWithChar(fieldName, &#x27;0&#x27;, index);
 133             index++;
 134         }
 135         return mappingFieldName;
 136     }
 137 
<abbr title=" 138     public static String dealDuplicateFieldName(HashBiMap&lt;String, String&gt; refFieldMap, String fieldName) {"> 138     public static String dealDuplicateFieldName(HashBiMap&lt;String, String&gt; refFieldMap, String fieldName) ðŸ”µ</abbr>
 139         String mappingFieldName = fieldName;
 140         int index = 1;
 141         while (refFieldMap.inverse().get(mappingFieldName) != null ) {
 142             mappingFieldName = suffixWithChar(fieldName, &#x27;0&#x27;, index);
 143             index++;
 144         }
 145 
 146         return mappingFieldName;
 147     }
 148 
 149     public static String dealDuplicateFieldName(Map&lt;String, String&gt; refFieldMap, String fieldName) {
 150         String mappingFieldName = fieldName;
 151         int index = 1;
 152         while (refFieldMap.containsKey(mappingFieldName)){
 153             mappingFieldName = suffixWithChar(fieldName, &#x27;0&#x27;, index);
 154             index++;
 155         }
 156 
 157         return mappingFieldName;
 158     }
 159 
 160     public static String suffixWithChar(String str, char padChar, int repeat){
 161         StringBuilder stringBuilder = new StringBuilder(str);
 162         for(int i=0; i&lt;repeat; i++){
 163             stringBuilder.append(padChar);
 164         }
 165 
 166         return stringBuilder.toString();
 167     }
 168 }
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 </pre></td>
                        </tr>
                    </table>
                </div>
                <div id="bottom">
                    <table style="margin:auto">
                        <tr>
                            <th>ours vs. base</th>
                            <th>theirs vs. base</th>
                        </tr>
                        <tr>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  /*
  20   * Licensed to the Apache Software Foundation (ASF) under one
  21   * or more contributor license agreements.  See the NOTICE file
  22   * distributed with this work for additional information
  23   * regarding copyright ownership.  The ASF licenses this file
  24   * to you under the Apache License, Version 2.0 (the
  25   * &quot;License&quot;); you may not use this file except in compliance
  26   * with the License.  You may obtain a copy of the License at
  27   *
  28   *     http://www.apache.org/licenses/LICENSE-2.0
  29   *
  30   * Unless required by applicable law or agreed to in writing, software
  31   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  32   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  33   * See the License for the specific language governing permissions and
  34   * limitations under the License.
  35   */
  36  
  37  package com.dtstack.flink.sql.util;
  38  
  39  import com.google.common.collect.HashBasedTable;
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  40 +import com.google.common.collect.HashBiMap;</span>
  41  import org.apache.calcite.sql.*;






  42  import org.apache.commons.lang3.StringUtils;
  43  import org.apache.flink.api.java.tuple.Tuple2;
  44  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  45 -import java.util.Arrays;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  46 -import java.util.List;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  47 -import java.util.Map;</span>
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  48 -import java.util.Set;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  49 +import java.util.*;</span>
  50  
  51  import static org.apache.calcite.sql.SqlKind.*;




  52  
  53  /**
  54   * @Auther: jiangjunjie
  55   * @Date: 2019-06-30 14:57
  56   * @Description:
  57   */
  58  public class ParseUtils {
  59      public static void parseAnd(SqlNode conditionNode, List&lt;SqlNode&gt; sqlNodeList) {
<abbr title="  60          if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().size() == 2) {">  60          if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().size() == 2)ðŸ”µ</abbr>
  61              parseAnd(((SqlBasicCall) conditionNode).getOperands()[0], sqlNodeList);
  62              sqlNodeList.add(((SqlBasicCall) conditionNode).getOperands()[1]);
  63          } else {
  64              sqlNodeList.add(conditionNode);
  65          }
  66      }
  67  
  68      public static void parseJoinCompareOperate(SqlNode condition, List&lt;String&gt; sqlJoinCompareOperate) {
  69          SqlBasicCall joinCondition = (SqlBasicCall) condition;
  70          if (joinCondition.getKind() == SqlKind.AND) {
  71              List&lt;SqlNode&gt; operandList = joinCondition.getOperandList();
  72              for (SqlNode sqlNode : operandList) {
  73                  parseJoinCompareOperate(sqlNode, sqlJoinCompareOperate);
  74              }
  75          } else {
  76              String operator = transformNotEqualsOperator(joinCondition.getKind());
  77              sqlJoinCompareOperate.add(operator);
  78          }
  79      }
  80  
  81      public static String transformNotEqualsOperator(SqlKind sqlKind) {
  82          if (StringUtils.equalsIgnoreCase(sqlKind.toString(), &quot;NOT_EQUALS&quot;)) {
  83              return &quot;!=&quot;;
  84          }
  85          return sqlKind.sql;
  86      }
  87  
  88      /**
  89       *  parse multi join table name, child query RealTabName is null
  90       * @param leftJoin
  91       * @param aliasAndRealTabName
  92       */
<abbr title="  93      public static void parseLeftNodeTableName(SqlNode leftJoin, List&lt;Tuple2&lt;String, String&gt;&gt; aliasAndRealTabName, Set&lt;String&gt; sideTableSet) {">  93      public static void parseLeftNodeTableName(SqlNode leftJoin, List&lt;Tuple2&lt;String, String&gt;&gt; aliasAndRealTabName, ðŸ”µ</abbr>
  94          if (leftJoin.getKind() == IDENTIFIER) {
  95              SqlIdentifier sqlIdentifier = (SqlIdentifier) leftJoin;
  96              if (sqlIdentifier.names.size() == 1 &amp;&amp; !sideTableSet.contains(sqlIdentifier.names.get(0))) {
  97                  aliasAndRealTabName.add(new Tuple2&lt;&gt;(sqlIdentifier.names.get(0), sqlIdentifier.names.get(0)));
  98              }
  99          } else if (leftJoin.getKind() == AS) {
 100              SqlNode sqlNode = ((SqlBasicCall) leftJoin).getOperands()[0];
 101              if (sideTableSet.contains(sqlNode.toString())) {
 102                  return;
 103              }
 104              if (sqlNode.getKind() == IDENTIFIER) {
<abbr title=" 105                  aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(), sqlNode.toString()));"> 105                  aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(), sqlNodðŸ”µ</abbr>
 106              } else {
 107                  // child query
<abbr title=" 108                  aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(), null));"> 108                  aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(), null))ðŸ”µ</abbr>
 109              }
 110          } else if (leftJoin.getKind() == JOIN) {
 111              parseLeftNodeTableName(((SqlJoin) leftJoin).getLeft(), aliasAndRealTabName, sideTableSet);
 112              parseLeftNodeTableName(((SqlJoin) leftJoin).getRight(), aliasAndRealTabName, sideTableSet);
 113          }
 114      }
 115  
<abbr title=" 116      public static SqlNode replaceJoinConditionTabName(SqlNode conditionNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tabAlias) {"> 116      public static SqlNode replaceJoinConditionTabName(SqlNode conditionNode, HashBasedTable&lt;String, String, StringðŸ”µ</abbr>
<abbr title=" 117          if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().size() == 2) {"> 117          if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().size() == 2)ðŸ”µ</abbr>
 118              SqlNode[] operands = ((SqlBasicCall) conditionNode).getOperands();
 119              Arrays.stream(operands).forEach(op -&gt; replaceJoinConditionTabName(op, mappingTable, tabAlias));
 120          } else {
 121              SqlNode[] operands = ((SqlBasicCall) conditionNode).getOperands();
 122              for (int i = 0; i &lt; operands.length; i++) {
 123                  SqlNode sqlNode = operands[i];
 124                  SqlNode replaceNode = replaceNodeInfo(sqlNode, mappingTable, tabAlias);
 125                  operands[i] = replaceNode;
 126              }
 127          }
 128          return conditionNode;
 129      }
 130  
<abbr title=" 131      public static SqlNode replaceNodeInfo(SqlNode parseNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tabAlias) {"> 131      public static SqlNode replaceNodeInfo(SqlNode parseNode, HashBasedTable&lt;String, String, String&gt; mappingTable, ðŸ”µ</abbr>
 132          if (parseNode.getKind() == IDENTIFIER) {
 133              SqlIdentifier sqlIdentifier = (SqlIdentifier) parseNode;
 134  
 135  
 136              return sqlIdentifier;
 137          }
 138          return parseNode;
 139      }
 140  
<abbr title=" 141      public static void fillFieldNameMapping(HashBasedTable&lt;String, String, String&gt; midTableMapping, String[] fieldNames, String tableAlias) {"> 141      public static void fillFieldNameMapping(HashBasedTable&lt;String, String, String&gt; midTableMapping, String[] fieldðŸ”µ</abbr>
 142          Arrays.asList(fieldNames).forEach(fieldName -&gt; {
 143              String mappingTableName = dealDuplicateFieldName(midTableMapping, fieldName);
 144              midTableMapping.put(tableAlias, fieldName, mappingTableName);
 145          });
 146      }
 147  
<abbr title=" 148      public static String dealDuplicateFieldName(HashBasedTable&lt;String, String, String&gt; mappingTable, String fieldName) {"> 148      public static String dealDuplicateFieldName(HashBasedTable&lt;String, String, String&gt; mappingTable, String fieldNðŸ”µ</abbr>
 149          String mappingFieldName = fieldName;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 150 -        int index = 0;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 151 +        int index = 1;</span>
 152          while (!mappingTable.column(mappingFieldName).isEmpty()) {
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0"> 153 -            mappingFieldName = mappingFieldName + index;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 154 +            mappingFieldName = suffixWithChar(fieldName, &#x27;0&#x27;, index);</span>
 155              index++;
 156          }
 157          return mappingFieldName;
 158      }
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 159 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 160 +    public static String dealDuplicateFieldName(HashBiMap&lt;String, String&gt; refFieldMap, String fieldName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 161 +        String mappingFieldName = fieldName;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 162 +        int index = 1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 163 +        while (refFieldMap.inverse().get(mappingFieldName) != null ) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 164 +            mappingFieldName = suffixWithChar(fieldName, &#x27;0&#x27;, index);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 165 +            index++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 166 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 167 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 168 +        return mappingFieldName;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 169 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 170 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 171 +    public static String dealDuplicateFieldName(Map&lt;String, String&gt; refFieldMap, String fieldName) {</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 172 +        String mappingFieldName = fieldName;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 173 +        int index = 1;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 174 +        while (refFieldMap.containsKey(mappingFieldName)){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 175 +            mappingFieldName = suffixWithChar(fieldName, &#x27;0&#x27;, index);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 176 +            index++;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 177 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 178 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 179 +        return mappingFieldName;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 180 +    }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 181 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 182 +    public static String suffixWithChar(String str, char padChar, int repeat){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 183 +        StringBuilder stringBuilder = new StringBuilder(str);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 184 +        for(int i=0; i&lt;repeat; i++){</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 185 +            stringBuilder.append(padChar);</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 186 +        }</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 187 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 188 +        return stringBuilder.toString();</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0"> 189 +    }</span>
 190  }</pre></td>
                            <td><pre>   1  /*
   2   * Licensed to the Apache Software Foundation (ASF) under one
   3   * or more contributor license agreements.  See the NOTICE file
   4   * distributed with this work for additional information
   5   * regarding copyright ownership.  The ASF licenses this file
   6   * to you under the Apache License, Version 2.0 (the
   7   * &quot;License&quot;); you may not use this file except in compliance
   8   * with the License.  You may obtain a copy of the License at
   9   *
  10   *     http://www.apache.org/licenses/LICENSE-2.0
  11   *
  12   * Unless required by applicable law or agreed to in writing, software
  13   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  14   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  15   * See the License for the specific language governing permissions and
  16   * limitations under the License.
  17   */
  18  
  19  /*
  20   * Licensed to the Apache Software Foundation (ASF) under one
  21   * or more contributor license agreements.  See the NOTICE file
  22   * distributed with this work for additional information
  23   * regarding copyright ownership.  The ASF licenses this file
  24   * to you under the Apache License, Version 2.0 (the
  25   * &quot;License&quot;); you may not use this file except in compliance
  26   * with the License.  You may obtain a copy of the License at
  27   *
  28   *     http://www.apache.org/licenses/LICENSE-2.0
  29   *
  30   * Unless required by applicable law or agreed to in writing, software
  31   * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
  32   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  33   * See the License for the specific language governing permissions and
  34   * limitations under the License.
  35   */
  36  
  37  package com.dtstack.flink.sql.util;
  38  
  39  import com.google.common.collect.HashBasedTable;

<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  40 -import org.apache.calcite.sql.*;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  41 +</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  42 +import org.apache.calcite.sql.SqlBasicCall;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  43 +import org.apache.calcite.sql.SqlIdentifier;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  44 +import org.apache.calcite.sql.SqlJoin;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  45 +import org.apache.calcite.sql.SqlKind;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  46 +import org.apache.calcite.sql.SqlNode;</span>
  47  import org.apache.commons.lang3.StringUtils;
  48  import org.apache.flink.api.java.tuple.Tuple2;
  49  
  50  import java.util.Arrays;
  51  import java.util.List;
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  52 -import java.util.Map;</span>
  53  import java.util.Set;

  54  
<span style="background-color: rgba(255, 0, 0, 0.2);; margin: 0">  55 -import static org.apache.calcite.sql.SqlKind.*;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  56 +import static org.apache.calcite.sql.SqlKind.AS;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  57 +import static org.apache.calcite.sql.SqlKind.IDENTIFIER;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  58 +import static org.apache.calcite.sql.SqlKind.JOIN;</span>
<span style="background-color: rgba(0, 255, 0, 0.2); margin: 0">  59 +</span>
  60  
  61  /**
  62   * @Auther: jiangjunjie
  63   * @Date: 2019-06-30 14:57
  64   * @Description:
  65   */
  66  public class ParseUtils {
  67      public static void parseAnd(SqlNode conditionNode, List&lt;SqlNode&gt; sqlNodeList) {
<abbr title="  68          if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().size() == 2) {">  68          if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().size() == 2)ðŸ”µ</abbr>
  69              parseAnd(((SqlBasicCall) conditionNode).getOperands()[0], sqlNodeList);
  70              sqlNodeList.add(((SqlBasicCall) conditionNode).getOperands()[1]);
  71          } else {
  72              sqlNodeList.add(conditionNode);
  73          }
  74      }
  75  
  76      public static void parseJoinCompareOperate(SqlNode condition, List&lt;String&gt; sqlJoinCompareOperate) {
  77          SqlBasicCall joinCondition = (SqlBasicCall) condition;
  78          if (joinCondition.getKind() == SqlKind.AND) {
  79              List&lt;SqlNode&gt; operandList = joinCondition.getOperandList();
  80              for (SqlNode sqlNode : operandList) {
  81                  parseJoinCompareOperate(sqlNode, sqlJoinCompareOperate);
  82              }
  83          } else {
  84              String operator = transformNotEqualsOperator(joinCondition.getKind());
  85              sqlJoinCompareOperate.add(operator);
  86          }
  87      }
  88  
  89      public static String transformNotEqualsOperator(SqlKind sqlKind) {
  90          if (StringUtils.equalsIgnoreCase(sqlKind.toString(), &quot;NOT_EQUALS&quot;)) {
  91              return &quot;!=&quot;;
  92          }
  93          return sqlKind.sql;
  94      }
  95  
  96      /**
  97       *  parse multi join table name, child query RealTabName is null
  98       * @param leftJoin
  99       * @param aliasAndRealTabName
 100       */
<abbr title=" 101      public static void parseLeftNodeTableName(SqlNode leftJoin, List&lt;Tuple2&lt;String, String&gt;&gt; aliasAndRealTabName, Set&lt;String&gt; sideTableSet) {"> 101      public static void parseLeftNodeTableName(SqlNode leftJoin, List&lt;Tuple2&lt;String, String&gt;&gt; aliasAndRealTabName, ðŸ”µ</abbr>
 102          if (leftJoin.getKind() == IDENTIFIER) {
 103              SqlIdentifier sqlIdentifier = (SqlIdentifier) leftJoin;
 104              if (sqlIdentifier.names.size() == 1 &amp;&amp; !sideTableSet.contains(sqlIdentifier.names.get(0))) {
 105                  aliasAndRealTabName.add(new Tuple2&lt;&gt;(sqlIdentifier.names.get(0), sqlIdentifier.names.get(0)));
 106              }
 107          } else if (leftJoin.getKind() == AS) {
 108              SqlNode sqlNode = ((SqlBasicCall) leftJoin).getOperands()[0];
 109              if (sideTableSet.contains(sqlNode.toString())) {
 110                  return;
 111              }
 112              if (sqlNode.getKind() == IDENTIFIER) {
<abbr title=" 113                  aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(), sqlNode.toString()));"> 113                  aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(), sqlNodðŸ”µ</abbr>
 114              } else {
 115                  // child query
<abbr title=" 116                  aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(), null));"> 116                  aliasAndRealTabName.add(new Tuple2&lt;&gt;(((SqlBasicCall) leftJoin).getOperands()[1].toString(), null))ðŸ”µ</abbr>
 117              }
 118          } else if (leftJoin.getKind() == JOIN) {
 119              parseLeftNodeTableName(((SqlJoin) leftJoin).getLeft(), aliasAndRealTabName, sideTableSet);
 120              parseLeftNodeTableName(((SqlJoin) leftJoin).getRight(), aliasAndRealTabName, sideTableSet);
 121          }
 122      }
 123  
<abbr title=" 124      public static SqlNode replaceJoinConditionTabName(SqlNode conditionNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tabAlias) {"> 124      public static SqlNode replaceJoinConditionTabName(SqlNode conditionNode, HashBasedTable&lt;String, String, StringðŸ”µ</abbr>
<abbr title=" 125          if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().size() == 2) {"> 125          if (conditionNode.getKind() == SqlKind.AND &amp;&amp; ((SqlBasicCall) conditionNode).getOperandList().size() == 2)ðŸ”µ</abbr>
 126              SqlNode[] operands = ((SqlBasicCall) conditionNode).getOperands();
 127              Arrays.stream(operands).forEach(op -&gt; replaceJoinConditionTabName(op, mappingTable, tabAlias));
 128          } else {
 129              SqlNode[] operands = ((SqlBasicCall) conditionNode).getOperands();
 130              for (int i = 0; i &lt; operands.length; i++) {
 131                  SqlNode sqlNode = operands[i];
 132                  SqlNode replaceNode = replaceNodeInfo(sqlNode, mappingTable, tabAlias);
 133                  operands[i] = replaceNode;
 134              }
 135          }
 136          return conditionNode;
 137      }
 138  
<abbr title=" 139      public static SqlNode replaceNodeInfo(SqlNode parseNode, HashBasedTable&lt;String, String, String&gt; mappingTable, String tabAlias) {"> 139      public static SqlNode replaceNodeInfo(SqlNode parseNode, HashBasedTable&lt;String, String, String&gt; mappingTable, ðŸ”µ</abbr>
 140          if (parseNode.getKind() == IDENTIFIER) {
 141              SqlIdentifier sqlIdentifier = (SqlIdentifier) parseNode;
 142  
 143  
 144              return sqlIdentifier;
 145          }
 146          return parseNode;
 147      }
 148  
<abbr title=" 149      public static void fillFieldNameMapping(HashBasedTable&lt;String, String, String&gt; midTableMapping, String[] fieldNames, String tableAlias) {"> 149      public static void fillFieldNameMapping(HashBasedTable&lt;String, String, String&gt; midTableMapping, String[] fieldðŸ”µ</abbr>
 150          Arrays.asList(fieldNames).forEach(fieldName -&gt; {
 151              String mappingTableName = dealDuplicateFieldName(midTableMapping, fieldName);
 152              midTableMapping.put(tableAlias, fieldName, mappingTableName);
 153          });
 154      }
 155  
<abbr title=" 156      public static String dealDuplicateFieldName(HashBasedTable&lt;String, String, String&gt; mappingTable, String fieldName) {"> 156      public static String dealDuplicateFieldName(HashBasedTable&lt;String, String, String&gt; mappingTable, String fieldNðŸ”µ</abbr>
 157          String mappingFieldName = fieldName;
 158          int index = 0;

 159          while (!mappingTable.column(mappingFieldName).isEmpty()) {
 160              mappingFieldName = mappingFieldName + index;

 161              index++;
 162          }
 163          return mappingFieldName;
 164      }































 165  }</pre></td>
                        </tr>
                    </table>
                </div>
              </body>
            </html>
            